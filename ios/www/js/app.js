'use strict';

var modules = [
  'angularMoment',
  'monospaced.qrcode',
  'gettext',
  'ionic',
  'ionic-toast',
  'angular-clipboard',
  'ngTouch',
  'ngLodash',
  'ngCsv',
  'angular-md5',
  'bwcModule',
  'bitauthModule',
  'copayApp.filters',
  'copayApp.services',
  'copayApp.controllers',
  'copayApp.directives',
  'copayApp.addons'
];

var copayApp = window.copayApp = angular.module('copayApp', modules);

angular.module('copayApp.filters', []);
angular.module('copayApp.services', []);
angular.module('copayApp.controllers', []);
angular.module('copayApp.directives', []);
angular.module('copayApp.addons', []);

'use strict';

var unsupported, isaosp;

if (window && window.navigator) {
  var rxaosp = window.navigator.userAgent.match(/Android.*AppleWebKit\/([\d.]+)/);
  isaosp = (rxaosp && rxaosp[1] < 537);
  if (!window.cordova && isaosp)
    unsupported = true;
  if (unsupported) {
    window.location = '#/unsupported';
  }
}

//Setting up route
angular.module('copayApp').config(function(historicLogProvider, $provide, $logProvider, $stateProvider, $urlRouterProvider, $compileProvider, $ionicConfigProvider) {
    $urlRouterProvider.otherwise('/starting');

    // NO CACHE
    //$ionicConfigProvider.views.maxCache(0);

    // TABS BOTTOM
    $ionicConfigProvider.tabs.position('bottom');

    // NAV TITTLE CENTERED
    $ionicConfigProvider.navBar.alignTitle('center');

    // NAV BUTTONS ALIGMENT
    $ionicConfigProvider.navBar.positionPrimaryButtons('left');
    $ionicConfigProvider.navBar.positionSecondaryButtons('right');

    // NAV BACK-BUTTON TEXT/ICON
    $ionicConfigProvider.backButton.icon('icon ion-ios-arrow-thin-left').text('');
    $ionicConfigProvider.backButton.previousTitleText(false);

    // CHECKBOX CIRCLE
    $ionicConfigProvider.form.checkbox('circle');

    // USE NATIVE SCROLLING
    $ionicConfigProvider.scrolling.jsScrolling(false);

    $logProvider.debugEnabled(true);
    $provide.decorator('$log', ['$delegate', 'platformInfo',
    function($delegate, platformInfo) {
        var historicLog = historicLogProvider.$get();

        historicLog.getLevels().forEach(function(levelDesc) {
          var level = levelDesc.level;
          if (platformInfo.isDevel && level == 'error') return;

          var orig = $delegate[level];
          $delegate[level] = function() {
            if (level == 'error')
              console.log(arguments);

            var args = Array.prototype.slice.call(arguments);

            args = args.map(function(v) {
              try {
                if (typeof v == 'undefined') v = 'undefined';
                if (!v) v = 'null';
                if (typeof v == 'object') {
                  if (v.message)
                    v = v.message;
                  else
                    v = JSON.stringify(v);
                }
                // Trim output in mobile
                if (platformInfo.isCordova) {
                  v = v.toString();
                  if (v.length > 3000) {
                    v = v.substr(0, 2997) + '...';
                  }
                }
              } catch (e) {
                console.log('Error at log decorator:', e);
                v = 'undefined';
              }
              return v;
            });

            try {
              if (platformInfo.isCordova)
                console.log(args.join(' '));

              historicLog.add(level, args.join(' '));
              orig.apply(null, args);
            } catch (e) {
              console.log('ERROR (at log decorator):', e, args[0]);
            }
          };
        });
        return $delegate;
    }
  ]);

    // whitelist 'chrome-extension:' for chromeApp to work with image URLs processed by Angular
    // link: http://stackoverflow.com/questions/15606751/angular-changes-urls-to-unsafe-in-extension-page?lq=1
    $compileProvider.imgSrcSanitizationWhitelist(/^\s*((https?|ftp|file|blob|chrome-extension):|data:image\/)/);

    $stateProvider

      /*
       *
       * Other pages
       *
       */

      .state('unsupported', {
        url: '/unsupported',
        templateUrl: 'views/unsupported.html'
      })

      .state('starting', {
        url: '/starting',
        template: '<ion-view id="starting"><ion-content><div class="block-spinner row"><ion-spinner class="spinner-stable" icon="crescent"></ion-spinner></div></ion-content></ion-view>'
      })

      /*
       *
       * URI
       *
       */

      .state('uri', {
        url: '/uri/:url',
        controller: function($stateParams, $log, openURLService, profileService) {
          profileService.whenAvailable(function() {
            $log.info('DEEP LINK from Browser:' + $stateParams.url);
            openURLService.handleURL({
              url: $stateParams.url
            });
          })
        }
      })

      /*
       *
       * Wallet
       *
       */

      .state('tabs.wallet', {
        url: '/wallet/:walletId/:fromOnboarding/:clearCache',
        views: {
          'tab-home@tabs': {
            controller: 'walletDetailsController',
            templateUrl: 'views/walletDetails.html'
          }
        }
      })
      .state('tabs.activity', {
        url: '/activity',
        views: {
          'tab-home@tabs': {
            controller: 'activityController',
            templateUrl: 'views/activity.html',
          }
        }
      })
      .state('tabs.proposals', {
        url: '/proposals',
        views: {
          'tab-home@tabs': {
            controller: 'proposalsController',
            templateUrl: 'views/proposals.html',
          }
        }
      })
      .state('tabs.wallet.tx-details', {
        url: '/tx-details/:txid',
        views: {
          'tab-home@tabs': {
            controller: 'txDetailsController',
            templateUrl: 'views/tx-details.html'
          }
        }
      })
      .state('tabs.wallet.backupWarning', {
        url: '/backupWarning/:from/:walletId',
        views: {
          'tab-home@tabs': {
            controller: 'backupWarningController',
            templateUrl: 'views/backupWarning.html'
          }
        }
      })
      .state('tabs.wallet.backup', {
        url: '/backup/:walletId',
        views: {
          'tab-home@tabs': {
            templateUrl: 'views/backup.html',
            controller: 'backupController'
          }
        }
      })

      .state('tabs.wallet.addresses', {
        url: '/addresses/:walletId/:toAddress',
        views: {
          'tab-home@tabs': {
            controller: 'addressesController',
            templateUrl: 'views/addresses.html'
          }
        }
      })
      .state('tabs.wallet.allAddresses', {
        url: '/allAddresses/:walletId',
        views: {
          'tab-home@tabs': {
            controller: 'addressesController',
            templateUrl: 'views/allAddresses.html'
          }
        }
      })

      /*
       *
       * Tabs
       *
       */

      .state('tabs', {
        url: '/tabs',
        abstract: true,
        controller: 'tabsController',
        templateUrl: 'views/tabs.html'
      })
      .state('tabs.home', {
        url: '/home/:fromOnboarding',
        views: {
          'tab-home': {
            controller: 'tabHomeController',
            templateUrl: 'views/tab-home.html',
          }
        }
      })
      .state('tabs.receive', {
        url: '/receive',
        views: {
          'tab-receive': {
            controller: 'tabReceiveController',
            templateUrl: 'views/tab-receive.html',
          }
        }
      })
      .state('tabs.scan', {
        url: '/scan',
        views: {
          'tab-scan': {
            controller: 'tabScanController',
            templateUrl: 'views/tab-scan.html',
          }
        }
      })
      .state('scanner', {
        url: '/scanner',
        params: {
          passthroughMode: null,
        },
        controller: 'tabScanController',
        templateUrl: 'views/tab-scan.html'
      })
      .state('tabs.send', {
        url: '/send',
        views: {
          'tab-send': {
            controller: 'tabSendController',
            templateUrl: 'views/tab-send.html',
          }
        }
      })
      .state('tabs.settings', {
        url: '/settings',
        views: {
          'tab-settings': {
            controller: 'tabSettingsController',
            templateUrl: 'views/tab-settings.html',
          }
        }
      })

      /*
       *
       * Send
       *
       */

      .state('tabs.send.amount', {
        url: '/amount/:recipientType/:toAddress/:toName/:toEmail/:toColor/:coin/:fixedUnit',
        views: {
          'tab-send@tabs': {
            controller: 'amountController',
            templateUrl: 'views/amount.html'
          }
        }
      })
      .state('tabs.send.confirm', {
        url: '/confirm/:recipientType/:toAddress/:toName/:toAmount/:toEmail/:toColor/:description/:coin/:useSendMax',
        views: {
          'tab-send@tabs': {
            controller: 'confirmController',
            templateUrl: 'views/confirm.html'
          }
        },
        params: {
          paypro: null
        }
      })
      .state('tabs.send.addressbook', {
        url: '/addressbook/add/:fromSendTab/:addressbookEntry',
        views: {
          'tab-send@tabs': {
            templateUrl: 'views/addressbook.add.html',
            controller: 'addressbookAddController'
          }
        }
      })

      /*
       *
       * Add
       *
       */

      .state('tabs.add', {
        url: '/add',
        views: {
          'tab-home@tabs': {
            templateUrl: 'views/add.html'
          }
        },
        params: {
          coin: 'btc'
        }
      })
      .state('tabs.add.join', {
        url: '/join/:url',
        views: {
          'tab-home@tabs': {
            templateUrl: 'views/join.html',
            controller: 'joinController'
          },
        }
      })
      .state('tabs.add.import', {
        url: '/import/:code',
        views: {
          'tab-home@tabs': {
            templateUrl: 'views/import.html',
            controller: 'importController'
          },
        },
      })
      .state('tabs.add.create-personal', {
        url: '/create-personal',
        views: {
          'tab-home@tabs': {
            templateUrl: 'views/tab-create-personal.html',
            controller: 'createController'
          },
        }
      })
      .state('tabs.add.create-shared', {
        url: '/create-shared',
        views: {
          'tab-home@tabs': {
            templateUrl: 'views/tab-create-shared.html',
            controller: 'createController'
          },
        }
      })

      /*
       *
       * Global Settings
       *
       */

      .state('tabs.preferencesCash', {
        url: '/preferencesCash',
        views: {
          'tab-settings@tabs': {
            controller: 'preferencesCashController',
            templateUrl: 'views/preferencesCash.html'
          }
        }
      })

      .state('tabs.notifications', {
        url: '/notifications',
        views: {
          'tab-settings@tabs': {
            controller: 'preferencesNotificationsController',
            templateUrl: 'views/preferencesNotifications.html'
          }
        }
      })
      .state('tabs.language', {
        url: '/language',
        views: {
          'tab-settings@tabs': {
            controller: 'preferencesLanguageController',
            templateUrl: 'views/preferencesLanguage.html'
          }
        }
      })
      .state('tabs.fee', {
        url: '/fee',
        views: {
          'tab-settings@tabs': {
            controller: 'preferencesFeeController',
            templateUrl: 'views/preferencesFee.html'
          }
        }
      })
      .state('tabs.altCurrency', {
        url: '/altCurrency',
        views: {
          'tab-settings@tabs': {
            controller: 'preferencesAltCurrencyController',
            templateUrl: 'views/preferencesAltCurrency.html'
          }
        }
      })
      .state('tabs.about', {
        url: '/about',
        views: {
          'tab-settings@tabs': {
            controller: 'preferencesAbout',
            templateUrl: 'views/preferencesAbout.html'
          }
        }
      })
      .state('tabs.about.logs', {
        url: '/logs',
        views: {
          'tab-settings@tabs': {
            controller: 'preferencesLogs',
            templateUrl: 'views/preferencesLogs.html'
          }
        }
      })
      .state('tabs.about.termsOfUse', {
        url: '/termsOfUse',
        views: {
          'tab-settings@tabs': {
            templateUrl: 'views/termsOfUse.html'
          }
        }
      })
      .state('tabs.advanced', {
        url: '/advanced',
        views: {
          'tab-settings@tabs': {
            controller: 'advancedSettingsController',
            templateUrl: 'views/advancedSettings.html'
          }
        }
      })
      .state('tabs.lockSetup', {
        url: '/lockSetup',
        views: {
          'tab-settings@tabs': {
            controller: 'lockSetupController',
            templateUrl: 'views/lockSetup.html',
          }
        }
      })
      .state('tabs.pin', {
        url: '/pin/:action',
        views: {
          'tab-settings@tabs': {
            controller: 'pinController',
            templateUrl: 'views/pin.html',
            cache: false
          }
        }
      })


      /*
       *
       * Wallet preferences
       *
       */

      .state('tabs.preferences', {
        url: '/preferences/:walletId',
        views: {
          'tab-settings@tabs': {
            controller: 'preferencesController',
            templateUrl: 'views/preferences.html'
          }
        }
      })
      .state('tabs.preferences.preferencesAlias', {
        url: '/preferencesAlias',
        views: {
          'tab-settings@tabs': {
            controller: 'preferencesAliasController',
            templateUrl: 'views/preferencesAlias.html'
          }
        }
      })
      .state('tabs.preferences.preferencesColor', {
        url: '/preferencesColor',
        views: {
          'tab-settings@tabs': {
            controller: 'preferencesColorController',
            templateUrl: 'views/preferencesColor.html'
          }
        }
      })
      .state('tabs.preferences.backupWarning', {
        url: '/backupWarning/:from',
        views: {
          'tab-settings@tabs': {
            controller: 'backupWarningController',
            templateUrl: 'views/backupWarning.html'
          }
        }
      })
      .state('tabs.preferences.backup', {
        url: '/backup',
        views: {
          'tab-settings@tabs': {
            controller: 'backupController',
            templateUrl: 'views/backup.html'
          }
        }
      })
      .state('tabs.preferences.preferencesAdvanced', {
        url: '/preferencesAdvanced',
        views: {
          'tab-settings@tabs': {
            controller: 'preferencesAdvancedController',
            templateUrl: 'views/preferencesAdvanced.html'
          }
        }
      })
      .state('tabs.preferences.information', {
        url: '/information',
        views: {
          'tab-settings@tabs': {
            controller: 'preferencesInformation',
            templateUrl: 'views/preferencesInformation.html'
          }
        }
      })
      .state('tabs.preferences.export', {
        url: '/export',
        views: {
          'tab-settings@tabs': {
            controller: 'exportController',
            templateUrl: 'views/export.html'
          }
        }
      })
      .state('tabs.preferences.preferencesBwsUrl', {
        url: '/preferencesBwsUrl',
        views: {
          'tab-settings@tabs': {
            controller: 'preferencesBwsUrlController',
            templateUrl: 'views/preferencesBwsUrl.html'
          }
        }
      })
      .state('tabs.preferences.preferencesHistory', {
        url: '/preferencesHistory',
        views: {
          'tab-settings@tabs': {
            controller: 'preferencesHistory',
            templateUrl: 'views/preferencesHistory.html'
          }
        }
      })
      .state('tabs.preferences.preferencesExternal', {
        url: '/preferencesExternal',
        views: {
          'tab-settings@tabs': {
            controller: 'preferencesExternalController',
            templateUrl: 'views/preferencesExternal.html'
          }
        }
      })
      .state('tabs.preferences.delete', {
        url: '/delete',
        views: {
          'tab-settings@tabs': {
            controller: 'preferencesDeleteWalletController',
            templateUrl: 'views/preferencesDeleteWallet.html'
          }
        }
      })
      .state('tabs.preferences.preferencesPrivateKey', {
        url: '/preferencesPrivateKey',
        views: {
          'tab-settings@tabs': {
            controller: 'preferencesPrivateKeyController',
            templateUrl: 'views/preferencesPrivateKey.html'
          }
        }
      })

      /*
       *
       * Addressbook
       *
       */


      .state('tabs.addressbook', {
        url: '/addressbook',
        views: {
          'tab-settings@tabs': {
            templateUrl: 'views/addressbook.html',
            controller: 'addressbookListController'
          }
        }
      })
      .state('tabs.addressbook.add', {
        url: '/add',
        views: {
          'tab-settings@tabs': {
            templateUrl: 'views/addressbook.add.html',
            controller: 'addressbookAddController'
          }
        }
      })
      .state('tabs.addressbook.view', {
        url: '/view/:address/:email/:name',
        views: {
          'tab-settings@tabs': {
            templateUrl: 'views/addressbook.view.html',
            controller: 'addressbookViewController'
          }
        }
      })

      /*
       *
       * Copayers
       *
       */

      .state('tabs.copayers', {
        url: '/copayers/:walletId',
        views: {
          'tab-home': {
            templateUrl: 'views/copayers.html',
            controller: 'copayersController'
          }
        }
      })

      /*
       *
       * Addresses
       *
       */

      .state('tabs.settings.addresses', {
        url: '/addresses/:walletId/:toAddress',
        views: {
          'tab-settings@tabs': {
            controller: 'addressesController',
            templateUrl: 'views/addresses.html'
          }
        }
      })
      .state('tabs.settings.allAddresses', {
        url: '/allAddresses/:walletId',
        views: {
          'tab-settings@tabs': {
            controller: 'addressesController',
            templateUrl: 'views/allAddresses.html'
          }
        }
      })

      /*
       *
       * Request Specific amount
       *
       */

      .state('tabs.paymentRequest', {
        url: '/payment-request',
        abstract: true,
        params: {
          id: null,
          nextStep: 'tabs.paymentRequest.confirm',
        }
      })

      .state('tabs.paymentRequest.amount', {
        url: '/amount/:coin',
        views: {
          'tab-receive@tabs': {
            controller: 'amountController',
            templateUrl: 'views/amount.html'
          }
        }
      })
      .state('tabs.paymentRequest.confirm', {
        url: '/confirm/:amount/:currency/:coin',
        views: {
          'tab-receive@tabs': {
            controller: 'customAmountController',
            templateUrl: 'views/customAmount.html'
          }
        }
      })

      /*
       *
       * Init backup flow
       *
       */

      .state('tabs.receive.backupWarning', {
        url: '/backupWarning/:from/:walletId',
        views: {
          'tab-receive@tabs': {
            controller: 'backupWarningController',
            templateUrl: 'views/backupWarning.html'
          }
        }
      })
      .state('tabs.receive.backup', {
        url: '/backup/:walletId',
        views: {
          'tab-receive@tabs': {
            controller: 'backupController',
            templateUrl: 'views/backup.html'
          }
        }
      })

      /*
       *
       * Paper Wallet
       *
       */

      .state('tabs.home.paperWallet', {
        url: '/paperWallet/:privateKey',
        views: {
          'tab-home@tabs': {
            controller: 'paperWalletController',
            templateUrl: 'views/paperWallet.html'
          }
        }
      })
      /*
       *
       * Onboarding
       *
       */

      .state('onboarding', {
        url: '/onboarding',
        abstract: true,
        template: '<ion-nav-view name="onboarding"></ion-nav-view>'
      })
      .state('onboarding.welcome', {
        url: '/welcome',
        views: {
          'onboarding': {
            templateUrl: 'views/onboarding/welcome.html',
            controller: 'welcomeController'
          }
        }
      })
      .state('onboarding.tour', {
        url: '/tour',
        views: {
          'onboarding': {
            templateUrl: 'views/onboarding/tour.html',
            controller: 'tourController'
          }
        }
      })
      .state('onboarding.collectEmail', {
        url: '/collectEmail/:walletId',
        views: {
          'onboarding': {
            templateUrl: 'views/onboarding/collectEmail.html',
            controller: 'collectEmailController'
          }
        }
      })
      .state('onboarding.backupRequest', {
        url: '/backupRequest/:walletId',
        views: {
          'onboarding': {
            templateUrl: 'views/onboarding/backupRequest.html',
            controller: 'backupRequestController'
          }
        }
      })
      .state('onboarding.backupWarning', {
        url: '/backupWarning/:from/:walletId',
        views: {
          'onboarding': {
            templateUrl: 'views/backupWarning.html',
            controller: 'backupWarningController'
          }
        }
      })
      .state('onboarding.backup', {
        url: '/backup/:walletId',
        views: {
          'onboarding': {
            templateUrl: 'views/backup.html',
            controller: 'backupController'
          }
        }
      })
      .state('onboarding.disclaimer', {
        url: '/disclaimer/:walletId/:backedUp/:resume',
        views: {
          'onboarding': {
            templateUrl: 'views/onboarding/disclaimer.html',
            controller: 'disclaimerController'
          }
        }
      })
      .state('onboarding.terms', {
        url: '/terms',
        views: {
          'onboarding': {
            templateUrl: 'views/onboarding/terms.html',
            controller: 'termsController'
          }
        }
      })
      .state('onboarding.import', {
        url: '/import',
        views: {
          'onboarding': {
            templateUrl: 'views/import.html',
            controller: 'importController'
          },
        },
        params: {
          code: null,
          fromOnboarding: null
        },
      })

      /*
       *
       * Feedback
       *
       */

      .state('tabs.feedback', {
        url: '/feedback',
        views: {
          'tab-settings@tabs': {
            templateUrl: 'views/feedback/send.html',
            controller: 'sendController'
          }
        }
      })
      .state('tabs.shareApp', {
        url: '/shareApp/:score/:skipped/:fromSettings',
        views: {
          'tab-settings@tabs': {
            controller: 'completeController',
            templateUrl: 'views/feedback/complete.html'
          }
        }
      })
      .state('tabs.rate', {
        url: '/rate',
        abstract: true
      })
      .state('tabs.rate.send', {
        url: '/send/:score',
        views: {
          'tab-home@tabs': {
            templateUrl: 'views/feedback/send.html',
            controller: 'sendController'
          }
        }
      })
      .state('tabs.rate.complete', {
        url: '/complete/:score/:skipped',
        views: {
          'tab-home@tabs': {
            controller: 'completeController',
            templateUrl: 'views/feedback/complete.html'
          }
        }
      })
      .state('tabs.rate.rateApp', {
        url: '/rateApp/:score',
        views: {
          'tab-home@tabs': {
            controller: 'rateAppController',
            templateUrl: 'views/feedback/rateApp.html'
          }
        }
      })

      /*
       *
       * Buy or Sell Qybcoin
       *
       */

      .state('tabs.buyandsell', {
        url: '/buyandsell',
        views: {
          'tab-home': {
            controller: 'buyandsellController',
            templateUrl: 'views/buyandsell.html'
          }
        }
      })

      /*
       *
       * Glidera
       *
       *
       */

      .state('tabs.buyandsell.glidera', {
        url: '/glidera/:code',
        views: {
          'tab-home@tabs': {
            controller: 'glideraController',
            controllerAs: 'glidera',
            templateUrl: 'views/glidera.html'
          }
        },
        params: {
          coin: 'btc',
        }
      })
      .state('tabs.buyandsell.glidera.amount', {
        url: '/amount/:nextStep/:currency',
        views: {
          'tab-home@tabs': {
            controller: 'amountController',
            templateUrl: 'views/amount.html'
          }
        }
      })
      .state('tabs.buyandsell.glidera.buy', {
        url: '/buy/:amount/:currency',
        views: {
          'tab-home@tabs': {
            controller: 'buyGlideraController',
            templateUrl: 'views/buyGlidera.html'
          }
        }
      })
      .state('tabs.buyandsell.glidera.sell', {
        url: '/sell/:amount/:currency',
        views: {
          'tab-home@tabs': {
            controller: 'sellGlideraController',
            templateUrl: 'views/sellGlidera.html'
          }
        }
      })
      .state('tabs.preferences.glidera', {
        url: '/glidera',
        views: {
          'tab-settings@tabs': {
            controller: 'preferencesGlideraController',
            templateUrl: 'views/preferencesGlidera.html'
          }
        }
      })

      /*
       *
       * Coinbase
       *
       */

      .state('tabs.buyandsell.coinbase', {
        url: '/coinbase/:code',
        views: {
          'tab-home@tabs': {
            controller: 'coinbaseController',
            controllerAs: 'coinbase',
            templateUrl: 'views/coinbase.html'
          }
        },
        params: {
          coin: 'btc',
        }
      })
      .state('tabs.preferences.coinbase', {
        url: '/coinbase',
        views: {
          'tab-settings@tabs': {
            controller: 'preferencesCoinbaseController',
            templateUrl: 'views/preferencesCoinbase.html'
          }
        }
      })
      .state('tabs.buyandsell.coinbase.amount', {
        url: '/amount/:nextStep/:currency',
        views: {
          'tab-home@tabs': {
            controller: 'amountController',
            templateUrl: 'views/amount.html'
          }
        }
      })
      .state('tabs.buyandsell.coinbase.buy', {
        url: '/buy/:amount/:currency',
        views: {
          'tab-home@tabs': {
            controller: 'buyCoinbaseController',
            templateUrl: 'views/buyCoinbase.html'
          }
        }
      })
      .state('tabs.buyandsell.coinbase.sell', {
        url: '/sell/:amount/:currency',
        views: {
          'tab-home@tabs': {
            controller: 'sellCoinbaseController',
            templateUrl: 'views/sellCoinbase.html'
          }
        }
      })

      /*
       *
       * Gift Cards
       *
       */

      .state('tabs.giftcards', {
        url: '/giftcards',
        abstract: true
      })

      /*
       *
       * Mercado Libre Gift Card
       *
       */

      .state('tabs.giftcards.mercadoLibre', {
        url: '/mercadoLibre',
        views: {
          'tab-home@tabs': {
            controller: 'mercadoLibreController',
            templateUrl: 'views/mercadoLibre.html'
          }
        }
      })
      .state('tabs.giftcards.mercadoLibre.cards', {
        url: '/cards',
        views: {
          'tab-home@tabs': {
            controller: 'mercadoLibreCardsController',
            templateUrl: 'views/mercadoLibreCards.html'
          }
        },
        params: {
          invoiceId: null
        }
      })
      .state('tabs.giftcards.mercadoLibre.amount', {
        url: '/amount',
        views: {
          'tab-home@tabs': {
            controller: 'amountController',
            templateUrl: 'views/amount.html'
          }
        },
        params: {
          nextStep: 'tabs.giftcards.mercadoLibre.buy',
          currency: 'BRL',
          coin: 'btc',
          fixedUnit: 1,
        }
      })
      .state('tabs.giftcards.mercadoLibre.buy', {
        url: '/buy/:amount/:currency',
        views: {
          'tab-home@tabs': {
            controller: 'buyMercadoLibreController',
            templateUrl: 'views/buyMercadoLibre.html'
          }
        }
      })

      /*
       *
       * Amazon.com Gift Card
       *
       */

      .state('tabs.giftcards.amazon', {
        url: '/amazon',
        views: {
          'tab-home@tabs': {
            controller: 'amazonController',
            templateUrl: 'views/amazon.html'
          }
        }
      })
      .state('tabs.giftcards.amazon.cards', {
        url: '/cards',
        views: {
          'tab-home@tabs': {
            controller: 'amazonCardsController',
            templateUrl: 'views/amazonCards.html'
          }
        },
        params: {
          invoiceId: null
        }
      })
      .state('tabs.giftcards.amazon.amount', {
        url: '/amount',
        views: {
          'tab-home@tabs': {
            controller: 'amountController',
            templateUrl: 'views/amount.html'
          }
        },
        params: {
          nextStep: 'tabs.giftcards.amazon.buy',
          currency: 'USD',
          coin: 'btc',
          fixedUnit: true,
        }
      })
      .state('tabs.giftcards.amazon.buy', {
        url: '/buy/:amount/:currency',
        views: {
          'tab-home@tabs': {
            controller: 'buyAmazonController',
            templateUrl: 'views/buyAmazon.html'
          }
        }
      })

      /*
       *
       * BitPay Card
       *
       */

      .state('tabs.bitpayCardIntro', {
        url: '/bitpay-card-intro/:secret/:email/:otp',
        views: {
          'tab-home@tabs': {
            controller: 'bitpayCardIntroController',
            templateUrl: 'views/bitpayCardIntro.html'
          }
        }
      })
      .state('tabs.bitpayCard', {
        url: '/bitpay-card',
        views: {
          'tab-home@tabs': {
            controller: 'bitpayCardController',
            controllerAs: 'bitpayCard',
            templateUrl: 'views/bitpayCard.html'
          }
        },
        params: {
          id: null,
          currency: 'USD',
          coin: 'btc',
          useSendMax: null
        }
      })
      .state('tabs.bitpayCard.amount', {
        url: '/amount/:nextStep',
        views: {
          'tab-home@tabs': {
            controller: 'amountController',
            templateUrl: 'views/amount.html'
          }
        }
      })
      .state('tabs.bitpayCard.topup', {
        url: '/topup/:amount',
        views: {
          'tab-home@tabs': {
            controller: 'topUpController',
            templateUrl: 'views/topup.html'
          }
        }
      })
      .state('tabs.preferences.bitpayServices', {
        url: '/bitpay-services',
        views: {
          'tab-settings@tabs': {
            controller: 'preferencesBitpayServicesController',
            templateUrl: 'views/preferencesBitpayServices.html'
          }
        }
      })

      /*
       *
       * ShapeShift
       *
       */

      .state('tabs.shapeshift', {
        url: '/shapeshift',
        views: {
          'tab-home@tabs': {
            controller: 'shapeshiftController',
            templateUrl: 'views/shapeshift.html'
          }
        }
      })
      .state('tabs.shapeshift.shift', {
        url: '/shift',
        views: {
          'tab-home@tabs': {
            controller: 'shapeshiftShiftController',
            templateUrl: 'views/shapeshiftShift.html'
          }
        },
        params: {
          currency: 'USD'
        }
      })
      .state('tabs.shapeshift.amount', {
        url: '/amount/:coin/:id/:toWalletId/:shiftMax/:shiftMin',
        views: {
          'tab-home@tabs': {
            controller: 'amountController',
            templateUrl: 'views/amount.html'
          }
        },
        params: {
          nextStep: 'tabs.shapeshift.confirm',
          fixedUnit: true,
        }
      })
      .state('tabs.shapeshift.confirm', {
        url: '/confirm/:amount/:currency/:id/:toWalletId/:useSendMax',
        views: {
          'tab-home@tabs': {
            controller: 'shapeshiftConfirmController',
            templateUrl: 'views/shapeshiftConfirm.html'
          }
        }
      })

      /*
       *
       * Lucky money
       *
       */


//      .state('tabs.luckymoney', {
//        url: '/luckymoney',
//        views: {
//          'tab-settings@tabs': {
//            templateUrl: 'views/luckymoney/luckymoney.html',
//            controller: 'luckymoneyController'
//          }
//        }
//      })
      .state('tabs.luckymoney.share', {
        url: '/luckymoney/share/:luckymoneyId',
        views: {
          'tab-settings@tabs': {
            controller: 'luckymoneyShareController',
            templateUrl: 'views/luckymoney/share.html'
          }
        }
      })
      .state('tabs.luckymoney.history', {
        url: '/luckymoney/history',
        views: {
          'tab-settings@tabs': {
            controller: 'luckymoneyHistoryController',
            templateUrl: 'views/luckymoney/history.html'
          }
        }
      })
      ;
  })
  .run(function($rootScope, $state, $location, $log, $timeout, startupService, ionicToast, fingerprintService, $ionicHistory, $ionicPlatform, $window, appConfigService, lodash, platformInfo, profileService, uxLanguage, gettextCatalog, openURLService, storageService, scannerService, configService, emailService, /* plugins START HERE => */ coinbaseService, glideraService, amazonService, shapeshiftService, bitpayCardService, applicationService, mercadoLibreService) {

    uxLanguage.init();

    $ionicPlatform.ready(function() {
      if (screen.width < 768 && platformInfo.isCordova)
        screen.lockOrientation('portrait');

      if (window.cordova && window.cordova.plugins && window.cordova.plugins.Keyboard && !platformInfo.isWP) {
        cordova.plugins.Keyboard.hideKeyboardAccessoryBar(false);
        cordova.plugins.Keyboard.disableScroll(true);
      }

      window.addEventListener('native.keyboardshow', function() {
        document.body.classList.add('keyboard-open');
      });

      $ionicPlatform.registerBackButtonAction(function(e) {

        //from root tabs view
        var matchHome = $ionicHistory.currentStateName() == 'tabs.home' ? true : false;
        var matchReceive = $ionicHistory.currentStateName() == 'tabs.receive' ? true : false;
        var matchScan = $ionicHistory.currentStateName() == 'tabs.scan' ? true : false;
        var matchSend = $ionicHistory.currentStateName() == 'tabs.send' ? true : false;
        var matchSettings = $ionicHistory.currentStateName() == 'tabs.settings' ? true : false;

        var fromTabs = matchHome | matchReceive | matchScan | matchSend | matchSettings;

        //onboarding with no back views
        var matchWelcome = $ionicHistory.currentStateName() == 'onboarding.welcome' ? true : false;
        var matchCollectEmail = $ionicHistory.currentStateName() == 'onboarding.collectEmail' ? true : false;
        var matchBackupRequest = $ionicHistory.currentStateName() == 'onboarding.backupRequest' ? true : false;
        var backedUp = $ionicHistory.backView().stateName == 'onboarding.backup' ? true : false;
        var noBackView = $ionicHistory.backView().stateName == 'starting' ? true : false;
        var matchDisclaimer = $ionicHistory.currentStateName() == 'onboarding.disclaimer' && (backedUp || noBackView) ? true : false;

        var fromOnboarding = matchCollectEmail | matchBackupRequest | matchWelcome | matchDisclaimer;

        //views with disable backbutton
        var matchComplete = $ionicHistory.currentStateName() == 'tabs.rate.complete' ? true : false;
        var matchLockedView = $ionicHistory.currentStateName() == 'lockedView' ? true : false;
        var matchPin = $ionicHistory.currentStateName() == 'pin' ? true : false;

        if ($ionicHistory.backView() && !fromTabs && !fromOnboarding && !matchComplete && !matchPin && !matchLockedView) {
          $ionicHistory.goBack();
        } else
        if ($rootScope.backButtonPressedOnceToExit) {
          navigator.app.exitApp();
        } else {
          $rootScope.backButtonPressedOnceToExit = true;
          $rootScope.$apply(function() {
            ionicToast.show(gettextCatalog.getString('Press again to exit'), 'bottom', false, 1000);
          });
          $timeout(function() {
            $rootScope.backButtonPressedOnceToExit = false;
          }, 3000);
        }
        e.preventDefault();
      }, 101);

      $ionicPlatform.on('pause', function() {
        // Nothing to do
      });

      $ionicPlatform.on('resume', function() {
        applicationService.appLockModal('check');
      });

      $ionicPlatform.on('menubutton', function() {
        window.location = '#/preferences';
      });

      $log.info('Init profile...');
      // Try to open local profile
      profileService.loadAndBindProfile(function(err) {
        $ionicHistory.nextViewOptions({
          disableAnimate: true
        });
        if (err) {
          if (err.message && err.message.match('NOPROFILE')) {
            $log.debug('No profile... redirecting');
            $state.go('onboarding.welcome');
          } else if (err.message && err.message.match('NONAGREEDDISCLAIMER')) {
            if (lodash.isEmpty(profileService.getWallets())) {
              $log.debug('No wallets and no disclaimer... redirecting');
              $state.go('onboarding.welcome');
            } else {
              $log.debug('Display disclaimer... redirecting');
              $state.go('onboarding.disclaimer', {
                resume: true
              });
            }
          } else {
            throw new Error(err); // TODO
          }
        } else {
          profileService.storeProfileIfDirty();
          $log.debug('Profile loaded ... Starting UX.');
          scannerService.gentleInitialize();
          // Reload tab-home if necessary (from root path: starting)
          $state.go('starting', {}, {
            'reload': true,
            'notify': $state.current.name == 'starting' ? false : true
          }).then(function() {
            $ionicHistory.nextViewOptions({
              disableAnimate: true,
              historyRoot: true
            });
            $state.transitionTo('tabs.home').then(function() {
              // Clear history
              $ionicHistory.clearHistory();
            });
            applicationService.appLockModal('check');
          });
        };
        // After everything have been loaded
        $timeout(function() {
          emailService.init(); // Update email subscription if necessary
          openURLService.init();
        }, 1000);
      });
    });

    if (platformInfo.isNW) {
      var gui = require('nw.gui');
      var win = gui.Window.get();
      var nativeMenuBar = new gui.Menu({
        type: "menubar"
      });
      try {
        nativeMenuBar.createMacBuiltin(appConfigService.nameCase);
      } catch (e) {
        $log.debug('This is not OSX');
      }
      win.menu = nativeMenuBar;
    }

    $rootScope.$on('$stateChangeStart', function(event, toState, toParams, fromState, fromParams) {
      $log.debug('Route change from:', fromState.name || '-', ' to:', toState.name);
      $log.debug('            toParams:' + JSON.stringify(toParams || {}));
      $log.debug('            fromParams:' + JSON.stringify(fromParams || {}));
    });
  });

'use strict';

angular.module('copayApp.directives')
  .directive('accountSelector', function($timeout) {
    return {
      restrict: 'E',
      templateUrl: 'views/includes/accountSelector.html',
      transclude: true,
      scope: {
        title: '=accountSelectorTitle',
        show: '=accountSelectorShow',
        accounts: '=accountSelectorAccounts',
        selectedAccount: '=accountSelectorSelectedAccount',
        onSelect: '=accountSelectorOnSelect'
      },
      link: function(scope, element, attrs) {
        scope.hide = function() {
          scope.show = false;
        };
        scope.selectAccount = function(account) {
          $timeout(function() {
            scope.hide();
          }, 100);
          scope.onSelect(account);
        };
      }
    };
  });

'use strict';

angular.module('copayApp.directives')
  .directive('actionSheet', function($rootScope, $timeout) {
    return {
      restrict: 'E',
      templateUrl: 'views/includes/actionSheet.html',
      transclude: true,
      scope: {
        show: '=actionSheetShow',
      },
      link: function(scope, element, attrs) {
        scope.$watch('show', function() {
          if (scope.show) {
            $timeout(function() {
              scope.revealMenu = true;
            }, 100);
          } else {
            scope.revealMenu = false;
          }
        });
        scope.hide = function() {
          scope.show = false;
          $rootScope.$broadcast('incomingDataMenu.menuHidden');
        };
      }
    };
  });

'use strict';

angular.module('copayApp.directives')
  .directive('clickToAccept', function() {
    return {
      restrict: 'E',
      templateUrl: 'views/includes/clickToAccept.html',
      transclude: true,
      scope: {
        sendStatus: '=clickSendStatus',
        isDisabled: '=isDisabled',
      },
      link: function(scope, element, attrs) {
        scope.$watch('sendStatus', function() {
          if (scope.sendStatus !== 'success') {
            scope.displaySendStatus = scope.sendStatus;
          }
        });
      }
    };
  });

'use strict';

angular.module('copayApp.directives')
  .directive('copyToClipboard', function(platformInfo, nodeWebkitService, gettextCatalog, ionicToast, clipboard) {
    return {
      restrict: 'A',
      scope: {
        copyToClipboard: '=copyToClipboard'
      },
      link: function(scope, elem, attrs, ctrl) {
        var isCordova = platformInfo.isCordova;
        var isChromeApp = platformInfo.isChromeApp;
        var isNW = platformInfo.isNW;
        elem.bind('mouseover', function() {
          elem.css('cursor', 'pointer');
        });

        var msg = gettextCatalog.getString('Copied to clipboard');
        elem.bind('click', function() {
          var data = scope.copyToClipboard;
          if (!data) return;

          if (isCordova) {
            cordova.plugins.clipboard.copy(data);
          } else if (isNW) {
            nodeWebkitService.writeToClipboard(data);
          } else if (clipboard.supported) {
            clipboard.copyText(data);
          } else {
            // No supported
            return;
          }
          scope.$apply(function() {
            ionicToast.show(msg, 'bottom', false, 1000);
          });
        });
      }
    }
  });

'use strict';

angular.module('copayApp.directives')
  .directive('timer', function() {
    return {
      restrict: 'EAC',
      replace: false,
      scope: {
        countdown: "=",
        interval: "=",
        active: "=",
        onZeroCallback: "="
      },
      template:"{{formatted}}",
      controller: function ($scope, $attrs, $timeout, lodash) {
        $scope.format = $attrs.outputFormat;

        var queueTick = function () {
          $scope.timer = $timeout(function () {
            if ($scope.countdown > 0) {
              $scope.countdown -= 1;

              if ($scope.countdown > 0) {
                queueTick();
              } else {
                $scope.countdown = 0;
                $scope.active = false;
                if (!lodash.isUndefined($scope.onZeroCallback)) {
                  $scope.onZeroCallback();
                }
              }
            }
          }, $scope.interval);
        };

        if ($scope.active) {
          queueTick();
        }

        $scope.$watch('active', function (newValue, oldValue) {
          if (newValue !== oldValue) {
            if (newValue === true) {
              if ($scope.countdown > 0) {
                queueTick();
              } else {
                $scope.active = false;
              }
            } else {
              $timeout.cancel($scope.timer);
            }
          }
        });
        $scope.$watch('countdown', function () {
          updateFormatted();
        });

        var updateFormatted = function () {
          $scope.formatted = moment($scope.countdown * $scope.interval).format($scope.format);
        };
        updateFormatted();

        $scope.$on('$destroy', function () {
          $timeout.cancel($scope.timer);
        });
      }
    };
  });

'use strict';
angular.module('copayApp.directives')
  .directive('validAddress', ['$rootScope', 'bitcore', 'bitcoreCash',
    function($rootScope, bitcore, bitcoreCash) {
      return {
        require: 'ngModel',
        link: function(scope, elem, attrs, ctrl) {
          // Qybcoin address
          var URI = bitcore.URI;
          var Address = bitcore.Address

          // Qybcoin Cash address
          var URICash = bitcoreCash.URI;
          var AddressCash = bitcoreCash.Address

          var validator = function(value) {

            // Regular url
            if (/^https?:\/\//.test(value)) {
              ctrl.$setValidity('validAddress', true);
              return value;
            }

            // Bip21 uri
            var uri, isAddressValidLivenet, isAddressValidTestnet;
            if (/^qybcoin:/.test(value)) {
              var isUriValid = URI.isValid(value);
              if (isUriValid) {
                uri = new URI(value);
                isAddressValidLivenet = Address.isValid(uri.address.toString(), 'livenet')
                isAddressValidTestnet = Address.isValid(uri.address.toString(), 'testnet')
              }
              ctrl.$setValidity('validAddress', isUriValid && (isAddressValidLivenet || isAddressValidTestnet));
              return value;
            } else if (/^bitcoincash:/.test(value)) {
              var isUriValid = URICash.isValid(value);
              if (isUriValid) {
                uri = new URICash(value);
                isAddressValidLivenet = AddressCash.isValid(uri.address.toString(), 'livenet')
              }
              ctrl.$setValidity('validAddress', isUriValid && (isAddressValidLivenet));
              return value;
            }

            if (typeof value == 'undefined') {
              ctrl.$pristine = true;
              return;
            }

            // Regular Address: try Qybcoin and Qybcoin Cash
            var regularAddressLivenet = Address.isValid(value, 'livenet');
            var regularAddressTestnet = Address.isValid(value, 'testnet');
            var regularAddressCashLivenet = AddressCash.isValid(value, 'livenet');
            ctrl.$setValidity('validAddress', (regularAddressLivenet || regularAddressTestnet || regularAddressCashLivenet));
            return value;
          };


          ctrl.$parsers.unshift(validator);
          ctrl.$formatters.unshift(validator);
        }
      };
    }
  ])
  .directive('validAmount', ['configService',
    function(configService) {

      return {
        require: 'ngModel',
        link: function(scope, element, attrs, ctrl) {
          var val = function(value) {
            var settings = configService.getSync().wallet.settings;
            var vNum = Number((value * settings.unitToSatoshi).toFixed(0));
            if (typeof value == 'undefined' || value == 0) {
              ctrl.$pristine = true;
            }



            if (typeof vNum == "number" && vNum > 0) {
              if (vNum > Number.MAX_SAFE_INTEGER) {
                ctrl.$setValidity('validAmount', false);
              } else {
                var decimals = Number(settings.unitDecimals);
                var sep_index = ('' + value).indexOf('.');
                var str_value = ('' + value).substring(sep_index + 1);
                if (sep_index >= 0 && str_value.length > decimals) {
                  ctrl.$setValidity('validAmount', false);
                  return;
                } else {
                  ctrl.$setValidity('validAmount', true);
                }
              }
            } else {
              ctrl.$setValidity('validAmount', false);
            }
            return value;
          }
          ctrl.$parsers.unshift(val);
          ctrl.$formatters.unshift(val);
        }
      };
    }
  ])
  .directive('walletSecret', function(bitcore) {
    return {
      require: 'ngModel',
      link: function(scope, elem, attrs, ctrl) {
        var validator = function(value) {
          if (value.length > 0) {
            var m = value.match(/^[0-9A-HJ-NP-Za-km-z]{70,80}$/);
            ctrl.$setValidity('walletSecret', m ? true : false);
          }
          return value;
        };

        ctrl.$parsers.unshift(validator);
      }
    };
  })
  .directive('ngFileSelect', function() {
    return {
      link: function($scope, el) {
        el.bind('change', function(e) {
          $scope.formData.file = (e.srcElement || e.target).files[0];
          $scope.getFile();
        });
      }
    }
  })
  .directive('contact', ['addressbookService', 'lodash',
    function(addressbookService, lodash) {
      return {
        restrict: 'E',
        link: function(scope, element, attrs) {
          var addr = attrs.address;
          addressbookService.get(addr, function(err, ab) {
            if (ab) {
              var name = lodash.isObject(ab) ? ab.name : ab;
              element.append(name);
            } else {
              element.append(addr);
            }
          });
        }
      };
    }
  ])
  .directive('ignoreMouseWheel', function($rootScope, $timeout) {
    return {
      restrict: 'A',
      link: function(scope, element, attrs) {
        element.bind('mousewheel', function(event) {
          element[0].blur();
          $timeout(function() {
            element[0].focus();
          }, 1);
        });
      }
    }
  });

'use strict';

angular.module('copayApp.directives')
  .directive('gravatar', function(md5) {
    return {
      restrict: 'AE',
      replace: true,
      scope: {
        name: '@',
        height: '@',
        width: '@',
        email: '@'
      },
      link: function(scope, el, attr) {
        if (typeof scope.email === "string") {
          scope.emailHash = md5.createHash(scope.email.toLowerCase() || '');
        }
      },
      template: '<img class="gravatar" alt="{{ name }}" height="{{ height }}"  width="{{ width }}" src="https://secure.gravatar.com/avatar/{{ emailHash }}.jpg?s={{ width }}&d=mm">'
    };
  });

'use strict';
angular.module('copayApp.directives')
.directive('hideTabs', function($rootScope, $timeout) {
  return {
    restrict: 'A',
    link: function($scope, $el) {
      $scope.$on("$ionicView.beforeEnter", function(event, data){
        $timeout(function() {
          $rootScope.hideTabs = 'tabs-item-hide';
          $rootScope.$apply();
        });
      });
    }
  };
});

'use strict';

angular.module('copayApp.directives')
  .directive('incomingDataMenu', function($timeout, $rootScope, $state, externalLinkService) {
    return {
      restrict: 'E',
      templateUrl: 'views/includes/incomingDataMenu.html',
      link: function(scope, element, attrs) {
        $rootScope.$on('incomingDataMenu.showMenu', function(event, data) {
          $timeout(function() {
            scope.data = data.data;
            scope.type = data.type;
            scope.showMenu = true;
            scope.https = false;

            if (scope.type === 'url') {
              if (scope.data.indexOf('https://') === 0) {
                scope.https = true;
              }
            }
          });
        });
        scope.hide = function() {
          scope.showMenu = false;
          $rootScope.$broadcast('incomingDataMenu.menuHidden');
        };
        scope.goToUrl = function(url) {
          externalLinkService.open(url);
        };
        scope.sendPaymentToAddress = function(bitcoinAddress) {
          scope.showMenu = false;
          $state.go('tabs.send').then(function() {
            $timeout(function() {
              $state.transitionTo('tabs.send.amount', {
                toAddress: bitcoinAddress
              });
            }, 50);
          });
        };
        scope.addToAddressBook = function(bitcoinAddress) {
          scope.showMenu = false;
          $timeout(function() {
            $state.go('tabs.send').then(function() {
              $timeout(function() {
                $state.transitionTo('tabs.send.addressbook', {
                  addressbookEntry: bitcoinAddress
                });
              });
            });
          }, 100);
        };
        scope.scanPaperWallet = function(privateKey) {
          scope.showMenu = false;
          $state.go('tabs.home').then(function() {
            $timeout(function() {
              $state.transitionTo('tabs.home.paperWallet', {
                privateKey: privateKey
              });
            }, 50);
          });
        };
      }
    };
  });

'use strict';

angular.module('copayApp.directives')
  .directive('itemSelector', function($timeout) {
    return {
      restrict: 'E',
      templateUrl: 'views/includes/itemSelector.html',
      transclude: true,
      scope: {
        show: '=itemSelectorShow',
        onSelect: '=itemSelectorOnSelect'
      },
      link: function(scope, element, attrs) {
        scope.hide = function() {
          scope.show = false;
        };
        scope.sendMax = function() {
          $timeout(function() {
            scope.hide();
          }, 100);
          scope.onSelect();
        };
      }
    };
  });

'use strict';

angular.module('copayApp.directives')
  .directive('logOptions', function($timeout, platformInfo) {
    return {
      restrict: 'E',
      templateUrl: 'views/includes/logOptions.html',
      transclude: true,
      scope: {
        show: '=logOptionsShow',
        options: '=logOptions',
        fillClass: '=logOptionsFillClass',
        onSelect: '=logOptionsOnSelect',
        onCopy: '=logOptionsOnCopy',
        onSend: '=logOptionsOnSend'
      },
      link: function(scope, element, attrs) {
        scope.isCordova = platformInfo.isCordova;

        scope.hide = function() {
          scope.show = false;
        };

        scope.getFillClass = function(index) {
          scope.onSelect(index);
        };
      }
    };
  });

'use strict';

angular.module('copayApp.directives')
  /**
   * Replaces img tag with its svg content to allow for CSS styling of the svg.
   */
  .directive('noLowFee', function($log, $ionicHistory, configService, popupService) {
    return {
      restrict: 'A',
      link: function(scope, elem, attrs, ctrl) {


        elem.bind('click', function() {
          configService.whenAvailable(function(config) {
            if (config.wallet.settings.feeLevel && config.wallet.settings.feeLevel.match(/conomy/)) {
              $log.debug('Economy Fee setting... disabling link:' + elem.text());
              popupService.showAlert('Low Fee Error', 'Please change your Qybcoin Network Fee Policy setting to Normal or higher to use this service', function() {
                $ionicHistory.goBack();
              });
            }
          });
        });
      }
    }
  });

'use strict';

angular.module('copayApp.directives')
  .directive('qrScanner', function($state, $rootScope, $log, $ionicHistory, platformInfo, scannerService, popupService) {

    return {
      restrict: 'E',
      scope: {
        onScan: "&"
      },
      replace: true,
      template: '<a on-tap="chooseScanner()" nav-transition="none"><i class="icon ion-qr-scanner"></i></a>',
      link: function(scope, el, attrs) {

        scope.chooseScanner = function() {
          var isWindowsPhoneApp = platformInfo.isCordova && platformInfo.isWP;

          if (!isWindowsPhoneApp) {
            scope.openScanner();
            return;
          }

          scannerService.useOldScanner(function(err, contents) {
            if (err) {
              popupService.showAlert(gettextCatalog.getString('Error'), err);
              return;
            }
            scope.onScan({
              data: contents
            });
          });
        };

        scope.openScanner = function() {
          $log.debug('Opening scanner by directive...');
          $ionicHistory.nextViewOptions({
            disableAnimate: true
          });
          $state.go('scanner', {
            passthroughMode: 1
          });
        };

        var afterEnter = $rootScope.$on('$ionicView.afterEnter', function() {
          if ($rootScope.scanResult) {
            scope.onScan({
              data: $rootScope.scanResult
            });
            $rootScope.scanResult = null;
          }
        });

        // Destroy event
        scope.$on('$destroy', function() {
          afterEnter();
        });
      }
    }
  });

'use strict';
angular.module('copayApp.directives')
  .directive('showTabs', function($rootScope, $timeout) {
    return {
      restrict: 'A',
      link: function($scope, $el) {
        $scope.$on("$ionicView.beforeEnter", function(event, data) {
          $timeout(function() {
            $rootScope.hideTabs = '';
            $rootScope.$apply();
          });
        });
      }
    };
  });

'use strict';

angular.module('copayApp.directives')
  .directive('simplePay', function ($timeout, lodash) {
    return {
      restrict: 'E',
      templateUrl: 'views/includes/simplePay.html',
      transclude: true,
      scope: {
        title: '=simplePayTitle',
        show: '=simplePayShow',
        wallets: '=simplePayWallets',
        selectedWallet: '=simplePaySelectedWallet',
        onSelect: '=simplePayOnSelect',
        sendStatus: '=simplePaySendStatus',
        statusChangeHandler: '=simplePayStatusChangeHandler',
        approve: '=simplePayApprove',
        isCordova:'=simplePayIsCordova',
        isWindowsPhoneApp:'=simplePayIsWindowsPhoneApp',
      },
      link: function (scope, element, attrs) {

        var separeWallets = function () {
          scope.walletsBtc = [];
          scope.walletsBch = [];
          if (!scope.wallets) return;
          for (var i = 0; i <= scope.wallets.length; i++) {
            if (scope.wallets[i]) {
              if (scope.wallets[i].coin == 'btc') scope.walletsBtc.push(scope.wallets[i]);
              else scope.walletsBch.push(scope.wallets[i]);
            }
          }
        }

        scope.$watch('wallets', function (newVal, oldVal) {
          var isEqual = lodash.isEqual(newVal, oldVal);
          if (!isEqual) separeWallets();
        });

        scope.hide = function () {
          scope.show = false;
        };

        scope.selectWallet = function (wallet) {
          $timeout(function () {
            scope.hide();
          }, 100);
          scope.onSelect(wallet);
        };

        separeWallets();
      }
    };
  });

'use strict';

angular.module('copayApp.directives')
  .directive('slideToAccept', function($timeout, $window, $q) {
    return {
      restrict: 'E',
      templateUrl: 'views/includes/slideToAccept.html',
      transclude: true,
      scope: {
        sendStatus: '=slideSendStatus',
        onConfirm: '&slideOnConfirm',
        isDisabled: '=isDisabled'
      },
      link: function(scope, element, attrs) {

        var KNOB_WIDTH = 71;
        var MAX_SLIDE_START_PERCENTAGE = 50;
        var FULLY_SLID_PERCENTAGE = 72;
        var PERCENTAGE_BUMP = 5;
        var JIGGLE_EASING = linear;
        var JIGGLE_DURATION = 100;
        var RECEDE_DURATION = 250;
        var INITIAL_TAP_EASE_DURATION = 75;

        var elm = element[0];
        var isSliding = false;
        var curSliderPct = getKnobWidthPercentage();
        var curBitcoinPct = 0;
        var curTextPct = 0;
        var currentEaseStartTime;
        var bezier = $window.BezierEasing(0.175, 0.885, 0.320, 1.275);

        scope.isSlidFully = false;
        scope.displaySendStatus = '';

        scope.$watch('sendStatus', function() {
          if (!scope.sendStatus) {
            reset();
          } else if (scope.sendStatus === 'success') {
            scope.displaySendStatus = '';
            $timeout(function() {
              reset();
            }, 500);
          } else {
            scope.displaySendStatus = scope.sendStatus;
          }
        });

        function easePosition(fromPct, pct, duration, easeFx, animateFx) {
          var deferred = $q.defer();
          currentEaseStartTime = Date.now();
          var startTime = currentEaseStartTime;
          var initialPct = fromPct;
          var distance = pct - fromPct;

          function ease() {
            if (startTime !== currentEaseStartTime) {
              return;
            }
            $window.requestAnimationFrame(function() {
              var now = Date.now();
              var elapsed = now - startTime;
              var normalizedElapsedTime = elapsed / duration;
              var newVal = easeFx(normalizedElapsedTime);
              var newPct = newVal * distance + initialPct;
              animateFx(newPct);
              scope.$digest();
              if (elapsed < duration) {
                ease();
              } else {
                deferred.resolve();
              }
            });
          }
          ease();
          return deferred.promise;
        }

        function linear(t) {
          return t;
        }

        function easeInOutBack(t) {
          return bezier(t);
        }

        function reset() {
          scope.isSlidFully = false;
          isSliding = false;
          setNewSliderStyle(getKnobWidthPercentage());
          setNewBitcoinStyle(0);
          setNewTextStyle(0);
        }

        function setNewSliderStyle(pct) {
          var knobWidthPct = getKnobWidthPercentage();
          var translatePct = pct - knobWidthPct;
          if (isSliding) {
            translatePct += 0.35 * pct;
          }
          scope.sliderStyle = getTransformStyle(translatePct);
          curSliderPct = pct;
        }

        function setNewBitcoinStyle(pct) {
          var translatePct = -2.25 * pct;
          scope.bitcoinStyle = getTransformStyle(translatePct);
          curBitcoinPct = pct;
        }

        function setNewTextStyle(pct) {
          var translatePct = -0.1 * pct;
          scope.textStyle = getTransformStyle(translatePct);
          curTextPct = pct;
        }

        function getTransformStyle(translatePct) {
          return {
            'transform': 'translateX(' + translatePct + '%)'
          };
        }

        function getKnobWidthPercentage() {
          var knobWidthPct = (KNOB_WIDTH / elm.clientWidth) * 100;
          return knobWidthPct;
        }

        function setSliderPosition(pct) {
          setNewSliderStyle(pct);
          setNewBitcoinStyle(pct);
          setNewTextStyle(pct);
        }

        function easeSliderPosition(pct) {
          var duration = INITIAL_TAP_EASE_DURATION;
          easePosition(curSliderPct, pct, duration, JIGGLE_EASING, function(pct) {
            setNewSliderStyle(pct);
          });
          easePosition(curBitcoinPct, pct, duration, JIGGLE_EASING, function(pct) {
            setNewBitcoinStyle(pct);
          });
          easePosition(curTextPct, pct, duration, JIGGLE_EASING, function(pct) {
            setNewTextStyle(pct);
          });
        }

        function jiggleSlider() {
          var pct = getKnobWidthPercentage() + PERCENTAGE_BUMP;
          var duration = JIGGLE_DURATION;
          var p1 = easePosition(curSliderPct, pct, duration, JIGGLE_EASING, function(pct) {
            setNewSliderStyle(pct);
          });
          var p2 = easePosition(curBitcoinPct, pct, duration, JIGGLE_EASING, function(pct) {
            setNewBitcoinStyle(pct);
          });

          $q.all([p1, p2]).then(function() {
            recede();
          });
        }

        function recede() {
          var duration = RECEDE_DURATION;
          easePosition(curSliderPct, getKnobWidthPercentage(), duration, easeInOutBack, function(pct) {
            setNewSliderStyle(pct);
          });
          easePosition(curBitcoinPct, 0, duration, easeInOutBack, function(pct) {
            setNewBitcoinStyle(pct);
          });
          easePosition(curTextPct, 0, duration, easeInOutBack, function(pct) {
            setNewTextStyle(pct);
          });
        }

        function alertSlidFully() {
          scope.isSlidFully = true;
          scope.onConfirm();
        }

        function getTouchXPosition($event) {
          var x;
          if ($event.touches || $event.changedTouches) {
            if ($event.touches.length) {
              x = $event.touches[0].clientX;
            } else {
              x = $event.changedTouches[0].clientX;
            }
          } else {
            x = $event.clientX;
          }
          return x;
        }

        function getSlidPercentage($event) {
          var x = getTouchXPosition($event);
          var width = elm.clientWidth;
          var pct = (x / width) * 100;
          if (x >= width) {
            pct = 100;
          }
          return pct;
        }

        scope.onTouchstart = function($event) {
          if (scope.isSlidFully) {
            return;
          }
          if (!isSliding) {
            var pct = getSlidPercentage($event);
            if (pct > MAX_SLIDE_START_PERCENTAGE) {
              jiggleSlider();
              return;
            } else {
              isSliding = true;
              var knobWidthPct = getKnobWidthPercentage();
              if (pct < knobWidthPct) {
                pct = knobWidthPct;
              }
              pct += PERCENTAGE_BUMP;
              easeSliderPosition(pct);
            }
          }
        };

        scope.onTouchmove = function($event) {
          if (!isSliding || scope.isSlidFully) {
            return;
          }
          var pct = getSlidPercentage($event);
          var knobWidthPct = getKnobWidthPercentage();
          if (pct < knobWidthPct) {
            pct = knobWidthPct;
          }
          pct += PERCENTAGE_BUMP;
          currentEaseStartTime = null;
          setSliderPosition(pct);
        };

        scope.onTouchend = function($event) {
          if (scope.isSlidFully) {
            return;
          }
          var pct = getSlidPercentage($event);
          if (isSliding && pct > FULLY_SLID_PERCENTAGE) {
            pct = 100;
            setSliderPosition(pct);
            alertSlidFully();
          } else {
            recede();
          }
          isSliding = false;
        };
      }
    };
  });

'use strict';

angular.module('copayApp.directives')
  .directive('slideToAcceptSuccess', function($timeout, platformInfo) {
    return {
      restrict: 'E',
      templateUrl: 'views/includes/slideToAcceptSuccess.html',
      transclude: true,
      scope: {
        isShown: '=slideSuccessShow',
        onConfirm: '&slideSuccessOnConfirm',
        hideOnConfirm: '=slideSuccessHideOnConfirm'
      },
      link: function(scope, element, attrs) {

        scope.isWindowsPhoneApp = platformInfo.isCordova && platformInfo.isWP;

        var elm = element[0];
        elm.style.display = 'none';
        scope.$watch('isShown', function() {
          if (scope.isShown) {
            elm.style.display = 'flex';
            $timeout(function() {
              scope.fillScreen = true;
            }, 10);
          }
        });
        scope.onConfirmButtonClick = function() {
          scope.onConfirm();
          if (scope.hideOnConfirm) {
            scope.fillScreen = false;
            elm.style.display = 'none';
          }
        };
      }
    };
  });

'use strict';

angular.module('copayApp.directives')
  /**
   * Replaces img tag with its svg content to allow for CSS styling of the svg.
   */
  .directive('svg', function($http) {
    return {
      restrict: 'C',
      link: function(scope, element, attrs) {
        var imgId = attrs.id;
        var imgClass = attrs.class;
        var imgUrl = attrs.src || attrs.ngSrc;
        var svg;

        // Load svg content
        $http.get(imgUrl).success(function(data, status) {
          svg = angular.element(data);
          for (var i = svg.length - 1; i >= 0; i--) {
            if (svg[i].constructor == SVGSVGElement) {
              svg = angular.element(svg[i]);
              break;
            }
          }

          if (typeof imgId !== 'undefined') {
            svg.attr('id', imgId);
          }

          if (typeof imgClass !== 'undefined') {
            svg.attr('class', imgClass);
          }
          // Remove invalid attributes
          svg = svg.removeAttr('xmlns:a');
          element.replaceWith(svg);
        });

        scope.$on('$destroy', function() {
          if (svg) svg.remove();
        });
      }
    };
  });
    
'use strict';

angular.module('copayApp.directives')
  .directive('walletSelector', function($timeout, lodash) {
    return {
      restrict: 'E',
      templateUrl: 'views/includes/walletSelector.html',
      transclude: true,
      scope: {
        title: '=walletSelectorTitle',
        show: '=walletSelectorShow',
        wallets: '=walletSelectorWallets',
        selectedWallet: '=walletSelectorSelectedWallet',
        onSelect: '=walletSelectorOnSelect'
      },
      link: function(scope, element, attrs) {

        var separeWallets = function() {
          scope.walletsBtc = [];
          scope.walletsBch = [];
          if (!scope.wallets) return;
          for(var i = 0; i <= scope.wallets.length; i++) {
            if (scope.wallets[i]) {
              if (scope.wallets[i].coin == 'btc') scope.walletsBtc.push(scope.wallets[i]);
              else scope.walletsBch.push(scope.wallets[i]);
            }
          }
        }

        scope.$watch('wallets', function(newVal, oldVal) {
          var isEqual = lodash.isEqual(newVal, oldVal);
          if (!isEqual) separeWallets();
        });

        scope.hide = function() {
          scope.show = false;
        };
        scope.selectWallet = function(wallet) {
          $timeout(function() {
            scope.hide();
          }, 100);
          scope.onSelect(wallet);
        };

        separeWallets();
      }
    };
  });

'use strict';

angular.module('copayApp.filters', [])
  .filter('amTimeAgo', ['amMoment',
    function(amMoment) {
      return function(input) {
        return amMoment.preprocessDate(input).fromNow();
      };
    }
  ])
  .filter('paged', function() {
    return function(elements) {
      if (elements) {
        return elements.filter(Boolean);
      }

      return false;
    };
  })
  .filter('removeEmpty', function() {
    return function(elements) {
      elements = elements || [];
      // Hide empty change addresses from other copayers
      return elements.filter(function(e) {
        return !e.isChange || e.balance > 0;
      });
    }
  })
  .filter('formatFiatAmount', ['$filter', '$locale', 'configService',
    function(filter, locale) {
      var numberFilter = filter('number');
      var formats = locale.NUMBER_FORMATS;
      return function(amount) {

        var fractionSize = 2;
        var value = numberFilter(amount, fractionSize);
        var sep = value.indexOf(formats.DECIMAL_SEP);
        var group = value.indexOf(formats.GROUP_SEP);

        if (amount >= 0) {
          if (group > 0) {
            if (sep < 0) {
              return value;
            }
            var intValue = value.substring(0, sep);
            var floatValue = parseFloat(value.substring(sep));
            floatValue = floatValue.toFixed(2);
            floatValue = floatValue.toString().substring(1);
            var finalValue = intValue + floatValue;
            return finalValue;
          } else {
            value = parseFloat(value);
            return value.toFixed(2);
          }
        }
        return 0;
      };
    }
  ])
  .filter('orderObjectBy', function() {
    return function(items, field, reverse) {
      var filtered = [];
      angular.forEach(items, function(item) {
        filtered.push(item);
      });
      filtered.sort(function(a, b) {
        return (a[field] > b[field] ? 1 : -1);
      });
      if (reverse) filtered.reverse();
      return filtered;
    };
  })
  .filter('range', function() {
    return function(input, total) {
      total = parseInt(total);
      for (var i = 0; i < total; i++)
        input.push(i);
      return input;
    };
  });

'use strict';

/**
 * Profile
 *
 * credential: array of OBJECTS
 */
function Profile() {
  this.version = '1.0.0';
};

Profile.create = function(opts) {
  opts = opts || {};

  var x = new Profile();
  x.createdOn = Date.now();
  x.credentials = opts.credentials || [];
  x.disclaimerAccepted = false;
  x.checked = {};
  return x;
};

Profile.fromObj = function(obj) {
  var x = new Profile();

  x.createdOn = obj.createdOn;
  x.credentials = obj.credentials;
  x.disclaimerAccepted = obj.disclaimerAccepted;
  x.checked = obj.checked || {};
  x.checkedUA = obj.checkedUA || {};

  if (x.credentials[0] && typeof x.credentials[0] != 'object')
    throw ("credentials should be an object");

  return x;
};

Profile.fromString = function(str) {
  return Profile.fromObj(JSON.parse(str));
};

Profile.prototype.toObj = function() {
  delete this.dirty;
  return JSON.stringify(this);
};


Profile.prototype.hasWallet = function(walletId) {
  for (var i in this.credentials) {
    var c = this.credentials[i];
    if (c.walletId == walletId) return true;
  };
  return false;
};

Profile.prototype.isChecked = function(ua, walletId) {
  return !!(this.checkedUA == ua && this.checked[walletId]);
};


Profile.prototype.isDeviceChecked = function(ua) {
  return this.checkedUA == ua;
};


Profile.prototype.setChecked = function(ua, walletId) {
  if (this.checkedUA != ua) {
    this.checkedUA = ua;
    this.checked = {};
  }
  this.checked[walletId] = true;
  this.dirty = true;
};


Profile.prototype.addWallet = function(credentials) {
  if (!credentials.walletId)
    throw 'credentials must have .walletId';

  if (this.hasWallet(credentials.walletId))
    return false;

  this.credentials.push(credentials);
  this.dirty = true;
  return true;
};

Profile.prototype.updateWallet = function(credentials) {
  if (!credentials.walletId)
    throw 'credentials must have .walletId';

  if (!this.hasWallet(credentials.walletId))
    return false;

  this.credentials = this.credentials.map(function(c) {
    if(c.walletId != credentials.walletId ) {
      return c;
    } else {
      return credentials
    }
  });

  this.dirty = true;
  return true;
};

Profile.prototype.deleteWallet = function(walletId) {
  if (!this.hasWallet(walletId))
    return false;

  this.credentials = this.credentials.filter(function(c) {
    return c.walletId != walletId;
  });

  this.dirty = true;
  return true;
};

'use strict';

angular.module('copayApp.services').factory('addressbookService', function($log, bitcore, bitcoreCash, storageService, lodash) {
  var root = {};

  var getNetwork = function(address) {
    var network;
    try {
      network = (new bitcore.Address(address)).network.name;
    } catch(e) {
      $log.warn('No valid bitcoin address. Trying bitcoin cash...');
      network = (new bitcoreCash.Address(address)).network.name;
    }
    return network;
  };

  root.get = function(addr, cb) {
    storageService.getAddressbook('testnet', function(err, ab) {
      if (err) return cb(err);
      if (ab) ab = JSON.parse(ab);
      if (ab && ab[addr]) return cb(null, ab[addr]);

      storageService.getAddressbook('livenet', function(err, ab) {
        if (err) return cb(err);
        if (ab) ab = JSON.parse(ab);
        if (ab && ab[addr]) return cb(null, ab[addr]);
        return cb();
      });
    });
  };

  root.list = function(cb) {
    storageService.getAddressbook('testnet', function(err, ab) {
      if (err) return cb('Could not get the Addressbook');

      if (ab) ab = JSON.parse(ab);

      ab = ab || {};
      storageService.getAddressbook('livenet', function(err, ab2) {
        if (ab2) ab2 = JSON.parse(ab2);

        ab2 = ab2 || {};
        return cb(err, lodash.defaults(ab2, ab));
      });
    });
  };

  root.add = function(entry, cb) {
    var network = getNetwork(entry.address);
    if (lodash.isEmpty(network)) return cb('Not valid bitcoin address');
    storageService.getAddressbook(network, function(err, ab) {
      if (err) return cb(err);
      if (ab) ab = JSON.parse(ab);
      ab = ab || {};
      if (lodash.isArray(ab)) ab = {}; // No array
      if (ab[entry.address]) return cb('Entry already exist');
      ab[entry.address] = entry;
      storageService.setAddressbook(network, JSON.stringify(ab), function(err, ab) {
        if (err) return cb('Error adding new entry');
        root.list(function(err, ab) {
          return cb(err, ab);
        });
      });
    });
  };

  root.remove = function(addr, cb) {
    var network = getNetwork(addr);
    if (lodash.isEmpty(network)) return cb('Not valid bitcoin address');
    storageService.getAddressbook(network, function(err, ab) {
      if (err) return cb(err);
      if (ab) ab = JSON.parse(ab);
      ab = ab || {};
      if (lodash.isEmpty(ab)) return cb('Addressbook is empty');
      if (!ab[addr]) return cb('Entry does not exist');
      delete ab[addr];
      storageService.setAddressbook(network, JSON.stringify(ab), function(err) {
        if (err) return cb('Error deleting entry');
        root.list(function(err, ab) {
          return cb(err, ab);
        });
      });
    });
  };

  root.removeAll = function() {
    storageService.removeAddressbook('livenet', function(err) {
      storageService.removeAddressbook('testnet', function(err) {
        if (err) return cb('Error deleting addressbook');
        return cb();
      });
    });
  };

  return root;
});

'use strict';
angular.module('copayApp.services').factory('amazonService', function($http, $log, lodash, moment, storageService, configService, platformInfo, nextStepsService, homeIntegrationsService) {
  var root = {};
  var credentials = {};

  root.limitPerDay = 1000;

  /*
   * Development: 'testnet'
   * Production: 'livenet'
   */
  credentials.NETWORK = 'livenet';
  //credentials.NETWORK = 'testnet';

  if (credentials.NETWORK == 'testnet') {
    credentials.BITPAY_API_URL = "https://test.bitpay.com";
  } else {
    credentials.BITPAY_API_URL = "https://bitpay.com";
  };

  var homeItem = {
    name: 'amazon',
    title: 'Amazon.com Gift Cards',
    icon: 'icon-amazon',
    sref: 'tabs.giftcards.amazon',
  };

  var nextStepItem = {
    name: 'amazon',
    title: 'Buy Amazon.com Gift Cards',
    icon: 'icon-amazon',
    sref: 'tabs.giftcards.amazon',
  };

  var _getBitPay = function(endpoint) {
    return {
      method: 'GET',
      url: credentials.BITPAY_API_URL + endpoint,
      headers: {
        'content-type': 'application/json'
      }
    };
  };

  var _postBitPay = function(endpoint, data) {
    return {
      method: 'POST',
      url: credentials.BITPAY_API_URL + endpoint,
      headers: {
        'content-type': 'application/json'
      },
      data: data
    };
  };

  root.getNetwork = function() {
    return credentials.NETWORK;
  };

  root.savePendingGiftCard = function(gc, opts, cb) {
    var network = root.getNetwork();
    storageService.getAmazonGiftCards(network, function(err, oldGiftCards) {
      if (lodash.isString(oldGiftCards)) {
        oldGiftCards = JSON.parse(oldGiftCards);
      }
      if (lodash.isString(gc)) {
        gc = JSON.parse(gc);
      }
      var inv = oldGiftCards || {};
      inv[gc.invoiceId] = gc;
      if (opts && (opts.error || opts.status)) {
        inv[gc.invoiceId] = lodash.assign(inv[gc.invoiceId], opts);
      }
      if (opts && opts.remove) {
        delete(inv[gc.invoiceId]);
      }

      inv = JSON.stringify(inv);


      storageService.setAmazonGiftCards(network, inv, function(err) {

        homeIntegrationsService.register(homeItem);
        nextStepsService.unregister(nextStepItem.name);
        return cb(err);
      });
    });
  };

  root.getPendingGiftCards = function(cb) {
    var network = root.getNetwork();
    storageService.getAmazonGiftCards(network, function(err, giftCards) {
      var _gcds = giftCards ? JSON.parse(giftCards) : null;
      return cb(err, _gcds);
    });
  };

  root.createBitPayInvoice = function(data, cb) {

    var dataSrc = {
      currency: data.currency,
      amount: data.amount,
      clientId: data.uuid,
      email: data.email
    };

    $http(_postBitPay('/amazon-gift/pay', dataSrc)).then(function(data) {
      $log.info('BitPay Create Invoice: SUCCESS');
      return cb(null, data.data);
    }, function(data) {
      $log.error('BitPay Create Invoice: ERROR ' + data.data.message);
      return cb(data.data);
    });
  };

  root.getBitPayInvoice = function(id, cb) {
    $http(_getBitPay('/invoices/' + id)).then(function(data) {
      $log.info('BitPay Get Invoice: SUCCESS');
      return cb(null, data.data.data);
    }, function(data) {
      $log.error('BitPay Get Invoice: ERROR ' + data.data.error);
      return cb(data.data.error);
    });
  };

  root.createGiftCard = function(data, cb) {

    var dataSrc = {
      "clientId": data.uuid,
      "invoiceId": data.invoiceId,
      "accessKey": data.accessKey
    };

    $http(_postBitPay('/amazon-gift/redeem', dataSrc)).then(function(data) {
      var status = data.data.status == 'new' ? 'PENDING' : (data.data.status == 'paid') ? 'PENDING' : data.data.status;
      data.data.status = status;
      $log.info('Amazon.com Gift Card Create/Update: ' + status);
      return cb(null, data.data);
    }, function(data) {
      $log.error('Amazon.com Gift Card Create/Update: ' + data.data.message);
      return cb(data.data);
    });
  };

  root.cancelGiftCard = function(data, cb) {

    var dataSrc = {
      "clientId": data.uuid,
      "invoiceId": data.invoiceId,
      "accessKey": data.accessKey
    };

    $http(_postBitPay('/amazon-gift/cancel', dataSrc)).then(function(data) {
      $log.info('Amazon.com Gift Card Cancel: SUCCESS');
      return cb(null, data.data);
    }, function(data) {
      $log.error('Amazon.com Gift Card Cancel: ' + data.data.message);
      return cb(data.data);
    });
  };

  var register = function() {
    storageService.getAmazonGiftCards(root.getNetwork(), function(err, giftCards) {
      if (giftCards) {
        homeIntegrationsService.register(homeItem);
      } else {
        nextStepsService.register(nextStepItem);
      }
    });
  };

  register();
  return root;
});

'use strict';

angular.module('copayApp.services').factory('appConfigService', function($window) {
  return $window.appConfig;
});

'use strict';

angular.module('copayApp.services').factory('appIdentityService', function($log, lodash, storageService, bitauthService) {
  var root = {};

  root.getIdentity = function(network, cb) {
    var pubkey, sin, isNew;
    storageService.getAppIdentity(network, function(err, data) {
      if (err) return cb(err);
      var appIdentity = data || {};
      if (lodash.isEmpty(appIdentity) || (appIdentity && !appIdentity.priv)) {
        isNew = true;
        appIdentity = bitauthService.generateSin();
      }
      try {
        pubkey = bitauthService.getPublicKeyFromPrivateKey(appIdentity.priv);
        sin = bitauthService.getSinFromPublicKey(pubkey);
        if (isNew)
          storageService.setAppIdentity(network, JSON.stringify(appIdentity), function(err) {});
      }
      catch (e) {
        $log.error(e);
        return cb(e);
      };
      return cb(null, appIdentity);
    });
  };

  return root;
  
});
'use strict';
angular.module('copayApp.services')
  .factory('applicationService', function($rootScope, $timeout, $ionicHistory, $ionicModal, platformInfo, fingerprintService, openURLService, configService, $state) {
    var root = {};

    root.isPinModalOpen = false;

    var isChromeApp = platformInfo.isChromeApp;
    var isNW = platformInfo.isNW;

    root.restart = function() {
      var hashIndex = window.location.href.indexOf('#/');
      if (platformInfo.isCordova) {
        window.location = window.location.href.substr(0, hashIndex);
        $timeout(function() {
          $rootScope.$digest();
        }, 1);

      } else {
        // Go home reloading the application
        if (isChromeApp) {
          chrome.runtime.reload();
        } else if (isNW) {
          $ionicHistory.removeBackView();
          $state.go('tabs.home');
          $timeout(function() {
            var win = require('nw.gui').Window.get();
            win.reload(3);
            //or
            win.reloadDev();
          }, 100);
        } else {
          window.location = window.location.href.substr(0, hashIndex);
        }
      }
    };

    root.fingerprintModal = function() {

      var scope = $rootScope.$new(true);
      $ionicModal.fromTemplateUrl('views/modals/fingerprintCheck.html', {
        scope: scope,
        animation: 'none',
        backdropClickToClose: false,
        hardwareBackButtonClose: false
      }).then(function(modal) {
        scope.fingerprintCheckModal = modal;
        root.isModalOpen = true;
        scope.openModal();
      });
      scope.openModal = function() {
        scope.fingerprintCheckModal.show();
        scope.checkFingerprint();
      };
      scope.hideModal = function() {
        root.isModalOpen = false;
        scope.fingerprintCheckModal.hide();
      };
      scope.checkFingerprint = function() {
        fingerprintService.check('unlockingApp', function(err) {
          if (err) return;
          $timeout(function() {
            scope.hideModal();
          }, 200);
        });
      }
    };

    root.pinModal = function(action) {

      var scope = $rootScope.$new(true);
      scope.action = action;
      $ionicModal.fromTemplateUrl('views/modals/pin.html', {
        scope: scope,
        animation: 'none',
        backdropClickToClose: false,
        hardwareBackButtonClose: false
      }).then(function(modal) {
        scope.pinModal = modal;
        root.isModalOpen = true;
        scope.openModal();
      });
      scope.openModal = function() {
        scope.pinModal.show();
      };
      scope.hideModal = function() {
        scope.$emit('pinModalClosed');
        root.isModalOpen = false;
        scope.pinModal.hide();
      };
    };

    root.appLockModal = function(action) {

      if (root.isModalOpen) return;

      configService.whenAvailable(function(config) {
        var lockMethod = config.lock && config.lock.method;
        if (!lockMethod || lockMethod == 'none') return;

        if (lockMethod == 'fingerprint' && fingerprintService.isAvailable()) root.fingerprintModal();
        if (lockMethod == 'pin') root.pinModal(action);

      });
    }
    return root;
  });

'use strict';
angular.module('copayApp.services')
  .factory('backupService', function backupServiceFactory($log, $timeout, $stateParams, profileService, sjcl, appConfigService) {

    var root = {};

    var _download = function(ew, filename, cb) {
      var NewBlob = function(data, datatype) {
        var out;

        try {
          out = new Blob([data], {
            type: datatype
          });
          $log.debug("case 1");
        } catch (e) {
          window.BlobBuilder = window.BlobBuilder ||
            window.WebKitBlobBuilder ||
            window.MozBlobBuilder ||
            window.MSBlobBuilder;

          if (e.name == 'TypeError' && window.BlobBuilder) {
            var bb = new BlobBuilder();
            bb.append(data);
            out = bb.getBlob(datatype);
            $log.debug("case 2");
          } else if (e.name == "InvalidStateError") {
            // InvalidStateError (tested on FF13 WinXP)
            out = new Blob([data], {
              type: datatype
            });
            $log.debug("case 3");
          } else {
            // We're screwed, blob constructor unsupported entirely
            $log.debug("Error");
          }
        }
        return out;
      };

      var a = angular.element('<a></a>');
      var blob = new NewBlob(ew, 'text/plain;charset=utf-8');
      a.attr('href', window.URL.createObjectURL(blob));
      a.attr('download', filename);
      a[0].click();
      return cb();
    };

    root.addMetadata = function(b, opts) {

      b = JSON.parse(b);
      if (opts.addressBook) b.addressBook = opts.addressBook;
      return JSON.stringify(b);
    }

    root.walletExport = function(password, opts) {
      if (!password) {
        return null;
      }
      var wallet = profileService.getWallet($stateParams.walletId);
      try {
        opts = opts || {};
        var b = wallet.export(opts);
        if (opts.addressBook) b = root.addMetadata(b, opts);

        var e = sjcl.encrypt(password, b, {
          iter: 10000
        });
        return e;
      } catch (err) {
        $log.debug('Error exporting wallet: ', err);
        return null;
      };
    };

    root.walletDownload = function(password, opts, cb) {
      var wallet = profileService.getWallet($stateParams.walletId);
      var ew = root.walletExport(password, opts);
      if (!ew) return cb('Could not create backup');

      var walletName = (wallet.alias || '') + (wallet.alias ? '-' : '') + wallet.credentials.walletName;
      if (opts.noSign) walletName = walletName + '-noSign'
      var filename = walletName + '-' + appConfigService.nameCase + 'backup.aes.json';
      _download(ew, filename, cb)
    };
    return root;
  });

'use strict';
angular.module('copayApp.services')
  .factory('bitcore', function bitcoreFactory(bwcService) {
    var bitcore = bwcService.getBitcore();
    return bitcore;
  });

'use strict';
angular.module('copayApp.services')
  .factory('bitcoreCash', function bitcoreFactory(bwcService) {
    var bitcoreCash = bwcService.getBitcoreCash();
    return bitcoreCash;
  });

'use strict';

angular.module('copayApp.services').factory('bitpayAccountService', function($log, lodash, platformInfo, appIdentityService, bitpayService, bitpayCardService, storageService, gettextCatalog, popupService) {
  var root = {};

  /*
   * Pair this app with the bitpay server using the specified pairing data.
   * An app identity will be created if one does not already exist.
   * Pairing data is provided by an input URI provided by the bitpay server.
   *
   * pairData - data needed to complete the pairing process
   * {
   *   secret: shared pairing secret
   *   email: email address associated with bitpay account
   *   otp: two-factor one-time use password
   * }
   *
   * pairingReason - text string to be embedded into popup message.  If `null` then the reason
   * message is not shown to the UI.
   *   "To {{reason}} you must pair this app with your BitPay account ({{email}})."
   *
   * cb - callback after completion
   *   callback(err, paired, apiContext)
   *
   *   err - something unexpected happened which prevented the pairing
   *
   *   paired - boolean indicating whether the pairing was compledted by the user
   *
   *   apiContext - the context needed for making future api calls
   *   {
   *     token: api token for use in future calls
   *     pairData: the input pair data
   *     appIdentity: the identity of this app
   *   }
   */

  root.pair = function(pairData, pairingReason, cb) {
    checkOtp(pairData, function(otp) {
      pairData.otp = otp;
	    var deviceName = 'Unknown device';
	    if (platformInfo.isNW) {
	      deviceName = require('os').platform();
	    } else if (platformInfo.isCordova) {
	      deviceName = device.model;
	    }
	    var json = {
	      method: 'createToken',
	      params: {
	        secret: pairData.secret,
	        version: 2,
	        deviceName: deviceName,
	        code: pairData.otp
	      }
	    };

      bitpayService.postAuth(json, function(data) {
        if (data && data.data.error) {
          return cb(data.data.error);
        }
        var apiContext = {
          token: data.data.data,
          pairData: pairData,
          appIdentity: data.appIdentity
        };
        $log.info('BitPay service BitAuth create token: SUCCESS');

        fetchBasicInfo(apiContext, function(err, basicInfo) {
          if (err) return cb(err);
          var title = gettextCatalog.getString('Add BitPay Account?');
          var msg;

          if (pairingReason) {
            msg = gettextCatalog.getString('To {{reason}} you must first add your BitPay account - {{email}}', {
              reason: pairingReason,
              email: pairData.email
            });
          } else {
            msg = gettextCatalog.getString('Add this BitPay account ({{email}})?', {
              email: pairData.email
            });
          }

          var ok = gettextCatalog.getString('Add Account');
          var cancel = gettextCatalog.getString('Go back');
          popupService.showConfirm(title, msg, ok, cancel, function(res) {
          	if (res) {
  		        var acctData = {
                token: apiContext.token,
                email: pairData.email,
                givenName: basicInfo.givenName,
                familyName: basicInfo.familyName
              };
  						setBitpayAccount(acctData, function(err) {
  			        return cb(err, true, apiContext);
  						});
          	} else {
  				    $log.info('User cancelled BitPay pairing process');
  		        return cb(null, false);
          	}
          });
        });
      }, function(data) {
        return cb(_setError('BitPay service BitAuth create token: ERROR ', data));
	    });
	  });
  };

  var checkOtp = function(pairData, cb) {
    if (pairData.otp) {
      var msg = gettextCatalog.getString('Enter Two Factor for your BitPay account');
      popupService.showPrompt(null, msg, null, function(res) {
        cb(res);
      });
    } else {
      cb();
    }
  };

  var fetchBasicInfo = function(apiContext, cb) {
    var json = {
      method: 'getBasicInfo'
    };
    // Get basic account information
    bitpayService.post('/api/v2/' + apiContext.token, json, function(data) {
      if (data && data.data.error) return cb(data.data.error);
      $log.info('BitPay Account Get Basic Info: SUCCESS');
      return cb(null, data.data.data);
    }, function(data) {
      return cb(_setError('BitPay Account Error: Get Basic Info', data));
    });
  };

  // Returns account objects as stored.
  root.getAccountsAsStored = function(cb) {
    storageService.getBitpayAccounts(bitpayService.getEnvironment().network, cb);
  };

  // Returns an array where each element represents an account including all information required for fetching data
  // from the server for each account (apiContext).
  root.getAccounts = function(cb) {
    root.getAccountsAsStored(function(err, accounts) {
      if (err || lodash.isEmpty(accounts)) {
        return cb(err, []);
      }
      appIdentityService.getIdentity(bitpayService.getEnvironment().network, function(err, appIdentity) {
        if (err) {
          return cb(err);
        }

        var accountsArray = [];
        lodash.forEach(Object.keys(accounts), function(key) {
          accounts[key].cards = accounts[key].cards;
          accounts[key].email = key;
          accounts[key].givenName = accounts[key].givenName || '';
          accounts[key].familyName = accounts[key].familyName || '';
          accounts[key].apiContext = {
            token: accounts[key].token,
            pairData: {
              email: key
            },
            appIdentity: appIdentity
          };

          accountsArray.push(accounts[key]);
        });
        return cb(null, accountsArray);
      });
    });
  };

  var setBitpayAccount = function(account, cb) {
    storageService.setBitpayAccount(bitpayService.getEnvironment().network, account, function(err) {
      return cb(err);
    });
  };

  root.removeAccount = function(account, cb) {
    storageService.removeBitpayAccount(bitpayService.getEnvironment().network, account, function(err) {
      bitpayCardService.registerNextStep();
      cb(err);
    });
  };

  var _setError = function(msg, e) {
    $log.error(msg);
    var error = (e && e.data && e.data.error) ? e.data.error : msg;
    return error;
  };

  return root;

});

'use strict';

angular.module('copayApp.services').factory('bitpayCardService', function($log, $rootScope, $filter, lodash, storageService, bitauthService, platformInfo, moment, appIdentityService, bitpayService, nextStepsService, txFormatService, appConfigService) {
  var root = {};

  var _setError = function(msg, e) {
    $log.error(msg);
    var error = (e && e.data && e.data.error) ? e.data.error : msg;
    return error;
  };

  var _buildDate = function(date, time) {
    date = date.match(/(\d{2})\/(\d{2})\/(\d{4})/);
    time = time.match(/(\d{2})(\d{2})(\d{2})/);
    var newDate = new Date(date[1] + '/' + date[2] + '/' + date[3]);
    newDate.setHours(time[1], time[2], time[3]);
    return newDate;
  };

  var _lowercaseMerchant = function(merchant) {
    if (merchant.name && merchant.name.toLowerCase) {
      merchant.name = merchant.name.toLowerCase();
    }
    if (merchant.city && merchant.city.toLowerCase) {
      merchant.city = merchant.city.toLowerCase();
    }

    return merchant;
  };

  var _getMerchantInfo = function(tx) {
    var bpTranCodes = root.bpTranCodes;
    lodash.keys(bpTranCodes).forEach(function(code) {
      if (tx.type.indexOf(code) === 0) {
        lodash.assign(tx, bpTranCodes[code]);
      }
    });
    return tx;
  };

  var _getIconName = function(tx) {
    var icon = tx.mcc || tx.category || null;
    if (!icon || root.iconMap[icon] == undefined) return 'default';
    return root.iconMap[icon];
  };

  var _processDescription = function(tx) {
    if (lodash.isArray(tx.description)) {
      return tx.description[0];
    }
    return tx.description;
  };

  var _processLocation = function(tx) {
    if (tx.merchant.city && tx.merchant.state) {
      return tx.merchant.city + ', ' + tx.merchant.state;
    } else {
      return tx.merchant.city || tx.merchant.state || '';
    }
  };

  var _fromTransaction = function(txn, runningBalance) {
    var dateTime = _buildDate(txn.date, txn.time);
    var merchant = _lowercaseMerchant(txn.merchant);
    return _getMerchantInfo({
      date: txn.timestamp || dateTime,
      category: txn.mcc,
      merchant: merchant,
      description: txn.description[0],
      price: parseFloat(txn.amount) + parseFloat(txn.fee),
      type: txn.type,
      runningBalance: runningBalance
    });
  };

  var _processTransactions = function(invoices, history) {

    var balance = history.endingBalance || history.currentCardBalance;
    var runningBalance = parseFloat(balance);
    var activityList = [];

    if(history && history.transactionList){
      for (var j = 0; j < history.transactionList.length; j++) {
        runningBalance -= parseFloat(history.transactionList[j].amount);
        activityList.push(_fromTransaction(history.transactionList[j], runningBalance));
      }
    }

    if (activityList.length > 0) {

      invoices = invoices ||  [];
      for (var i = 0; i < invoices.length; i++) {
        var matched = false;
        for (var j = 0; j < history.transactionList.length; j++) {
          var description = history.transactionList[j].description;
          for (var k = 0; k < description.length; k++) {
            if (description[k] && description[k].indexOf(invoices[i].id) > -1) {
              matched = true;
            }
          }
        }

        var isInvoiceLessThanOneDayOld = moment() < moment(new Date(invoices[i].invoiceTime)).add(1, 'day');

        if (!matched && isInvoiceLessThanOneDayOld) {
          var isInvoiceUnderpaid = invoices[i].exceptionStatus === 'paidPartial';

          if (['paid', 'confirmed', 'complete'].indexOf(invoices[i].status) >= 0 ||
            (invoices[i].status === 'invalid' || isInvoiceUnderpaid)) {

            activityList.unshift(_getMerchantInfo({
              date: new Date(invoices[i].invoiceTime),
              category: '',
              merchant: '',
              description: invoices[i].itemDesc,
              price: invoices[i].price,
              type: '00611 = Client Funded Deposit',
              runningBalance: null,
              pending: true,
              transactionId: invoices[i].transactions && invoices[i].transactions[0] ? invoices[i].transactions[0].txid : ''
            }));
          }
        }
      }
    }
    for (var i = 0; i < activityList.length; i++) {
      activityList[i].icon = _getIconName(activityList[i]);
      activityList[i].desc = _processDescription(activityList[i]);
      activityList[i].merchant['location'] = _processLocation(activityList[i]);
    }
    return activityList;
  };

  root.filterTransactions = function(type, txns) {
    var list,
      getPreAuth = lodash.filter(txns, function(txn) {
        return txn.type.indexOf('93') > -1;
      }),
      getPending = lodash.filter(txns, function(txn) {
        return txn.pending;
      }),
      getCompleted = lodash.filter(txns, function(txn) {
        return !txn.pending && txn.type.indexOf('93') == -1;
      });

    switch (type) {
      case "preAuth":
        list = lodash.filter(getPreAuth);
        break;
      case "confirming":
        list = lodash.filter(getPending);
        break;
      case "completed":
        list = lodash.filter(getCompleted);
        break;
      default:
        // code...
        break;
    }
    return list;
  };

  root.sync = function(apiContext, cb) {
    var json = {
      method: 'getDebitCards'
    };
    // Get Debit Cards
    bitpayService.post('/api/v2/' + apiContext.token, json, function(data) {
      if (data && data.data.error) return cb(data.data.error);
      $log.info('BitPay Get Debit Cards: SUCCESS');

      var cards = [];

      lodash.each(data.data.data, function(x) {
        var n = {};

        if (!x.eid || !x.id || !x.lastFourDigits || !x.token) {
          $log.warn('BAD data from BitPay card' + JSON.stringify(x));
          return;
        }

        n.eid = x.eid;
        n.id = x.id;
        n.lastFourDigits = x.lastFourDigits;
        n.token = x.token;
        n.currency = x.currency;
        n.country = x.country;
        cards.push(n);
      });

      storageService.setBitpayDebitCards(bitpayService.getEnvironment().network, apiContext.pairData.email, cards, function(err) {
        root.registerNextStep();
        return cb(err, cards);
      });
    }, function(data) {
      return cb(_setError('BitPay Card Error: Get Debit Cards', data));
    });
  };

  root.setCurrencySymbol = function(card) {
    // Sets a currency symbol.
    // Uses the currency code if no symbol is mapped (should never happen).
    // Backaward compatibility for FirstView cards (all USD).
    // This avoids users having to re-pair their account.
    if (!card.currency) {
      card.currency = 'USD';
    }
    card.currencySymbol = root.currencySymbols[card.currency] || card.currency + ' ';
  };

  // opts: range
  root.getHistory = function(cardId, opts, cb) {
    var invoices, history;
    opts = opts || {};

    var json = {
      method: 'getInvoiceHistory'
    };

    appIdentityService.getIdentity(bitpayService.getEnvironment().network, function(err, appIdentity) {
      if (err) return cb(err);

      root.getCards(function(err, data) {
        if (err) return cb(err);
        var card = lodash.find(data, {
          id: cardId
        });

        if (!card)
          return cb(_setError('Card not found'));

        // Get invoices
        bitpayService.post('/api/v2/' + card.token, json, function(data) {
          $log.info('BitPay Get Invoices: SUCCESS');
          invoices = data.data.data || [];

          if (lodash.isEmpty(invoices))
            $log.info('No invoices');

          json = {
            method: 'getTransactionHistory',
            params: JSON.stringify(opts)
          };
          // Get transactions History list
          bitpayService.post('/api/v2/' + card.token, json, function(data) {
            $log.info('BitPay Get History: SUCCESS');
            history = data.data.data || {};
            history['txs'] = _processTransactions(invoices, history);

            root.setLastKnownBalance(cardId, history.currentCardBalance, function() {});

            return cb(data.data.error, history);
          }, function(data) {
            return cb(_setError('BitPay Card Error: Get History', data));
          });
        }, function(data) {
          return cb(_setError('BitPay Card Error: Get Invoices', data));
        });
      });
    });
  };

  root.topUp = function(cardId, opts, cb) {
    opts = opts || {};
    var json = {
      method: 'generateTopUpInvoice',
      params: JSON.stringify(opts)
    };
    appIdentityService.getIdentity(bitpayService.getEnvironment().network, function(err, appIdentity) {
      if (err) return cb(err);

      root.getCards(function(err, data) {
        if (err) return cb(err);

        var card = lodash.find(data, {
          id: cardId
        });

        if (!card)
          return cb(_setError('Card not found'));

        bitpayService.post('/api/v2/' + card.token, json, function(data) {
          $log.info('BitPay TopUp: SUCCESS');
          if (data.data.error) {
            return cb(data.data.error);
          } else {
            return cb(null, data.data.data.invoice);
          }
        }, function(data) {
          return cb(_setError('BitPay Card Error: TopUp', data));
        });
      });
    });
  };

  root.getInvoice = function(id, cb) {
    bitpayService.get('/invoices/' + id, function(data) {
      $log.info('BitPay Get Invoice: SUCCESS');
      return cb(data.data.error, data.data.data);
    }, function(data) {
      return cb(_setError('BitPay Card Error: Get Invoice', data));
    });
  };

  // get all cards, for all accounts.
  root.getCards = function(cb) {
    storageService.getBitpayDebitCards(bitpayService.getEnvironment().network, cb);
  };

  root.getLastKnownBalance = function(cardId, cb) {
    storageService.getBalanceCache(cardId, cb);
  };

  root.addLastKnownBalance = function(card, cb) {
    var now = Math.floor(Date.now() / 1000);
    var showRange = 600; // 10min;

    root.getLastKnownBalance(card.eid, function(err, data) {
      if (data) {
        data = JSON.parse(data);
        card.balance = data.balance;
        card.updatedOn = (data.updatedOn < now - showRange) ? data.updatedOn : null;
      }
      return cb();
    });
  };

  root.setLastKnownBalance = function(cardId, balance, cb) {

    storageService.setBalanceCache(cardId, {
      balance: balance,
      updatedOn: Math.floor(Date.now() / 1000),
    }, cb);
  };

  root.remove = function(cardId, cb) {
    storageService.removeBitpayDebitCard(bitpayService.getEnvironment().network, cardId, function(err) {
      if (err) {
        $log.error('Error removing BitPay debit card: ' + err);
        return cb(err);
      }
      root.registerNextStep();
      storageService.removeBalanceCache(cardId, cb);
    });
  };

  root.getRates = function(currency, cb) {
    bitpayService.get('/rates/' + currency, function(data) {
      $log.info('BitPay Get Rates: SUCCESS');
      return cb(data.data.error, data.data.data);
    }, function(data) {
      return cb(_setError('BitPay Error: Get Rates', data));
    });
  };


  root.get = function(opts, cb) {
    root.getCards(function(err, cards) {
      if (err) return;

      if (lodash.isEmpty(cards)) {
        return cb();
      }

      if (opts.cardId) {
        cards = lodash.filter(cards, function(x) {
          return opts.cardId == x.eid;
        });
      }

      // Async, no problem
      lodash.each(cards, function(x) {

        root.setCurrencySymbol(x);
        root.addLastKnownBalance(x, function() {});

        // async refresh
        if (!opts.noRefresh) {
          root.getHistory(x.id, {}, function(err, data) {
            if (err) return;
            root.addLastKnownBalance(x, function() {});
          });
        }
      });

      return cb(null, cards);
    });
  };

  /*
   * CONSTANTS
   */

  root.currencySymbols = {
    'EUR': '€',
    'GBP': '£',
    'USD': '$'
  };

  root.bpTranCodes = {
    '00611': {
      merchant: {
        name: 'BitPay',
        city: 'Atlanta',
        state: 'GA'
      },
      category: 'bp001',
      description: 'Top-Up'
    },
    '602': {
      merchant: {
        name: 'ATM Withdrawal Fee',
      },
      category: 'bp002',
      description: ''
    },
    '604': {
      merchant: {
        name: 'Foreign Transaction Fee',
      },
      category: 'bp002',
      description: ''
    },
    '606': {
      merchant: {
        name: 'International ATM Fee',
      },
      category: 'bp002',
      description: ''
    },
    '00240': {
      merchant: {
        name: 'ACH Debit Fee',
      },
      category: 'bp002',
      description: ''
    },
    '5032': {
      merchant: {
        name: 'ACH Debit',
      },
      category: 'bp002',
      description: ''
    },
    '37': {
      merchant: {
        name: 'ACH / Payroll Deposit',
      },
      category: 'bp002',
      description: ''
    },
    '10036': {
      merchant: {
        name: 'Inactivity Fee (90 days)',
      },
      category: 'bp002',
      description: ''
    },
    'load': {
      merchant: {
        name: 'BitPay',
        city: 'Atlanta',
        state: 'GA'
      },
      category: 'bp001',
      description: 'Top-Up'
    },
    'unload | pos': {
      description: 'Purchase'
    },
    'unload | epos': {
      description: 'Online Purchase'
    },
    'transactionfee': {
      merchant: {
        name: 'Transaction Fee',
      },
      category: 'bp002',
      description: ''
    }
  };

  root.iconMap = {
    742: 'medical',
    763: 'plant',
    780: 'plant',
    1520: 'repair',
    1711: 'repair',
    1731: 'repair',
    1740: 'repair',
    1750: 'repair',
    1761: 'repair',
    1771: 'repair',
    1799: 'repair',
    2741: 'books',
    2791: 'books',
    2842: 'clean',
    3000: 'airplane',
    3001: 'airplane',
    3002: 'airplane',
    3003: 'airplane',
    3004: 'airplane',
    3005: 'airplane',
    3006: 'airplane',
    3007: 'airplane',
    3008: 'airplane',
    3009: 'airplane',
    3010: 'airplane',
    3011: 'airplane',
    3012: 'airplane',
    3013: 'airplane',
    3014: 'airplane',
    3015: 'airplane',
    3016: 'airplane',
    3017: 'airplane',
    3018: 'airplane',
    3019: 'airplane',
    3020: 'airplane',
    3021: 'airplane',
    3022: 'airplane',
    3023: 'airplane',
    3024: 'airplane',
    3025: 'airplane',
    3026: 'airplane',
    3027: 'airplane',
    3028: 'airplane',
    3029: 'airplane',
    3030: 'airplane',
    3031: 'airplane',
    3032: 'airplane',
    3033: 'airplane',
    3034: 'airplane',
    3035: 'airplane',
    3036: 'airplane',
    3037: 'airplane',
    3038: 'airplane',
    3039: 'airplane',
    3040: 'airplane',
    3041: 'airplane',
    3042: 'airplane',
    3043: 'airplane',
    3044: 'airplane',
    3045: 'airplane',
    3046: 'airplane',
    3047: 'airplane',
    3048: 'airplane',
    3049: 'airplane',
    3050: 'airplane',
    3051: 'airplane',
    3052: 'airplane',
    3053: 'airplane',
    3054: 'airplane',
    3055: 'airplane',
    3056: 'airplane',
    3057: 'airplane',
    3058: 'airplane',
    3059: 'airplane',
    3060: 'airplane',
    3061: 'airplane',
    3062: 'airplane',
    3063: 'airplane',
    3064: 'airplane',
    3065: 'airplane',
    3066: 'airplane',
    3067: 'airplane',
    3068: 'airplane',
    3069: 'airplane',
    3070: 'airplane',
    3071: 'airplane',
    3072: 'airplane',
    3073: 'airplane',
    3074: 'airplane',
    3075: 'airplane',
    3076: 'airplane',
    3077: 'airplane',
    3078: 'airplane',
    3079: 'airplane',
    3080: 'airplane',
    3081: 'airplane',
    3082: 'airplane',
    3083: 'airplane',
    3084: 'airplane',
    3085: 'airplane',
    3086: 'airplane',
    3087: 'airplane',
    3088: 'airplane',
    3089: 'airplane',
    3090: 'airplane',
    3091: 'airplane',
    3092: 'airplane',
    3093: 'airplane',
    3094: 'airplane',
    3095: 'airplane',
    3096: 'airplane',
    3097: 'airplane',
    3098: 'airplane',
    3099: 'airplane',
    3100: 'airplane',
    3101: 'airplane',
    3102: 'airplane',
    3103: 'airplane',
    3104: 'airplane',
    3105: 'airplane',
    3106: 'airplane',
    3107: 'airplane',
    3108: 'airplane',
    3109: 'airplane',
    3110: 'airplane',
    3111: 'airplane',
    3112: 'airplane',
    3113: 'airplane',
    3114: 'airplane',
    3115: 'airplane',
    3116: 'airplane',
    3117: 'airplane',
    3118: 'airplane',
    3119: 'airplane',
    3120: 'airplane',
    3121: 'airplane',
    3122: 'airplane',
    3123: 'airplane',
    3124: 'airplane',
    3125: 'airplane',
    3126: 'airplane',
    3127: 'airplane',
    3128: 'airplane',
    3129: 'airplane',
    3130: 'airplane',
    3131: 'airplane',
    3132: 'airplane',
    3133: 'airplane',
    3134: 'airplane',
    3135: 'airplane',
    3136: 'airplane',
    3137: 'airplane',
    3138: 'airplane',
    3139: 'airplane',
    3140: 'airplane',
    3141: 'airplane',
    3142: 'airplane',
    3143: 'airplane',
    3144: 'airplane',
    3145: 'airplane',
    3146: 'airplane',
    3147: 'airplane',
    3148: 'airplane',
    3149: 'airplane',
    3150: 'airplane',
    3151: 'airplane',
    3152: 'airplane',
    3153: 'airplane',
    3154: 'airplane',
    3155: 'airplane',
    3156: 'airplane',
    3157: 'airplane',
    3158: 'airplane',
    3159: 'airplane',
    3160: 'airplane',
    3161: 'airplane',
    3162: 'airplane',
    3163: 'airplane',
    3164: 'airplane',
    3165: 'airplane',
    3166: 'airplane',
    3167: 'airplane',
    3168: 'airplane',
    3169: 'airplane',
    3170: 'airplane',
    3171: 'airplane',
    3172: 'airplane',
    3173: 'airplane',
    3174: 'airplane',
    3175: 'airplane',
    3176: 'airplane',
    3177: 'airplane',
    3178: 'airplane',
    3179: 'airplane',
    3180: 'airplane',
    3181: 'airplane',
    3182: 'airplane',
    3183: 'airplane',
    3184: 'airplane',
    3185: 'airplane',
    3186: 'airplane',
    3187: 'airplane',
    3188: 'airplane',
    3189: 'airplane',
    3190: 'airplane',
    3191: 'airplane',
    3192: 'airplane',
    3193: 'airplane',
    3194: 'airplane',
    3195: 'airplane',
    3196: 'airplane',
    3197: 'airplane',
    3198: 'airplane',
    3199: 'airplane',
    3200: 'airplane',
    3201: 'airplane',
    3202: 'airplane',
    3203: 'airplane',
    3204: 'airplane',
    3205: 'airplane',
    3206: 'airplane',
    3207: 'airplane',
    3208: 'airplane',
    3209: 'airplane',
    3210: 'airplane',
    3211: 'airplane',
    3212: 'airplane',
    3213: 'airplane',
    3214: 'airplane',
    3215: 'airplane',
    3216: 'airplane',
    3217: 'airplane',
    3218: 'airplane',
    3219: 'airplane',
    3220: 'airplane',
    3221: 'airplane',
    3222: 'airplane',
    3223: 'airplane',
    3224: 'airplane',
    3225: 'airplane',
    3226: 'airplane',
    3227: 'airplane',
    3228: 'airplane',
    3229: 'airplane',
    3230: 'airplane',
    3231: 'airplane',
    3232: 'airplane',
    3233: 'airplane',
    3234: 'airplane',
    3235: 'airplane',
    3236: 'airplane',
    3237: 'airplane',
    3238: 'airplane',
    3239: 'airplane',
    3240: 'airplane',
    3241: 'airplane',
    3242: 'airplane',
    3243: 'airplane',
    3244: 'airplane',
    3245: 'airplane',
    3246: 'airplane',
    3247: 'airplane',
    3248: 'airplane',
    3249: 'airplane',
    3250: 'airplane',
    3251: 'airplane',
    3252: 'airplane',
    3253: 'airplane',
    3254: 'airplane',
    3255: 'airplane',
    3256: 'airplane',
    3257: 'airplane',
    3258: 'airplane',
    3259: 'airplane',
    3260: 'airplane',
    3261: 'airplane',
    3262: 'airplane',
    3263: 'airplane',
    3264: 'airplane',
    3265: 'airplane',
    3266: 'airplane',
    3267: 'airplane',
    3268: 'airplane',
    3269: 'airplane',
    3270: 'airplane',
    3271: 'airplane',
    3272: 'airplane',
    3273: 'airplane',
    3274: 'airplane',
    3275: 'airplane',
    3276: 'airplane',
    3277: 'airplane',
    3278: 'airplane',
    3279: 'airplane',
    3280: 'airplane',
    3281: 'airplane',
    3282: 'airplane',
    3283: 'airplane',
    3284: 'airplane',
    3285: 'airplane',
    3286: 'airplane',
    3287: 'airplane',
    3288: 'airplane',
    3289: 'airplane',
    3290: 'airplane',
    3291: 'airplane',
    3292: 'airplane',
    3293: 'airplane',
    3294: 'airplane',
    3295: 'airplane',
    3296: 'airplane',
    3297: 'airplane',
    3298: 'airplane',
    3299: 'airplane',
    3351: 'car',
    3352: 'car',
    3353: 'car',
    3354: 'car',
    3355: 'car',
    3356: 'car',
    3357: 'car',
    3358: 'car',
    3359: 'car',
    3360: 'car',
    3361: 'car',
    3362: 'car',
    3363: 'car',
    3364: 'car',
    3365: 'car',
    3366: 'car',
    3367: 'car',
    3368: 'car',
    3369: 'car',
    3370: 'car',
    3371: 'car',
    3372: 'car',
    3373: 'car',
    3374: 'car',
    3375: 'car',
    3376: 'car',
    3377: 'car',
    3378: 'car',
    3379: 'car',
    3380: 'car',
    3381: 'car',
    3382: 'car',
    3383: 'car',
    3384: 'car',
    3385: 'car',
    3386: 'car',
    3387: 'car',
    3388: 'car',
    3389: 'car',
    3390: 'car',
    3391: 'car',
    3392: 'car',
    3393: 'car',
    3394: 'car',
    3395: 'car',
    3396: 'car',
    3397: 'car',
    3398: 'car',
    3399: 'car',
    3400: 'car',
    3401: 'car',
    3402: 'car',
    3403: 'car',
    3404: 'car',
    3405: 'car',
    3406: 'car',
    3407: 'car',
    3408: 'car',
    3409: 'car',
    3410: 'car',
    3411: 'car',
    3412: 'car',
    3413: 'car',
    3414: 'car',
    3415: 'car',
    3416: 'car',
    3417: 'car',
    3418: 'car',
    3419: 'car',
    3420: 'car',
    3421: 'car',
    3422: 'car',
    3423: 'car',
    3424: 'car',
    3425: 'car',
    3426: 'car',
    3427: 'car',
    3428: 'car',
    3429: 'car',
    3430: 'car',
    3431: 'car',
    3432: 'car',
    3433: 'car',
    3434: 'car',
    3435: 'car',
    3436: 'car',
    3437: 'car',
    3438: 'car',
    3439: 'car',
    3440: 'car',
    3441: 'car',
    3501: 'hotel',
    3502: 'hotel',
    3503: 'hotel',
    3504: 'hotel',
    3505: 'hotel',
    3506: 'hotel',
    3507: 'hotel',
    3508: 'hotel',
    3509: 'hotel',
    3510: 'hotel',
    3511: 'hotel',
    3512: 'hotel',
    3513: 'hotel',
    3514: 'hotel',
    3515: 'hotel',
    3516: 'hotel',
    3517: 'hotel',
    3518: 'hotel',
    3519: 'hotel',
    3520: 'hotel',
    3521: 'hotel',
    3522: 'hotel',
    3523: 'hotel',
    3524: 'hotel',
    3525: 'hotel',
    3526: 'hotel',
    3527: 'hotel',
    3528: 'hotel',
    3529: 'hotel',
    3530: 'hotel',
    3531: 'hotel',
    3532: 'hotel',
    3533: 'hotel',
    3534: 'hotel',
    3535: 'hotel',
    3536: 'hotel',
    3537: 'hotel',
    3538: 'hotel',
    3539: 'hotel',
    3540: 'hotel',
    3541: 'hotel',
    3542: 'hotel',
    3543: 'hotel',
    3544: 'hotel',
    3545: 'hotel',
    3546: 'hotel',
    3547: 'hotel',
    3548: 'hotel',
    3549: 'hotel',
    3550: 'hotel',
    3551: 'hotel',
    3552: 'hotel',
    3553: 'hotel',
    3554: 'hotel',
    3555: 'hotel',
    3556: 'hotel',
    3557: 'hotel',
    3558: 'hotel',
    3559: 'hotel',
    3560: 'hotel',
    3561: 'hotel',
    3562: 'hotel',
    3563: 'hotel',
    3564: 'hotel',
    3565: 'hotel',
    3566: 'hotel',
    3567: 'hotel',
    3568: 'hotel',
    3569: 'hotel',
    3570: 'hotel',
    3571: 'hotel',
    3572: 'hotel',
    3573: 'hotel',
    3574: 'hotel',
    3575: 'hotel',
    3576: 'hotel',
    3577: 'hotel',
    3578: 'hotel',
    3579: 'hotel',
    3580: 'hotel',
    3581: 'hotel',
    3582: 'hotel',
    3583: 'hotel',
    3584: 'hotel',
    3585: 'hotel',
    3586: 'hotel',
    3587: 'hotel',
    3588: 'hotel',
    3589: 'hotel',
    3590: 'hotel',
    3591: 'hotel',
    3592: 'hotel',
    3593: 'hotel',
    3594: 'hotel',
    3595: 'hotel',
    3596: 'hotel',
    3597: 'hotel',
    3598: 'hotel',
    3599: 'hotel',
    3600: 'hotel',
    3601: 'hotel',
    3602: 'hotel',
    3603: 'hotel',
    3604: 'hotel',
    3605: 'hotel',
    3606: 'hotel',
    3607: 'hotel',
    3608: 'hotel',
    3609: 'hotel',
    3610: 'hotel',
    3611: 'hotel',
    3612: 'hotel',
    3613: 'hotel',
    3614: 'hotel',
    3615: 'hotel',
    3616: 'hotel',
    3617: 'hotel',
    3618: 'hotel',
    3619: 'hotel',
    3620: 'hotel',
    3621: 'hotel',
    3622: 'hotel',
    3623: 'hotel',
    3624: 'hotel',
    3625: 'hotel',
    3626: 'hotel',
    3627: 'hotel',
    3628: 'hotel',
    3629: 'hotel',
    3630: 'hotel',
    3631: 'hotel',
    3632: 'hotel',
    3633: 'hotel',
    3634: 'hotel',
    3635: 'hotel',
    3636: 'hotel',
    3637: 'hotel',
    3638: 'hotel',
    3639: 'hotel',
    3640: 'hotel',
    3641: 'hotel',
    3642: 'hotel',
    3643: 'hotel',
    3644: 'hotel',
    3645: 'hotel',
    3646: 'hotel',
    3647: 'hotel',
    3648: 'hotel',
    3649: 'hotel',
    3650: 'hotel',
    3651: 'hotel',
    3652: 'hotel',
    3653: 'hotel',
    3654: 'hotel',
    3655: 'hotel',
    3656: 'hotel',
    3657: 'hotel',
    3658: 'hotel',
    3659: 'hotel',
    3660: 'hotel',
    3661: 'hotel',
    3662: 'hotel',
    3663: 'hotel',
    3664: 'hotel',
    3665: 'hotel',
    3666: 'hotel',
    3667: 'hotel',
    3668: 'hotel',
    3669: 'hotel',
    3670: 'hotel',
    3671: 'hotel',
    3672: 'hotel',
    3673: 'hotel',
    3674: 'hotel',
    3675: 'hotel',
    3676: 'hotel',
    3677: 'hotel',
    3678: 'hotel',
    3679: 'hotel',
    3680: 'hotel',
    3681: 'hotel',
    3682: 'hotel',
    3683: 'hotel',
    3684: 'hotel',
    3685: 'hotel',
    3686: 'hotel',
    3687: 'hotel',
    3688: 'hotel',
    3689: 'hotel',
    3690: 'hotel',
    3691: 'hotel',
    3692: 'hotel',
    3693: 'hotel',
    3694: 'hotel',
    3695: 'hotel',
    3696: 'hotel',
    3697: 'hotel',
    3698: 'hotel',
    3699: 'hotel',
    3700: 'hotel',
    3701: 'hotel',
    3702: 'hotel',
    3703: 'hotel',
    3704: 'hotel',
    3705: 'hotel',
    3706: 'hotel',
    3707: 'hotel',
    3708: 'hotel',
    3709: 'hotel',
    3710: 'hotel',
    3711: 'hotel',
    3712: 'hotel',
    3713: 'hotel',
    3714: 'hotel',
    3715: 'hotel',
    3716: 'hotel',
    3717: 'hotel',
    3718: 'hotel',
    3719: 'hotel',
    3720: 'hotel',
    3721: 'hotel',
    3722: 'hotel',
    3723: 'hotel',
    3724: 'hotel',
    3725: 'hotel',
    3726: 'hotel',
    3727: 'hotel',
    3728: 'hotel',
    3729: 'hotel',
    3730: 'hotel',
    3731: 'hotel',
    3732: 'hotel',
    3733: 'hotel',
    3734: 'hotel',
    3735: 'hotel',
    3736: 'hotel',
    3737: 'hotel',
    3738: 'hotel',
    3739: 'hotel',
    3740: 'hotel',
    3741: 'hotel',
    3742: 'hotel',
    3743: 'hotel',
    3744: 'hotel',
    3745: 'hotel',
    3746: 'hotel',
    3747: 'hotel',
    3748: 'hotel',
    3749: 'hotel',
    3750: 'hotel',
    3751: 'hotel',
    3752: 'hotel',
    3753: 'hotel',
    3754: 'hotel',
    3755: 'hotel',
    3756: 'hotel',
    3757: 'hotel',
    3758: 'hotel',
    3759: 'hotel',
    3760: 'hotel',
    3761: 'hotel',
    3762: 'hotel',
    3763: 'hotel',
    3764: 'hotel',
    3765: 'hotel',
    3766: 'hotel',
    3767: 'hotel',
    3768: 'hotel',
    3769: 'hotel',
    3770: 'hotel',
    3771: 'hotel',
    3772: 'hotel',
    3773: 'hotel',
    3774: 'hotel',
    3775: 'hotel',
    3776: 'hotel',
    3777: 'hotel',
    3778: 'hotel',
    3779: 'hotel',
    3780: 'hotel',
    3781: 'hotel',
    3782: 'hotel',
    3783: 'hotel',
    3784: 'hotel',
    3785: 'hotel',
    3786: 'hotel',
    3787: 'hotel',
    3788: 'hotel',
    3789: 'hotel',
    3790: 'hotel',
    3816: 'hotel',
    3835: 'hotel',
    4011: 'car',
    4111: 'car',
    4112: 'car',
    4119: 'car',
    4121: 'car',
    4131: 'car',
    4214: 'car',
    4215: 'bus',
    4225: 'default',
    4411: 'boat',
    4457: 'boat',
    4468: 'boat',
    4511: 'airplane',
    4582: 'airplane',
    4722: 'airplane',
    4723: 'airplane',
    4784: 'car',
    4789: 'car',
    4812: 'car',
    4814: 'telephone',
    4815: 'telephone',
    4816: 'computer',
    4821: 'money',
    4829: 'money',
    4899: 'television',
    4900: 'gas',
    5013: 'car',
    5021: 'default',
    5039: 'repair',
    5044: 'computer',
    5045: 'computer',
    5046: 'default',
    5047: 'medical',
    5051: 'default',
    5065: 'default',
    5072: 'default',
    5074: 'default',
    5085: 'default',
    5094: 'diamond-ring',
    5099: 'default',
    5111: 'default',
    5122: 'medical',
    5131: 'default',
    5137: 'shirt',
    5139: 'shoes',
    5169: 'gas',
    5172: 'gas',
    5192: 'books',
    5193: 'plant',
    5198: 'repair',
    5199: 'repair',
    5200: 'repair',
    5211: 'repair',
    5231: 'repair',
    5251: 'default',
    5261: 'plant',
    5271: 'bus',
    5300: 'purchase',
    5309: 'purchase',
    5310: 'purchase',
    5311: 'purchase',
    5331: 'purchase',
    5399: 'purchase',
    5411: 'food',
    5422: 'food',
    5441: 'food',
    5451: 'food',
    5462: 'food',
    5499: 'food',
    5511: 'car',
    5521: 'car',
    5531: 'car',
    5532: 'car',
    5533: 'car',
    5541: 'gas',
    5542: 'gas',
    5551: 'boat',
    5561: 'motorcycle',
    5571: 'motorcycle',
    5592: 'default',
    5598: 'default',
    5599: 'car',
    5611: 'shirt',
    5621: 'shirt',
    5631: 'shirt',
    5641: 'shirt',
    5651: 'shirt',
    5655: 'shirt',
    5661: 'shoes',
    5681: 'default',
    5691: 'shirt',
    5697: 'default',
    5698: 'default',
    5699: 'default',
    5712: 'default',
    5713: 'default',
    5714: 'default',
    5718: 'default',
    5719: 'default',
    5722: 'default',
    5732: 'computer',
    5733: 'music',
    5734: 'computer',
    5735: 'music',
    5811: 'food',
    5812: 'food',
    5813: 'cocktail',
    5814: 'food',
    5815: 'books',
    5816: 'computer',
    5817: 'default',
    5818: 'default',
    5832: 'default',
    5912: 'medical',
    5921: 'cocktail',
    5931: 'default',
    5932: 'default',
    5933: 'default',
    5935: 'default',
    5937: 'default',
    5940: 'bicycle',
    5941: 'bicycle',
    5942: 'books',
    5943: 'default',
    5944: 'clock',
    5945: 'toy',
    5946: 'camera',
    5947: 'default',
    5948: 'default',
    5949: 'default',
    5950: 'default',
    5960: 'default',
    5961: 'mail',
    5962: 'telephone',
    5963: 'default',
    5964: 'telephone',
    5965: 'telephone',
    5966: 'telephone',
    5967: 'telephone',
    5968: 'telephone',
    5969: 'telephone',
    5970: 'art',
    5971: 'art',
    5972: 'coins',
    5973: 'default',
    5975: 'default',
    5976: 'default',
    5977: 'default',
    5978: 'default',
    5983: 'gas',
    5992: 'plant',
    5993: 'default',
    5994: 'newspaper',
    5995: 'pet',
    5996: 'cocktail',
    5997: 'purchase',
    5998: 'tent',
    5999: 'money',
    6010: 'money',
    6011: 'money',
    6012: 'money',
    6051: 'money',
    6211: 'money',
    6300: 'money',
    6381: 'money',
    6399: 'repair',
    6513: 'repair',
    7011: 'hotel',
    7012: 'hotel',
    7032: 'park',
    7033: 'park',
    7210: 'shirt',
    7211: 'shirt',
    7216: 'shirt',
    7217: 'default',
    7221: 'camera',
    7230: 'scissors',
    7251: 'shoe',
    7261: 'sadface',
    7273: 'smiley-face',
    7276: 'money',
    7277: 'people',
    7278: 'people',
    7296: 'shirt',
    7297: 'smiley-face',
    7298: 'smiley-face',
    7299: 'default',
    7311: 'default',
    7321: 'default',
    7332: 'computer',
    7333: 'camera',
    7338: 'computer',
    7339: 'people',
    7342: 'bug',
    7349: 'default',
    7361: 'people',
    7372: 'computer',
    7375: 'computer',
    7379: 'computer',
    7392: 'people',
    7393: 'search',
    7394: 'default',
    7395: 'car',
    7399: 'car',
    7511: 'truck',
    7512: 'car',
    7513: 'truck',
    7519: 'truck',
    7523: 'car',
    7531: 'car',
    7534: 'car',
    7535: 'car',
    7538: 'car',
    7542: 'car',
    7549: 'truck',
    7622: 'television',
    7623: 'default',
    7629: 'default',
    7631: 'watch',
    7641: 'furniture',
    7692: 'default',
    7699: 'default',
    7800: 'money',
    7801: 'money',
    7802: 'money',
    7829: 'money',
    7832: 'film',
    7841: 'film',
    7911: 'music',
    7922: 'ticket',
    7929: 'ticket',
    7932: 'music',
    7933: 'bowling',
    7941: 'football',
    7991: 'people',
    7992: 'golf',
    7993: 'game',
    7994: 'game',
    7995: 'coins',
    7996: 'ticket',
    7997: 'money',
    7998: 'ticket',
    7999: 'people',
    8011: 'medical',
    8021: 'medical',
    8031: 'medical',
    8041: 'medical',
    8042: 'medical',
    8043: 'medical',
    8044: 'medical',
    8049: 'medical',
    8050: 'medical',
    8062: 'medical',
    8071: 'medical',
    8099: 'medical',
    8111: 'law',
    8211: 'books',
    8220: 'books',
    8241: 'books',
    8244: 'books',
    8249: 'books',
    8299: 'people',
    8351: 'people',
    8398: 'people',
    8641: 'people',
    8651: 'people',
    8661: 'people',
    8675: 'car',
    8699: 'people',
    8734: 'medical',
    8911: 'tree',
    8931: 'books',
    8999: 'suitcase',
    9211: 'law',
    9222: 'law',
    9223: 'law',
    9311: 'law',
    9399: 'default',
    9402: 'mail',
    9405: 'default',
    9700: 'default',
    9701: 'default',
    9702: 'default',
    9950: 'default',
    'bp001': 'bitcoin-topup',
    'bp002': 'default'
  };

  var nextStepItem = {
    name: 'bitpaycard',
    title: 'Add BitPay Visa® Card',
    icon: 'icon-bitpay-card',
    sref: 'tabs.bitpayCardIntro',
  };


  root.registerNextStep = function() {
    // Disable BitPay Card
    if (!appConfigService._enabledExtensions.debitcard) return;
    root.getCards(function(err, cards) {
      if (lodash.isEmpty(cards)) {
        nextStepsService.register(nextStepItem);
      } else {
        nextStepsService.unregister(nextStepItem.name);
      }
    });
  };

  root.registerNextStep();
  return root;

});

'use strict';

angular.module('copayApp.services').factory('bitpayService', function($log, $http, appIdentityService, bitauthService) {
  var root = {};

  var NETWORK = 'livenet';
  var BITPAY_API_URL = NETWORK == 'livenet' ? 'https://bitpay.com' : 'https://test.bitpay.com';

  root.getEnvironment = function() {
    return {
      network: NETWORK
    };
  };

  root.get = function(endpoint, successCallback, errorCallback) {
    $http(_get(endpoint)).then(function(data) {
      successCallback(data);
    }, function(data) {
      errorCallback(data);
    });
  };

  root.post = function(endpoint, json, successCallback, errorCallback) {
    appIdentityService.getIdentity(root.getEnvironment().network, function(err, appIdentity) {
      if (err) {
        return errorCallback(err);
      }
      $http(_post(endpoint, json, appIdentity)).then(function(data) {
        successCallback(data);
      }, function(data) {
        errorCallback(data);
      });
    });
  };

  root.postAuth = function(json, successCallback, errorCallback) {
    appIdentityService.getIdentity(root.getEnvironment().network, function(err, appIdentity) {
      if (err) {
        return errorCallback(err);
      }
      $http(_postAuth('/api/v2/', json, appIdentity)).then(function(data) {
        data.appIdentity = appIdentity;
        successCallback(data);
      }, function(data) {
        errorCallback(data);
      });
    });
  };

  var _get = function(endpoint) {
    return {
      method: 'GET',
      url: BITPAY_API_URL + endpoint,
      headers: {
        'content-type': 'application/json'
      }
    };
  };

  var _post = function(endpoint, json, appIdentity) {
    var dataToSign = BITPAY_API_URL + endpoint + JSON.stringify(json);
    var signedData = bitauthService.sign(dataToSign, appIdentity.priv);

    return {
      method: 'POST',
      url: BITPAY_API_URL + endpoint,
      headers: {
        'content-type': 'application/json',
        'x-identity': appIdentity.pub,
        'x-signature': signedData
      },
      data: json
    };
  };

  var _postAuth = function(endpoint, json, appIdentity) {
    json['params'].signature = bitauthService.sign(JSON.stringify(json.params), appIdentity.priv);
    json['params'].pubkey = appIdentity.pub;
    json['params'] = JSON.stringify(json.params);

    var ret = {
      method: 'POST',
      url: BITPAY_API_URL + endpoint,
      headers: {
        'content-type': 'application/json'
      },
      data: json
    };

    $log.debug('post auth:' + JSON.stringify(ret));
    return ret;
  };

  return root;
  
});

'use strict';

angular.module('copayApp.services').factory('buyAndSellService', function($log, nextStepsService, lodash, $ionicScrollDelegate, $timeout) {
  var root = {};
  var services = [];
  var linkedServices = [];

  root.update = function() {

    var newLinked = lodash.filter(services, function(x) {
      return x.linked;
    });

    // This is to preserve linkedServices pointer
    while (linkedServices.length)
      linkedServices.pop();

    while (newLinked.length)
      linkedServices.push(newLinked.pop());
    //

    $log.debug('buyAndSell Service, updating nextSteps. linked/total: ' + linkedServices.length + '/' + services.length);

    if (linkedServices.length == 0) {
      nextStepsService.register({
        title: 'Buy or Sell Qybcoin',
        name: 'buyandsell',
        icon: 'icon-buy-bitcoin',
        sref: 'tabs.buyandsell',
      });
    } else {
      nextStepsService.unregister({
        name: 'buyandsell',
      });
    };

    $timeout(function() {
      $ionicScrollDelegate.resize();
    }, 10);
  };

  var updateNextStepsDebunced = lodash.debounce(root.update, 1000);

  root.register = function(serviceInfo) {
    services.push(serviceInfo);
    $log.info('Adding Buy and Sell service:' + serviceInfo.name + ' linked:' + serviceInfo.linked);
    updateNextStepsDebunced();
  };


  root.updateLink = function(name, linked) {
    var service = lodash.find(services, function(x) {
      return x.name == name;
    });
    $log.info('Updating Buy and Sell service:' + name + ' linked:' + linked);
    service.linked = linked

    root.update();
  };


  root.get = function() {
    return services;
  };


  root.getLinked = function() {
    return linkedServices;
  };


  return root;
});

'use strict';
angular.module('copayApp.services')
  .factory('bwcError', function bwcErrorService($log, gettextCatalog) {
    var root = {};

    root.msg = function(err, prefix) {
      if (!err)
        return 'Unknown error';

      var name;

      if (err.name) {
        if (err.name == 'Error')
          name = err.message
        else
          name = err.name.replace(/^bwc.Error/g, '');
      } else
        name = err;

      var body = '';
      prefix = prefix || '';

      if (name) {
        switch (name) {
          case 'INVALID_BACKUP':
            body = gettextCatalog.getString('Wallet Recovery Phrase is invalid');
            break;
          case 'WALLET_DOES_NOT_EXIST':
            body = gettextCatalog.getString('Wallet not registered at the wallet service. Recreate it from "Create Wallet" using "Advanced Options" to set your recovery phrase');
            break;
          case 'MISSING_PRIVATE_KEY':
            body = gettextCatalog.getString('Missing private keys to sign');
            break;
          case 'ENCRYPTED_PRIVATE_KEY':
            body = gettextCatalog.getString('Private key is encrypted, cannot sign');
            break;
          case 'SERVER_COMPROMISED':
            body = gettextCatalog.getString('Server response could not be verified');
            break;
          case 'COULD_NOT_BUILD_TRANSACTION':
            body = gettextCatalog.getString('Could not build transaction');
            break;
          case 'INSUFFICIENT_FUNDS':
            body = gettextCatalog.getString('Insufficient funds');
            break;
          case 'CONNECTION_ERROR':
            body = gettextCatalog.getString('Network error');
            break;
          case 'NOT_FOUND':
            body = gettextCatalog.getString('Wallet service not found');
            break;
          case 'ECONNRESET_ERROR':
            body = gettextCatalog.getString('Connection reset by peer');
            break;
          case 'BAD_RESPONSE_CODE':
            body = gettextCatalog.getString('The request could not be understood by the server');
            break;
          case 'WALLET_ALREADY_EXISTS':
            body = gettextCatalog.getString('Wallet already exists');
            break;
          case 'COPAYER_IN_WALLET':
            body = gettextCatalog.getString('Copayer already in this wallet');
            break;
          case 'WALLET_FULL':
            body = gettextCatalog.getString('Wallet is full');
            break;
          case 'WALLET_NOT_FOUND':
            body = gettextCatalog.getString('Wallet not found');
            break;
          case 'INSUFFICIENT_FUNDS_FOR_FEE':
            body = gettextCatalog.getString('Insufficient funds for fee');
            break;
          case 'LOCKED_FUNDS':
            body = gettextCatalog.getString('Funds are locked by pending spend proposals');
            break;
          case 'COPAYER_VOTED':
            body = gettextCatalog.getString('Copayer already voted on this spend proposal');
            break;
          case 'NOT_AUTHORIZED':
            body = gettextCatalog.getString('Not authorized');
            break;
          case 'TX_ALREADY_BROADCASTED':
            body = gettextCatalog.getString('Transaction already broadcasted');
            break;
          case 'TX_CANNOT_CREATE':
            body = gettextCatalog.getString('Locktime in effect. Please wait to create a new spend proposal');
            break;
          case 'TX_CANNOT_REMOVE':
            body = gettextCatalog.getString('Locktime in effect. Please wait to remove this spend proposal');
            break;
          case 'TX_NOT_ACCEPTED':
            body = gettextCatalog.getString('Spend proposal is not accepted');
            break;
          case 'TX_NOT_FOUND':
            body = gettextCatalog.getString('Spend proposal not found');
            break;
          case 'TX_NOT_PENDING':
            body = gettextCatalog.getString('The spend proposal is not pending');
            break;
          case 'UPGRADE_NEEDED':
            body = gettextCatalog.getString('Please upgrade Qyb to perform this action');
            break;
          case 'BAD_SIGNATURES':
            body = gettextCatalog.getString('Signatures rejected by server');
            break;
          case 'COPAYER_DATA_MISMATCH':
            body = gettextCatalog.getString('Copayer data mismatch');
            break;
          case 'DUST_AMOUNT':
            body = gettextCatalog.getString('Amount below minimum allowed');
            break;
          case 'INCORRECT_ADDRESS_NETWORK':
            body = gettextCatalog.getString('Incorrect network address');
            break;
          case 'COPAYER_REGISTERED':
            body = gettextCatalog.getString('Key already associated with an existing wallet');
            break;
          case 'INVALID_ADDRESS':
            body = gettextCatalog.getString('Invalid address');
            break;
          case 'MAIN_ADDRESS_GAP_REACHED':
            body = gettextCatalog.getString('Empty addresses limit reached. New addresses cannot be generated.');
            break;
          case 'WALLET_LOCKED':
            body = gettextCatalog.getString('Wallet is locked');
            break;
          case 'WALLET_NOT_COMPLETE':
            body = gettextCatalog.getString('Wallet is not complete');
            break;
          case 'WALLET_NEEDS_BACKUP':
            body = gettextCatalog.getString('Wallet needs backup');
            break;
          case 'MISSING_PARAMETER':
            body = gettextCatalog.getString('Missing parameter');
            break;
          case 'NO_PASSWORD_GIVEN':
            body = gettextCatalog.getString('Spending Password needed');
            break;
          case 'PASSWORD_INCORRECT':
            body = gettextCatalog.getString('Wrong spending password');
            break;
          case 'EXCEEDED_DAILY_LIMIT':
            body = gettextCatalog.getString('Exceeded daily limit of $500 per user');
            break;
          case 'ERROR':
            body = (err.message || err.error);
            break;

          default:
            $log.warn('Unknown error type:', name);
            body = err.message || name;
            break;
        }
      } else if (err.message) {
        body = err.message;
      } else {
        body = err;
      }

      var msg = prefix + (body ? (prefix ? ': ' : '') + body : '');
      return msg;
    };

    root.cb = function(err, prefix, cb) {
      return cb(root.msg(err, prefix));
    };

    return root;
  });

'use strict';

angular.module('copayApp.services').factory('coinbaseService', function($http, $log, $window, $filter, platformInfo, lodash, storageService, configService, appConfigService, txFormatService, buyAndSellService, $rootScope, feeService) {
  var root = {};
  var credentials = {};
  var isCordova = platformInfo.isCordova;
  var isNW = platformInfo.isNW;
  var isWindowsPhoneApp = platformInfo.isCordova && platformInfo.isWP;

  root.priceSensitivity = [{
    value: 0.5,
    name: '0.5%'
  }, {
    value: 1,
    name: '1%'
  }, {
    value: 2,
    name: '2%'
  }, {
    value: 5,
    name: '5%'
  }, {
    value: 10,
    name: '10%'
  }];

  root.selectedPriceSensitivity = root.priceSensitivity[1];

  var setCredentials = function() {

    if (!$window.externalServices || !$window.externalServices.coinbase) {
      return;
    }

    var coinbase = $window.externalServices.coinbase;

    /*
     * Development: 'testnet'
     * Production: 'livenet'
     */
    credentials.NETWORK = 'livenet';

    // Coinbase permissions
    credentials.SCOPE = '' +
      'wallet:accounts:read,' +
      'wallet:addresses:read,' +
      'wallet:addresses:create,' +
      'wallet:user:read,' +
      'wallet:user:email,' +
      'wallet:buys:read,' +
      'wallet:buys:create,' +
      'wallet:sells:read,' +
      'wallet:sells:create,' +
      'wallet:transactions:read,' +
      'wallet:transactions:send,' +
      'wallet:transactions:send:bypass-2fa,' +
      'wallet:payment-methods:read';

    // NW has a bug with Window Object
    if (isCordova) {
      credentials.REDIRECT_URI = coinbase.redirect_uri.mobile;
    } else {
      credentials.REDIRECT_URI = coinbase.redirect_uri.desktop;
    }

    if (credentials.NETWORK == 'testnet') {
      credentials.HOST = coinbase.sandbox.host;
      credentials.API = coinbase.sandbox.api;
      credentials.CLIENT_ID = coinbase.sandbox.client_id;
      credentials.CLIENT_SECRET = coinbase.sandbox.client_secret;
    } else {
      credentials.HOST = coinbase.production.host;
      credentials.API = coinbase.production.api;
      credentials.CLIENT_ID = coinbase.production.client_id;
      credentials.CLIENT_SECRET = coinbase.production.client_secret;
    };

    // Force to use specific version
    credentials.API_VERSION = '2017-10-31';
  };

  var _afterTokenReceived = function(data, cb) {
    if (data && data.access_token && data.refresh_token) {
      storageService.setCoinbaseToken(credentials.NETWORK, data.access_token, function() {
        storageService.setCoinbaseRefreshToken(credentials.NETWORK, data.refresh_token, function() {
          buyAndSellService.updateLink('coinbase', true);
          return cb(null, data.access_token);
        });
      });
    } else {
      return cb('Could not get the access token');
    }
  };

  root.getErrorsAsString = function(errors) {
    var errStr = '';

    if (!lodash.isArray(errors)) {
      errStr = errors.message || errors;
      return errStr;
    }

    for (var i = 0; i < errors.length; i++) {
      errStr = errStr + errors[i].message + '. ';
    }
    return errStr;
  };

  root.getNetwork = function() {
    return credentials.NETWORK;
  };

  root.getStoredToken = function(cb) {
    storageService.getCoinbaseToken(credentials.NETWORK, function(err, accessToken) {
      if (err || !accessToken) return cb();
      return cb(accessToken);
    });
  };

  root.getAvailableCurrency = function() {
    var config = configService.getSync().wallet.settings;
    // ONLY "USD"
    switch (config.alternativeIsoCode) {
      default: return 'USD'
    };
  };

  root.checkEnoughFundsForFee = function(amount, cb) {
    _getNetAmount(amount, function(err, reducedAmount) {
      if (err) return cb(err);

      // Check if transaction has enough funds to transfer bitcoin from Coinbase to Qyb
      if (reducedAmount < 0) {
        return cb('Not enough funds for fee');
      }

      return cb();
    });
  };

  root.getSignupUrl = function() {
    return credentials.HOST + '/signup';
  }

  root.getSupportUrl = function() {
    return 'https://support.coinbase.com/';
  }

  root.getOauthCodeUrl = function() {
    return credentials.HOST +
      '/oauth/authorize?response_type=code&client_id=' +
      credentials.CLIENT_ID +
      '&redirect_uri=' +
      credentials.REDIRECT_URI +
      '&state=SECURE_RANDOM&scope=' +
      credentials.SCOPE +
      '&meta[send_limit_amount]=1000&meta[send_limit_currency]=USD&meta[send_limit_period]=day';
  };

  root.getToken = function(code, cb) {
    var req = {
      method: 'POST',
      url: credentials.HOST + '/oauth/token',
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json'
      },
      data: {
        grant_type: 'authorization_code',
        code: code,
        client_id: credentials.CLIENT_ID,
        client_secret: credentials.CLIENT_SECRET,
        redirect_uri: credentials.REDIRECT_URI
      }
    };

    $http(req).then(function(data) {
      $log.info('Coinbase: GET Access Token SUCCESS');
      // Show pending task from the UI
      _afterTokenReceived(data.data, cb);
    }, function(data) {
      $log.error('Coinbase: GET Access Token ERROR ' + data.status + '. ' + root.getErrorsAsString(data.data.errors));
      return cb(data.data);
    });
  };

  var _getNetAmount = function(amount, cb) {
    // Fee Normal for a single transaction (450 bytes)
    var txNormalFeeKB = 450 / 1000;
    feeService.getFeeRate('btc', 'livenet', 'normal', function(err, feePerKb) {
      if (err) return cb('Could not get fee rate');
      var feeQYB = (feePerKb * txNormalFeeKB / 100000000).toFixed(8);

      return cb(null, amount - feeQYB, feeQYB);
    });
  };

  var _refreshToken = function(refreshToken, cb) {
    var req = {
      method: 'POST',
      url: credentials.HOST + '/oauth/token',
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json'
      },
      data: {
        grant_type: 'refresh_token',
        client_id: credentials.CLIENT_ID,
        client_secret: credentials.CLIENT_SECRET,
        redirect_uri: credentials.REDIRECT_URI,
        refresh_token: refreshToken
      }
    };

    $http(req).then(function(data) {
      $log.info('Coinbase: Refresh Access Token SUCCESS');
      _afterTokenReceived(data.data, cb);
    }, function(data) {
      $log.error('Coinbase: Refresh Access Token ERROR ' + data.status + '. ' + root.getErrorsAsString(data.data.errors));
      return cb(data.data);
    });
  };

  var _getMainAccountId = function(accessToken, cb) {
    root.getAccounts(accessToken, function(err, a) {
      if (err) return cb(err);
      var data = a.data;
      for (var i = 0; i < data.length; i++) {
        if (data[i].primary && data[i].type == 'wallet' && data[i].currency && data[i].currency.code == 'QYB') {
          return cb(null, data[i].id);
        }
      }
      root.logout(function() {});
      return cb('Your primary account should be a QYB WALLET. Set your wallet account as primary and try again');
    });
  };

  root.isActive = function(cb) {

    if (isWindowsPhoneApp)
      return cb();

    if (lodash.isEmpty(credentials.CLIENT_ID))
      return cb();

    storageService.getCoinbaseToken(credentials.NETWORK, function(err, accessToken) {
      return cb(err, !!accessToken);
    });
  }

  root.init = lodash.throttle(function(cb) {
    if (lodash.isEmpty(credentials.CLIENT_ID)) {
      return cb('Coinbase is Disabled. Missing credentials.');
    }
    $log.debug('Trying to initialise Coinbase...');

    storageService.getCoinbaseToken(credentials.NETWORK, function(err, accessToken) {
      if (err || !accessToken) return cb();
      else {
        _getMainAccountId(accessToken, function(err, accountId) {
          if (err) {
            if (!err.errors) return cb(err);

            if (err.errors && !lodash.isArray(err.errors)) return cb(err);

            var expiredToken;
            for (var i = 0; i < err.errors.length; i++) {
              if (err.errors[i].id == 'expired_token') expiredToken = true;
            }
            if (expiredToken) {
              $log.debug('Refresh token');
              storageService.getCoinbaseRefreshToken(credentials.NETWORK, function(err, refreshToken) {
                if (err) return cb(err);
                _refreshToken(refreshToken, function(err, newToken) {
                  if (err) return cb(err);
                  _getMainAccountId(newToken, function(err, accountId) {
                    if (err) return cb(err);
                    return cb(null, {
                      accessToken: newToken,
                      accountId: accountId
                    });
                  });
                });
              });
            } else {
              return cb(err);
            }
          } else {
            return cb(null, {
              accessToken: accessToken,
              accountId: accountId
            });
          }
        });
      }
    });
  }, 10000);

  var _get = function(endpoint, token) {
    return {
      method: 'GET',
      url: credentials.API + '/v2' + endpoint,
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
        'CB-VERSION': credentials.API_VERSION,
        'Authorization': 'Bearer ' + token
      }
    };
  };

  root.getAccounts = function(token, cb) {
    if (!token) return cb('Invalid Token');
    $http(_get('/accounts', token)).then(function(data) {
      $log.info('Coinbase: Get Accounts SUCCESS');
      return cb(null, data.data);
    }, function(data) {
      $log.error('Coinbase: Get Accounts ERROR ' + data.status + '. ' + root.getErrorsAsString(data.data.errors));
      return cb(data.data);
    });
  };

  root.getAccount = function(token, accountId, cb) {
    if (!token) return cb('Invalid Token');
    $http(_get('/accounts/' + accountId, token)).then(function(data) {
      $log.info('Coinbase: Get Account SUCCESS');
      return cb(null, data.data);
    }, function(data) {
      $log.error('Coinbase: Get Account ERROR ' + data.status + '. ' + root.getErrorsAsString(data.data.errors));
      return cb(data.data);
    });
  };

  root.getAuthorizationInformation = function(token, cb) {
    if (!token) return cb('Invalid Token');
    $http(_get('/user/auth', token)).then(function(data) {
      $log.info('Coinbase: Autorization Information SUCCESS');
      return cb(null, data.data);
    }, function(data) {
      $log.error('Coinbase: Authorization Information ERROR ' + data.status + '. ' + root.getErrorsAsString(data.data.errors));
      return cb(data.data);
    });
  };

  root.getCurrentUser = function(token, cb) {
    if (!token) return cb('Invalid Token');
    $http(_get('/user', token)).then(function(data) {
      $log.info('Coinbase: Get Current User SUCCESS');
      return cb(null, data.data);
    }, function(data) {
      $log.error('Coinbase: Get Current User ERROR ' + data.status + '. ' + root.getErrorsAsString(data.data.errors));
      return cb(data.data);
    });
  };

  root.getBuyOrder = function(token, accountId, buyId, cb) {
    if (!token) return cb('Invalid Token');
    $http(_get('/accounts/' + accountId + '/buys/' + buyId, token)).then(function(data) {
      $log.info('Coinbase: Buy Info SUCCESS');
      return cb(null, data.data);
    }, function(data) {
      $log.error('Coinbase: Buy Info ERROR ' + data.status + '. ' + root.getErrorsAsString(data.data.errors));
      return cb(data.data);
    });
  };

  root.getTransaction = function(token, accountId, transactionId, cb) {
    if (!token) return cb('Invalid Token');
    $http(_get('/accounts/' + accountId + '/transactions/' + transactionId, token)).then(function(data) {
      $log.info('Coinbase: Transaction SUCCESS');
      return cb(null, data.data);
    }, function(data) {
      $log.error('Coinbase: Transaction ERROR ' + data.status + '. ' + root.getErrorsAsString(data.data.errors));
      return cb(data.data);
    });
  };

  root.getAddressTransactions = function(token, accountId, addressId, cb) {
    if (!token) return cb('Invalid Token');
    $http(_get('/accounts/' + accountId + '/addresses/' + addressId + '/transactions', token)).then(function(data) {
      $log.info('Coinbase: Address Transactions SUCCESS');
      return cb(null, data.data);
    }, function(data) {
      $log.error('Coinbase: Address Transactions ERROR ' + data.status + '. ' + root.getErrorsAsString(data.data.errors));
      return cb(data.data);
    });
  };

  root.getTransactions = function(token, accountId, cb) {
    if (!token) return cb('Invalid Token');
    $http(_get('/accounts/' + accountId + '/transactions', token)).then(function(data) {
      $log.info('Coinbase: Transactions SUCCESS');
      return cb(null, data.data);
    }, function(data) {
      $log.error('Coinbase: Transactions ERROR ' + data.status + '. ' + root.getErrorsAsString(data.data.errors));
      return cb(data.data);
    });
  };

  root.paginationTransactions = function(token, Url, cb) {
    if (!token) return cb('Invalid Token');
    $http(_get(Url.replace('/v2', ''), token)).then(function(data) {
      $log.info('Coinbase: Pagination Transactions SUCCESS');
      return cb(null, data.data);
    }, function(data) {
      $log.error('Coinbase: Pagination Transactions ERROR ' + data.status + '. ' + root.getErrorsAsString(data.data.errors));
      return cb(data.data);
    });
  };

  root.sellPrice = function(token, currency, cb) {
    $http(_get('/prices/sell?currency=' + currency, token)).then(function(data) {
      $log.info('Coinbase: Sell Price SUCCESS');
      return cb(null, data.data);
    }, function(data) {
      $log.error('Coinbase: Sell Price ERROR ' + data.status + '. ' + root.getErrorsAsString(data.data.errors));
      return cb(data.data);
    });
  };

  root.buyPrice = function(token, currency, cb) {
    $http(_get('/prices/buy?currency=' + currency, token)).then(function(data) {
      $log.info('Coinbase: Buy Price SUCCESS');
      return cb(null, data.data);
    }, function(data) {
      $log.error('Coinbase: Buy Price ERROR ' + data.status + '. ' + root.getErrorsAsString(data.data.errors));
      return cb(data.data);
    });
  };

  root.getPaymentMethods = function(token, cb) {
    $http(_get('/payment-methods', token)).then(function(data) {
      $log.info('Coinbase: Get Payment Methods SUCCESS');
      return cb(null, data.data);
    }, function(data) {
      $log.error('Coinbase: Get Payment Methods ERROR ' + data.status + '. ' + root.getErrorsAsString(data.data.errors));
      return cb(data.data);
    });
  };

  root.getPaymentMethod = function(token, paymentMethodId, cb) {
    $http(_get('/payment-methods/' + paymentMethodId, token)).then(function(data) {
      $log.info('Coinbase: Get Payment Method SUCCESS');
      return cb(null, data.data);
    }, function(data) {
      $log.error('Coinbase: Get Payment Method ERROR ' + data.status + '. ' + root.getErrorsAsString(data.data.errors));
      return cb(data.data);
    });
  };

  var _post = function(endpoint, token, data) {
    return {
      method: 'POST',
      url: credentials.API + '/v2' + endpoint,
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
        'CB-VERSION': credentials.API_VERSION,
        'Authorization': 'Bearer ' + token
      },
      data: data
    };
  };

  root.sellRequest = function(token, accountId, data, cb) {
    var data = {
      amount: data.amount,
      currency: data.currency,
      payment_method: data.payment_method ||  null,
      commit: data.commit || false,
      quote: data.quote || false
    };
    $http(_post('/accounts/' + accountId + '/sells', token, data)).then(function(data) {
      $log.info('Coinbase: Sell Request SUCCESS');
      return cb(null, data.data);
    }, function(data) {
      $log.error('Coinbase: Sell Request ERROR ' + data.status + '. ' + root.getErrorsAsString(data.data.errors));
      return cb(data.data);
    });
  };

  root.sellCommit = function(token, accountId, sellId, cb) {
    $http(_post('/accounts/' + accountId + '/sells/' + sellId + '/commit', token)).then(function(data) {
      $log.info('Coinbase: Sell Commit SUCCESS');
      return cb(null, data.data);
    }, function(data) {
      $log.error('Coinbase: Sell Commit ERROR ' + data.status + '. ' + root.getErrorsAsString(data.data.errors));
      return cb(data.data);
    });
  };

  root.buyRequest = function(token, accountId, data, cb) {
    var data = {
      amount: data.amount,
      currency: data.currency,
      payment_method: data.payment_method || null,
      commit: data.commit || false,
      quote: data.quote || false
    };
    $http(_post('/accounts/' + accountId + '/buys', token, data)).then(function(data) {
      $log.info('Coinbase: Buy Request SUCCESS');
      return cb(null, data.data);
    }, function(data) {
      $log.error('Coinbase: Buy Request ERROR ' + data.status + '. ' + root.getErrorsAsString(data.data.errors));
      return cb(data.data);
    });
  };

  root.buyCommit = function(token, accountId, buyId, cb) {
    $http(_post('/accounts/' + accountId + '/buys/' + buyId + '/commit', token)).then(function(data) {
      $log.info('Coinbase Buy Commit: SUCCESS');
      return cb(null, data.data);
    }, function(data) {
      $log.error('Coinbase: Buy Commit ERROR ' + data.status + '. ' + root.getErrorsAsString(data.data.errors));
      return cb(data.data);
    });
  };

  root.createAddress = function(token, accountId, data, cb) {
    var data = {
      name: data.name
    };
    $http(_post('/accounts/' + accountId + '/addresses', token, data)).then(function(data) {
      $log.info('Coinbase: Create Address SUCCESS');
      return cb(null, data.data);
    }, function(data) {
      $log.error('Coinbase: Create Address ERROR ' + data.status + '. ' + root.getErrorsAsString(data.data.errors));
      return cb(data.data);
    });
  };

  root.sendTo = function(token, accountId, data, cb) {
    var data = {
      type: 'send',
      to: data.to,
      amount: data.amount,
      currency: data.currency,
      description: data.description
    };
    $http(_post('/accounts/' + accountId + '/transactions', token, data)).then(function(data) {
      $log.info('Coinbase: Send Transaction SUCCESS');
      return cb(null, data.data);
    }, function(data) {
      $log.error('Coinbase: Send Transaction ERROR ' + data.status + '. ' + root.getErrorsAsString(data.data.errors));
      return cb(data.data);
    });
  };

  // Pending transactions

  root.savePendingTransaction = function(ctx, opts, cb) {
    _savePendingTransaction(ctx, opts, cb);
  };

  var _savePendingTransaction = function(ctx, opts, cb) {
    storageService.getCoinbaseTxs(credentials.NETWORK, function(err, oldTxs) {
      if (lodash.isString(oldTxs)) {
        oldTxs = JSON.parse(oldTxs);
      }
      if (lodash.isString(ctx)) {
        ctx = JSON.parse(ctx);
      }
      var tx = oldTxs || {};
      tx[ctx.id] = ctx;
      if (opts && (opts.error || opts.status)) {
        tx[ctx.id] = lodash.assign(tx[ctx.id], opts);
      }
      if (opts && opts.remove) {
        delete(tx[ctx.id]);
      }
      tx = JSON.stringify(tx);

      storageService.setCoinbaseTxs(credentials.NETWORK, tx, function(err) {
        return cb(err);
      });
    });
  };

  root.getPendingTransactions = function(coinbasePendingTransactions) {
    storageService.getCoinbaseTxs(credentials.NETWORK, function(err, txs) {
      txs = txs ? JSON.parse(txs) : {};
      coinbasePendingTransactions.data = lodash.isEmpty(txs) ? null : txs;

      root.init(function(err, data) {
        if (err || lodash.isEmpty(data)) {
          if (err) $log.error(err);
          return;
        }
        var accessToken = data.accessToken;
        var accountId = data.accountId;

        lodash.forEach(coinbasePendingTransactions.data, function(dataFromStorage, txId) {
          if ((dataFromStorage.type == 'sell' && dataFromStorage.status == 'completed') ||
            (dataFromStorage.type == 'buy' && dataFromStorage.status == 'completed') ||
            dataFromStorage.status == 'error' ||
            (dataFromStorage.type == 'send' && dataFromStorage.status == 'completed'))
            return;
          root.getTransaction(accessToken, accountId, txId, function(err, tx) {
            if (err || lodash.isEmpty(tx) || (tx.data && tx.data.error)) {
              _savePendingTransaction(dataFromStorage, {
                status: 'error',
                error: (tx.data && tx.data.error) ? tx.data.error : err
              }, function(err) {
                if (err) $log.debug(err);
                _updateTxs(coinbasePendingTransactions);
              });
              return;
            }
            _updateCoinbasePendingTransactions(dataFromStorage, tx.data);
            coinbasePendingTransactions.data[txId] = dataFromStorage;
            if (tx.data.type == 'send' && tx.data.status == 'completed' && tx.data.from) {
              root.sellPrice(accessToken, dataFromStorage.sell_price_currency, function(err, s) {
                if (err) {
                  _savePendingTransaction(dataFromStorage, {
                    status: 'error',
                    error: err
                  }, function(err) {
                    if (err) $log.debug(err);
                    _updateTxs(coinbasePendingTransactions);
                  });
                  return;
                }
                var newSellPrice = s.data.amount;
                var variance = Math.abs((newSellPrice - dataFromStorage.sell_price_amount) / dataFromStorage.sell_price_amount * 100);
                if (variance < dataFromStorage.price_sensitivity.value) {
                  _sellPending(dataFromStorage, accessToken, accountId, coinbasePendingTransactions);
                } else {
                  _savePendingTransaction(dataFromStorage, {
                    status: 'error',
                    error: {errors: [{message: 'Price falls over the selected percentage'}]}
                  }, function(err) {
                    if (err) $log.debug(err);
                    _updateTxs(coinbasePendingTransactions);
                  });
                }
              });
            } else if (tx.data.type == 'buy' && tx.data.status == 'completed' && tx.data.buy) {
              _sendToWallet(dataFromStorage, accessToken, accountId, coinbasePendingTransactions);
            } else {
              _savePendingTransaction(dataFromStorage, {}, function(err) {
                if (err) $log.debug(err);
                _updateTxs(coinbasePendingTransactions);
              });
            }
          });
        });
      });
    });
  };

  root.updatePendingTransactions = lodash.throttle(function() {
    $log.debug('Updating coinbase pending transactions...');
    var pendingTransactions = {
      data: {}
    };
    root.getPendingTransactions(pendingTransactions);
  }, 20000);

  var _updateTxs = function(coinbasePendingTransactions) {
    storageService.getCoinbaseTxs(credentials.NETWORK, function(err, txs) {
      txs = txs ? JSON.parse(txs) : {};
      coinbasePendingTransactions.data = lodash.isEmpty(txs) ? null : txs;
    });
  };

  var _sellPending = function(tx, accessToken, accountId, coinbasePendingTransactions) {
    var data = tx.amount;
    data['payment_method'] = tx.payment_method || null;
    data['commit'] = true;
    root.sellRequest(accessToken, accountId, data, function(err, res) {
      if (err) {
        _savePendingTransaction(tx, {
          status: 'error',
          error: err
        }, function(err) {
          if (err) $log.debug(err);
          _updateTxs(coinbasePendingTransactions);
        });
      } else {
        if (res.data && !res.data.transaction) {
          _savePendingTransaction(tx, {
            status: 'error',
            error: {errors: [{message: 'Sell order: transaction not found.'}]}
          }, function(err) {
            if (err) $log.debug(err);
            _updateTxs(coinbasePendingTransactions);
          });
          return;
        }

        root.getTransaction(accessToken, accountId, res.data.transaction.id, function(err, updatedTx) {
          if (err) {
            _savePendingTransaction(tx, {
              status: 'error',
              error: err
            }, function(err) {
              if (err) $log.error(err);
              _updateTxs(coinbasePendingTransactions);
            });
            return;
          }
          _savePendingTransaction(tx, {
            remove: true
          }, function(err) {
            _savePendingTransaction(updatedTx.data, {}, function(err) {
              if (err) $log.debug(err);
              _updateTxs(coinbasePendingTransactions);
            });
          });
        });
      }
    });
  };

  var _sendToWallet = function(tx, accessToken, accountId, coinbasePendingTransactions) {
    if (!tx) return;
    var desc = appConfigService.nameCase + ' Wallet';
    _getNetAmount(tx.amount.amount, function(err, amountQYB, feeQYB) {
      if (err) {
        _savePendingTransaction(tx, {
          status: 'error',
          error: {errors: [{message: err}]}
        }, function(err) {
          if (err) $log.debug(err);
          _updateTxs(coinbasePendingTransactions);
        });
        return;
      }

      var data = {
        to: tx.toAddr,
        amount: amountQYB,
        currency: tx.amount.currency,
        description: desc,
        fee: feeQYB
      };
      root.sendTo(accessToken, accountId, data, function(err, res) {
        if (err) {
          _savePendingTransaction(tx, {
            status: 'error',
            error: err
          }, function(err) {
            if (err) $log.debug(err);
            _updateTxs(coinbasePendingTransactions);
          });
        } else {
          if (res.data && !res.data.id) {
            _savePendingTransaction(tx, {
              status: 'error',
              error: {errors: [{message: 'Transactions not found in Coinbase.com'}]}
            }, function(err) {
              if (err) $log.debug(err);
              _updateTxs(coinbasePendingTransactions);
            });
            return;
          }
          root.getTransaction(accessToken, accountId, res.data.id, function(err, sendTx) {
            if (err) {
              _savePendingTransaction(tx, {
                status: 'error',
                error: err
              }, function(err) {
                if (err) $log.error(err);
                _updateTxs(coinbasePendingTransactions);
              });
              return;
            }

            _savePendingTransaction(tx, {
              remove: true
            }, function(err) {
              if (err) $log.error(err);
              _savePendingTransaction(sendTx.data, {}, function(err) {
                if (err) $log.debug(err);
                _updateTxs(coinbasePendingTransactions);
              });
            });
          });
        }
      });
    });
  };

  var _updateCoinbasePendingTransactions = function(obj /*, …*/ ) {
    for (var i = 1; i < arguments.length; i++) {
      for (var prop in arguments[i]) {
        var val = arguments[i][prop];
        if (typeof val == "object")
          _updateCoinbasePendingTransactions(obj[prop], val);
        else
          obj[prop] = val ? val : obj[prop];
      }
    }
    return obj;
  };

  root.logout = function(cb) {
    storageService.removeCoinbaseToken(credentials.NETWORK, function() {
      buyAndSellService.updateLink('coinbase', false);
      storageService.removeCoinbaseRefreshToken(credentials.NETWORK, function() {
        storageService.removeCoinbaseTxs(credentials.NETWORK, function() {
          return cb();
        });
      });
    });
  };

  var register = function() {

    root.isActive(function(err, isActive) {
      if (err) return;

      buyAndSellService.register({
        name: 'coinbase',
        logo: 'img/coinbase-logo.png',
        location: '33 Countries',
        sref: 'tabs.buyandsell.coinbase',
        configSref: 'tabs.preferences.coinbase',
        linked: isActive,
      });
    });
  };

  setCredentials();
  register();

  $rootScope.$on('bwsEvent', function(e, walletId, type, n) {
    if (type == 'NewBlock' && n && n.data && n.data.network == 'livenet') {
      root.isActive(function(err, isActive) {
        // Update Coinbase
        if (isActive)
          root.updatePendingTransactions();
      });
    }
  });
  return root;
});

'use strict';

angular.module('copayApp.services').factory('configService', function(storageService, lodash, $log, $timeout, $rootScope, platformInfo) {
  var root = {};

  var isWindowsPhoneApp = platformInfo.isCordova && platformInfo.isWP;

  var defaultConfig = {
    // wallet limits
    limits: {
      totalCopayers: 6,
      mPlusN: 100,
    },

    // Bitcore wallet service URL
    bws: {
      //url: 'https://bws.bitpay.com/bws/api',
      //url: 'http://1943h2623o.51mypc.cn/bws/api',
      url: 'http://api.qyb.chainclub.one/bws/api',
    },

    download: {
      bitpay: {
        url: 'https://bitpay.com/wallet'
      },
      copay: {
        url: 'https://copay.io/#download'
      }
    },

    rateApp: {
      bitpay: {
        ios: 'http://itunes.apple.com/WebObjects/MZStore.woa/wa/viewContentsUserReviews?id=1149581638&pageNumber=0&sortOrdering=2&type=Purple+Software&mt=8',
        android: 'https://play.google.com/store/apps/details?id=com.bitpay.wallet',
        wp: ''
      },
      copay: {
        ios: 'http://itunes.apple.com/WebObjects/MZStore.woa/wa/viewContentsUserReviews?id=951330296&pageNumber=0&sortOrdering=2&type=Purple+Software&mt=8',
        android: 'https://play.google.com/store/apps/details?id=com.bitpay.copay',
        wp: ''
      }
    },
    // wallet default config
    wallet: {
      requiredCopayers: 2,
      totalCopayers: 3,
      spendUnconfirmed: false,
      reconnectDelay: 5000,
      idleDurationMin: 4,
      settings: {
        unitName: 'QYB',
        unitToSatoshi: 100000000,
        unitDecimals: 8,
        unitCode: 'btc',
        alternativeName: 'US Dollar',
        alternativeIsoCode: 'USD',
      }
    },

    lock: {
      method: null,
      value: null,
      bannedUntil: null,
    },

    recentTransactions: {
      enabled: true,
    },

    hideNextSteps: {
      enabled: isWindowsPhoneApp ? true : false,
    },

    rates: {
      url: 'http://qyb.chainclub.one/insight-api/rates',
    },

    release: {
      url: 'https://api.github.com/repos/bitpay/copay/releases/latest'
    },

    pushNotificationsEnabled: true,

    confirmedTxsNotifications: {
      enabled: true,
    },

    emailNotifications: {
      enabled: false,
    },

    log: {
      filter: 'debug',
    },
  };

  var configCache = null;

  root.getSync = function() {
    if (!configCache)
      throw new Error('configService#getSync called when cache is not initialized');

    return configCache;
  };

  root._queue = [];
  root.whenAvailable = function(cb) {
    if (!configCache) {
      root._queue.push(cb);
      return;
    }
    return cb(configCache);
  };


  root.get = function(cb) {

    storageService.getConfig(function(err, localConfig) {
      if (localConfig) {
        configCache = JSON.parse(localConfig);

        //these ifs are to avoid migration problems
        if (!configCache.bws) {
          configCache.bws = defaultConfig.bws;
        }
        if (!configCache.wallet) {
          configCache.wallet = defaultConfig.wallet;
        }
        if (!configCache.wallet.settings.unitCode) {
          configCache.wallet.settings.unitCode = defaultConfig.wallet.settings.unitCode;
        }

        if (!configCache.hideNextSteps) {
          configCache.hideNextSteps = defaultConfig.hideNextSteps;
        }

        if (!configCache.recentTransactions) {
          configCache.recentTransactions = defaultConfig.recentTransactions;
        }
        if (!configCache.pushNotifications) {
          configCache.pushNotifications = defaultConfig.pushNotifications;
        }
        if (!configCache.bitpayAccount) {
          configCache.bitpayAccount = defaultConfig.bitpayAccount;
        }

        if (configCache.wallet.settings.unitCode == 'bit') {
          // Convert to QYB. Bits will be disabled
          configCache.wallet.settings.unitName = defaultConfig.wallet.settings.unitName;
          configCache.wallet.settings.unitToSatoshi = defaultConfig.wallet.settings.unitToSatoshi;
          configCache.wallet.settings.unitDecimals = defaultConfig.wallet.settings.unitDecimals;
          configCache.wallet.settings.unitCode = defaultConfig.wallet.settings.unitCode;
        }

      } else {
        configCache = lodash.clone(defaultConfig);
      };

      configCache.bwsFor = configCache.bwsFor || {};
      configCache.colorFor = configCache.colorFor || {};
      configCache.aliasFor = configCache.aliasFor || {};
      configCache.emailFor = configCache.emailFor || {};

      $log.debug('Preferences read:', configCache)

      lodash.each(root._queue, function(x) {
        $timeout(function() {
          return x(configCache);
        }, 1);
      });
      root._queue = [];

      return cb(err, configCache);
    });
  };

  root.set = function(newOpts, cb) {
    var config = lodash.cloneDeep(defaultConfig);
    storageService.getConfig(function(err, oldOpts) {
      oldOpts = oldOpts || {};

      if (lodash.isString(oldOpts)) {
        oldOpts = JSON.parse(oldOpts);
      }
      if (lodash.isString(config)) {
        config = JSON.parse(config);
      }
      if (lodash.isString(newOpts)) {
        newOpts = JSON.parse(newOpts);
      }

      lodash.merge(config, oldOpts, newOpts);
      configCache = config;

      $rootScope.$emit('Local/SettingsUpdated');

      storageService.storeConfig(JSON.stringify(config), cb);
    });
  };

  root.reset = function(cb) {
    configCache = lodash.clone(defaultConfig);
    storageService.removeConfig(cb);
  };

  root.getDefaults = function() {
    return lodash.clone(defaultConfig);
  };


  return root;
});

'use strict';

angular.module('copayApp.services').factory('derivationPathHelper', function(lodash) {
  var root = {};

  root.default = "m/44'/0'/0'";
  root.defaultTestnet = "m/44'/1'/0'";

  root.parse = function(str) {
    var arr = str.split('/');

    var ret = {};

    if (arr[0] != 'm')
      return false;

    switch (arr[1]) {
      case "44'":
        ret.derivationStrategy = 'BIP44';
        break;
      case "45'":
        return {
          derivationStrategy: 'BIP45',
          networkName: 'livenet',
          account: 0,
        }
        break;
      case "48'":
        ret.derivationStrategy = 'BIP48';
        break;
      default:
        return false;
    };

    switch (arr[2]) {
      case "0'":
        ret.networkName = 'livenet';
        break;
      case "1'":
        ret.networkName = 'testnet';
        break;
      default:
        return false;
    };

    var match = arr[3].match(/(\d+)'/);
    if (!match)
      return false;
    ret.account = +match[1]

    return ret;
  };

  return root;
});

'use strict';

angular.module('copayApp.services').factory('emailService', function($log, configService, lodash, walletService, profileService) {
  var root = {};

  root.updateEmail = function(opts) {
    opts = opts || {};
    if (!opts.email) return;

    var wallets = profileService.getWallets();

    configService.set({
      emailFor: null, // Backward compatibility
      emailNotifications: {
        enabled: opts.enabled,
        email: opts.enabled ? opts.email : null
      }
    }, function(err) {
      if (err) $log.warn(err);
      walletService.updateRemotePreferences(wallets);
    });
  };

  root.getEmailIfEnabled = function(config) {
    config = config || configService.getSync();
    
    if (config.emailNotifications) {
      if (!config.emailNotifications.enabled) return;

      if (config.emailNotifications.email) 
        return config.emailNotifications.email;
    }
    
    if (lodash.isEmpty(config.emailFor)) return;
    
    // Backward compatibility
    var emails = lodash.values(config.emailFor);
    for(var i = 0; i < emails.length; i++) {
      if (emails[i] !== null && typeof emails[i] !== 'undefined') {
        return emails[i];
      }
    }
  };

  root.init = function() {
    configService.whenAvailable(function(config) {

      if (config.emailNotifications && config.emailNotifications.enabled) {
        
        // If email already set
        if (config.emailNotifications.email) return;

        var currentEmail = root.getEmailIfEnabled(config);

        root.updateEmail({
          enabled: currentEmail ? true : false,
          email: currentEmail
        });
      }
    });
  };

  return root;
});

'use strict';

angular.module('copayApp.services').service('externalLinkService', function(platformInfo, nodeWebkitService, popupService, gettextCatalog, $window, $log, $timeout) {

  var _restoreHandleOpenURL = function(old) {
    $timeout(function() {
      $window.handleOpenURL = old;
    }, 500);
  };

  this.open = function(url, optIn, title, message, okText, cancelText, cb) {
    var old = $window.handleOpenURL;

    $window.handleOpenURL = function(url) {
      // Ignore external URLs
      $log.debug('Skip: ' + url);
    };

    if (platformInfo.isNW) {
      nodeWebkitService.openExternalLink(url);
      _restoreHandleOpenURL(old);
    } else {
      if (optIn) {
        var openBrowser = function(res) {
          if (res) window.open(url, '_system');
          if (cb) return cb();
          _restoreHandleOpenURL(old);
        };
        popupService.showConfirm(title, message, okText, cancelText, openBrowser);
      } else {
        window.open(url, '_system');
        _restoreHandleOpenURL(old);
      }
    }
  };

});

'use strict';
angular.module('copayApp.services').factory('feedbackService', function($http, $log, $httpParamSerializer, configService) {
  var root = {};
  var URL = "https://script.google.com/macros/s/AKfycbybtvNSQKUfgzgXcj3jYLlvCKrcBoktjiJ1V8_cwd2yVkpUBGe3/exec";

  root.send = function(dataSrc, cb) {
    $http(_post(dataSrc)).then(function() {
      $log.info("SUCCESS: Feedback sent");
      return cb();
    }, function(err) {
      $log.info("ERROR: Feedback sent anyway.");
      return cb(err);
    });
  };

  var _post = function(dataSrc) {
    return {
      method: 'POST',
      url: URL,
      headers: {
        'content-type': 'application/x-www-form-urlencoded; charset=UTF-8'
      },
      data: $httpParamSerializer(dataSrc)
    };
  };

  root.isVersionUpdated = function(currentVersion, savedVersion) {

    if (!verifyTagFormat(currentVersion))
      return 'Cannot verify the format of version tag: ' + currentVersion;
    if (!verifyTagFormat(savedVersion))
      return 'Cannot verify the format of the saved version tag: ' + savedVersion;

    var current = formatTagNumber(currentVersion);
    var saved = formatTagNumber(savedVersion);
    if (saved.major > current.major || (saved.major == current.major && saved.minor > current.minor))
      return false;

    return true;

    function verifyTagFormat(tag) {
      var regex = /^v?\d+\.\d+\.\d+$/i;
      return regex.exec(tag);
    };

    function formatTagNumber(tag) {
      var formattedNumber = tag.replace(/^v/i, '').split('.');
      return {
        major: +formattedNumber[0],
        minor: +formattedNumber[1],
        patch: +formattedNumber[2]
      };
    };

  };

  return root;
});

'use strict';

angular.module('copayApp.services').factory('feeService', function($log, bwcService, configService, gettext, lodash, gettextCatalog) {
  var root = {};

  var CACHE_TIME_TS = 60; // 1 min

  // Constant fee options to translate
  root.feeOpts = {
    urgent: gettext('Urgent'),
    priority: gettext('Priority'),
    normal: gettext('Normal'),
    economy: gettext('Economy'),
    superEconomy: gettext('Super Economy'),
    custom: gettext('Custom')
  };

  var cache = {
    updateTs: 0,
    coin: ''
  };

  root.getCurrentFeeLevel = function() {
    return configService.getSync().wallet.settings.feeLevel || 'normal';
  };


  root.getFeeRate = function(coin, network, feeLevel, cb) {

    if (feeLevel == 'custom') return cb();

    network = network || 'livenet';

    root.getFeeLevels(coin, function(err, levels, fromCache) {
      if (err) return cb(err);

      var feeLevelRate = lodash.find(levels[network], {
        level: feeLevel
      });

      if (!feeLevelRate || !feeLevelRate.feePerKb) {
        return cb({
          message: gettextCatalog.getString("Could not get dynamic fee for level: {{feeLevel}}", {
            feeLevel: feeLevel
          })
        });
      }

      var feeRate = feeLevelRate.feePerKb;

      if (!fromCache) $log.debug('Dynamic fee: ' + feeLevel + '/' + network + ' ' + (feeLevelRate.feePerKb / 1000).toFixed() + ' SAT/B');

      return cb(null, feeRate);
    });
  };

  root.getCurrentFeeRate = function(coin, network, cb) {
    return root.getFeeRate(coin, network, root.getCurrentFeeLevel(), cb);
  };

  root.getFeeLevels = function(coin, cb) {
    coin = coin || 'btc';

    if (cache.coin == coin && cache.updateTs > Date.now() - CACHE_TIME_TS * 1000) {
      return cb(null, cache.data, true);
    }

    var walletClient = bwcService.getClient();

    walletClient.getFeeLevels(coin, 'livenet', function(errLivenet, levelsLivenet) {
      walletClient.getFeeLevels('btc', 'livenet', function(errTestnet, levelsTestnet) {
        if (errLivenet || errTestnet) {
          return cb(gettextCatalog.getString('Could not get dynamic fee'));
        }

        cache.updateTs = Date.now();
        cache.coin = coin;
        cache.data = {
          'livenet': levelsLivenet,
          'testnet': levelsTestnet
        };

        root.cachedFeeLevels = cache.data;

        return cb(null, cache.data);
      });
    });
  };

  // Fee levels (first start)
  root.cachedFeeLevels = {};
  root.getFeeLevels(null, function() {});

  return root;
});

'use strict';

angular.module('copayApp.services')
  .factory('fileStorageService', function(lodash, $log) {
    var root = {},
      _fs, _dir;

    root.init = function(cb) {
      if (_dir) return cb(null, _fs, _dir);

      function onFileSystemSuccess(fileSystem) {
        console.log('File system started: ', fileSystem.name, fileSystem.root.name);
        _fs = fileSystem;
        root.getDir(function(err, newDir) {
          if (err || !newDir.nativeURL) return cb(err);
          _dir = newDir
          $log.debug("Got main dir:", _dir.nativeURL);
          return cb(null, _fs, _dir);
        });
      }

      function fail(evt) {
        var msg = 'Could not init file system: ' + evt.target.error.code;
        console.log(msg);
        return cb(msg);
      };

      window.requestFileSystem(LocalFileSystem.PERSISTENT, 0, onFileSystemSuccess, fail);
    };

    root.get = function(k, cb) {
      root.init(function(err, fs, dir) {
        if (err) return cb(err);
        dir.getFile(k, {
          create: false,
        }, function(fileEntry) {
          if (!fileEntry) return cb();
          fileEntry.file(function(file) {
            var reader = new FileReader();

            reader.onloadend = function(e) {
              return cb(null, this.result)
            }

            reader.readAsText(file);
          });
        }, function(err) {
          // Not found
          if (err.code == 1) return cb();
          else return cb(err);
        });
      })
    };

    var writelock = {};

    root.set = function(k, v, cb, delay) {

      delay = delay || 100;

      if (writelock[k]) {
        return setTimeout(function() {
          console.log('## Writelock for:' + k + ' Retrying in ' + delay);
          return root.set(k, v, cb, delay + 100);
        }, delay);
      }

      writelock[k] = true;
      root.init(function(err, fs, dir) {
        if (err) {
          writelock[k] = false;
          return cb(err);
        }
        dir.getFile(k, {
          create: true,
        }, function(fileEntry) {
          // Create a FileWriter object for our FileEntry (log.txt).
          fileEntry.createWriter(function(fileWriter) {

            fileWriter.onwriteend = function(e) {
              console.log('Write completed:' + k);
              writelock[k] = false;
              return cb();
            };

            fileWriter.onerror = function(e) {
              var err = e.error ? e.error : JSON.stringify(e);
              console.log('Write failed: ' + err);
              writelock[k] = false;
              return cb('Fail to write:' + err);
            };

            if (lodash.isObject(v))
              v = JSON.stringify(v);

            if (v && !lodash.isString(v)) {
              v = v.toString();
            }

            $log.debug('Writing:', k, v);
            fileWriter.write(v);

          }, cb);
        });
      });
    };


    // See https://github.com/apache/cordova-plugin-file/#where-to-store-files
    root.getDir = function(cb) {
      if (!cordova.file) {
        return cb('Could not write on device storage');
      }

      var url = cordova.file.dataDirectory;
      // This could be needed for windows
      // if (cordova.file === undefined) {
      //   url = 'ms-appdata:///local/';
      window.resolveLocalFileSystemURL(url, function(dir) {
        return cb(null, dir);
      }, function(err) {
        $log.warn(err);
        return cb(err || 'Could not resolve filesystem:' + url);
      });
    };

    root.remove = function(k, cb) {
      root.init(function(err, fs, dir) {
        if (err) return cb(err);
        dir.getFile(k, {
          create: false,
        }, function(fileEntry) {
          // Create a FileWriter object for our FileEntry (log.txt).
          fileEntry.remove(function() {
            console.log('File removed.');
            return cb();
          }, cb);
        }, cb);
      });
    };

    /**
     * Same as setItem, but fails if an item already exists
     */
    root.create = function(name, value, callback) {
      root.get(name,
        function(err, data) {
          if (data) {
            return callback('EEXISTS');
          } else {
            return root.set(name, value, callback);
          }
        });
    };

    return root;
  });

'use strict';

angular.module('copayApp.services').factory('fingerprintService', function ($log, gettextCatalog, configService, platformInfo) {
  var root = {};

  var _isAvailable = false;

  if (platformInfo.isCordova && !platformInfo.isWP) {
    window.plugins.touchid = window.plugins.touchid || {};
    window.plugins.touchid.isAvailable(
      function (msg) {
        _isAvailable = 'IOS';
      },
      function (msg) {
        FingerprintAuth.isAvailable(function (result) {

          if (result.isAvailable)
            _isAvailable = 'ANDROID';

        }, function () {
          _isAvailable = false;
        });
      });
  };

  var requestFinger = function (cb) {
    try {
      FingerprintAuth.encrypt({
        clientId: 'Qyb'
      },
        function (result) {
          if (result.withFingerprint) {
            $log.debug('Finger OK');
            return cb();
          } else if (result.withPassword) {
            $log.debug("Finger: Authenticated with backup password");
            return cb();
          }
        },
        function (msg) {
          $log.debug('Finger Failed:' + JSON.stringify(msg));
          return cb(gettextCatalog.getString('Finger Scan Failed'));
        }
      );
    } catch (e) {
      $log.warn('Finger Scan Failed:' + JSON.stringify(e));
      return cb(gettextCatalog.getString('Finger Scan Failed'));
    };
  };


  var requestTouchId = function (cb) {
    try {
      window.plugins.touchid.verifyFingerprint(
        gettextCatalog.getString('Scan your fingerprint please'),
        function (msg) {
          $log.debug('Touch ID OK');
          return cb();
        },
        function (msg) {
          $log.debug('Touch ID Failed:' + JSON.stringify(msg));
          return cb(gettextCatalog.getString('Touch ID Failed'));
        }
      );
    } catch (e) {
      $log.debug('Touch ID Failed:' + JSON.stringify(e));
      return cb(gettextCatalog.getString('Touch ID Failed'));
    };
  };

  var isNeeded = function (client) {
    if (!_isAvailable) return false;
    if (client === 'unlockingApp') return true;

    var config = configService.getSync();
    config.touchIdFor = config.touchIdFor || {};

    return config.touchIdFor[client.credentials.walletId];
  };

  root.isAvailable = function (client) {
    return _isAvailable;
  };

  root.check = function (client, cb) {
    if (isNeeded(client)) {
      $log.debug('FingerPrint Service:', _isAvailable);
      if (_isAvailable == 'IOS')
        return requestTouchId(cb);
      else
        return requestFinger(cb);
    } else {
      return cb();
    }
  };

  return root;
});

'use strict';

angular.module('copayApp.services').factory('glideraService', function($http, $log, $window, $filter, platformInfo, storageService, buyAndSellService, lodash, configService, txFormatService) {
  var root = {};
  var credentials = {};
  var isCordova = platformInfo.isCordova;
  var isWindowsPhoneApp = platformInfo.isCordova && platformInfo.isWP;

  var setCredentials = function() {
    if (!$window.externalServices || !$window.externalServices.glidera) {
      return;
    }

    var glidera = $window.externalServices.glidera;

    /*
     * Development: 'testnet'
     * Production: 'livenet'
     */
    credentials.NETWORK = 'livenet';
    //credentials.NETWORK = 'testnet';

    if (credentials.NETWORK == 'testnet') {
      credentials.HOST = glidera.sandbox.host;
      if (isCordova) {
        credentials.REDIRECT_URI = glidera.sandbox.mobile.redirect_uri;
        credentials.CLIENT_ID = glidera.sandbox.mobile.client_id;
        credentials.CLIENT_SECRET = glidera.sandbox.mobile.client_secret;
      } else {
        credentials.REDIRECT_URI = glidera.sandbox.desktop.redirect_uri;
        credentials.CLIENT_ID = glidera.sandbox.desktop.client_id;
        credentials.CLIENT_SECRET = glidera.sandbox.desktop.client_secret;
      }
    } else {
      credentials.HOST = glidera.production.host;
      if (isCordova) {
        credentials.REDIRECT_URI = glidera.production.mobile.redirect_uri;
        credentials.CLIENT_ID = glidera.production.mobile.client_id;
        credentials.CLIENT_SECRET = glidera.production.mobile.client_secret;
      } else {
        credentials.REDIRECT_URI = glidera.production.desktop.redirect_uri;
        credentials.CLIENT_ID = glidera.production.desktop.client_id;
        credentials.CLIENT_SECRET = glidera.production.desktop.client_secret;
      }
    };
  };

  root.getNetwork = function() {
    return credentials.NETWORK;
  };

  root.getCurrency = function() {
    return 'USD';
  };

  root.getSignupUrl = function() {
    return credentials.HOST + '/register';
  }

  root.getSupportUrl = function() {
    return 'https://twitter.com/GlideraInc';
  }

  root.getOauthCodeUrl = function() {
    return credentials.HOST + '/oauth2/auth?response_type=code&client_id=' + credentials.CLIENT_ID + '&redirect_uri=' + credentials.REDIRECT_URI;
  };

  root.remove = function(cb) {
    storageService.removeGlideraToken(credentials.NETWORK, function() {
      storageService.removeGlideraPermissions(credentials.NETWORK, function() {
        storageService.removeGlideraStatus(credentials.NETWORK, function() {
          storageService.removeGlideraTxs(credentials.NETWORK, function() {
            buyAndSellService.updateLink('glidera', false);
            return cb();
          });
        });
      });
    });
  };

  root.getToken = function(code, cb) {
    var req = {
      method: 'POST',
      url: credentials.HOST + '/api/v1/oauth/token',
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json'
      },
      data: {
        grant_type: 'authorization_code',
        code: code,
        client_id: credentials.CLIENT_ID,
        client_secret: credentials.CLIENT_SECRET,
        redirect_uri: credentials.REDIRECT_URI
      }
    };

    $http(req).then(function(data) {
      $log.info('Glidera Authorization Access Token: SUCCESS');
      return cb(null, data.data);
    }, function(data) {
      $log.error('Glidera Authorization Access Token: ERROR ' + data.statusText);
      var message = data.data && data.data.message ? data.data.message : data.statusText;
      return cb(message);
    });
  };

  root.authorize = function(code, cb) {
    root.getToken(code, function(err, data) {
      if (err) return cb(err);
      if (data && !data.access_token) return cb('No access token');
      var accessToken = data.access_token;
      root.getAccessTokenPermissions(accessToken, function(err, p) {
        if (err) return cb(err);
        root.getStatus(accessToken, function(err, status) {
          if (err) $log.error(err);
          storageService.setGlideraToken(credentials.NETWORK, accessToken, function() {
            storageService.setGlideraPermissions(credentials.NETWORK, JSON.stringify(p), function() {
              storageService.setGlideraStatus(credentials.NETWORK, JSON.stringify(status), function() {
                return cb(null, {
                  token: accessToken,
                  permissions: p,
                  status: status
                });
              });
            });
          });
        });
      });
    });
  };

  var _get = function(endpoint, token) {
    return {
      method: 'GET',
      url: credentials.HOST + '/api/v1' + endpoint,
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
        'Authorization': 'Bearer ' + token
      }
    };
  };

  root.getAccessTokenPermissions = function(token, cb) {
    if (!token) return cb('Invalid Token');
    $http(_get('/oauth/token', token)).then(function(data) {
      $log.info('Glidera Access Token Permissions: SUCCESS');
      return cb(null, data.data);
    }, function(data) {
      var message = data.data && data.data.message ? data.data.message : data.statusText;
      $log.error('Glidera Access Token Permissions: ERROR ' + message);
      return cb(message);
    });
  };

  root.getEmail = function(token, cb) {
    if (!token) return cb('Invalid Token');
    $http(_get('/user/email', token)).then(function(data) {
      $log.info('Glidera Get Email: SUCCESS');
      return cb(null, data.data);
    }, function(data) {
      $log.error('Glidera Get Email: ERROR ' + data.statusText);
      var message = data.data && data.data.message ? data.data.message : data.statusText;
      return cb(message);
    });
  };

  root.getPersonalInfo = function(token, cb) {
    if (!token) return cb('Invalid Token');
    $http(_get('/user/personalinfo', token)).then(function(data) {
      $log.info('Glidera Get Personal Info: SUCCESS');
      return cb(null, data.data);
    }, function(data) {
      $log.error('Glidera Get Personal Info: ERROR ' + data.statusText);
      var message = data.data && data.data.message ? data.data.message : data.statusText;
      return cb(message);
    });
  };

  root.getStatus = function(token, cb) {
    if (!token) return cb('Invalid Token');
    $http(_get('/user/status', token)).then(function(data) {
      $log.info('Glidera User Status: SUCCESS');
      return cb(null, data.data);
    }, function(data) {
      $log.error('Glidera User Status: ERROR ' + data.statusText);
      var message = data.data && data.data.message ? data.data.message : data.statusText;
      return cb(message);
    });
  };

  root.getLimits = function(token, cb) {
    if (!token) return cb('Invalid Token');
    $http(_get('/user/limits', token)).then(function(data) {
      $log.info('Glidera Transaction Limits: SUCCESS');
      return cb(null, data.data);
    }, function(data) {
      $log.error('Glidera Transaction Limits: ERROR ' + data.statusText);
      var message = data.data && data.data.message ? data.data.message : data.statusText;
      return cb(message);
    });
  };

  root.getTransactions = function(token, cb) {
    if (!token) return cb('Invalid Token');
    $http(_get('/transaction', token)).then(function(data) {
      $log.info('Glidera Transactions: SUCCESS');
      return cb(null, data.data.transactions);
    }, function(data) {
      $log.error('Glidera Transactions: ERROR ' + data.statusText);
      var message = data.data && data.data.message ? data.data.message : data.statusText;
      return cb(message);
    });
  };

  root.getTransaction = function(token, txid, cb) {
    if (!token) return cb('Invalid Token');
    if (!txid) return cb('TxId required');
    $http(_get('/transaction/' + txid, token)).then(function(data) {
      $log.info('Glidera Transaction: SUCCESS');
      return cb(null, data.data);
    }, function(data) {
      $log.error('Glidera Transaction: ERROR ' + data.statusText);
      var message = data.data && data.data.message ? data.data.message : data.statusText;
      return cb(message);
    });
  };

  root.getSellAddress = function(token, cb) {
    if (!token) return cb('Invalid Token');
    $http(_get('/user/create_sell_address', token)).then(function(data) {
      $log.info('Glidera Create Sell Address: SUCCESS');
      return cb(null, data.data.sellAddress);
    }, function(data) {
      $log.error('Glidera Create Sell Address: ERROR ' + data.statusText);
      var message = data.data && data.data.message ? data.data.message : data.statusText;
      return cb(message);
    });
  };

  root.get2faCode = function(token, cb) {
    if (!token) return cb('Invalid Token');
    $http(_get('/authentication/get2faCode', token)).then(function(data) {
      $log.info('Glidera 2FA code: SUCCESS');
      return cb(null, data.data);
    }, function(data) {
      $log.error('Glidera 2FA code: ERROR ' + data.statusText);
      var message = data.data && data.data.message ? data.data.message : data.statusText;
      return cb(message);
    });
  };

  var _post = function(endpoint, token, twoFaCode, data) {
    return {
      method: 'POST',
      url: credentials.HOST + '/api/v1' + endpoint,
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
        'Authorization': 'Bearer ' + token,
        'X-2FA-CODE': twoFaCode
      },
      data: data
    };
  };

  root.sellPrice = function(token, price, cb) {
    var data = {
      qty: price.qty,
      fiat: price.fiat
    };
    $http(_post('/prices/sell', token, null, data)).then(function(data) {
      $log.info('Glidera Sell Price: SUCCESS');
      return cb(null, data.data);
    }, function(data) {
      $log.error('Glidera Sell Price: ERROR ' + data.statusText);
      var message = data.data && data.data.message ? data.data.message : data.statusText;
      return cb(message);
    });
  };

  root.sell = function(token, twoFaCode, data, cb) {
    var data = {
      refundAddress: data.refundAddress,
      signedTransaction: data.signedTransaction,
      priceUuid: data.priceUuid,
      useCurrentPrice: data.useCurrentPrice,
      ip: data.ip
    };
    $http(_post('/sell', token, twoFaCode, data)).then(function(data) {
      $log.info('Glidera Sell: SUCCESS');
      return cb(null, data.data);
    }, function(data) {
      $log.error('Glidera Sell Request: ERROR ' + data.statusText);
      var message = data.data && data.data.message ? data.data.message : data.statusText;
      return cb(message);
    });
  };

  root.buyPrice = function(token, price, cb) {
    var data = {
      qty: price.qty,
      fiat: price.fiat
    };
    $http(_post('/prices/buy', token, null, data)).then(function(data) {
      $log.info('Glidera Buy Price: SUCCESS');
      return cb(null, data.data);
    }, function(data) {
      $log.error('Glidera Buy Price: ERROR ' + data.statusText);
      var message = data.data && data.data.message ? data.data.message : data.statusText;
      return cb(message);
    });
  };

  root.buy = function(token, twoFaCode, data, cb) {
    var data = {
      destinationAddress: data.destinationAddress,
      qty: data.qty,
      priceUuid: data.priceUuid,
      useCurrentPrice: data.useCurrentPrice,
      ip: data.ip
    };
    $http(_post('/buy', token, twoFaCode, data)).then(function(data) {
      $log.info('Glidera Buy: SUCCESS');
      return cb(null, data.data);
    }, function(data) {
      $log.error('Glidera Buy Request: ERROR ' + data.statusText);
      var message = data.data && data.data.message ? data.data.message : data.statusText;
      return cb(message);
    });
  };

  var getPermissions = function(accessToken, network, force, cb) {
    storageService.getGlideraPermissions(network, function(err, permissions) {
      if (lodash.isString(permissions)) permissions = JSON.parse(permissions);
      if (force || lodash.isEmpty(permissions)) {
        root.getAccessTokenPermissions(accessToken, function(err, p) {
          if (err) {
            // Return error and remove token
            root.remove(function() {
              return cb(err);
            });
          } else {
            // Return permissions and store
            storageService.setGlideraPermissions(network, JSON.stringify(p), function() {
              return cb(null, p);
            });
          }
        });
      } else {
        return cb(null, permissions);
      }
    });
  };

  root.init = function(cb) {
    if (lodash.isEmpty(credentials.CLIENT_ID)) {
      return cb('Glidera is Disabled');
    }
    $log.debug('Trying to initialise Glidera...');

    storageService.getGlideraToken(credentials.NETWORK, function(err, accessToken) {
      if (lodash.isEmpty(accessToken)) return cb();

      getPermissions(accessToken, credentials.NETWORK, true, function(err, permissions) {
        if (err) return cb(err);

        storageService.getGlideraStatus(credentials.NETWORK, function(err, status) {
          if (lodash.isString(status)) status = JSON.parse(status);
          storageService.getGlideraTxs(credentials.NETWORK, function(err, txs) {
            if (lodash.isString(txs)) txs = JSON.parse(txs);
            buyAndSellService.updateLink('glidera', true);
            return cb(null, {
              token: accessToken,
              permissions: permissions,
              status: status,
              txs: txs
            });
          });
        });
      });
    });
  };

  root.updateStatus = function(data) {
    storageService.getGlideraToken(credentials.NETWORK, function(err, accessToken) {
      if (err) return;

      getPermissions(accessToken, credentials.NETWORK, false, function(err, permissions) {
        if (err) return;
        data.permissions = permissions;

        data.price = {};
        root.buyPrice(accessToken, {
          qty: 1
        }, function(err, buy) {
          if (err) return;
          data.price['buy'] = buy.price;
        });
        root.sellPrice(accessToken, {
          qty: 1
        }, function(err, sell) {
          if (err) return;
          data.price['sell'] = sell.price;
        });

        root.getStatus(accessToken, function(err, status) {
          if (err) return;
          data.status = status;
          storageService.setGlideraStatus(credentials.NETWORK, JSON.stringify(status), function() {});
        });

        root.getLimits(accessToken, function(err, limits) {
          data.limits = limits;
        });

        if (permissions.transaction_history) {
          root.getTransactions(accessToken, function(err, txs) {
            if (err) return;
            storageService.setGlideraTxs(credentials.NETWORK, JSON.stringify(txs), function() {});
            data.txs = txs;
          });
        }

        if (permissions.view_email_address) {
          root.getEmail(accessToken, function(err, email) {
            if (err) return;
            data.email = email;
          });
        }
        if (permissions.personal_info) {
          root.getPersonalInfo(accessToken, function(err, info) {
            if (err) return;
            data.personalInfo = info;
          });
        }
      });
    });
  };

  var register = function() {
    if (isWindowsPhoneApp) return;

    storageService.getGlideraToken(credentials.NETWORK, function(err, token) {
      if (err) return cb(err);

      buyAndSellService.register({
        name: 'glidera',
        logo: 'img/glidera-logo.png',
        location: 'US Only',
        sref: 'tabs.buyandsell.glidera',
        configSref: 'tabs.preferences.glidera',
        linked: !!token,
      });
    });
  };

  setCredentials();
  register();
  return root;
});

'use strict';
var logs = [];
angular.module('copayApp.services')
  .factory('historicLog', function historicLog(lodash) {
    var root = {};

    var levels = [
      { level: 'error', weight: 0, label: 'Error'},
      { level: 'warn',  weight: 1, label: 'Warning'},
      { level: 'info',  weight: 2, label: 'Info', default: true},
      { level: 'debug', weight: 3, label: 'Debug'}
    ];

    // Create an array of level weights for performant filtering.
    var weight = {};
    for (var i = 0; i < levels.length; i++) {
      weight[levels[i].level] = levels[i].weight;
    }

    root.getLevels = function() {
      return levels;
    };

    root.getLevel = function(level) {
      return lodash.find(levels, function(l) {
        return l.level == level;
      });
    };

    root.getDefaultLevel = function() {
      return lodash.find(levels, function(l) {
        return l.default;
      });
    };

    root.add = function(level, msg) {
      msg = msg.replace('/xpriv.*/', 'xpriv[Hidden]');
      logs.push({
        timestamp: new Date().toISOString(),
        level: level,
        msg: msg,
      });
    };

    root.get = function(filterWeight) {
      var filteredLogs = logs;
      if (filterWeight != undefined) {
        filteredLogs = lodash.filter(logs, function(l) {
          return weight[l.level] <= filterWeight;
        });
      }
      return filteredLogs;
    };

    return root;
  });

 'use strict';
 angular.module('copayApp.services').factory('homeIntegrationsService', function(lodash, configService, $log) {
   var root = {};
   var services = [];

   root.register = function(serviceInfo) {
     // Check if already exists
     if (lodash.find(services, { 'name': serviceInfo.name })) return;
     $log.info('Adding home Integrations entry:' + serviceInfo.name);
     services.push(serviceInfo);
   };

   root.unregister = function(serviceName) {
     services = lodash.filter(services, function(x) {
       return x.name != serviceName
     });
   };

   root.get = function() {
     return services;
   };

   return root;

 });

'use strict';

angular.module('copayApp.services')
  .factory('hwWallet', function($log, bwcService) {
    var root = {};

    // Ledger magic number to get xPub without user confirmation
    root.ENTROPY_INDEX_PATH = "0xb11e/";
    root.M = 'm/';
    root.UNISIG_ROOTPATH = 44;
    root.MULTISIG_ROOTPATH = 48;
    root.LIVENET_PATH = 0;
    root.TESTNET_PATH = 1;

    root._err = function(data) {
      var msg = data.error || data.message || 'unknown';
      return msg;
    };


    root.getRootPath = function(device, isMultisig, account) {
      var path;
      if (isMultisig) {
        path = root.MULTISIG_ROOTPATH;
      } else {
        if (device == 'ledger' && account > 0) {
          path = root.MULTISIG_ROOTPATH;
        } else {
          path = root.UNISIG_ROOTPATH;
        }
      }
      if (device == 'intelTEE') {
        path = root.M + path;
      }
      return path;
    };

    root.getAddressPath = function(device, isMultisig, account, network) {
      network = network || 'livenet';
      var networkPath = root.LIVENET_PATH;
      if (network == 'testnet') {
        networkPath = root.TESTNET_PATH;
      }
      return root.getRootPath(device, isMultisig, account) + "'/" + networkPath + "'/" + account + "'";
     };

    root.getEntropyPath = function(device, isMultisig, account) {
      var path = root.ENTROPY_INDEX_PATH;
      if (isMultisig) {
        path = path + "48'/"
      } else {
        path = path + "44'/"
      }

      // Old ledger wallet compat
      if (device == 'ledger' && account == 0) {
        return path + "0'/";
      }

      if (device == 'intelTEE') {
        path = root.M + path;
      }

      return path + account + "'";
    };

    root.pubKeyToEntropySource = function(xPubKey) {
      var b = bwcService.getBitcore();
      var x = b.HDPublicKey(xPubKey);
      return x.publicKey.toString();
    };

    return root;
  });

'use strict';

angular.module('copayApp.services').factory('incomingData', function($log, $state, $timeout, $ionicHistory, bitcore, bitcoreCash, $rootScope, payproService, scannerService, appConfigService, popupService, gettextCatalog) {

  var root = {};

  root.showMenu = function(data) {
    $rootScope.$broadcast('incomingDataMenu.showMenu', data);
  };

  root.redir = function(data) {
    $log.debug('Processing incoming data: ' + data);

    function sanitizeUri(data) {
      // Fixes when a region uses comma to separate decimals
      var regex = /[\?\&]amount=(\d+([\,\.]\d+)?)/i;
      var match = regex.exec(data);
      if (!match || match.length === 0) {
        return data;
      }
      var value = match[0].replace(',', '.');
      var newUri = data.replace(regex, value);

      // mobile devices, uris like qyb://glidera
      newUri.replace('://', ':');

      return newUri;
    }

    function getParameterByName(name, url) {
      if (!url) return;
      name = name.replace(/[\[\]]/g, "\\$&");
      var regex = new RegExp("[?&]" + name + "(=([^&#]*)|&|#|$)"),
        results = regex.exec(url);
      if (!results) return null;
      if (!results[2]) return '';
      return decodeURIComponent(results[2].replace(/\+/g, " "));
    }

    function checkPrivateKey(privateKey) {
      try {
        new bitcore.PrivateKey(privateKey, 'livenet');
      } catch (err) {
        return false;
      }
      return true;
    }

    function goSend(addr, amount, message, coin) {
      $state.go('tabs.send', {}, {
        'reload': true,
        'notify': $state.current.name == 'tabs.send' ? false : true
      });
      // Timeout is required to enable the "Back" button
      $timeout(function() {
        if (amount) {
          $state.transitionTo('tabs.send.confirm', {
            toAmount: amount,
            toAddress: addr,
            description: message,
            coin: coin
          });
        } else {
          $state.transitionTo('tabs.send.amount', {
            toAddress: addr,
            coin: coin
          });
        }
      }, 100);
    }
    // data extensions for Payment Protocol with non-backwards-compatible request
    // @empty modify to qybcoin
    // if ((/^bitcoin(cash)?:\?r=[\w+]/).exec(data)) {
    if ((/^qybcoin(cash)?:\?r=[\w+]/).exec(data)) {
      var coin = 'btc';
      if (data.indexOf('bitcoincash') === 0) coin = 'bch';
      // @empty modify data = decodeURIComponent(data.replace(/bitcoin(cash)?:\?r=/, ''));
      data = decodeURIComponent(data.replace(/qybcoin(cash)?:\?r=/, ''));

      payproService.getPayProDetails(data, function(err, details) {
        if (err) {
          popupService.showAlert(gettextCatalog.getString('Error'), err);
        } else handlePayPro(details, coin);
      });

      return true;
    }

    data = sanitizeUri(data);

    // Qybcoin  URL
    if (bitcore.URI.isValid(data)) {
        var coin = 'btc';
        var parsed = new bitcore.URI(data);

        var addr = parsed.address ? parsed.address.toString() : '';
        var message = parsed.message;

        var amount = parsed.amount ? parsed.amount : '';

        if (parsed.r) {
          payproService.getPayProDetails(parsed.r, function(err, details) {
            if (err) {
              if (addr && amount) goSend(addr, amount, message, coin);
              else popupService.showAlert(gettextCatalog.getString('Error'), err);
            } else handlePayPro(details);
          });
        } else {
          goSend(addr, amount, message, coin);
        }
        return true;
    // Cash URI
    } else if (bitcoreCash.URI.isValid(data)) {
        var coin = 'bch';
        var parsed = new bitcoreCash.URI(data);

        var addr = parsed.address ? parsed.address.toString() : '';
        var message = parsed.message;

        var amount = parsed.amount ? parsed.amount : '';

        // paypro not yet supported on cash
        if (parsed.r) {
          payproService.getPayProDetails(parsed.r, function(err, details) {
            if (err) {
              if (addr && amount)
                goSend(addr, amount, message, coin);
              else
                popupService.showAlert(gettextCatalog.getString('Error'), err);
            }
            handlePayPro(details, coin);
          });
        } else {
          goSend(addr, amount, message, coin);
        }
        return true;

    // Cash URI with bitcoin core address version number?
    } else if (bitcore.URI.isValid(data.replace(/^bitcoincash:/,'bitcoin:'))) {
        $log.debug('Handling bitcoincash URI with legacy address');
        var coin = 'bch';
        var parsed = new bitcore.URI(data.replace(/^bitcoincash:/,'bitcoin:'));

        var oldAddr = parsed.address ? parsed.address.toString() : '';
        if (!oldAddr) return false;

        var addr = '';

        var a = bitcore.Address(oldAddr).toObject();
        addr = bitcoreCash.Address.fromObject(a).toString();

        // Translate address
        $log.debug('address transalated to:' + addr);
        popupService.showConfirm(
          gettextCatalog.getString('Qybcoin cash Payment'),
          gettextCatalog.getString('Payment address was translated to new Qybcoin Cash address format: ' + addr),
          gettextCatalog.getString('OK'),
          gettextCatalog.getString('Cancel'),
          function(ret) {
            if (!ret) return false;

            var message = parsed.message;
            var amount = parsed.amount ? parsed.amount : '';

            // paypro not yet supported on cash
            if (parsed.r) {
              payproService.getPayProDetails(parsed.r, function(err, details) {
                if (err) {
                  if (addr && amount)
                    goSend(addr, amount, message, coin);
                  else
                    popupService.showAlert(gettextCatalog.getString('Error'), err);
                }
                handlePayPro(details, coin);
              });
            } else {
              goSend(addr, amount, message, coin);
            }
          }
        );
      return true;
      // Plain URL
    } else if (/^https?:\/\//.test(data)) {

      payproService.getPayProDetails(data, function(err, details) {
        if (err) {
          root.showMenu({
            data: data,
            type: 'url'
          });
          return;
        }
        handlePayPro(details);
        return true;
      });
      // Plain Address
    } else if (bitcore.Address.isValid(data, 'livenet') || bitcore.Address.isValid(data, 'testnet')) {
      if ($state.includes('tabs.scan')) {
        root.showMenu({
          data: data,
          type: 'bitcoinAddress'
        });
      } else {
        goToAmountPage(data);
      }
    } else if (bitcoreCash.Address.isValid(data, 'livenet')) {
      if ($state.includes('tabs.scan')) {
        root.showMenu({
          data: data,
          type: 'bitcoinAddress',
          coin: 'bch',
        });
      } else {
        goToAmountPage(data, 'bch');
      }
    } else if (data && data.indexOf(appConfigService.name + '://glidera') === 0) {
      var code = getParameterByName('code', data);
      $ionicHistory.nextViewOptions({
        disableAnimate: true
      });
      $state.go('tabs.home', {}, {
        'reload': true,
        'notify': $state.current.name == 'tabs.home' ? false : true
      }).then(function() {
        $ionicHistory.nextViewOptions({
          disableAnimate: true
        });
        $state.transitionTo('tabs.buyandsell.glidera', {
          code: code
        });
      });
      return true;

    } else if (data && data.indexOf(appConfigService.name + '://coinbase') === 0) {
      var code = getParameterByName('code', data);
      $ionicHistory.nextViewOptions({
        disableAnimate: true
      });
      $state.go('tabs.home', {}, {
        'reload': true,
        'notify': $state.current.name == 'tabs.home' ? false : true
      }).then(function() {
        $ionicHistory.nextViewOptions({
          disableAnimate: true
        });
        $state.transitionTo('tabs.buyandsell.coinbase', {
          code: code
        });
      });
      return true;

      // BitPayCard Authentication
    } else if (data && data.indexOf(appConfigService.name + '://') === 0) {

      // Disable BitPay Card
      if (!appConfigService._enabledExtensions.debitcard) return false;

      var secret = getParameterByName('secret', data);
      var email = getParameterByName('email', data);
      var otp = getParameterByName('otp', data);
      var reason = getParameterByName('r', data);

      $state.go('tabs.home', {}, {
        'reload': true,
        'notify': $state.current.name == 'tabs.home' ? false : true
      }).then(function() {
        switch (reason) {
          default:
            case '0':
            /* For BitPay card binding */
            $state.transitionTo('tabs.bitpayCardIntro', {
              secret: secret,
              email: email,
              otp: otp
            });
          break;
        }
      });
      return true;

      // Join
    } else if (data && data.match(/^qybcoin:[0-9A-HJ-NP-Za-km-z]{70,80}$/)) {
      $state.go('tabs.home', {}, {
        'reload': true,
        'notify': $state.current.name == 'tabs.home' ? false : true
      }).then(function() {
        $state.transitionTo('tabs.add.join', {
          url: data
        });
      });
      return true;

      // Old join
    } else if (data && data.match(/^[0-9A-HJ-NP-Za-km-z]{70,80}$/)) {
      $state.go('tabs.home', {}, {
        'reload': true,
        'notify': $state.current.name == 'tabs.home' ? false : true
      }).then(function() {
        $state.transitionTo('tabs.add.join', {
          url: data
        });
      });
      return true;
    } else if (data && (data.substring(0, 2) == '6P' || checkPrivateKey(data))) {
      root.showMenu({
        data: data,
        type: 'privateKey'
      });
    } else if (data && ((data.substring(0, 2) == '1|') || (data.substring(0, 2) == '2|') || (data.substring(0, 2) == '3|'))) {
      $state.go('tabs.home').then(function() {
        $state.transitionTo('tabs.add.import', {
          code: data
        });
      });
      return true;

    } else {
      if ($state.includes('tabs.scan')) {
        root.showMenu({
          data: data,
          type: 'text'
        });
      }
    }
    return false;
  };

  function goToAmountPage(toAddress, coin) {
    $state.go('tabs.send', {}, {
      'reload': true,
      'notify': $state.current.name == 'tabs.send' ? false : true
    });
    $timeout(function() {
      $state.transitionTo('tabs.send.amount', {
        toAddress: toAddress,
        coin: coin,
      });
    }, 100);
  }

  function handlePayPro(payProDetails, coin) {
    var stateParams = {
      toAmount: payProDetails.amount,
      toAddress: payProDetails.toAddress,
      description: payProDetails.memo,
      paypro: payProDetails,
      coin: coin,
    };
    scannerService.pausePreview();
    $state.go('tabs.send', {}, {
      'reload': true,
      'notify': $state.current.name == 'tabs.send' ? false : true
    }).then(function() {
      $timeout(function() {
        $state.transitionTo('tabs.send.confirm', stateParams);
      });
    });
  }

  return root;
});

'use strict';

angular.module('copayApp.services')
  .factory('intelTEE', function($log, $timeout, gettext, lodash, bitcore, hwWallet, bwcService, platformInfo) {

    var root = {};

    root.description = {
      supported: platformInfo.supportsIntelTEE,
      version: platformInfo.versionIntelTEE,
      id: 'intelTEE',
      name: 'Intel TEE',
      longName: 'Intel TEE Hardware Wallet',
      derivationStrategy: 'BIP44',
      isEmbeddedHardware: true,
      supportsTestnet: true
    };

    if (!root.description.supported) {
      return root;
    }

    var IntelWallet = require('intelWalletCon');
    var TEE_APP_ID = '63279de1b6cb4dcf8c206716bd318092f8c206716bd31809263279de1b6cb4dc';

    root.walletEnclave = new IntelWallet.Wallet();
    var walletEnclaveStatus = root.walletEnclave.initializeEnclave();
    if (walletEnclaveStatus != 0) {
      $log.error('Failed to create Intel Wallet enclave');
    }

    root.getInfoForNewWallet = function(isMultisig, account, networkName, callback) {
      var opts = {};
      initSource(opts, function(err, opts) {
        if (err) return callback(err);

        root.getEntropySource(opts.hwInfo.id, isMultisig, account, function(err, entropySource) {
          if (err) return callback(err);

          opts.entropySource = entropySource;
          root.getXPubKey(opts.hwInfo.id, hwWallet.getAddressPath(root.description.id, isMultisig, account, networkName), function(data) {
            if (!data.success) {
              $log.warn(data.message);
              return callback(data);
            }
            opts.extendedPublicKey = data.xpubkey;
            opts.externalSource = root.description.id;
            opts.derivationStrategy = root.description.derivationStrategy;

            return callback(null, opts);
          });
        });
      });
    };

    root.getXPubKey = function(teeWalletId, path, callback) {
      $log.debug('TEE deriving xPub path:', path);

      // Expected to be a extended public key.
      var xpubkey = root.walletEnclave.getPublicKey(teeWalletId, path);

      // Error messages returned in value.
      var result = {
        success: false,
        message: xpubkey.ExtendedPublicKey
      };

      // Success indicated by status being equal to the tee wallet id.
      if (xpubkey.Status == teeWalletId) {
        result.success = true;
        result.message = 'OK';
        result.xpubkey = xpubkey.ExtendedPublicKey;
      } else {
        $log.error('Failed to get xpubkey from TEE wallet: ' + result.message);
      }

      callback(result);
    };

    root.getEntropySource = function(teeWalletId, isMultisig, account, callback) {
      root.getXPubKey(teeWalletId, hwWallet.getEntropyPath(root.description.id, isMultisig, account), function(data) {
        if (!data.success)
          return callback(hwWallet._err(data));

        return callback(null,  hwWallet.pubKeyToEntropySource(data.xpubkey));
      });
    };

    root.showMneumonic = function(teeWalletId, cb) {
      var result = root.walletEnclave.displayWordList(teeWalletId, 'en');
      if (result != teeWalletId) {
        cb(result);
      } else {
        cb();
      }
    };

    root.showReceiveAddress = function(teeWalletId, address, cb) {
      var isMultisig = false; // TODO
      var account = 0; // TODO
      var basePath = hwWallet.getAddressPath(root.description.id, isMultisig, account, address.network);
      var keyPath = address.path.replace('m', basePath);

      var result = root.walletEnclave.displayReceiveAddress(teeWalletId, keyPath);
      if (result != teeWalletId) {
        cb(result);
      } else {
        cb();
      }
    };

    root.signTx = function(teeWalletId, txp, callback) {
      var account = 0; // TODO
      var isMultisig = txp.requiredSignatures > 1;
      var basePath = hwWallet.getAddressPath(root.description.id, isMultisig, account, txp.network);

      var rawTx = bwcService.Client.getRawTx(txp);
      var keypaths = lodash.map(lodash.pluck(txp.inputs, 'path'), function(path) {
        return path.replace('m', basePath);
      });
      var publicKeys = lodash.pluck(txp.inputs, 'publicKeys');
      var changePublicKeys = txp.changeAddress.publicKeys;
      publicKeys.push(changePublicKeys);
      
      var changeaddrpath;
      if (txp.changeAddress) {
        changeaddrpath = txp.changeAddress.path.replace('m', basePath);
      }

      var result;
      if (txp.requiredSignatures == 1) {
        result = root.walletEnclave.signTransaction(teeWalletId, rawTx, changeaddrpath, keypaths);
      } else {
        result = root.walletEnclave.signTransaction(teeWalletId, rawTx, changeaddrpath, keypaths, publicKeys, txp.requiredSignatures, changePublicKeys, txp.requiredSignatures);
      }

      if (result.Status != teeWalletId) {
        return callback('TEE failed to sign transction: ' + result.Status);
      }
      return callback(null, result);
    };

    function initSource(opts, callback) {
        var args = {
          "Testnet" : (opts.networkName == 'livenet'? false : true),
          "PINUnlockRequired" : false,
          "PINSignatureDataRequired" : false,
          "PINSignatureTransaction" : 0,
          "ExportCount" : 10,
          "MaxPINAttempts" : 3,
          "PINTimeout" : 30
        };

        var teeStatus = root.walletEnclave.createWallet(TEE_APP_ID, args);
        switch (teeStatus) {
          case "CREATE WALLET FAILURE":
          case "CREATE WALLET FAILED TO INITIALIZE":
          case "CREATE WALLET FAILURE BAD INPUT":
          case "CREATE WALLET FAILURE case SERIALIZATION":
          case "DELETE_WALLET_AUTHORIZATION_UNSUCCESSFUL":
          case "LOAD_WALLET_FAILTURE":
          case "IMPORT WORD LIST FAILTURE":
          case "IMPORT WORD LIST FAILURE BAD INPUT":
          case "IMPORT WORD NOT IN DICTIONARY":
          case "INVALID PIN":
          case "INVALID APPLICATION ID":
          case "DISPLAY WORD LIST FAILURE":
          case "DELETE WALLET NO SUCH APPLICATION ID":
          case "SIGN DATA FAILURE":
          case "SIGN DATA INVALID HASH":
          case "SIGN DATA BUFFER TOO SMALL":
          case "SIGN DATA INVALID PIN":
          case "RECEIVE ADDRESS INVALID INPUT":
          case "RECEIVE ADDRESS NULL":
          case "RECEIVE ADDRESS BUFFER TOO SMALL":
          case "PUBLIC KEY BUFFER TOO SMALL":
          case "LOAD WALLET FAILURE":
          case "PUBLIC KEY FAILURE":
          case "PUBLIC KEY FAIL TO SERIALIZE":
          case "UKNOWN ERROR CODE":
            $log.error(teeStatus);
            return callback(teeStatus); // TODO: translate error text for display
            break;
          default:
            opts.hwInfo = {
              name: root.description.id,
              id: teeStatus
            };
            $log.debug('TEE wallet created: ' + opts.hwInfo.id);
            return callback(null, opts);
        }
    };

    return root;
});
'use strict';
angular.module('copayApp.services')
  .factory('latestReleaseService', function latestReleaseServiceFactory($log, $http, configService) {

    var root = {};

    root.checkLatestRelease = function(cb) {
      var releaseURL = configService.getDefaults().release.url;

      requestLatestRelease(releaseURL, function(err, release) {
        if (err) return cb(err);
        var currentVersion = window.version;
        var latestVersion = release.data.tag_name;

        if (!verifyTagFormat(currentVersion))
          return cb('Cannot verify the format of version tag: ' + currentVersion);
        if (!verifyTagFormat(latestVersion))
          return cb('Cannot verify the format of latest release tag: ' + latestVersion);

        var current = formatTagNumber(currentVersion);
        var latest = formatTagNumber(latestVersion);

        if (latest.major < current.major || (latest.major == current.major && latest.minor <= current.minor))
          return cb(null, false);

        $log.debug('A new version is available: ' + latestVersion);
        return cb(null, true);
      });

      function verifyTagFormat(tag) {
        var regex = /^v?\d+\.\d+\.\d+$/i;
        return regex.exec(tag);
      };

      function formatTagNumber(tag) {
        var formattedNumber = tag.replace(/^v/i, '').split('.');
        return {
          major: +formattedNumber[0],
          minor: +formattedNumber[1],
          patch: +formattedNumber[2]
        };
      };
    };

    function requestLatestRelease(releaseURL, cb) {
      $log.debug('Retrieving latest relsease information...');

      var request = {
        url: releaseURL,
        method: 'GET',
        json: true
      };

      $http(request).then(function(release) {
        $log.debug('Latest release: ' + release.data.name);
        return cb(null, release);
      }, function(err) {
        return cb('Cannot get the release information: ' + err);
      });
    };

    return root;
  });

'use strict';

angular.module('copayApp.services')
  .factory('ledger', function($log, bwcService, gettext, hwWallet, platformInfo) {
    var root = {};
    var LEDGER_CHROME_ID = "kkdpmhnladdopljabkgpacgpliggeeaf";

    root.description = {
      supported: platformInfo.supportsLedger,
      id: 'ledger',
      name: 'Ledger',
      longName: 'Ledger Hardware Wallet',
      isEmbeddedHardware: false,
      supportsTestnet: false
    };

    root.callbacks = {};
    root.hasSession = function() {
      root._message({
        command: "has_session"
      });
    }

    root.getEntropySource = function(isMultisig, account, callback) {
      root.getXPubKey(hwWallet.getEntropyPath(root.description.id, isMultisig, account), function(data) {
        if (!data.success)
          return callback(hwWallet._err(data));

        return callback(null, hwWallet.pubKeyToEntropySource(data.xpubkey));
      });
    };

    root.getXPubKey = function(path, callback) {
      $log.debug('Ledger deriving xPub path:', path);
      root.callbacks["get_xpubkey"] = callback;
      root._messageAfterSession({
        command: "get_xpubkey",
        path: path
      });
    };

    root.initSource = function(opts, callback) {
      // No initialization for this hardware source.
      return callback(opts);
    };

    root.getInfoForNewWallet = function(isMultisig, account, networkName, callback) {
      // networkName not used for this hardware (always livenet)
      root.getEntropySource(isMultisig, account, function(err, entropySource) {
        if (err) return callback(err);

        var opts = {};
        opts.entropySource = entropySource;
        root.getXPubKey(hwWallet.getAddressPath(root.description.id, isMultisig, account), function(data) {
          if (!data.success) {
            $log.warn(data.message);
            return callback(data);
          }
          opts.extendedPublicKey = data.xpubkey;
          opts.externalSource = root.description.id;

          // Old ledger compat
          opts.derivationStrategy = opts.account ? 'BIP48' : 'BIP44';
          return callback(null, opts);
        });
      });
    };

    root._signP2SH = function(txp, account, isMultisig, callback) {
      root.callbacks["sign_p2sh"] = callback;
      var redeemScripts = [];
      var paths = [];
      var tx = bwcService.getUtils().buildTx(txp);
      for (var i = 0; i < tx.inputs.length; i++) {
        redeemScripts.push(new ByteString(tx.inputs[i].redeemScript.toBuffer().toString('hex'), GP.HEX).toString());
        paths.push(hwWallet.getAddressPath(root.description.id, isMultisig, account) + txp.inputs[i].path.substring(1));
      }
      var splitTransaction = root._splitTransaction(new ByteString(tx.toString(), GP.HEX));
      var inputs = [];
      for (var i = 0; i < splitTransaction.inputs.length; i++) {
        var input = splitTransaction.inputs[i];
        inputs.push([
          root._reverseBytestring(input.prevout.bytes(0, 32)).toString(),
          root._reverseBytestring(input.prevout.bytes(32)).toString()
        ]);
      }
      $log.debug('Ledger signing  paths:', paths);
      root._messageAfterSession({
        command: "sign_p2sh",
        inputs: inputs,
        scripts: redeemScripts,
        outputs_number: splitTransaction.outputs.length,
        outputs_script: splitTransaction.outputScript.toString(),
        paths: paths
      });
    };

    root.signTx = function(txp, account, callback) {

      // TODO Compat
      var isMultisig = true;
      if (txp.addressType == 'P2PKH') {
        var msg = 'P2PKH wallets are not supported with ledger';
        $log.error(msg);
        return callback(msg);
      } else {
        root._signP2SH(txp, account, isMultisig, callback);
      }
    }

    root._message = function(data) {
      chrome.runtime.sendMessage(
        LEDGER_CHROME_ID, {
          request: data
        },
        function(response) {
          root._callback(response);
        }
      );
    }

    root._messageAfterSession = function(data) {
      root._after_session = data;
      root._message({
        command: "launch"
      });
      root._should_poll_session = true;
      root._do_poll_session();
    }

    root._do_poll_session = function() {
      root.hasSession();
      if (root._should_poll_session) {
        setTimeout(root._do_poll_session, 500);
      }
    }

    root._callback = function(data) {
      if (typeof data == "object") {
        if (data.command == "has_session" && data.success) {
          root._message(root._after_session);
          root._after_session = null;
          root._should_poll_session = false;
        } else if (typeof root.callbacks[data.command] == "function") {
          root.callbacks[data.command](data);
        } else {}
      } else {
        root._should_poll_session = false;
        Object.keys(root.callbacks).forEach(function(key) {
          root.callbacks[key]({
            success: false,
            message: gettext("The Ledger Chrome application is not installed"),
          });
        });
      }
    }

    root._splitTransaction = function(transaction) {
      var result = {};
      var inputs = [];
      var outputs = [];
      var offset = 0;
      var version = transaction.bytes(offset, 4);
      offset += 4;
      var varint = root._getVarint(transaction, offset);
      var numberInputs = varint[0];
      offset += varint[1];
      for (var i = 0; i < numberInputs; i++) {
        var input = {};
        input['prevout'] = transaction.bytes(offset, 36);
        offset += 36;
        varint = root._getVarint(transaction, offset);
        offset += varint[1];
        input['script'] = transaction.bytes(offset, varint[0]);
        offset += varint[0];
        input['sequence'] = transaction.bytes(offset, 4);
        offset += 4;
        inputs.push(input);
      }
      varint = root._getVarint(transaction, offset);
      var numberOutputs = varint[0];
      offset += varint[1];
      var outputStartOffset = offset;
      for (var i = 0; i < numberOutputs; i++) {
        var output = {};
        output['amount'] = transaction.bytes(offset, 8);
        offset += 8;
        varint = root._getVarint(transaction, offset);
        offset += varint[1];
        output['script'] = transaction.bytes(offset, varint[0]);
        offset += varint[0];
        outputs.push(output);
      }
      var locktime = transaction.bytes(offset, 4);
      result['version'] = version;
      result['inputs'] = inputs;
      result['outputs'] = outputs;
      result['locktime'] = locktime;
      result['outputScript'] = transaction.bytes(outputStartOffset, offset - outputStartOffset);
      return result;
    }

    root._getVarint = function(data, offset) {
      if (data.byteAt(offset) < 0xfd) {
        return [data.byteAt(offset), 1];
      }
      if (data.byteAt(offset) == 0xfd) {
        return [((data.byteAt(offset + 2) << 8) + data.byteAt(offset + 1)), 3];
      }
      if (data.byteAt(offset) == 0xfe) {
        return [((data.byteAt(offset + 4) << 24) + (data.byteAt(offset + 3) << 16) +
          (data.byteAt(offset + 2) << 8) + data.byteAt(offset + 1)), 5];
      }
    }

    root._reverseBytestring = function(x) {
      var res = "";
      for (var i = x.length - 1; i >= 0; i--) {
        res += Convert.toHexByte(x.byteAt(i));
      }
      return new ByteString(res, GP.HEX);
    }

    return root;
  });

var Convert = {};

/**
 * Convert a binary string to his hexadecimal representation
 * @param {String} src binary string
 * @static
 * @returns {String} hexadecimal representation
 */
Convert.stringToHex = function(src) {
  var r = "";
  var hexes = new Array("0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f");
  for (var i = 0; i < src.length; i++) {
    r += hexes[src.charCodeAt(i) >> 4] + hexes[src.charCodeAt(i) & 0xf];
  }
  return r;
}

/**
 * Convert an hexadecimal string to its binary representation
 * @param {String} src hexadecimal string
 * @static
 * @return {Array} byte array
 * @throws {InvalidString} if the string isn't properly formatted
 */
Convert.hexToBin = function(src) {
  var result = "";
  var digits = "0123456789ABCDEF";
  if ((src.length % 2) != 0) {
    throw "Invalid string";
  }
  src = src.toUpperCase();
  for (var i = 0; i < src.length; i += 2) {
    var x1 = digits.indexOf(src.charAt(i));
    if (x1 < 0) {
      return "";
    }
    var x2 = digits.indexOf(src.charAt(i + 1));
    if (x2 < 0) {
      return "";
    }
    result += String.fromCharCode((x1 << 4) + x2);
  }
  return result;
}

/**
 * Convert a double digit hexadecimal number to an integer
 * @static
 * @param {String} data buffer containing the digit to parse
 * @param {Number} offset offset to the digit (default is 0)
 * @returns {Number} converted digit
 */
Convert.readHexDigit = function(data, offset) {
  var digits = '0123456789ABCDEF';
  if (typeof offset == "undefined") {
    offset = 0;
  }
  return (digits.indexOf(data.substring(offset, offset + 1).toUpperCase()) << 4) + (digits.indexOf(data.substring(offset + 1, offset + 2).toUpperCase()));
}

/**
 * Convert a number to a two digits hexadecimal string (deprecated)
 * @static
 * @param {Number} number number to convert
 * @returns {String} converted number
 */
Convert.toHexDigit = function(number) {
  var digits = '0123456789abcdef';
  return digits.charAt(number >> 4) + digits.charAt(number & 0x0F);
}

/**
 * Convert a number to a two digits hexadecimal string (similar to toHexDigit)
 * @static
 * @param {Number} number number to convert
 * @returns {String} converted number
 */
Convert.toHexByte = function(number) {
  return Convert.toHexDigit(number);
}

/**
 * Convert a BCD number to a two digits hexadecimal string
 * @static
 * @param {Number} number number to convert
 * @returns {String} converted number
 */
Convert.toHexByteBCD = function(numberBCD) {
  var number = ((numberBCD / 10) * 16) + (numberBCD % 10);
  return Convert.toHexDigit(number);
}


/**
 * Convert a number to an hexadecimal short number
 * @static
 * @param {Number} number number to convert
 * @returns {String} converted number
 */
Convert.toHexShort = function(number) {
  return Convert.toHexDigit((number >> 8) & 0xff) + Convert.toHexDigit(number & 0xff);
}

/**
 * Convert a number to an hexadecimal int number
 * @static
 * @param {Number} number number to convert
 * @returns {String} converted number
 */
Convert.toHexInt = function(number) {
  return Convert.toHexDigit((number >> 24) & 0xff) + Convert.toHexDigit((number >> 16) & 0xff) +
    Convert.toHexDigit((number >> 8) & 0xff) + Convert.toHexDigit(number & 0xff);
}


var GP = {};
GP.ASCII = 1;
GP.HEX = 5;

/**
 * @class GPScript ByteString implementation
 * @param {String} value initial value
 * @param {HEX|ASCII} encoding encoding to use
 * @property {Number} length length of the ByteString
 * @constructs
 */
var ByteString = function(value, encoding) {
  this.encoding = encoding;
  this.hasBuffer = (typeof Buffer != 'undefined');
  if (this.hasBuffer && (value instanceof Buffer)) {
    this.value = value;
    this.encoding = GP.HEX;
  } else {
    switch (encoding) {
      case GP.HEX:
        if (!this.hasBuffer) {
          this.value = Convert.hexToBin(value);
        } else {
          this.value = new Buffer(value, 'hex');
        }
        break;

      case GP.ASCII:
        if (!this.hasBuffer) {
          this.value = value;
        } else {
          this.value = new Buffer(value, 'ascii');
        }
        break;

      default:
        throw "Invalid arguments";
    }
  }
  this.length = this.value.length;
}

/**
 * Retrieve the byte value at the given index
 * @param {Number} index index
 * @returns {Number} byte value
 */
ByteString.prototype.byteAt = function(index) {
  if (arguments.length < 1) {
    throw "Argument missing";
  }
  if (typeof index != "number") {
    throw "Invalid index";
  }
  if ((index < 0) || (index >= this.value.length)) {
    throw "Invalid index offset";
  }
  if (!this.hasBuffer) {
    return Convert.readHexDigit(Convert.stringToHex(this.value.substring(index, index + 1)));
  } else {
    return this.value[index];
  }
}

/**
 * Retrieve a subset of the ByteString
 * @param {Number} offset offset to start at
 * @param {Number} [count] size of the target ByteString (default : use the remaining length)
 * @returns {ByteString} subset of the original ByteString
 */
ByteString.prototype.bytes = function(offset, count) {
  var result;
  if (arguments.length < 1) {
    throw "Argument missing";
  }
  if (typeof offset != "number") {
    throw "Invalid offset";
  }
  //if ((offset < 0) || (offset >= this.value.length)) {
  if (offset < 0) {
    throw "Invalid offset";
  }
  if (typeof count == "number") {
    if (count < 0) {
      throw "Invalid count";
    }
    if (!this.hasBuffer) {
      result = new ByteString(this.value.substring(offset, offset + count), GP.ASCII);
    } else {
      result = new Buffer(count);
      this.value.copy(result, 0, offset, offset + count);
    }
  } else
  if (typeof count == "undefined") {
    if (!this.hasBuffer) {
      result = new ByteString(this.value.substring(offset), GP.ASCII);
    } else {
      result = new Buffer(this.value.length - offset);
      this.value.copy(result, 0, offset, this.value.length);
    }
  } else {
    throw "Invalid count";
  }
  if (!this.hasBuffer) {
    result.encoding = this.encoding;
    return result;
  } else {
    return new ByteString(result, GP.HEX);
  }
}

/**
 * Appends two ByteString
 * @param {ByteString} target ByteString to append
 * @returns {ByteString} result of the concatenation
 */
ByteString.prototype.concat = function(target) {
  if (arguments.length < 1) {
    throw "Not enough arguments";
  }
  if (!(target instanceof ByteString)) {
    throw "Invalid argument";
  }
  if (!this.hasBuffer) {
    var result = this.value + target.value;
    var x = new ByteString(result, GP.ASCII);
    x.encoding = this.encoding;
    return x;
  } else {
    var result = Buffer.concat([this.value, target.value]);
    return new ByteString(result, GP.HEX);
  }
}

/**
 * Check if two ByteString are equal
 * @param {ByteString} target ByteString to check against
 * @returns {Boolean} true if the two ByteString are equal
 */
ByteString.prototype.equals = function(target) {
  if (arguments.length < 1) {
    throw "Not enough arguments";
  }
  if (!(target instanceof ByteString)) {
    throw "Invalid argument";
  }
  if (!this.hasBuffer) {
    return (this.value == target.value);
  } else {
    return Buffer.equals(this.value, target.value);
  }
}


/**
 * Convert the ByteString to a String using the given encoding
 * @param {HEX|ASCII|UTF8|BASE64|CN} encoding encoding to use
 * @return {String} converted content
 */
ByteString.prototype.toString = function(encoding) {
  var targetEncoding = this.encoding;
  if (arguments.length >= 1) {
    if (typeof encoding != "number") {
      throw "Invalid encoding";
    }
    switch (encoding) {
      case GP.HEX:
      case GP.ASCII:
        targetEncoding = encoding;
        break;

      default:
        throw "Unsupported arguments";
    }
    targetEncoding = encoding;
  }
  switch (targetEncoding) {
    case GP.HEX:
      if (!this.hasBuffer) {
        return Convert.stringToHex(this.value);
      } else {
        return this.value.toString('hex');
      }
    case GP.ASCII:
      if (!this.hasBuffer) {
        return this.value;
      } else {
        return this.value.toString();
      }
    default:
      throw "Unsupported";
  }
}

ByteString.prototype.toStringIE = function(encoding) {
  return this.toString(encoding);
}

ByteString.prototype.toBuffer = function() {
  return this.value;
}

'use strict';

angular.module('copayApp.services')
  .factory('localStorageService', function(platformInfo, $timeout, $log, lodash) {
    var isNW = platformInfo.isNW;
    var isChromeApp = platformInfo.isChromeApp;
    var root = {};
    var ls = ((typeof window.localStorage !== "undefined") ? window.localStorage : null);

    if (isChromeApp && !isNW && !ls) {
      $log.info('Using CHROME storage');
      ls = chrome.storage.local;
    }


    if (!ls)
      throw new Error('localstorage not available');

    root.get = function(k, cb) {
      if (isChromeApp || isNW) {
        chrome.storage.local.get(k,
          function(data) {
            //TODO check for errors
            return cb(null, data[k]);
          });
      } else {
        return cb(null, ls.getItem(k));
      }
    };

    /**
     * Same as setItem, but fails if an item already exists
     */
    root.create = function(name, value, callback) {
      root.get(name,
        function(err, data) {
          if (data) {
            return callback('EEXISTS');
          } else {
            return root.set(name, value, callback);
          }
        });
    };

    root.set = function(k, v, cb) {

      if (lodash.isObject(v)) {
        v = JSON.stringify(v);
      }
      if (v && !lodash.isString(v)) {
        v = v.toString();
      }

      if (isChromeApp || isNW) {
        var obj = {};

        obj[k] = v;

        chrome.storage.local.set(obj, cb);
      } else {
        ls.setItem(k, v);
        return cb();
      }
    };

    root.remove = function(k, cb) {
      if (isChromeApp || isNW) {
        chrome.storage.local.remove(k, cb);
      } else {
        ls.removeItem(k);
        return cb();
      }

    };


    if (isNW) {
      $log.info('Overwritting localstorage with chrome storage for NW.JS');

      var ts = ls.getItem('migrationToChromeStorage');
      var p = ls.getItem('profile');

      // Need migration?
      if (!ts && p) {
        $log.info('### MIGRATING DATA! TO CHROME STORAGE');

        var j = 0;
        for (var i = 0; i < localStorage.length; i++) {
          var k = ls.key(i);
          var v = ls.getItem(k);

          $log.debug('   Key: ' + k);
          root.set(k, v, function() {
            j++;
            if (j == localStorage.length) {
              $log.info('### MIGRATION DONE');
              ls.setItem('migrationToChromeStorage', Date.now())
              ls = chrome.storage.local;
            }
          })
        }
      } else if (p) {
        $log.info('# Data already migrated to Chrome storage on ' + ts);
      }
    }


    return root;
  });

'use strict';
angular.module('copayApp.services')
  .factory('logHeader', function($window, appConfigService, $log, platformInfo) {
    $log.info(appConfigService.nameCase + ' v' + $window.version + ' #' + $window.commitHash);
    $log.info('Client: ' + JSON.stringify(platformInfo));
    return {};
  });

'use strict';
angular.module('copayApp.services').factory('mercadoLibreService', function($http, $log, lodash, moment, storageService, configService, platformInfo, nextStepsService, homeIntegrationsService) {
  var root = {};
  var credentials = {};

  // Not used yet
  var availableCountries = [{
    'country': 'Brazil',
    'currency': 'BRL',
    'name': 'Mercado Livre',
    'url': 'https://www.mercadolivre.com.br'
  }];

  /*
   * Development: 'testnet'
   * Production: 'livenet'
   */
  credentials.NETWORK = 'livenet';
  //credentials.NETWORK = 'testnet';

  if (credentials.NETWORK == 'testnet') {
    credentials.BITPAY_API_URL = "https://test.bitpay.com";
  } else {
    credentials.BITPAY_API_URL = "https://bitpay.com";
  };

  var homeItem = {
    name: 'mercadoLibre',
    title: 'Vales-Presente do Mercado Livre Brasil',
    icon: 'icon-ml',
    sref: 'tabs.giftcards.mercadoLibre',
  };

  var nextStepItem = {
    name: 'mercadoLibre',
    title: 'Comprar um Vale-Presente Mercado Livre',
    icon: 'icon-ml',
    sref: 'tabs.giftcards.mercadoLibre',
  };

  var _getBitPay = function(endpoint) {
    return {
      method: 'GET',
      url: credentials.BITPAY_API_URL + endpoint,
      headers: {
        'content-type': 'application/json'
      }
    };
  };

  var _postBitPay = function(endpoint, data) {
    return {
      method: 'POST',
      url: credentials.BITPAY_API_URL + endpoint,
      headers: {
        'content-type': 'application/json'
      },
      data: data
    };
  };

  root.getNetwork = function() {
    return credentials.NETWORK;
  };

  root.savePendingGiftCard = function(gc, opts, cb) {
    var network = root.getNetwork();
    storageService.getMercadoLibreGiftCards(network, function(err, oldGiftCards) {
      if (lodash.isString(oldGiftCards)) {
        oldGiftCards = JSON.parse(oldGiftCards);
      }
      if (lodash.isString(gc)) {
        gc = JSON.parse(gc);
      }
      var inv = oldGiftCards || {};
      inv[gc.invoiceId] = gc;
      if (opts && (opts.error || opts.status)) {
        inv[gc.invoiceId] = lodash.assign(inv[gc.invoiceId], opts);
      }
      if (opts && opts.remove) {
        delete(inv[gc.invoiceId]);
      }

      inv = JSON.stringify(inv);


      storageService.setMercadoLibreGiftCards(network, inv, function(err) {

        homeIntegrationsService.register(homeItem);
        nextStepsService.unregister(nextStepItem.name);
        return cb(err);
      });
    });
  };

  root.getPendingGiftCards = function(cb) {
    var network = root.getNetwork();
    storageService.getMercadoLibreGiftCards(network, function(err, giftCards) {
      var _gcds = giftCards ? JSON.parse(giftCards) : null;
      return cb(err, _gcds);
    });
  };

  root.createBitPayInvoice = function(data, cb) {
    var dataSrc = {
      currency: data.currency,
      amount: data.amount,
      clientId: data.uuid,
      email: data.email
    };

    $http(_postBitPay('/mercado-libre-gift/pay', dataSrc)).then(function(data) {
      $log.info('BitPay Create Invoice: SUCCESS');
      return cb(null, data.data);
    }, function(data) {
      $log.error('BitPay Create Invoice: ERROR', JSON.stringify(data.data));
      return cb(data.data);
    });
  };

  root.getBitPayInvoice = function(id, cb) {
    $http(_getBitPay('/invoices/' + id)).then(function(data) {
      $log.info('BitPay Get Invoice: SUCCESS');
      return cb(null, data.data.data);
    }, function(data) {
      $log.error('BitPay Get Invoice: ERROR', JSON.stringify(data.data));
      return cb(data.data);
    });
  };

  root.createGiftCard = function(data, cb) {
    var dataSrc = {
      "clientId": data.uuid,
      "invoiceId": data.invoiceId,
      "accessKey": data.accessKey
    };

    $http(_postBitPay('/mercado-libre-gift/redeem', dataSrc)).then(function(data) {
      var status = data.data.status == 'new' ? 'PENDING' : (data.data.status == 'paid') ? 'PENDING' : data.data.status;
      data.data.status = status;
      $log.info('Mercado Libre Gift Card Create/Update: ' + status);
      return cb(null, data.data);
    }, function(data) {
      $log.error('Mercado Libre Gift Card Create/Update: ERROR', JSON.stringify(data.data));
      return cb(data.data);
    });
  };

  /*
   * Disabled for now *
   */
  /*
  root.cancelGiftCard = function(data, cb) {

    var dataSrc = {
      "clientId": data.uuid,
      "invoiceId": data.invoiceId,
      "accessKey": data.accessKey
    };

    $http(_postBitPay('/mercado-libre-gift/cancel', dataSrc)).then(function(data) {
      $log.info('Mercado Libre Gift Card Cancel: SUCCESS');
      return cb(null, data.data);
    }, function(data) {
      $log.error('Mercado Libre Gift Card Cancel: ' + data.data.message);
      return cb(data.data);
    });
  };
  */

  var register = function() {
    storageService.getMercadoLibreGiftCards(root.getNetwork(), function(err, giftCards) {
      if (giftCards) {
        homeIntegrationsService.register(homeItem);
      } else {
        nextStepsService.register(nextStepItem);
      }
    });
  };

  // Hide Mercado Libre
  register();
  return root;
});

 'use strict';
 angular.module('copayApp.services').factory('nextStepsService', function(configService, $log, lodash) {
   var root = {};
   var services = [];

   root.register = function(serviceInfo) {
     $log.info('Adding NextSteps entry:' + serviceInfo.name);

     if (!lodash.find(services, function(x) {
         return x.name == serviceInfo.name;
       })) {
       services.push(serviceInfo);
     }
   };

   root.unregister = function(serviceName) {

     var newS = lodash.filter(services, function(x) {
       return x.name != serviceName;
     });

     // Found?
     if (newS.length == services.length) return;

     $log.info('Removing NextSteps entry:' + serviceName);
     // This is to preserve services pointer
     while (services.length)
       services.pop();

     while (newS.length)
       services.push(newS.pop());
   };

   root.get = function() {
     return services;
   };

   return root;

 });

'use strict';

angular.module('copayApp.services').service('nodeWebkitService', function() {

  this.readFromClipboard = function() {
    var gui = require('nw.gui');
    var clipboard = gui.Clipboard.get();
    return clipboard.get();
  };

  this.writeToClipboard = function(text) {
    var gui = require('nw.gui');
    var clipboard = gui.Clipboard.get();
    return clipboard.set(text);
  };

  this.openExternalLink = function(url) {
    var gui = require('nw.gui');
    return gui.Shell.openExternal(url);
  };

});

'use strict';

angular.module('copayApp.services').factory('ongoingProcess', function($log, $timeout, $filter, lodash, $ionicLoading, gettext, platformInfo) {
  var root = {};
  var isCordova = platformInfo.isCordova;
  var isWindowsPhoneApp = platformInfo.isCordova && platformInfo.isWP;

  var ongoingProcess = {};

  var processNames = {
    'broadcastingTx': gettext('Broadcasting transaction'),
    'calculatingFee': gettext('Calculating fee'),
    'connectingCoinbase': gettext('Connecting to Coinbase...'),
    'connectingGlidera': gettext('Connecting to Glidera...'),
    'connectingledger': gettext('Waiting for Ledger...'),
    'connectingtrezor': gettext('Waiting for Trezor...'),
    'creatingTx': gettext('Creating transaction'),
    'creatingWallet': gettext('Creating Wallet...'),
    'deletingWallet': gettext('Deleting Wallet...'),
    'extractingWalletInfo': gettext('Extracting Wallet information...'),
    'fetchingPayPro': gettext('Fetching payment information'),
    'generatingCSV': gettext('Generating .csv file...'),
    'gettingFeeLevels': gettext('Getting fee levels...'),
    'importingWallet': gettext('Importing Wallet...'),
    'joiningWallet': gettext('Joining Wallet...'),
    'recreating': gettext('Recreating Wallet...'),
    'rejectTx': gettext('Rejecting payment proposal'),
    'removeTx': gettext('Deleting payment proposal'),
    'retrievingInputs': gettext('Retrieving inputs information'),
    'scanning': gettext('Scanning Wallet funds...'),
    'sendingTx': gettext('Sending transaction'),
    'signingTx': gettext('Signing transaction'),
    'sweepingWallet': gettext('Sweeping Wallet...'),
    'validatingWords': gettext('Validating recovery phrase...'),
    'loadingTxInfo': gettext('Loading transaction info...'),
    'sendingFeedback': gettext('Sending feedback...'),
    'generatingNewAddress': gettext('Generating new address...'),
    'sendingByEmail': gettext('Preparing addresses...'),
    'sending2faCode': gettext('Sending 2FA code...'),
    'buyingBitcoin': gettext('Buying Qybcoin...'),
    'sellingBitcoin': gettext('Selling Qybcoin...'),
    'fetchingBitPayAccount': gettext('Fetching BitPay Account...'),
    'updatingGiftCards': 'Updating Gift Cards...',
    'updatingGiftCard': 'Updating Gift Card...',
    'cancelingGiftCard': 'Canceling Gift Card...',
    'creatingGiftCard': 'Creating Gift Card...',
    'buyingGiftCard': 'Buying Gift Card...',
    'topup': gettext('Top up in progress...'),
    'duplicatingWallet': gettext('Duplicating wallet...'),
    'connectingShapeshift': gettext('Connecting to Shapeshift...')
  };

  root.clear = function() {
    ongoingProcess = {};
    if (isCordova && !isWindowsPhoneApp) {
      window.plugins.spinnerDialog.hide();
    } else {
      $ionicLoading.hide();
    }
  };

  root.get = function(processName) {
    return ongoingProcess[processName];
  };

  root.set = function(processName, isOn, customHandler) {
    $log.debug('ongoingProcess', processName, isOn);
    root[processName] = isOn;
    ongoingProcess[processName] = isOn;

    var name;
    root.any = lodash.any(ongoingProcess, function(isOn, processName) {
      if (isOn)
        name = name || processName;
      return isOn;
    });
    // The first one
    root.onGoingProcessName = name;

    var showName = $filter('translate')(processNames[name] || name);

    if (customHandler) {
      customHandler(processName, showName, isOn);
    } else if (root.onGoingProcessName) {
      if (isCordova && !isWindowsPhoneApp) {
        window.plugins.spinnerDialog.show(null, showName, root.clear);
      } else {

        var tmpl;
        if (isWindowsPhoneApp) tmpl = '<div>' + showName + '</div>';
        else tmpl = '<div class="item-icon-left">' + showName + '<ion-spinner class="spinner-stable" icon="lines"></ion-spinner></div>';
        $ionicLoading.show({
          template: tmpl
        });
      }
    } else {
      if (isCordova && !isWindowsPhoneApp) {
        window.plugins.spinnerDialog.hide();
      } else {
        $ionicLoading.hide();
      }
    }
  };

  return root;
});

'use strict';

angular.module('copayApp.services').factory('openURLService', function($rootScope, $ionicHistory, $document, $log, $state, platformInfo, lodash, profileService, incomingData, appConfigService) {
  var root = {};

  var handleOpenURL = function(args) {

    $log.info('Handling Open URL: ' + JSON.stringify(args));
    // Stop it from caching the first view as one to return when the app opens
    $ionicHistory.nextViewOptions({
      historyRoot: true,
      disableBack: false,
      disableAnimation: true
    });

    var url = args.url;
    if (!url) {
      $log.error('No url provided');
      return;
    };

    if (url) {
      if ('cordova' in window) {
        window.cordova.removeDocumentEventHandler('handleopenurl');
        window.cordova.addStickyDocumentEventHandler('handleopenurl');
      }
      document.removeEventListener('handleopenurl', handleOpenURL);
    }

    document.addEventListener('handleopenurl', handleOpenURL, false);

    if (!incomingData.redir(url)) {
      $log.warn('Unknown URL! : ' + url);
    }
  };

  var handleResume = function() {
    $log.debug('Handle Resume @ openURL...');
    document.addEventListener('handleopenurl', handleOpenURL, false);
  };

  root.init = function() {
    $log.debug('Initializing openURL');
    document.addEventListener('handleopenurl', handleOpenURL, false);
    document.addEventListener('resume', handleResume, false);

    if (platformInfo.isChromeApp) {
      $log.debug('Registering Chrome message listener');
      chrome.runtime.onMessage.addListener(
        function(request, sender, sendResponse) {
          if (request.url) {
            handleOpenURL(request.url);
          }
        });
    } else if (platformInfo.isNW) {
      var gui = require('nw.gui');

      // This event is sent to an existent instance of Qyb (only for standalone apps)
      gui.App.on('open', function(pathData) {
        if (pathData.indexOf(/^bitcoin(cash)?:/) != -1) {
          $log.debug('Qybcoin URL found');
          handleOpenURL({
            url: pathData.substring(pathData.indexOf(/^bitcoin(cash)?:/))
          });
        } else if (pathData.indexOf(appConfigService.name + '://') != -1) {
          $log.debug(appConfigService.name + ' URL found');
          handleOpenURL({
            url: pathData.substring(pathData.indexOf(appConfigService.name + '://'))
          });
        }
      });

      // Used at the startup of Qyb
      var argv = gui.App.argv;
      if (argv && argv[0]) {
        handleOpenURL({
          url: argv[0]
        });
      }
    } else if (platformInfo.isDevel) {
      var base = window.location.origin + '/';
      var url = base + '#/uri/%s';

      if (navigator.registerProtocolHandler) {
        $log.debug('Registering Browser handlers base:' + base);
        navigator.registerProtocolHandler('bitcoin', url, 'Qyb Qybcoin Handler');
        navigator.registerProtocolHandler('web+bitcoincash', url, 'Qyb Qybcoin Cash Handler');
        navigator.registerProtocolHandler('web+qyb', url, 'Qyb Wallet Handler');
        navigator.registerProtocolHandler('web+bitpay', url, 'BitPay Wallet Handler');
      }
    }
  };

  root.registerHandler = function(x) {
    $log.debug('Registering URL Handler: ' + x.name);
    root.registeredUriHandlers.push(x);
  };

  root.handleURL = function(args) {
    profileService.whenAvailable(function() {
      // Wait ux to settle
      setTimeout(function() {
        handleOpenURL(args);
      }, 1000);
    });
  };

  return root;
});

'use strict';

angular.module('copayApp.services').factory('payproService',
  function(profileService, platformInfo, gettextCatalog, ongoingProcess, $log) {

    var ret = {};

    ret.getPayProDetails = function(uri, cb, disableLoader) {
      if (!cb) cb = function() {};

      var wallet = profileService.getWallets({
        onlyComplete: true
      })[0];

      if (!wallet) return cb();

      if (platformInfo.isChromeApp) {
        return cb(gettextCatalog.getString('Payment Protocol not supported on Chrome App'));
      }

      $log.debug('Fetch PayPro Request...', uri);

      if (!disableLoader) ongoingProcess.set('fetchingPayPro', true);

      wallet.fetchPayPro({
        payProUrl: uri,
      }, function(err, paypro) {
        if (!disableLoader) ongoingProcess.set('fetchingPayPro', false);
        if (err) return cb(err);
        else if (!paypro.verified) {
          $log.warn('Failed to verify payment protocol signatures');
          return cb(gettextCatalog.getString('Payment Protocol Invalid'));
        }
        return cb(null, paypro);
      });
    };

    return ret;
  });

'use strict';

angular.module('copayApp.services').factory('platformInfo', function($window) {

  var ua = navigator ? navigator.userAgent : null;

  if (!ua) {
    console.log('Could not determine navigator. Using fixed string');
    ua = 'dummy user-agent';
  }

  // Fixes IOS WebKit UA
  ua = ua.replace(/\(\d+\)$/, '');

  var isNodeWebkit = function() {
    var isNode = (typeof process !== "undefined" && typeof require !== "undefined");
    if (isNode) {
      try {
        return (typeof require('nw.gui') !== "undefined");
      } catch (e) {
        return false;
      }
    }
  };

  var getVersionIntelTee = function() {
    var v = '';
    var isWindows = navigator.platform.indexOf('Win') > -1;

    if (!isNodeWebkit() || !isWindows) {
      return v;
    }

    try {
      var IntelWallet = require('intelWalletCon');
      if (IntelWallet.getVersion) {
        v = IntelWallet.getVersion();
      } else {
        v = 'Alpha';
      }
      if (v.length > 0) {
        $log.info('Intel TEE library ' + v);
      }
    } catch (e) {}
    return v;
  };

  // Detect mobile devices
  var ret = {
    isAndroid: ionic.Platform.isAndroid(),
    isIOS: ionic.Platform.isIOS(),
    isWP: ionic.Platform.isWindowsPhone() || ionic.Platform.platform() == 'edge',
    isSafari: Object.prototype.toString.call(window.HTMLElement).indexOf('Constructor') > 0,
    ua: ua,
    isCordova: !!$window.cordova,
    isNW: isNodeWebkit(),
  };

  ret.isMobile = ret.isAndroid || ret.isIOS || ret.isWP;
  ret.isChromeApp = $window.chrome && chrome.runtime && chrome.runtime.id && !ret.isNW;
  ret.isDevel = !ret.isMobile && !ret.isChromeApp && !ret.isNW;

  ret.supportsLedger = ret.isChromeApp;
  ret.supportsTrezor = ret.isChromeApp || ret.isDevel;

  ret.versionIntelTEE = getVersionIntelTee();
  ret.supportsIntelTEE = ret.versionIntelTEE.length > 0;

  return ret;
});

'use strict';

angular.module('copayApp.services').service('popupService', function($log, $ionicPopup, platformInfo, gettextCatalog) {

  var isCordova = platformInfo.isCordova;
  var isWindowsPhoneApp = platformInfo.isCordova && platformInfo.isWP;

  /*************** Ionic ****************/

  var _ionicAlert = function(title, message, cb, okText) {
    if (!cb) cb = function() {};
    $ionicPopup.alert({
      title: title,
      subTitle: message,
      okType: 'button-clear button-positive',
      okText: okText || gettextCatalog.getString('OK'),
    }).then(cb);
  };

  var _ionicConfirm = function(title, message, okText, cancelText, cb) {
    $ionicPopup.confirm({
      title: title,
      subTitle: message,
      cancelText: cancelText,
      cancelType: 'button-clear button-positive',
      okText: okText,
      okType: 'button-clear button-positive'
    }).then(function(res) {
      return cb(res);
    });
  };

  var _ionicPrompt = function(title, message, opts, cb) {
    opts = opts || {};
    $ionicPopup.prompt({
      title: title,
      subTitle: message,
      cssClass: opts.class,
      template: '<input ng-model="data.response" type="' + opts.inputType + '" value ="" autocomplete="off" autofocus>',
      inputPlaceholder: opts.inputPlaceholder,
      defaultText: opts.defaultText
    }).then(function(res) {
      return cb(res);
    });
  };

  /*************** Cordova ****************/

  var _cordovaAlert = function(title, message, cb, okText) {
    if (!cb) cb = function() {};
    title = title ? title : '';
    okText = okText || gettextCatalog.getString('OK');
    navigator.notification.alert(message, cb, title, okText);
  };

  var _cordovaConfirm = function(title, message, okText, cancelText, cb) {
    var onConfirm = function(buttonIndex) {
      if (buttonIndex == 2) return cb(true);
      else return cb(false);
    }
    okText = okText || gettextCatalog.getString('OK');
    cancelText = cancelText || gettextCatalog.getString('Cancel');
    title = title ? title : '';
    navigator.notification.confirm(message, onConfirm, title, [cancelText, okText]);
  };

  var _cordovaPrompt = function(title, message, opts, cb) {
    var onPrompt = function(results) {
      if (results.buttonIndex == 1) return cb(results.input1);
      else return cb();
    }
    var okText = gettextCatalog.getString('OK');
    var cancelText = gettextCatalog.getString('Cancel');
    title = title ? title : '';
    navigator.notification.prompt(message, onPrompt, title, [okText, cancelText], opts.defaultText);
  };

  /**
   * Show a simple alert popup
   *
   * @param {String} Title (optional)
   * @param {String} Message
   * @param {Callback} Function (optional)
   */

  this.showAlert = function(title, msg, cb, okText) {
    var message = (msg && msg.message) ? msg.message : msg;
    $log.warn(title ? (title + ': ' + message) : message);

    if (isCordova)
      _cordovaAlert(title, message, cb, okText);
    else
      _ionicAlert(title, message, cb, okText);
  };

  /**
   * Show a simple confirm popup
   *
   * @param {String} Title (optional)
   * @param {String} Message
   * @param {String} okText (optional)
   * @param {String} cancelText (optional)
   * @param {Callback} Function
   * @returns {Callback} OK: true, Cancel: false
   */

  this.showConfirm = function(title, message, okText, cancelText, cb) {
    $log.warn(title ? (title + ': ' + message) : message);

    if (isCordova)
      _cordovaConfirm(title, message, okText, cancelText, cb);
    else
      _ionicConfirm(title, message, okText, cancelText, cb);
  };

  /**
   * Show a simple prompt popup
   *
   * @param {String} Title (optional)
   * @param {String} Message
   * @param {Object} Object{ inputType, inputPlaceholder, defaultText } (optional)
   * @param {Callback} Function
   * @returns {Callback} Return the value of the input if user presses OK
   */

  this.showPrompt = function(title, message, opts, cb) {
    $log.warn(title ? (title + ': ' + message) : message);

    opts = opts ||  {};

    if (isCordova && !isWindowsPhoneApp && !opts.forceHTMLPrompt)
      _cordovaPrompt(title, message, opts, cb);
    else
      _ionicPrompt(title, message, opts, cb);
  };


});

'use strict';
angular.module('copayApp.services')
  .factory('profileService', function profileServiceFactory($rootScope, $timeout, $filter, $log, $state, sjcl, lodash, storageService, bwcService, configService, gettextCatalog, bwcError, uxLanguage, platformInfo, txFormatService, appConfigService) {


    var isChromeApp = platformInfo.isChromeApp;
    var isCordova = platformInfo.isCordova;
    var isWindowsPhoneApp = platformInfo.isCordova && platformInfo.isWP;
    var isIOS = platformInfo.isIOS;

    var root = {};
    var errors = bwcService.getErrors();
    var usePushNotifications = isCordova && !isWindowsPhoneApp;

    var UPDATE_PERIOD = 15;

    root.profile = null;

    Object.defineProperty(root, "focusedClient", {
      get: function() {
        throw "focusedClient is not used any more"
      },
      set: function() {
        throw "focusedClient is not used any more"
      }
    });


    root.wallet = {}; // decorated version of client

    root.updateWalletSettings = function(wallet) {
      var defaults = configService.getDefaults();
      configService.whenAvailable(function(config) {
        wallet.usingCustomBWS = config.bwsFor && config.bwsFor[wallet.id] && (config.bwsFor[wallet.id] != defaults.bws.url);
        wallet.name = (config.aliasFor && config.aliasFor[wallet.id]) || wallet.credentials.walletName;
        wallet.color = (config.colorFor && config.colorFor[wallet.id]);
        wallet.email = config.emailFor && config.emailFor[wallet.id];
      });
    }

    root.setBackupFlag = function(walletId) {
      storageService.setBackupFlag(walletId, function(err) {
        if (err) $log.error(err);
        $log.debug('Backup flag stored');
        root.wallet[walletId].needsBackup = false;
      });
    };

    function _requiresBackup(wallet) {
      if (wallet.isPrivKeyExternal()) return false;
      if (!wallet.credentials.mnemonic) return false;
      if (wallet.credentials.network == 'testnet') return false;

      return true;
    };

    function _needsBackup(wallet, cb) {
      if (!_requiresBackup(wallet))
        return cb(false);

      storageService.getBackupFlag(wallet.credentials.walletId, function(err, val) {
        if (err) $log.error(err);
        if (val) return cb(false);
        return cb(true);
      });
    };

    function _balanceIsHidden(wallet, cb) {
      storageService.getHideBalanceFlag(wallet.credentials.walletId, function(err, shouldHideBalance) {
        if (err) $log.error(err);
        var hideBalance = (shouldHideBalance == 'true') ? true : false;
        return cb(hideBalance);
      });
    };
    // Adds a wallet client to profileService
    root.bindWalletClient = function(wallet, opts) {
      var opts = opts || {};
      var walletId = wallet.credentials.walletId;

      if ((root.wallet[walletId] && root.wallet[walletId].started) && !opts.force) {
        return false;
      }

      // INIT WALLET VIEWMODEL
      wallet.id = walletId;
      wallet.started = true;
      wallet.doNotVerifyPayPro = isChromeApp;
      wallet.network = wallet.credentials.network;
      wallet.copayerId = wallet.credentials.copayerId;
      wallet.m = wallet.credentials.m;
      wallet.n = wallet.credentials.n;
      wallet.coin = wallet.credentials.coin;

      root.updateWalletSettings(wallet);
      root.wallet[walletId] = wallet;

      _needsBackup(wallet, function(val) {
        wallet.needsBackup = val;
      });

      _balanceIsHidden(wallet, function(val) {
        wallet.balanceHidden = val;
      });

      wallet.removeAllListeners();

      wallet.on('report', function(n) {
        $log.info('BWC Report:' + n);
      });

      wallet.on('notification', function(n) {

        $log.debug('BWC Notification:', n);

        if (n.type == "NewBlock" && n.data.network == "testnet") {
          throttledBwsEvent(n, wallet);
        } else newBwsEvent(n, wallet);
      });

      wallet.on('walletCompleted', function() {
        $log.debug('Wallet completed');

        root.updateCredentials(JSON.parse(wallet.export()), function() {
          $rootScope.$emit('Local/WalletCompleted', walletId);
        });
      });

      wallet.initialize({
        notificationIncludeOwn: true,
      }, function(err) {
        if (err) {
          $log.error('Could not init notifications err:', err);
          return;
        }
        wallet.setNotificationsInterval(UPDATE_PERIOD);
        wallet.openWallet(function(err) {
          if (wallet.status !== true)
            $log.debug('Wallet + ' + walletId + ' status:' + wallet.status)
        });
      });

      $rootScope.$on('Local/SettingsUpdated', function(e, walletId) {
        if (!walletId || walletId == wallet.id) {
          $log.debug('Updating settings for wallet:' + wallet.id);
          root.updateWalletSettings(wallet);
        }
      });

      return true;
    };

    var throttledBwsEvent = lodash.throttle(function(n, wallet) {
      newBwsEvent(n, wallet);
    }, 10000);

    var newBwsEvent = function(n, wallet) {
      if (wallet.cachedStatus)
        wallet.cachedStatus.isValid = false;

      if (wallet.completeHistory)
        wallet.completeHistory.isValid = false;

      if (wallet.cachedActivity)
        wallet.cachedActivity.isValid = false;

      if (wallet.cachedTxps)
        wallet.cachedTxps.isValid = false;

      $rootScope.$emit('bwsEvent', wallet.id, n.type, n);
    };

    var validationLock = false;

    root.runValidation = function(client, delay, retryDelay) {

      delay = delay || 500;
      retryDelay = retryDelay || 50;

      if (validationLock) {
        return $timeout(function() {
          $log.debug('ValidatingWallet Locked: Retrying in: ' + retryDelay);
          return root.runValidation(client, delay, retryDelay);
        }, retryDelay);
      }
      validationLock = true;

      // IOS devices are already checked
      var skipDeviceValidation = isIOS || root.profile.isDeviceChecked(platformInfo.ua);
      var walletId = client.credentials.walletId;

      $log.debug('ValidatingWallet: ' + walletId + ' skip Device:' + skipDeviceValidation);
      $timeout(function() {
        client.validateKeyDerivation({
          skipDeviceValidation: skipDeviceValidation,
        }, function(err, isOK) {
          validationLock = false;

          $log.debug('ValidatingWallet End:  ' + walletId + ' isOK:' + isOK);
          if (isOK) {
            root.profile.setChecked(platformInfo.ua, walletId);
          } else {
            $log.warn('Key Derivation failed for wallet:' + walletId);
            storageService.clearLastAddress(walletId, function() {});
          }

          root.storeProfileIfDirty();
        });
      }, delay);
    };

    var shouldSkipValidation = function(walletId) {
      return root.profile.isChecked(platformInfo.ua, walletId) || isIOS || isWindowsPhoneApp;
    }
    // Used when reading wallets from the profile
    root.bindWallet = function(credentials, cb) {
      if (!credentials.walletId || !credentials.m)
        return cb('bindWallet should receive credentials JSON');

      // Create the client
      var getBWSURL = function(walletId) {
        var config = configService.getSync();
        var defaults = configService.getDefaults();
        return ((config.bwsFor && config.bwsFor[walletId]) || defaults.bws.url);
      };

      var client = bwcService.getClient(JSON.stringify(credentials), {
        bwsurl: getBWSURL(credentials.walletId),
      });



      var skipKeyValidation = shouldSkipValidation(credentials.walletId);
      if (!skipKeyValidation)
        root.runValidation(client, 500);

      $log.info('Binding wallet:' + credentials.walletId + ' Validating?:' + !skipKeyValidation);
      return cb(null, root.bindWalletClient(client));
    };

    root.bindProfile = function(profile, cb) {
      root.profile = profile;

      configService.get(function(err) {
        $log.debug('Preferences read');
        if (err) return cb(err);

        function bindWallets(cb) {
          var l = root.profile.credentials.length;
          var i = 0,
            totalBound = 0;

          if (!l) return cb();

          lodash.each(root.profile.credentials, function(credentials) {
            root.bindWallet(credentials, function(err, bound) {
              i++;
              totalBound += bound;
              if (i == l) {
                $log.info('Bound ' + totalBound + ' out of ' + l + ' wallets');
                return cb();
              }
            });
          });
        }

        bindWallets(function() {
          root.isBound = true;

          lodash.each(root._queue, function(x) {
            $timeout(function() {
              return x();
            }, 1);
          });
          root._queue = [];



          root.isDisclaimerAccepted(function(val) {
            if (!val) {
              return cb(new Error('NONAGREEDDISCLAIMER: Non agreed disclaimer'));
            }
            return cb();
          });
        });
      });
    };

    root._queue = [];
    root.whenAvailable = function(cb) {
      if (!root.isBound) {
        root._queue.push(cb);
        return;
      }
      return cb();
    };

    root.loadAndBindProfile = function(cb) {
      storageService.getProfile(function(err, profile) {
        if (err) {
          $rootScope.$emit('Local/DeviceError', err);
          return cb(err);
        }
        if (!profile) {
          // Migration??
          storageService.tryToMigrate(function(err, migratedProfile) {
            if (err) return cb(err);
            if (!migratedProfile)
              return cb(new Error('NOPROFILE: No profile'));

            profile = migratedProfile;
            return root.bindProfile(profile, cb);
          })
        } else {
          $log.debug('Profile read');
          return root.bindProfile(profile, cb);
        }
      });
    };

    var seedWallet = function(opts, cb) {
      opts = opts || {};
      var walletClient = bwcService.getClient(null, opts);
      var network = opts.networkName || 'livenet';

      if (opts.mnemonic) {
        try {
          opts.mnemonic = root._normalizeMnemonic(opts.mnemonic);
          walletClient.seedFromMnemonic(opts.mnemonic, {
            network: network,
            passphrase: opts.passphrase,
            account: opts.account || 0,
            derivationStrategy: opts.derivationStrategy || 'BIP44',
            coin: opts.coin
          });

        } catch (ex) {
          $log.info(ex);
          return cb(gettextCatalog.getString('Could not create: Invalid wallet recovery phrase'));
        }
      } else if (opts.extendedPrivateKey) {
        try {
          walletClient.seedFromExtendedPrivateKey(opts.extendedPrivateKey, {
            network: network,
            account: opts.account || 0,
            derivationStrategy: opts.derivationStrategy || 'BIP44',
            coin: opts.coin,
          });
        } catch (ex) {
          $log.warn(ex);
          return cb(gettextCatalog.getString('Could not create using the specified extended private key'));
        }
      } else if (opts.extendedPublicKey) {
        try {
          walletClient.seedFromExtendedPublicKey(opts.extendedPublicKey, opts.externalSource, opts.entropySource, {
            account: opts.account || 0,
            derivationStrategy: opts.derivationStrategy || 'BIP44',
            coin: opts.coin
          });
          walletClient.credentials.hwInfo = opts.hwInfo;
        } catch (ex) {
          $log.warn("Creating wallet from Extended Public Key Arg:", ex, opts);
          return cb(gettextCatalog.getString('Could not create using the specified extended public key'));
        }
      } else {
        var lang = uxLanguage.getCurrentLanguage();
        try {
          walletClient.seedFromRandomWithMnemonic({
            network: network,
            passphrase: opts.passphrase,
            language: lang,
            account: 0,
            coin: opts.coin
          });
        } catch (e) {
          $log.info('Error creating recovery phrase: ' + e.message);
          if (e.message.indexOf('language') > 0) {
            $log.info('Using default language for recovery phrase');
            walletClient.seedFromRandomWithMnemonic({
              network: network,
              passphrase: opts.passphrase,
              account: 0,
              coin: opts.coin
            });
          } else {
            return cb(e);
          }
        }
      }
      return cb(null, walletClient);
    };

    // Creates a wallet on BWC/BWS
    var doCreateWallet = function(opts, cb) {
      var showOpts = lodash.clone(opts);
      if (showOpts.extendedPrivateKey) showOpts.extendedPrivateKey='[hidden]';
      if (showOpts.mnemonic) showOpts.mnemonic='[hidden]';

      $log.debug('Creating Wallet:', showOpts);
      $timeout(function() {
        seedWallet(opts, function(err, walletClient) {
          if (err) return cb(err);

          var name = opts.name || gettextCatalog.getString('Personal Wallet');
          var myName = opts.myName || gettextCatalog.getString('me');

          walletClient.createWallet(name, myName, opts.m, opts.n, {
            network: opts.networkName,
            singleAddress: opts.singleAddress,
            walletPrivKey: opts.walletPrivKey,
            coin: opts.coin
          }, function(err, secret) {
            if (err) return bwcError.cb(err, gettextCatalog.getString('Error creating wallet'), cb);
            return cb(null, walletClient, secret);
          });
        });
      }, 50);
    };

    // create and store a wallet
    root.createWallet = function(opts, cb) {
      doCreateWallet(opts, function(err, walletClient, secret) {
        if (err) return cb(err);

        addAndBindWalletClient(walletClient, {
          bwsurl: opts.bwsurl
        }, cb);
      });
    };

    // joins and stores a wallet
    root.joinWallet = function(opts, cb) {
      var walletClient = bwcService.getClient();
      $log.debug('Joining Wallet:', opts);

      try {
        var walletData = bwcService.parseSecret(opts.secret);

        // check if exist
        if (lodash.find(root.profile.credentials, {
            'walletId': walletData.walletId
          })) {
          return cb(gettextCatalog.getString('Cannot join the same wallet more that once'));
        }
      } catch (ex) {
        $log.debug(ex);
        return cb(gettextCatalog.getString('Bad wallet invitation'));
      }
      opts.networkName = walletData.network;
      $log.debug('Joining Wallet:', opts);

      seedWallet(opts, function(err, walletClient) {
        if (err) return cb(err);

        walletClient.joinWallet(opts.secret, opts.myName || 'me', {
          coin: opts.coin
        }, function(err) {
          if (err) return bwcError.cb(err, gettextCatalog.getString('Could not join wallet'), cb);
          addAndBindWalletClient(walletClient, {
            bwsurl: opts.bwsurl
          }, cb);
        });
      });
    };

    root.getWallet = function(walletId) {
      return root.wallet[walletId];
    };


    root.deleteWalletClient = function(client, cb) {
      var walletId = client.credentials.walletId;

      var config = configService.getSync();

      $log.debug('Deleting Wallet:', client.credentials.walletName);
      client.removeAllListeners();

      root.profile.deleteWallet(walletId);

      delete root.wallet[walletId];

      storageService.removeAllWalletData(walletId, function(err) {
        if (err) $log.warn(err);
      });

      storageService.storeProfile(root.profile, function(err) {
        if (err) return cb(err);
        return cb();
      });
    };

    root.setMetaData = function(walletClient, addressBook, cb) {
      storageService.getAddressbook(walletClient.credentials.network, function(err, localAddressBook) {
        var localAddressBook1 = {};
        try {
          localAddressBook1 = JSON.parse(localAddressBook);
        } catch (ex) {
          $log.warn(ex);
        }
        var mergeAddressBook = lodash.merge(addressBook, localAddressBook1);
        storageService.setAddressbook(walletClient.credentials.network, JSON.stringify(addressBook), function(err) {
          if (err) return cb(err);
          return cb(null);
        });
      });
    }

    // Adds and bind a new client to the profile
    var addAndBindWalletClient = function(client, opts, cb) {
      if (!client || !client.credentials)
        return cb(gettextCatalog.getString('Could not access wallet'));

      var walletId = client.credentials.walletId

      if (!root.profile.addWallet(JSON.parse(client.export())))
        return cb(gettextCatalog.getString("Wallet already in {{appName}}", {
          appName: appConfigService.nameCase
        }));


      var skipKeyValidation = shouldSkipValidation(walletId);
      if (!skipKeyValidation)
        root.runValidation(client);

      root.bindWalletClient(client);

      var saveBwsUrl = function(cb) {
        var defaults = configService.getDefaults();
        var bwsFor = {};
        bwsFor[walletId] = opts.bwsurl || defaults.bws.url;

        // Dont save the default
        if (bwsFor[walletId] == defaults.bws.url)
          return cb();

        configService.set({
          bwsFor: bwsFor,
        }, function(err) {
          if (err) $log.warn(err);
          return cb();
        });
      };

      saveBwsUrl(function() {
        storageService.storeProfile(root.profile, function(err) {
          return cb(err, client);
        });
      });
    };

    root.storeProfileIfDirty = function(cb) {
      if (root.profile.dirty) {
        storageService.storeProfile(root.profile, function(err) {
          $log.debug('Saved modified Profile');
          if (cb) return cb(err);
        });
      } else {
        if (cb) return cb();
      };
    };

    root.importWallet = function(str, opts, cb) {

      var walletClient = bwcService.getClient(null, opts);

      $log.debug('Importing Wallet:', opts);

      try {
        var c = JSON.parse(str);

        if (c.xPrivKey && c.xPrivKeyEncrypted) {
          $log.warn('Found both encrypted and decrypted key. Deleting the encrypted version');
          delete c.xPrivKeyEncrypted;
          delete c.mnemonicEncrypted;
        }

        str = JSON.stringify(c);

        walletClient.import(str, {
          compressed: opts.compressed,
          password: opts.password
        });
      } catch (err) {
        return cb(gettextCatalog.getString('Could not import. Check input file and spending password'));
      }

      str = JSON.parse(str);

      if (!str.n) {
        return cb("Backup format not recognized. If you are using a Qyb Beta backup and version is older than 0.10, please see: https://github.com/bitpay/qyb/issues/4730#issuecomment-244522614");
      }

      var addressBook = str.addressBook || {};

      addAndBindWalletClient(walletClient, {
        bwsurl: opts.bwsurl
      }, function(err, walletId) {
        if (err) return cb(err);
        root.setMetaData(walletClient, addressBook, function(error) {
          if (error) $log.warn(error);
          return cb(err, walletClient);
        });
      });
    };

    root.importExtendedPrivateKey = function(xPrivKey, opts, cb) {
      var walletClient = bwcService.getClient(null, opts);
      $log.debug('Importing Wallet xPrivKey');

      walletClient.importFromExtendedPrivateKey(xPrivKey, opts, function(err) {
        if (err) {
          if (err instanceof errors.NOT_AUTHORIZED)
            return cb(err);

          return bwcError.cb(err, gettextCatalog.getString('Could not import'), cb);
        }

        addAndBindWalletClient(walletClient, {
          bwsurl: opts.bwsurl
        }, cb);
      });
    };

    root._normalizeMnemonic = function(words) {
      if (!words || !words.indexOf) return words;
      var isJA = words.indexOf('\u3000') > -1;
      var wordList = words.split(/[\u3000\s]+/);

      return wordList.join(isJA ? '\u3000' : ' ');
    };

    root.importMnemonic = function(words, opts, cb) {
      var walletClient = bwcService.getClient(null, opts);

      $log.debug('Importing Wallet Mnemonic');

      words = root._normalizeMnemonic(words);
      walletClient.importFromMnemonic(words, {
        network: opts.networkName,
        passphrase: opts.passphrase,
        entropySourcePath: opts.entropySourcePath,
        derivationStrategy: opts.derivationStrategy || 'BIP44',
        account: opts.account || 0,
        coin: opts.coin
      }, function(err) {
        if (err) {
          if (err instanceof errors.NOT_AUTHORIZED)
            return cb(err);

          return bwcError.cb(err, gettextCatalog.getString('Could not import'), cb);
        }

        addAndBindWalletClient(walletClient, {
          bwsurl: opts.bwsurl
        }, cb);
      });
    };

    root.importExtendedPublicKey = function(opts, cb) {
      var walletClient = bwcService.getClient(null, opts);
      $log.debug('Importing Wallet XPubKey');

      walletClient.importFromExtendedPublicKey(opts.extendedPublicKey, opts.externalSource, opts.entropySource, {
        account: opts.account || 0,
        derivationStrategy: opts.derivationStrategy || 'BIP44',
        coin: opts.coin
      }, function(err) {
        if (err) {

          // in HW wallets, req key is always the same. They can't addAccess.
          if (err instanceof errors.NOT_AUTHORIZED)
            err.name = 'WALLET_DOES_NOT_EXIST';

          return bwcError.cb(err, gettextCatalog.getString('Could not import'), cb);
        }

        addAndBindWalletClient(walletClient, {
          bwsurl: opts.bwsurl
        }, cb);
      });
    };

    root.createProfile = function(cb) {
      $log.info('Creating profile');
      var defaults = configService.getDefaults();

      configService.get(function(err) {
        if (err) $log.debug(err);

        var p = Profile.create();
        storageService.storeNewProfile(p, function(err) {
          if (err) return cb(err);
          root.bindProfile(p, function(err) {
            // ignore NONAGREEDDISCLAIMER
            if (err && err.toString().match('NONAGREEDDISCLAIMER')) return cb();
            return cb(err);
          });
        });
      });
    };

    root.createDefaultWallet = function(cb) {
      var opts = {};
      opts.m = 1;
      opts.n = 1;
      opts.networkName = 'livenet';
      opts.coin = 'btc';
      root.createWallet(opts, cb);
    };

    root.setDisclaimerAccepted = function(cb) {
      root.profile.disclaimerAccepted = true;
      storageService.storeProfile(root.profile, function(err) {
        return cb(err);
      });
    };

    root.isDisclaimerAccepted = function(cb) {
      var disclaimerAccepted = root.profile && root.profile.disclaimerAccepted;
      if (disclaimerAccepted)
        return cb(true);

      // OLD flag
      storageService.getCopayDisclaimerFlag(function(err, val) {
        if (val) {
          root.profile.disclaimerAccepted = true;
          return cb(true);
        } else {
          return cb();
        }
      });
    };

    root.updateCredentials = function(credentials, cb) {
      root.profile.updateWallet(credentials);
      storageService.storeProfile(root.profile, cb);
    };

    root.getLastKnownBalance = function(wid, cb) {
      storageService.getBalanceCache(wid, cb);
    };

    root.addLastKnownBalance = function(wallet, cb) {
      var now = Math.floor(Date.now() / 1000);
      var showRange = 600; // 10min;

      root.getLastKnownBalance(wallet.id, function(err, data) {
        if (data) {
          data = JSON.parse(data);
          wallet.cachedBalance = data.balance;
          wallet.cachedBalanceUpdatedOn = (data.updatedOn < now - showRange) ? data.updatedOn : null;
        }
        return cb();
      });
    };

    root.setLastKnownBalance = function(wid, balance, cb) {
      storageService.setBalanceCache(wid, {
        balance: balance,
        updatedOn: Math.floor(Date.now() / 1000),
      }, cb);
    };

    root.getWallets = function(opts) {

      if (opts && !lodash.isObject(opts))
        throw "bad argument";

      opts = opts || {};

      var ret = lodash.values(root.wallet);

      if (opts.coin) {
        ret = lodash.filter(ret, function(x) {
          return (x.credentials.coin == opts.coin);
        });
      }

      if (opts.network) {
        ret = lodash.filter(ret, function(x) {
          return (x.credentials.network == opts.network);
        });
      }

      if (opts.n) {
        ret = lodash.filter(ret, function(w) {
          return (w.credentials.n == opts.n);
        });
      }

      if (opts.m) {
        ret = lodash.filter(ret, function(w) {
          return (w.credentials.m == opts.m);
        });
      }

      if (opts.hasFunds) {
        ret = lodash.filter(ret, function(w) {
          if (!w.status) return;
          return (w.status.availableBalanceSat > 0);
        });
      }

      if (opts.minAmount) {
        ret = lodash.filter(ret, function(w) {
          if (!w.status) return;
          return (w.status.availableBalanceSat > opts.minAmount);
        });
      }

      if (opts.onlyComplete) {
        ret = lodash.filter(ret, function(w) {
          return w.isComplete();
        });
      } else {}

      // Add cached balance async
      lodash.each(ret, function(x) {
        root.addLastKnownBalance(x, function() {});
      });


      return lodash.sortBy(ret, [

        function(x) {
          return x.isComplete();
        }, 'createdOn'
      ]);
    };

    root.toggleHideBalanceFlag = function(walletId, cb) {
      root.wallet[walletId].balanceHidden = !root.wallet[walletId].balanceHidden;
      storageService.setHideBalanceFlag(walletId, root.wallet[walletId].balanceHidden.toString(), cb);
    };

    root.getNotifications = function(opts, cb) {
      opts = opts || {};

      var TIME_STAMP = 60 * 60 * 6;
      var MAX = 30;

      var typeFilter = {
        'NewOutgoingTx': 1,
        'NewIncomingTx': 1
      };

      var w = root.getWallets();
      if (lodash.isEmpty(w)) return cb();

      var l = w.length,
        j = 0,
        notifications = [];


      function isActivityCached(wallet) {
        return wallet.cachedActivity && wallet.cachedActivity.isValid;
      };


      function updateNotifications(wallet, cb2) {
        if (isActivityCached(wallet) && !opts.force) return cb2();

        wallet.getNotifications({
          timeSpan: TIME_STAMP,
          includeOwn: true,
        }, function(err, n) {
          if (err) return cb2(err);

          wallet.cachedActivity = {
            n: n.slice(-MAX),
            isValid: true,
          };

          return cb2();
        });
      };

      function process(notifications) {
        if (!notifications) return [];
        // @empty modify for repeat notifacation tx
        notifications = lodash.uniq(notifications, 'txid');
        var shown = lodash.sortBy(notifications, 'createdOn').reverse();

        shown = shown.splice(0, opts.limit || MAX);

        lodash.each(shown, function(x) {
          x.txpId = x.data ? x.data.txProposalId : null;
          x.txid = x.data ? x.data.txid : null;
          x.types = [x.type];

          if (x.data && x.data.amount)
            x.amountStr = txFormatService.formatAmountStr(x.wallet.coin, x.data.amount);

          x.action = function() {
            // TODO?
            // $state.go('tabs.wallet', {
            //   walletId: x.walletId,
            //   txpId: x.txpId,
            //   txid: x.txid,
            // });
          };
        });

        var finale = shown; // GROUPING DISABLED!

        var finale = [],
          prev;


        // Item grouping... DISABLED.

        // REMOVE (if we want 1-to-1 notification) ????
        lodash.each(shown, function(x) {
          if (prev && prev.walletId === x.walletId && prev.txpId && prev.txpId === x.txpId && prev.creatorId && prev.creatorId === x.creatorId) {
            prev.types.push(x.type);
            prev.data = lodash.assign(prev.data, x.data);
            prev.txid = prev.txid || x.txid;
            prev.amountStr = prev.amountStr || x.amountStr;
            prev.creatorName = prev.creatorName || x.creatorName;
          } else {
            finale.push(x);
            prev = x;
          }
        });

        var u = bwcService.getUtils();
        lodash.each(finale, function(x) {
          if (x.data && x.data.message && x.wallet && x.wallet.credentials.sharedEncryptingKey) {
            // TODO TODO TODO => BWC
            x.message = u.decryptMessage(x.data.message, x.wallet.credentials.sharedEncryptingKey);
          }
        });

        return finale;
      };

      lodash.each(w, function(wallet) {
        updateNotifications(wallet, function(err) {
          j++;
          if (err) {
            $log.warn('Error updating notifications:' + err);
          } else {

            var n;

            n = lodash.filter(wallet.cachedActivity.n, function(x) {
              return typeFilter[x.type];
            });

            var idToName = {};
            if (wallet.cachedStatus) {
              lodash.each(wallet.cachedStatus.wallet.copayers, function(c) {
                idToName[c.id] = c.name;
              });
            }

            lodash.each(n, function(x) {
              x.wallet = wallet;
              if (x.creatorId && wallet.cachedStatus) {
                x.creatorName = idToName[x.creatorId];
              };
            });

            notifications.push(n);
          }
          if (j == l) {
            notifications = lodash.sortBy(notifications, 'createdOn');
            notifications = lodash.compact(lodash.flatten(notifications)).slice(0, MAX);
            var total = notifications.length;
            return cb(null, process(notifications), total);
          };
        });
      });
    };


    root.getTxps = function(opts, cb) {
      var MAX = 100;
      opts = opts || {};

      var w = root.getWallets();
      if (lodash.isEmpty(w)) return cb();

      var txps = [];

      lodash.each(w, function(x) {
        if (x.pendingTxps)
          txps = txps.concat(x.pendingTxps);
      });
      var n = txps.length;
      txps = lodash.sortBy(txps, 'pendingForUs', 'createdOn');
      txps = lodash.compact(lodash.flatten(txps)).slice(0, opts.limit || MAX);
      return cb(null, txps, n);
    };

    return root;
  });

'use strict';
angular.module('copayApp.services').factory('pushNotificationsService', function pushNotificationsService($log, $state, $ionicHistory, sjcl, platformInfo, lodash, appConfigService, profileService, configService) {
  var root = {};
  var isIOS = platformInfo.isIOS;
  var isAndroid = platformInfo.isAndroid;
  var usePushNotifications = platformInfo.isCordova && !platformInfo.isWP;

  var _token = null;

  root.init = function() {
    if (!usePushNotifications || _token) return;
    configService.whenAvailable(function(config) {
      if (!config.pushNotificationsEnabled) return;
    
      $log.debug('Starting push notification registration...'); 

      //Keep in mind the function will return null if the token has not been established yet.
      FCMPlugin.getToken(function(token) {
        $log.debug('Get token for push notifications: ' + token);
        _token = token;
        root.enable();
      }); 
    }); 
  };

  root.updateSubscription = function(walletClient) {
    if (!_token) {
      $log.warn('Push notifications disabled for this device. Nothing to do here.');
      return;
    }
    _subscribe(walletClient);
  };

  root.enable = function() {
    if (!_token) {
      $log.warn('No token available for this device. Cannot set push notifications. Needs registration.');
      return;
    }

    var wallets = profileService.getWallets();
    lodash.forEach(wallets, function(walletClient) {
      _subscribe(walletClient);
    });
  };

  root.disable = function() {
    if (!_token) {
      $log.warn('No token available for this device. Cannot disable push notifications.');
      return;
    }

    var wallets = profileService.getWallets();
    lodash.forEach(wallets, function(walletClient) {
      _unsubscribe(walletClient);
    });
    _token = null;
  };

  root.unsubscribe = function(walletClient) {
    if (!_token) return;
    _unsubscribe(walletClient);
  };

  var _subscribe = function(walletClient) {
    var opts = {
      token : _token,
      platform: isIOS ? 'ios' : isAndroid ? 'android' : null,
      packageName : appConfigService.packageNameId
    };
    walletClient.pushNotificationsSubscribe(opts, function(err) {
      if (err) $log.error(walletClient.name + ': Subscription Push Notifications error. ', JSON.stringify(err));
      else $log.debug(walletClient.name + ': Subscription Push Notifications success.');
    });
  };

  var _unsubscribe = function(walletClient, cb) {
    walletClient.pushNotificationsUnsubscribe(_token, function(err) {
      if (err) $log.error(walletClient.name + ': Unsubscription Push Notifications error. ', JSON.stringify(err));
      else $log.debug(walletClient.name + ': Unsubscription Push Notifications Success.');
    });
  };

  var _openWallet = function(walletIdHashed) {
    var wallets = profileService.getWallets();
    var wallet = lodash.find(wallets, function(w) {
      return (lodash.isEqual(walletIdHashed, sjcl.codec.hex.fromBits(sjcl.hash.sha256.hash(w.id))));
    });

    if (!wallet) return;
    
    if (!wallet.isComplete()) {
      return $state.go('tabs.copayers', {
        walletId: wallet.id 
      });
    }

    $state.go('tabs.wallet', {
      walletId: wallet.id
    });
  };

  if (usePushNotifications) {
    
    FCMPlugin.onTokenRefresh(function(token) {
      if (!_token) return;
      $log.debug('Refresh and update token for push notifications...');
      _token = token;
      root.enable();
    });

    FCMPlugin.onNotification(function(data) {
      if (!_token) return;
      $log.debug('New Event Push onNotification: ' + JSON.stringify(data));
      if(data.wasTapped) {
        // Notification was received on device tray and tapped by the user. 
        var walletIdHashed = data.walletId;
        if (!walletIdHashed) return;
        $ionicHistory.nextViewOptions({
          disableAnimate: true,
          historyRoot: true
        });
        $ionicHistory.clearHistory();
        $state.go('tabs.home', {}, {
          'reload': true,
          'notify': $state.current.name == 'tabs.home' ? false : true
        }).then(function() {
          _openWallet(walletIdHashed);
        });
      } else {
        // TODO
        // Notification was received in foreground. Maybe the user needs to be notified. 
      }
    });
  } 

  return root;

});

'use strict';

//var util = require('util');
//var _ = require('lodash');
//var log = require('../util/log');
//var preconditions = require('preconditions').singleton();
//var request = require('request');

/*
  This class lets interfaces with BitPay's exchange rate API.
*/

var RateService = function(opts) {
  var self = this;

  opts = opts || {};
  self.httprequest = opts.httprequest; // || request;
  self.lodash = opts.lodash;

  self.SAT_TO_QYB = 1 / 1e8;
  self.QYB_TO_SAT = 1e8;
  self.UNAVAILABLE_ERROR = 'Service is not available - check for service.isAvailable() or use service.whenAvailable()';
  self.UNSUPPORTED_CURRENCY_ERROR = 'Currency not supported';

  self._isAvailable = false;
  self._rates = {};
  self._alternatives = [];
  self._ratesBCH = {};
  self._queued = [];

  self.updateRates();
};


var _instance;
RateService.singleton = function(opts) {
  if (!_instance) {
    _instance = new RateService(opts);
  }
  return _instance;
};

RateService.prototype.updateRates = function() {
  var self = this;

  var backoffSeconds = 5;
  var updateFrequencySeconds = 5 * 60;
  var rateServiceUrl = 'https://bitpay.com/api/rates';
  var bchRateServiceUrl = 'https://api.kraken.com/0/public/Ticker?pair=BCHUSD,BCHEUR';


  function getQYB(cb, tries) {
    tries = tries || 0;
    if (!self.httprequest) return;
    if (tries > 5) return cb('could not get QYB rates');

    //log.info('Fetching exchange rates');
    self.httprequest.get(rateServiceUrl).success(function(res) {
      self.lodash.each(res, function(currency) {
        self._rates[currency.code] = currency.rate;
        self._alternatives.push({
          name: currency.name,
          isoCode: currency.code,
          rate: currency.rate
        });
      });

      return cb();
    }).error(function() {
      //log.debug('Error fetching exchange rates', err);
      setTimeout(function() {
        backoffSeconds *= 1.5;
        getQYB(cb, tries++);
      }, backoffSeconds * 1000);
      return;
    })
  }

  function getBCH(cb, tries) {
    tries = tries || 0;
    if (!self.httprequest) return;
    if (tries > 5) return cb('could not get dmb rates');

    function retry(tries) {
      //log.debug('Error fetching exchange rates', err);
      setTimeout(function() {
        backoffSeconds *= 1.5;
        getQYB(cb, tries++);
      }, backoffSeconds * 1000);
      return;
    }

    self.httprequest.get(bchRateServiceUrl).success(function(res) {
      self.lodash.each(res.result, function(data, paircode) {
        var code = paircode.substr(3,3);
        var rate =data.c[0];
        self._ratesBCH[code] = rate;
      })
      return cb();
    }).error(function() {
      return retry(tries);
    })
  }

  getQYB(function(err) {
    if (err) return;
    getBCH(function(err) {
      if (err) return;

      self._isAvailable = true;
      self.lodash.each(self._queued, function(callback) {
        setTimeout(callback, 1);
      });
      setTimeout( self.updateRates  , updateFrequencySeconds * 1000);
    })
  })

};

RateService.prototype.getRate = function(code, chain) {
  if (chain == 'bch')
    return this._ratesBCH[code];
  else
    return this._rates[code];
};

RateService.prototype.getAlternatives = function() {
  return this._alternatives;
};

RateService.prototype.isAvailable = function() {
  return this._isAvailable;
};

RateService.prototype.whenAvailable = function(callback) {
  if (this.isAvailable()) {
    setTimeout(callback, 10);
  } else {
    this._queued.push(callback);
  }
};

RateService.prototype.toFiat = function(satoshis, code, chain) {
  if (!this.isAvailable()) {
    return null;
  }

  return satoshis * this.SAT_TO_QYB * this.getRate(code, chain);
};

RateService.prototype.fromFiat = function(amount, code, chain) {
  if (!this.isAvailable()) {
    return null;
  }
  return amount / this.getRate(code, chain) * this.QYB_TO_SAT;
};

RateService.prototype.listAlternatives = function(sort) {
  var self = this;
  if (!this.isAvailable()) {
    return [];
  }

  var alternatives = self.lodash.map(this.getAlternatives(), function(item) {
    return {
      name: item.name,
      isoCode: item.isoCode
    }
  });
  if (sort) {
    alternatives.sort(function(a, b) {
      return a.name.toLowerCase() > b.name.toLowerCase() ? 1 : -1;
    });
  }
  return self.lodash.uniq(alternatives, 'isoCode');
};

angular.module('copayApp.services').factory('rateService', function($http, lodash) {
  // var cfg = _.extend(config.rates, {
  //   httprequest: $http
  // });

  var cfg = {
    httprequest: $http,
    lodash: lodash
  };
  return RateService.singleton(cfg);
});

'use strict';

angular.module('copayApp.services').service('scannerService', function($log, $timeout, platformInfo, $rootScope, $window) {

  var isDesktop = !platformInfo.isCordova;
  var QRScanner = $window.QRScanner;
  var lightEnabled = false;
  var backCamera = true; // the plugin defaults to the back camera

  // Initalize known capabilities
  // Assume camera is available. If init fails, we'll set this to false.
  var isAvailable = true;
  var hasPermission = false;
  var isDenied = false;
  var isRestricted = false;
  var canEnableLight = false;
  var canChangeCamera = false;
  var canOpenSettings = false;

  function _checkCapabilities(status) {
    $log.debug('scannerService is reviewing platform capabilities...');
    // Permission can be assumed on the desktop builds
    hasPermission = (isDesktop || status.authorized) ? true : false;
    isDenied = status.denied ? true : false;
    isRestricted = status.restricted ? true : false;
    canEnableLight = status.canEnableLight ? true : false;
    canChangeCamera = status.canChangeCamera ? true : false;
    canOpenSettings = status.canOpenSettings ? true : false;
    _logCapabilities();
  }

  function _logCapabilities() {
    function _orIsNot(bool) {
      return bool ? '' : 'not ';
    }
    $log.debug('A camera is ' + _orIsNot(isAvailable) + 'available to this app.');
    var access = 'not authorized';
    if (hasPermission) access = 'authorized';
    if (isDenied) access = 'denied';
    if (isRestricted) access = 'restricted';
    $log.debug('Camera access is ' + access + '.');
    $log.debug('Support for opening device settings is ' + _orIsNot(canOpenSettings) + 'available on this platform.');
    $log.debug('A light is ' + _orIsNot(canEnableLight) + 'available on this platform.');
    $log.debug('A second camera is ' + _orIsNot(canChangeCamera) + 'available on this platform.');
  }

  /**
   * Immediately return known capabilities of the current platform.
   */
  this.getCapabilities = function() {
    return {
      isAvailable: isAvailable,
      hasPermission: hasPermission,
      isDenied: isDenied,
      isRestricted: isRestricted,
      canEnableLight: canEnableLight,
      canChangeCamera: canChangeCamera,
      canOpenSettings: canOpenSettings
    };
  };

  var initializeStarted = false;
  /**
   * If camera access has been granted, pre-initialize the QRScanner. This method
   * can be safely called before the scanner is visible to improve perceived
   * scanner loading times.
   *
   * The `status` of QRScanner is returned to the callback.
   */
  this.gentleInitialize = function(callback) {
    if (initializeStarted && !isDesktop) {
      QRScanner.getStatus(function(status) {
        _completeInitialization(status, callback);
      });
      return;
    }
    initializeStarted = true;
    $log.debug('Trying to pre-initialize QRScanner.');
    if (!isDesktop) {
      QRScanner.getStatus(function(status) {
        _checkCapabilities(status);
        if (status.authorized) {
          $log.debug('Camera permission already granted.');
          initialize(callback);
        } else {
          $log.debug('QRScanner not authorized, waiting to initalize.');
          _completeInitialization(status, callback);
        }
      });
    } else {
      $log.debug('To avoid flashing the privacy light, we do not pre-initialize the camera on desktop.');
    }
  };

  function initialize(callback) {
    $log.debug('Initializing scanner...');
    QRScanner.prepare(function(err, status) {
      if (err) {
        isAvailable = false;
        $log.error(err);
        // does not return `status` if there is an error
        QRScanner.getStatus(function(status) {
          _completeInitialization(status, callback);
        });
      } else {
        _completeInitialization(status, callback);
      }
    });
  }
  this.initialize = initialize;

  // This could be much cleaner with a Promise API
  // (needs a polyfill for some platforms)
  var initializeCompleted = false;

  function _completeInitialization(status, callback) {
    _checkCapabilities(status);
    initializeCompleted = true;
    $rootScope.$emit('scannerServiceInitialized');
    if (typeof callback === "function") {
      callback(status);
    }
  }
  this.isInitialized = function() {
    return initializeCompleted;
  };
  this.initializeStarted = function() {
    return initializeStarted;
  };

  var nextHide = null;
  var nextDestroy = null;
  var hideAfterSeconds = 5;
  var destroyAfterSeconds = 60;

  /**
   * (Re)activate the QRScanner, and cancel the timeouts if present.
   *
   * The `status` of QRScanner is passed to the callback when activation
   * is complete.
   */
  this.activate = function(callback) {
    $log.debug('Activating scanner...');
    QRScanner.show(function(status) {
      initializeCompleted = true;
      _checkCapabilities(status);
      if (typeof callback === "function") {
        callback(status);
      }
    });
    if (nextHide !== null) {
      $timeout.cancel(nextHide);
      nextHide = null;
    }
    if (nextDestroy !== null) {
      $timeout.cancel(nextDestroy);
      nextDestroy = null;
    }
  };

  /**
   * Start a new scan.
   *
   * The callback receives: (err, contents)
   */
  this.scan = function(callback) {
    $log.debug('Scanning...');
    QRScanner.scan(callback);
  };

  this.pausePreview = function() {
    QRScanner.pausePreview();
  };

  this.resumePreview = function() {
    QRScanner.resumePreview();
  };

  /**
   * Deactivate the QRScanner. To balance user-perceived performance and power
   * consumption, this kicks off a countdown which will "sleep" the scanner
   * after a certain amount of time.
   *
   * The `status` of QRScanner is passed to the callback when deactivation
   * is complete.
   */
  this.deactivate = function(callback) {
    $log.debug('Deactivating scanner...');
    QRScanner.cancelScan();
    nextHide = $timeout(_hide, hideAfterSeconds * 1000);
    nextDestroy = $timeout(_destroy, destroyAfterSeconds * 1000);
  };

  // Natively hide the QRScanner's preview
  // On mobile platforms, this can reduce GPU/power usage
  // On desktop, this fully turns off the camera (and any associated privacy lights)
  function _hide() {
    $log.debug('Scanner not in use for ' + hideAfterSeconds + ' seconds, hiding...');
    QRScanner.hide();
  }

  // Reduce QRScanner power/processing consumption by the maximum amount
  function _destroy() {
    $log.debug('Scanner not in use for ' + destroyAfterSeconds + ' seconds, destroying...');
    QRScanner.destroy();
  }

  this.reinitialize = function(callback) {
    initializeCompleted = false;
    QRScanner.destroy();
    initialize(callback);
  };

  /**
   * Toggle the device light (if available).
   *
   * The callback receives a boolean which is `true` if the light is enabled.
   */
  this.toggleLight = function(callback) {
    $log.debug('Toggling light...');
    if (lightEnabled) {
      QRScanner.disableLight(_handleResponse);
    } else {
      QRScanner.enableLight(_handleResponse);
    }

    function _handleResponse(err, status) {
      if (err) {
        $log.error(err);
      } else {
        lightEnabled = status.lightEnabled;
        var state = lightEnabled ? 'enabled' : 'disabled';
        $log.debug('Light ' + state + '.');
      }
      callback(lightEnabled);
    }
  };

  /**
   * Switch cameras (if a second camera is available).
   *
   * The `status` of QRScanner is passed to the callback when activation
   * is complete.
   */
  this.toggleCamera = function(callback) {
    var nextCamera = backCamera ? 1 : 0;

    function cameraToString(index) {
      return index === 1 ? 'front' : 'back'; // front = 1, back = 0
    }
    $log.debug('Toggling to the ' + cameraToString(nextCamera) + ' camera...');
    QRScanner.useCamera(nextCamera, function(err, status) {
      if (err) {
        $log.error(err);
      }
      backCamera = status.currentCamera === 1 ? false : true;
      $log.debug('Camera toggled. Now using the ' + cameraToString(backCamera) + ' camera.');
      callback(status);
    });
  };

  this.openSettings = function() {
    $log.debug('Attempting to open device settings...');
    QRScanner.openSettings();
  };

  this.useOldScanner = function(callback) {
    cordova.plugins.barcodeScanner.scan(
      function(result) {
        callback(null, result.text);
      },
      function(error) {
        callback(error);
      }
    );
  }
});

'use strict';

angular.module('copayApp.services').service('sendMaxService', function(feeService, configService, walletService) {

  /**
   * Get sendMaxInfo
   *
   * @param {Obj} Wallet
   * @param {Callback} Function (optional)
   *
   */
  this.getInfo = function(wallet, cb) {
    feeService.getCurrentFeeRate(wallet.coin, wallet.credentials.network, function(err, feePerKb) {
      if (err) return cb(err);

      var config = configService.getSync().wallet;

      walletService.getSendMaxInfo(wallet, {
        feePerKb: feePerKb,
        excludeUnconfirmedUtxos: !config.spendUnconfirmed,
        returnInputs: true,
      }, function(err, resp) {
        if (err) return cb(err);

        return cb(null, {
          sendMax: true,
          amount: resp.amount,
          inputs: resp.inputs,
          fee: resp.fee,
          feePerKb: feePerKb,
        });
      });
    });
  };

});

'use strict';
angular.module('copayApp.services').factory('shapeshiftService', function($http, $log, $window, lodash, moment, storageService, configService, platformInfo, nextStepsService, homeIntegrationsService) {
  var root = {};
  var credentials = {};

  // (Optional) Affiliate PUBLIC KEY, for volume tracking, affiliate payments, split-shifts, etc.
  if ($window.externalServices && $window.externalServices.shapeshift) {
    credentials.API_KEY = $window.externalServices.shapeshift.api_key || null;
  }

  /*
   * Development: 'testnet'
   * Production: 'livenet'
   */
  credentials.NETWORK = 'livenet';
  //credentials.NETWORK = 'testnet';

  if (credentials.NETWORK == 'testnet') {
    credentials.API_URL = "";
  } else {
    // CORS: cors.shapeshift.io
    credentials.API_URL = "https://shapeshift.io";
  }

  var homeItem = {
    name: 'shapeshift',
    title: 'ShapeShift',
    icon: 'icon-shapeshift',
    sref: 'tabs.shapeshift',
  };

  var _get = function(endpoint) {
    return {
      method: 'GET',
      url: credentials.API_URL + endpoint,
      headers: {
        'content-type': 'application/json'
      }
    };
  };

  var _post = function(endpoint, data) {
    return {
      method: 'POST',
      url: credentials.API_URL + endpoint,
      headers: {
        'content-type': 'application/json'
      },
      data: data
    };
  };

  root.getNetwork = function() {
    return credentials.NETWORK;
  };

  root.shift = function(data, cb) {

    var dataSrc = {
      withdrawal: data.withdrawal,
      pair: data.pair,
      returnAddress: data.returnAddress,
      apiKey: credentials.API_KEY
    };

    $http(_post('/shift', dataSrc)).then(function(data) {
      $log.info('Shapeshift SHIFT: SUCCESS');
      return cb(null, data.data);
    }, function(data) {
      $log.error('Shapeshift SHIFT ERROR', data);
      return cb(data);
    });
  };

  root.saveShapeshift = function(data, opts, cb) {
    var network = root.getNetwork();
    storageService.getShapeshift(network, function(err, oldData) {
      if (lodash.isString(oldData)) {
        oldData = JSON.parse(oldData);
      }
      if (lodash.isString(data)) {
        data = JSON.parse(data);
      }
      var inv = oldData || {};
      inv[data.address] = data;
      if (opts && (opts.error || opts.status)) {
        inv[data.address] = lodash.assign(inv[data.address], opts);
      }
      if (opts && opts.remove) {
        delete(inv[data.address]);
      }

      inv = JSON.stringify(inv);


      storageService.setShapeshift(network, inv, function(err) {
        homeIntegrationsService.register(homeItem);
        nextStepsService.unregister(homeItem.name);
        return cb(err);
      });
    });
  };

  root.getShapeshift = function(cb) {
    var network = root.getNetwork();
    storageService.getShapeshift(network, function(err, ss) {
      var _gcds = ss ? JSON.parse(ss) : null;
      return cb(err, _gcds);
    });
  };

  root.getRate = function(pair, cb) {
    $http(_get('/rate/' + pair)).then(function(data) {
      $log.info('Shapeshift PAIR: SUCCESS');
      return cb(null, data.data);
    }, function(data) {
      $log.error('Shapeshift PAIR ERROR', data);
      return cb(data);
    });
  };

  root.getLimit = function(pair, cb) {
    $http(_get('/limit/' + pair)).then(function(data) {
      $log.info('Shapeshift LIMIT: SUCCESS');
      return cb(null, data.data);
    }, function(data) {
      $log.error('Shapeshift LIMIT ERROR', data);
      return cb(data);
    });
  };

  root.getStatus = function(addr, cb) {
    $http(_get('/txStat/' + addr)).then(function(data) {
      $log.info('Shapeshift STATUS: SUCCESS');
      return cb(null, data.data);
    }, function(data) {
      $log.error('Shapeshift STATUS ERROR', data);
      return cb(data);
    });
  };

  var register = function() {
    storageService.getShapeshift(root.getNetwork(), function(err, ss) {
      if (ss) {
        homeIntegrationsService.register(homeItem);
      } else {
        nextStepsService.register(homeItem);
      }
    });
  };

  register();
  return root;
});


'use strict';
angular.module('copayApp.services')
  .factory('sjcl', function bitcoreFactory(bwcService) {
    var sjcl = bwcService.getSJCL();
    return sjcl;
  });

'use strict';

angular.module('copayApp.services').service('startupService', function($log, $timeout) {

  var splashscreenVisible = true;
  var statusBarVisible = false;

  function _hideSplash(){
    if(typeof navigator.splashscreen !== "undefined" && splashscreenVisible){
      $log.debug('startupService is hiding the splashscreen...');
      $timeout(function(){
        navigator.splashscreen.hide();
      }, 20);
      splashscreenVisible = false;
    }
  }
  function _showStatusBar(){
    if(typeof StatusBar !== "undefined" && !statusBarVisible){
      $log.debug('startupService is showing the StatusBar...');
      StatusBar.show();
      statusBarVisible = true;
    }
  }
  this.ready = function() {
    _showStatusBar();
    _hideSplash();
  };
});

'use strict';
angular.module('copayApp.services')
  .factory('storageService', function(logHeader, fileStorageService, localStorageService, sjcl, $log, lodash, platformInfo, $timeout) {

    var root = {};
    var storage;

    // File storage is not supported for writing according to
    // https://github.com/apache/cordova-plugin-file/#supported-platforms
    var shouldUseFileStorage = platformInfo.isCordova && !platformInfo.isWP;

    if (shouldUseFileStorage) {
      $log.debug('Using: FileStorage');
      storage = fileStorageService;
    } else {
      $log.debug('Using: LocalStorage');
      storage = localStorageService;
    }

    var getUUID = function(cb) {
      // TO SIMULATE MOBILE
      //return cb('hola');
      if (!window || !window.plugins || !window.plugins.uniqueDeviceID)
        return cb(null);

      window.plugins.uniqueDeviceID.get(
        function(uuid) {
          return cb(uuid);
        }, cb);
    };

    // This is only used in Qyb, we used to encrypt profile
    // using device's UUID.

    var decryptOnMobile = function(text, cb) {
      var json;
      try {
        json = JSON.parse(text);
      } catch (e) {
        $log.warn('Could not open profile:' + text);

        var i = text.lastIndexOf('}{');
        if (i > 0) {
          text = text.substr(i + 1);
          $log.warn('trying last part only:' + text);
          try {
            json = JSON.parse(text);
            $log.warn('Worked... saving.');
            storage.set('profile', text, function() {});
          } catch (e) {
            $log.warn('Could not open profile (2nd try):' + e);
          };
        };

      };

      if (!json) return cb('Could not access storage')

      if (!json.iter || !json.ct) {
        $log.debug('Profile is not encrypted');
        return cb(null, text);
      }

      $log.debug('Profile is encrypted');
      getUUID(function(uuid) {
        $log.debug('Device UUID:' + uuid);
        if (!uuid)
          return cb('Could not decrypt storage: could not get device ID');

        try {
          text = sjcl.decrypt(uuid, text);

          $log.info('Migrating to unencrypted profile');
          return storage.set('profile', text, function(err) {
            return cb(err, text);
          });
        } catch (e) {
          $log.warn('Decrypt error: ', e);
          return cb('Could not decrypt storage: device ID mismatch');
        };
        return cb(null, text);
      });
    };

    // This is only use in Qyb, for very old instalations
    // in which we use to use localStorage instead of fileStorage
    root.tryToMigrate = function(cb) {
      if (!shouldUseFileStorage) return cb();

      localStorageService.get('profile', function(err, str) {
        if (err) return cb(err);
        if (!str) return cb();

        $log.info('Starting Migration profile to File storage...');

        fileStorageService.create('profile', str, function(err) {
          if (err) cb(err);
          $log.info('Profile Migrated successfully');

          localStorageService.get('config', function(err, c) {
            if (err) return cb(err);
            if (!c) return root.getProfile(cb);

            fileStorageService.create('config', c, function(err) {

              if (err) {
                $log.info('Error migrating config: ignoring', err);
                return root.getProfile(cb);
              }
              $log.info('Config Migrated successfully');
              return root.getProfile(cb);
            });
          });
        });
      });
    };

    root.storeNewProfile = function(profile, cb) {
      storage.create('profile', profile.toObj(), cb);
    };

    root.storeProfile = function(profile, cb) {
      storage.set('profile', profile.toObj(), cb);
    };

    root.getProfile = function(cb) {
      storage.get('profile', function(err, str) {
        if (err || !str)
          return cb(err);

        decryptOnMobile(str, function(err, str) {
          if (err) return cb(err);
          var p, err;
          try {
            p = Profile.fromString(str);
          } catch (e) {
            $log.debug('Could not read profile:', e);
            err = new Error('Could not read profile:' + p);
          }
          return cb(err, p);
        });
      });
    };

    root.deleteProfile = function(cb) {
      storage.remove('profile', cb);
    };

    root.setFeedbackInfo = function(feedbackValues, cb) {
      storage.set('feedback', feedbackValues, cb);
    };

    root.getFeedbackInfo = function(cb) {
      storage.get('feedback', cb);
    };

    root.storeFocusedWalletId = function(id, cb) {
      storage.set('focusedWalletId', id || '', cb);
    };

    root.getFocusedWalletId = function(cb) {
      storage.get('focusedWalletId', cb);
    };

    root.getLastAddress = function(walletId, cb) {
      storage.get('lastAddress-' + walletId, cb);
    };

    root.storeLastAddress = function(walletId, address, cb) {
      storage.set('lastAddress-' + walletId, address, cb);
    };

    root.clearLastAddress = function(walletId, cb) {
      storage.remove('lastAddress-' + walletId, cb);
    };

    root.setBackupFlag = function(walletId, cb) {
      storage.set('backup-' + walletId, Date.now(), cb);
    };

    root.getBackupFlag = function(walletId, cb) {
      storage.get('backup-' + walletId, cb);
    };

    root.clearBackupFlag = function(walletId, cb) {
      storage.remove('backup-' + walletId, cb);
    };

    root.setCleanAndScanAddresses = function(walletId, cb) {
      storage.set('CleanAndScanAddresses', walletId, cb);
    };

    root.getCleanAndScanAddresses = function(cb) {
      storage.get('CleanAndScanAddresses', cb);
    };

    root.removeCleanAndScanAddresses = function(cb) {
      storage.remove('CleanAndScanAddresses', cb);
    };

    root.getConfig = function(cb) {
      storage.get('config', cb);
    };

    root.storeConfig = function(val, cb) {
      $log.debug('Storing Preferences', val);
      storage.set('config', val, cb);
    };

    root.clearConfig = function(cb) {
      storage.remove('config', cb);
    };

    root.getHomeTipAccepted = function(cb) {
      storage.get('homeTip', cb);
    };

    root.setHomeTipAccepted = function(val, cb) {
      storage.set('homeTip', val, cb);
    };

    root.setHideBalanceFlag = function(walletId, val, cb) {
      storage.set('hideBalance-' + walletId, val, cb);
    };

    root.getHideBalanceFlag = function(walletId, cb) {
      storage.get('hideBalance-' + walletId, cb);
    };

    //for compatibility
    root.getCopayDisclaimerFlag = function(cb) {
      storage.get('agreeDisclaimer', cb);
    };

    root.setRemotePrefsStoredFlag = function(cb) {
      storage.set('remotePrefStored', true, cb);
    };

    root.getRemotePrefsStoredFlag = function(cb) {
      storage.get('remotePrefStored', cb);
    };

    root.setGlideraToken = function(network, token, cb) {
      storage.set('glideraToken-' + network, token, cb);
    };

    root.getGlideraToken = function(network, cb) {
      storage.get('glideraToken-' + network, cb);
    };

    root.removeGlideraToken = function(network, cb) {
      storage.remove('glideraToken-' + network, cb);
    };

    root.setGlideraPermissions = function(network, p, cb) {
      storage.set('glideraPermissions-' + network, p, cb);
    };

    root.getGlideraPermissions = function(network, cb) {
      storage.get('glideraPermissions-' + network, cb);
    };

    root.removeGlideraPermissions = function(network, cb) {
      storage.remove('glideraPermissions-' + network, cb);
    };

    root.setGlideraStatus = function(network, status, cb) {
      storage.set('glideraStatus-' + network, status, cb);
    };

    root.getGlideraStatus = function(network, cb) {
      storage.get('glideraStatus-' + network, cb);
    };

    root.removeGlideraStatus = function(network, cb) {
      storage.remove('glideraStatus-' + network, cb);
    };

    root.setGlideraTxs = function(network, txs, cb) {
      storage.set('glideraTxs-' + network, txs, cb);
    };

    root.getGlideraTxs = function(network, cb) {
      storage.get('glideraTxs-' + network, cb);
    };

    root.removeGlideraTxs = function(network, cb) {
      storage.remove('glideraTxs-' + network, cb);
    };

    root.setCoinbaseRefreshToken = function(network, token, cb) {
      storage.set('coinbaseRefreshToken-' + network, token, cb);
    };

    root.getCoinbaseRefreshToken = function(network, cb) {
      storage.get('coinbaseRefreshToken-' + network, cb);
    };

    root.removeCoinbaseRefreshToken = function(network, cb) {
      storage.remove('coinbaseRefreshToken-' + network, cb);
    };

    root.setCoinbaseToken = function(network, token, cb) {
      storage.set('coinbaseToken-' + network, token, cb);
    };

    root.getCoinbaseToken = function(network, cb) {
      storage.get('coinbaseToken-' + network, cb);
    };

    root.removeCoinbaseToken = function(network, cb) {
      storage.remove('coinbaseToken-' + network, cb);
    };

    root.setAddressbook = function(network, addressbook, cb) {
      storage.set('addressbook-' + network, addressbook, cb);
    };

    root.getAddressbook = function(network, cb) {
      storage.get('addressbook-' + network, cb);
    };

    root.removeAddressbook = function(network, cb) {
      storage.remove('addressbook-' + network, cb);
    };

    root.setLastCurrencyUsed = function(lastCurrencyUsed, cb) {
      storage.set('lastCurrencyUsed', lastCurrencyUsed, cb)
    };

    root.getLastCurrencyUsed = function(cb) {
      storage.get('lastCurrencyUsed', cb)
    };

    root.checkQuota = function() {
      var block = '';
      // 50MB
      for (var i = 0; i < 1024 * 1024; ++i) {
        block += '12345678901234567890123456789012345678901234567890';
      }
      storage.set('test', block, function(err) {
        $log.error('CheckQuota Return:' + err);
      });
    };

    root.setTxHistory = function(txs, walletId, cb) {
      try {
        storage.set('txsHistory-' + walletId, txs, cb);
      } catch (e) {
        $log.error('Error saving tx History. Size:' + txs.length);
        $log.error(e);
        return cb(e);
      }
    }

    root.getTxHistory = function(walletId, cb) {
      storage.get('txsHistory-' + walletId, cb);
    }

    root.removeTxHistory = function(walletId, cb) {
      storage.remove('txsHistory-' + walletId, cb);
    }

    root.setCoinbaseTxs = function(network, ctx, cb) {
      storage.set('coinbaseTxs-' + network, ctx, cb);
    };

    root.getCoinbaseTxs = function(network, cb) {
      storage.get('coinbaseTxs-' + network, cb);
    };

    root.removeCoinbaseTxs = function(network, cb) {
      storage.remove('coinbaseTxs-' + network, cb);
    };

    root.setBalanceCache = function(cardId, data, cb) {
      storage.set('balanceCache-' + cardId, data, cb);
    };

    root.getBalanceCache = function(cardId, cb) {
      storage.get('balanceCache-' + cardId, cb);
    };

    root.removeBalanceCache = function(cardId, cb) {
      storage.remove('balanceCache-' + cardId, cb);
    };

    // cards: [
    //   eid: card id
    //   id: card id
    //   lastFourDigits: card number
    //   token: card token
    // ]
    root.setBitpayDebitCards = function(network, email, cards, cb) {
      root.getBitpayAccounts(network, function(err, allAccounts) {
        if (err) return cb(err);

        if (!allAccounts[email]) {
          return cb('Cannot set cards for unknown account ' + email);
        }

        allAccounts[email].cards = cards;
        storage.set('bitpayAccounts-v2-' + network, allAccounts, cb);
      });
    };

    // cb(err, cards)
    // cards: [
    //   eid: card id
    //   id: card id
    //   lastFourDigits: card number
    //   token: card token
    //   email: account email
    // ]
    root.getBitpayDebitCards = function(network, cb) {
      root.getBitpayAccounts(network, function(err, allAccounts) {
        if (err) return cb(err);

        var allCards = [];

        lodash.each(allAccounts, function(account, email) {

          if (account.cards) {
            // Add account's email to each card
            var cards = lodash.clone(account.cards);
            lodash.each(cards, function(x) {
              x.email = email;
            });

            allCards = allCards.concat(cards);
          }
        });

        return cb(null, allCards);
      });
    };

    root.removeBitpayDebitCard = function(network, cardEid, cb) {
      root.getBitpayAccounts(network, function(err, allAccounts) {

        lodash.each(allAccounts, function(account) {
          account.cards = lodash.reject(account.cards, {
            'eid': cardEid
          });
        });

        storage.set('bitpayAccounts-v2-' + network, allAccounts, cb);
      });
    };

    // cb(err, accounts)
    // accounts: {
    //   email_1: {
    //     token: account token
    //     cards: {
    //       <card-data>
    //     }
    //   }
    //   ...
    //   email_n: {
    //    token: account token
    //    cards: {
    //       <card-data>
    //     }
    //   }
    // }
    //
    root.getBitpayAccounts = function(network, cb) {
      storage.get('bitpayAccounts-v2-' + network, function(err, allAccountsStr) {
        if (err) return cb(err);

        if (!allAccountsStr)
          return cb(null, {});

        var allAccounts = {};
        try {
          allAccounts = JSON.parse(allAccountsStr);
        } catch (e) {
          $log.error('Bad storage value for bitpayAccount-v2' + allAccountsStr)
          return cb(null, {});
        };

        var anyMigration;

        lodash.each(allAccounts, function(account, email) {

          // Migrate old `'bitpayApi-' + network` key, if exists
          if (!account.token && account['bitpayApi-' + network].token) {

            $log.info('Migrating all bitpayApi-network branch');
            account.token = account['bitpayApi-' + network].token;
            account.cards = lodash.clone(account['bitpayApi-' + network].cards);
            if (!account.cards) {
              account.cards = lodash.clone(account['bitpayDebitCards-' + network]);
            }

            delete account['bitpayDebitCards-' + network];
            delete account['bitpayApi-' + network];
            anyMigration = true;

          }
        });

        if (anyMigration) {
          storage.set('bitpayAccounts-v2-' + network, allAccounts, function() {
            return cb(err, allAccounts);
          });
        } else
          return cb(err, allAccounts);

      });
    };

    // data: {
    //   email: account email
    //   token: account token
    //   familyName: account family (last) name
    //   givenName: account given (first) name
    // }
    root.setBitpayAccount = function(network, data, cb) {
      if (!lodash.isObject(data) || !data.email || !data.token)
        return cb('No account to set');

      root.getBitpayAccounts(network, function(err, allAccounts) {
        if (err) return cb(err);

        allAccounts = allAccounts || {};
        var account = allAccounts[data.email] || {};
        account.token = data.token;
        account.familyName = data.familyName;
        account.givenName = data.givenName;

        allAccounts[data.email] = account;

        $log.info('Storing BitPay accounts with new account:' + data.email);
        storage.set('bitpayAccounts-v2-' + network, allAccounts, cb);
      });
    };

    // account: {
    //   email: account email
    //   apiContext: the context needed for making future api calls
    //   cards: an array of cards
    // }
    root.removeBitpayAccount = function(network, account, cb) {
      if (lodash.isString(account)) {
        account = JSON.parse(account);
      }
      account = account || {};
      if (lodash.isEmpty(account)) return cb('No account to remove');
      storage.get('bitpayAccounts-v2-' + network, function(err, bitpayAccounts) {
        if (err) cb(err);
        if (lodash.isString(bitpayAccounts)) {
          bitpayAccounts = JSON.parse(bitpayAccounts);
        }
        bitpayAccounts = bitpayAccounts || {};
        delete bitpayAccounts[account.email];
        storage.set('bitpayAccounts-v2-' + network, JSON.stringify(bitpayAccounts), cb);
      });
    };

    root.setAppIdentity = function(network, data, cb) {
      storage.set('appIdentity-' + network, data, cb);
    };

    root.getAppIdentity = function(network, cb) {
      storage.get('appIdentity-' + network, function(err, data) {
        if (err) return cb(err);
        cb(err, JSON.parse(data || '{}'));
      });
    };

    root.removeAppIdentity = function(network, cb) {
      storage.remove('appIdentity-' + network, cb);
    };

    root.removeAllWalletData = function(walletId, cb) {
      root.clearLastAddress(walletId, function(err) {
        if (err) return cb(err);
        root.removeTxHistory(walletId, function(err) {
          if (err) return cb(err);
          root.clearBackupFlag(walletId, function(err) {
            return cb(err);
          });
        });
      });
    };

    root.setAmazonGiftCards = function(network, gcs, cb) {
      storage.set('amazonGiftCards-' + network, gcs, cb);
    };

    root.getAmazonGiftCards = function(network, cb) {
      storage.get('amazonGiftCards-' + network, cb);
    };

    root.removeAmazonGiftCards = function(network, cb) {
      storage.remove('amazonGiftCards-' + network, cb);
    };

    root.setTxConfirmNotification = function(txid, val, cb) {
      storage.set('txConfirmNotif-' + txid, val, cb);
    };

    root.getTxConfirmNotification = function(txid, cb) {
      storage.get('txConfirmNotif-' + txid, cb);
    };

    root.removeTxConfirmNotification = function(txid, cb) {
      storage.remove('txConfirmNotif-' + txid, cb);
    };

    root.setMercadoLibreGiftCards = function(network, gcs, cb) {
      storage.set('mercadoLibreGiftCards-' + network, gcs, cb);
    };

    root.getMercadoLibreGiftCards = function(network, cb) {
      storage.get('mercadoLibreGiftCards-' + network, cb);
    };

    root.removeMercadoLibreGiftCards = function(network, cb) {
      storage.remove('MercadoLibreGiftCards-' + network, cb);
    };

    root.setShapeshift = function(network, gcs, cb) {
      storage.set('shapeShift-' + network, gcs, cb);
    };

    root.getShapeshift = function(network, cb) {
      storage.get('shapeShift-' + network, cb);
    };

    root.removeShapeshift = function(network, cb) {
      storage.remove('shapeShift-' + network, cb);
    };

    return root;
  });

'use strict';

angular.module('copayApp.services').factory('timeService', function() {
  var root = {};

  root.withinSameMonth = function(time1, time2) {
    if (!time1 || !time2) return false;
    var date1 = new Date(time1);
    var date2 = new Date(time2);
    return root.getMonthYear(date1) === root.getMonthYear(date2);
  }

  root.withinPastDay = function(time) {
    var now = new Date();
    var date = new Date(time);
    return (now.getTime() - date.getTime()) < (1000 * 60 * 60 * 24);
  };

  root.isDateInCurrentMonth = function(date) {
    var now = new Date();
    return root.getMonthYear(now) === root.getMonthYear(date);
  };

  root.getMonthYear = function(date) {
    return date.getMonth() + date.getFullYear();
  }

  return root;

});

'use strict';

angular.module('copayApp.services')
  .factory('trezor', function($log, $timeout, lodash, bitcore, hwWallet, platformInfo) {
    var root = {};

    var SETTLE_TIME = 3000;
    root.callbacks = {};

    root.description = {
      supported: platformInfo.supportsTrezor,
      id: 'trezor',
      name: 'Trezor',
      longName: 'Trezor Hardware Wallet',
      derivationStrategy: 'BIP48',
      isEmbeddedHardware: false,
      supportsTestnet: false
    };

    root.getEntropySource = function(isMultisig, account, callback) {
      root.getXPubKey(hwWallet.getEntropyPath(root.description.id, isMultisig, account), function(data) {
        if (!data.success)
          return callback(hwWallet._err(data));

        return callback(null, hwWallet.pubKeyToEntropySource(data.xpubkey));
      });
    };


    root.getXPubKey = function(path, callback) {
      $log.debug('TREZOR deriving xPub path:', path);
      try {
        TrezorConnect.getXPubKey(path, callback);
      } catch (e) {
        callback('Error connecting Trezor');
      }
    };

    root.initSource = function(opts, callback) {
      // No initialization for this hardware source.
      return callback(opts);
    };

    root.getInfoForNewWallet = function(isMultisig, account, networkName, callback) {
      // networkName not used for this hardware (always livenet)
      var opts = {};
      root.getEntropySource(isMultisig, account, function(err, data) {
        if (err) return callback(err);
        opts.entropySource = data;
        $log.debug('Waiting TREZOR to settle...');
        $timeout(function() {

          root.getXPubKey(hwWallet.getAddressPath(root.description.id, isMultisig, account), function(data) {
            if (!data.success)
              return callback(hwWallet._err(data));

            opts.extendedPublicKey = data.xpubkey;
            opts.externalSource = root.description.id;

            if (isMultisig)
              opts.derivationStrategy = 'BIP48';

            return callback(null, opts);
          });
        }, SETTLE_TIME);
      });
    };

    root._orderPubKeys = function(xPub, np) {
      var xPubKeys = lodash.clone(xPub);
      var path = lodash.clone(np);
      path.unshift('m');
      path = path.join('/');

      var keys = lodash.map(xPubKeys, function(x) {
        var pub = (new bitcore.HDPublicKey(x)).derive(path).publicKey;
        return {
          xpub: x,
          pub: pub.toString('hex'),
        };
      });

      var sorted = lodash.sortBy(keys, function(x) {
        return x.pub;
      });

      return lodash.pluck(sorted, 'xpub');
    };

    root.signTx = function(xPubKeys, txp, account, callback) {

      var inputs = [],
        outputs = [];
      var tmpOutputs = [];

      if (txp.type && txp.type != 'simple') {
        return callback('Only TXPs type SIMPLE are supported in TREZOR');
      } else if (txp.outputs) {
        if (txp.outputs.length > 1)
          return callback('Only single output TXPs are supported in TREZOR');
      } else {
        return callback('Unknown TXP at TREZOR');
      }

      if (txp.outputs) {

        if (!txp.toAddress)
          txp.toAddress = txp.outputs[0].toAddress;

        if (!txp.amount)
          txp.amount = txp.outputs[0].amount;
      }

      if (!txp.toAddress || !txp.amount)
        return callback('No address or amount at TREZOR signing');


      var toScriptType = 'PAYTOADDRESS';
      if (txp.toAddress.charAt(0) == '2' || txp.toAddress.charAt(0) == '3')
        toScriptType = 'PAYTOSCRIPTHASH';


      // Add to
      tmpOutputs.push({
        address: txp.toAddress,
        amount: txp.amount,
        script_type: toScriptType,
      });



      if (txp.addressType == 'P2PKH') {

        $log.debug("Trezor signing uni-sig p2pkh. Account:", account);

        var inAmount = 0;
        inputs = lodash.map(txp.inputs, function(i) {
          $log.debug("Trezor TX input path:", i.path);
          var pathArr = i.path.split('/');
          var n = [hwWallet.UNISIG_ROOTPATH | 0x80000000, 0 | 0x80000000, account | 0x80000000, parseInt(pathArr[1]), parseInt(pathArr[2])];
          inAmount += i.satoshis;
          return {
            address_n: n,
            prev_index: i.vout,
            prev_hash: i.txid,
          };
        });

        var change = inAmount - txp.fee - txp.amount;
        if (change > 0) {
          $log.debug("Trezor TX change path:", txp.changeAddress.path);
          var pathArr = txp.changeAddress.path.split('/');
          var n = [hwWallet.UNISIG_ROOTPATH | 0x80000000, 0 | 0x80000000, account | 0x80000000, parseInt(pathArr[1]), parseInt(pathArr[2])];

          tmpOutputs.push({
            address_n: n,
            amount: change,
            script_type: 'PAYTOADDRESS'
          });
        }

      } else {

        // P2SH Wallet, multisig wallet
        var inAmount = 0;
        $log.debug("Trezor signing multi-sig p2sh. Account:", account);

        var sigs = xPubKeys.map(function(v) {
          return '';
        });

        inputs = lodash.map(txp.inputs, function(i) {
          $log.debug("Trezor TX input path:", i.path);
          var pathArr = i.path.split('/');
          var n = [hwWallet.MULTISIG_ROOTPATH | 0x80000000, 0 | 0x80000000, account | 0x80000000, parseInt(pathArr[1]), parseInt(pathArr[2])];
          var np = n.slice(3);

          inAmount += i.satoshis;

          var orderedPubKeys = root._orderPubKeys(xPubKeys, np);
          var pubkeys = orderedPubKeys.map(function(v) {
            return {
              node: v,
              address_n: np,
            };
          });

          return {
            address_n: n,
            prev_index: i.vout,
            prev_hash: i.txid,
            script_type: 'SPENDMULTISIG',
            multisig: {
              pubkeys: pubkeys,
              signatures: sigs,
              m: txp.requiredSignatures,
            }
          };
        });

        var change = inAmount - txp.fee - txp.amount;
        if (change > 0) {
          $log.debug("Trezor TX change path:", txp.changeAddress.path);
          var pathArr = txp.changeAddress.path.split('/');
          var n = [hwWallet.MULTISIG_ROOTPATH | 0x80000000, 0 | 0x80000000, account | 0x80000000, parseInt(pathArr[1]), parseInt(pathArr[2])];
          var np = n.slice(3);

          var orderedPubKeys = root._orderPubKeys(xPubKeys, np);
          var pubkeys = orderedPubKeys.map(function(v) {
            return {
              node: v,
              address_n: np,
            };
          });

          tmpOutputs.push({
            address_n: n,
            amount: change,
            script_type: 'PAYTOMULTISIG',
            multisig: {
              pubkeys: pubkeys,
              signatures: sigs,
              m: txp.requiredSignatures,
            }
          });
        }
      }

      // Shuffle outputs for improved privacy
      if (tmpOutputs.length > 1) {
        outputs = new Array(tmpOutputs.length);
        lodash.each(txp.outputOrder, function(order) {
          outputs[order] = tmpOutputs.shift();
        });

        if (tmpOutputs.length)
          return cb("Error creating transaction: tmpOutput order");
      } else {
        outputs = tmpOutputs;
      }

      // Prevents: Uncaught DataCloneError: Failed to execute 'postMessage' on 'Window': An object could not be cloned.
      inputs = JSON.parse(JSON.stringify(inputs));
      outputs = JSON.parse(JSON.stringify(outputs));

      $log.debug('Signing with TREZOR', inputs, outputs);
      TrezorConnect.signTx(inputs, outputs, function(res) {
        if (!res.success)
          return callback(hwWallet._err(res));

        callback(null, res);
      });
    };

    return root;
  });

'use strict';
angular.module('copayApp.services').factory('txConfirmNotification', function txConfirmNotification($log, storageService) {
  var root = {};

  root.checkIfEnabled = function(txid, cb) {
    storageService.getTxConfirmNotification(txid, function(err, res) {
      if (err) $log.error(err);
      return cb(!!res);
    });
  };

  root.subscribe = function(client, opts) {
    client.txConfirmationSubscribe(opts, function(err, res) {
      if (err) $log.error(err);
      storageService.setTxConfirmNotification(opts.txid, true, function(err) {
        if (err) $log.error(err);
      });
    });
  };

  root.unsubscribe = function(client, txId) {
    client.txConfirmationUnsubscribe(txId, function(err, res) {
      if (err) $log.error(err);
      storageService.removeTxConfirmNotification(txId, function(err) {
        if (err) $log.error(err);
      });
    });
  };

  return root;

});

'use strict';

angular.module('copayApp.services').factory('txFormatService', function($filter, bwcService, rateService, configService, lodash) {
  var root = {};

  root.Utils = bwcService.getUtils();


  root.formatCoin = function(coin){
    //return (coin).toUpperCase(); //@ipinko: default; TODO: refactoring;

    switch (coin) {
      case 'btc':
        return 'QYB';
      case 'bch':
        return 'dmb';
    }
    return (coin).toUpperCase();
  };

  root.formatAmount = function(satoshis, fullPrecision) {
    var config = configService.getDefaults().wallet.settings;
    if (config.unitCode == 'sat') return satoshis;

    //TODO : now only works for english, specify opts to change thousand separator and decimal separator
    var opts = {
      fullPrecision: !!fullPrecision
    };
    return this.Utils.formatAmount(satoshis, config.unitCode, opts);
  };

  root.formatAmountStr = function(coin, satoshis) {
    if (isNaN(satoshis)) return;
    return root.formatAmount(satoshis) + ' ' + root.formatCoin(coin);
    // @empty this update for QYB
    //return root.formatAmount(satoshis) + '  QYB';
  };

  root.toFiat = function(coin, satoshis, code, cb) {
    if (isNaN(satoshis)) return;
    var val = function() {
      var v1 = rateService.toFiat(satoshis, code, coin);
      if (!v1) return null;

      return v1.toFixed(2);
    };

    // Async version
    if (cb) {
      rateService.whenAvailable(function() {
        return cb(val());
      });
    } else {
      if (!rateService.isAvailable()) return null;
      return val();
    };
  };

  root.formatToUSD = function(coin, satoshis, cb) {
    if (isNaN(satoshis)) return;
    var val = function() {
      var v1 = rateService.toFiat(satoshis, 'USD', coin);
      if (!v1) return null;

      return v1.toFixed(2);
    };

    // Async version
    if (cb) {
      rateService.whenAvailable(function() {
        return cb(val());
      });
    } else {
      if (!rateService.isAvailable()) return null;
      return val();
    };
  };

  root.formatAlternativeStr = function(coin, satoshis, cb) {
    if (isNaN(satoshis)) return;
    var config = configService.getSync().wallet.settings;

    var val = function() {
      var v1 = parseFloat((rateService.toFiat(satoshis, config.alternativeIsoCode, coin)).toFixed(2));
      v1 = $filter('formatFiatAmount')(v1);
      if (!v1) return null;

      return v1 + ' ' + config.alternativeIsoCode;
    };

    // Async version
    if (cb) {
      rateService.whenAvailable(function() {
        return cb(val());
      });
    } else {
      if (!rateService.isAvailable()) return null;
      return val();
    };
  };

  root.processTx = function(coin, tx) {
    if (!tx || tx.action == 'invalid')
      return tx;

    // New transaction output format
    if (tx.outputs && tx.outputs.length) {

      var outputsNr = tx.outputs.length;

      if (tx.action != 'received') {
        if (outputsNr > 1) {
          tx.recipientCount = outputsNr;
          tx.hasMultiplesOutputs = true;
        }
        tx.amount = lodash.reduce(tx.outputs, function(total, o) {
          o.amountStr = root.formatAmountStr(coin, o.amount);
          o.alternativeAmountStr = root.formatAlternativeStr(coin, o.amount);
          return total + o.amount;
        }, 0);
      }
      tx.toAddress = tx.outputs[0].toAddress;
    }

    tx.amountStr = root.formatAmountStr(coin, tx.amount);
    tx.alternativeAmountStr = root.formatAlternativeStr(coin, tx.amount);
    tx.feeStr = root.formatAmountStr(coin, tx.fee || tx.fees);

    if (tx.amountStr) {
      tx.amountValueStr = tx.amountStr.split(' ')[0];
      tx.amountUnitStr = tx.amountStr.split(' ')[1];
    }

    return tx;
  };

  root.formatPendingTxps = function(txps) {
    $scope.pendingTxProposalsCountForUs = 0;
    var now = Math.floor(Date.now() / 1000);

    /* To test multiple outputs...
    var txp = {
      message: 'test multi-output',
      fee: 1000,
      createdOn: new Date() / 1000,
      outputs: []
    };
    function addOutput(n) {
      txp.outputs.push({
        amount: 600,
        toAddress: '2N8bhEwbKtMvR2jqMRcTCQqzHP6zXGToXcK',
        message: 'output #' + (Number(n) + 1)
      });
    };
    lodash.times(150, addOutput);
    txps.push(txp);
    */

    lodash.each(txps, function(tx) {

      // no future transactions...
      if (tx.createdOn > now)
        tx.createdOn = now;

      tx.wallet = profileService.getWallet(tx.walletId);
      if (!tx.wallet) {
        $log.error("no wallet at txp?");
        return;
      }

      tx = txFormatService.processTx(tx.wallet.coin, tx);

      var action = lodash.find(tx.actions, {
        copayerId: tx.wallet.copayerId
      });

      if (!action && tx.status == 'pending') {
        tx.pendingForUs = true;
      }

      if (action && action.type == 'accept') {
        tx.statusForUs = 'accepted';
      } else if (action && action.type == 'reject') {
        tx.statusForUs = 'rejected';
      } else {
        tx.statusForUs = 'pending';
      }

      if (!tx.deleteLockTime)
        tx.canBeRemoved = true;
    });

    return txps;
  };

  root.parseAmount = function(coin, amount, currency) {
    var config = configService.getSync().wallet.settings;
    var satToBtc = 1 / 100000000;
    var unitToSatoshi = config.unitToSatoshi;
    var amountUnitStr;
    var amountSat;
    var alternativeIsoCode = config.alternativeIsoCode;

    // If fiat currency
    if (currency != 'dmb' && currency != 'QYB' && currency != 'sat') {
      // @empty
      //amountUnitStr = $filter('formatFiatAmount')(amount) + ' ' + currency;
      amountUnitStr = $filter('formatFiatAmount')(amount) + '  QYB';
      amountSat = rateService.fromFiat(amount, currency, coin).toFixed(0);
    } else if (currency == 'sat') {
      amountSat = amount;
      amountUnitStr = root.formatAmountStr(coin, amountSat);
      // convert sat to QYB or dmb
      amount = (amountSat * satToBtc).toFixed(8);
      //currency = (coin).toUpperCase();
      // @empty change to QYB
      //currency = 'QYB';
      currency = root.formatCoin(coin);
    } else {
      amountSat = parseInt((amount * unitToSatoshi).toFixed(0));
      amountUnitStr = root.formatAmountStr(coin, amountSat);
      // convert unit to QYB or dmb
      amount = (amountSat * satToBtc).toFixed(8);
      //currency = (coin).toUpperCase();
      // @empty change to QYB
      //currency = 'QYB';
      currency = root.formatCoin(coin);
    }

    return {
      amount: amount,
      currency: currency,
      alternativeIsoCode: alternativeIsoCode,
      amountSat: amountSat,
      amountUnitStr: amountUnitStr
    };
  };

  root.satToUnit = function(amount) {
    var config = configService.getSync().wallet.settings;
    var unitToSatoshi = config.unitToSatoshi;
    var satToUnit = 1 / unitToSatoshi;
    var unitDecimals = config.unitDecimals;
    return parseFloat((amount * satToUnit).toFixed(unitDecimals));
  };

  return root;
});

'use strict';

angular.module('copayApp.services').factory('txpModalService', function(configService, profileService, $rootScope, $ionicModal) {

  var root = {};


  var glideraActive = true; // TODO TODO TODO
  // isGlidera flag is a security measure so glidera status is not
  // only determined by the tx.message


  root.open = function(tx) {
    var wallet = tx.wallet ? tx.wallet : profileService.getWallet(tx.walletId);
    var config = configService.getSync().wallet;
    var scope = $rootScope.$new(true);
    scope.tx = tx;
    if (!scope.tx.toAddress) scope.tx.toAddress = tx.outputs[0].toAddress;
    scope.wallet = wallet;
    scope.copayers = wallet ? wallet.copayers : null;
    scope.isGlidera = glideraActive;
    scope.currentSpendUnconfirmed = config.spendUnconfirmed;
    // scope.tx.hasMultiplesOutputs = true;  // Uncomment to test multiple outputs

    $ionicModal.fromTemplateUrl('views/modals/txp-details.html', {
      scope: scope
    }).then(function(modal) {
      scope.txpDetailsModal = modal;
      scope.txpDetailsModal.show();
    });
  };

  return root;
});

'use strict';
angular.module('copayApp.services')
  .factory('uxLanguage', function languageService($log, lodash, gettextCatalog, amMoment, configService) {
    var root = {};

    root.currentLanguage = null;

    root.availableLanguages = [{
      name: '中文（简体）',
      isoCode: 'zh',
      useIdeograms: true,
    }/*,{
      name: 'English',
      isoCode: 'en',
    }, {
      name: 'Español',
      isoCode: 'es',
    }, {
      name: 'Français',
      isoCode: 'fr',
    }, {
      name: 'Italiano',
      isoCode: 'it',
    }, {
      name: 'Nederlands',
      isoCode: 'nl',
    }, {
      name: 'Polski',
      isoCode: 'pl',
    }, {
      name: 'Deutsch',
      isoCode: 'de',
    }, {
      name: '日本語',
      isoCode: 'ja',
      useIdeograms: true,
    },  {
      name: 'Pусский',
      isoCode: 'ru',
    }, {
      name: 'Português',
      isoCode: 'pt',
    }*/];

    // }, {
    //   name: 'Český',
    //   isoCode: 'cs',
    // }

    root._detect = function(cb) {
      var userLang, androidLang;
      if (navigator && navigator.globalization) {

        navigator.globalization.getPreferredLanguage(function(preferedLanguage) {
          // works for iOS and Android 4.x
          userLang = preferedLanguage.value;
          userLang = userLang ? (userLang.split('-', 1)[0] || 'en') : 'en';
          // Set only available languages
          userLang = root.isAvailableLanguage(userLang);
          return cb(userLang);
        });
      } else {
        // Auto-detect browser language
        userLang = navigator.userLanguage || navigator.language;
        userLang = userLang ? (userLang.split('-', 1)[0] || 'en') : 'en';
        // Set only available languages
        userLang = root.isAvailableLanguage(userLang);
        return cb(userLang);
      }
    };

    root.isAvailableLanguage = function(userLang) {
      return lodash.find(root.availableLanguages, {
        'isoCode': userLang
      }) ? userLang : 'zh';
    };

    root._set = function(lang) {
      $log.debug('Setting default language: ' + lang);
      gettextCatalog.setCurrentLanguage(lang);
      root.currentLanguage = lang;

      if (lang == 'zh') lang = lang + '-CN'; // Fix for Chinese Simplified
      amMoment.changeLocale(lang);
    };

    root.getCurrentLanguage = function() {
      return root.currentLanguage;
    };

    root.getCurrentLanguageName = function() {
      return root.getName(root.currentLanguage);
    };

    root.getCurrentLanguageInfo = function() {
      return lodash.find(root.availableLanguages, {
        'isoCode': root.currentLanguage
      });
    };

    root.getLanguages = function() {
      return root.availableLanguages;
    };

    root.init = function(cb) {
      configService.whenAvailable(function(config) {
        var userLang = config.wallet.settings.defaultLanguage;

        if (userLang && userLang != root.currentLanguage) {
          root._set(userLang);
        } else {
          root._detect(function(lang) {
            root._set(lang);
          });
        }
        if (cb) return cb();
      });
    };

    root.getName = function(lang) {
      return lodash.result(lodash.find(root.availableLanguages, {
        'isoCode': lang
      }), 'name');
    };

    return root;
  });

'use strict';

angular.module('copayApp.services').factory('walletService', function($log, $timeout, lodash, trezor, ledger, intelTEE, storageService, configService, rateService, uxLanguage, $filter, gettextCatalog, bwcError, $ionicPopup, fingerprintService, ongoingProcess, gettext, $rootScope, txFormatService, $ionicModal, $state, bwcService, bitcore, popupService, feeService) {

  // Ratio low amount warning (fee/amount) in incoming TX
  var LOW_AMOUNT_RATIO = 0.15;

  // Ratio of "many utxos" warning in total balance (fee/amount)
  var TOTAL_LOW_WARNING_RATIO = .3;

  var root = {};

  root.externalSource = {
    ledger: ledger.description,
    trezor: trezor.description,
    intelTEE: intelTEE.description
  }

  root.WALLET_STATUS_MAX_TRIES = 7;
  root.WALLET_STATUS_DELAY_BETWEEN_TRIES = 1.4 * 1000;
  root.SOFT_CONFIRMATION_LIMIT = 12;
  root.SAFE_CONFIRMATIONS = 6;

  var errors = bwcService.getErrors();

  var _signWithLedger = function(wallet, txp, cb) {
    $log.info('Requesting Ledger Chrome app to sign the transaction');

    ledger.signTx(txp, wallet.credentials.account, function(result) {
      $log.debug('Ledger response', result);
      if (!result.success)
        return cb(result.message || result.error);

      txp.signatures = lodash.map(result.signatures, function(s) {
        return s.substring(0, s.length - 2);
      });
      return wallet.signTxProposal(txp, cb);
    });
  };

  var _signWithTrezor = function(wallet, txp, cb) {
    $log.info('Requesting Trezor  to sign the transaction');

    var xPubKeys = lodash.pluck(wallet.credentials.publicKeyRing, 'xPubKey');
    trezor.signTx(xPubKeys, txp, wallet.credentials.account, function(err, result) {
      if (err) return cb(err);

      $log.debug('Trezor response', result);
      txp.signatures = result.signatures;
      return wallet.signTxProposal(txp, cb);
    });
  };

  var _signWithIntelTEE = function(wallet, txp, cb) {
    $log.info('Requesting Intel TEE to sign the transaction');

    intelTEE.signTx(wallet.credentials.hwInfo.id, txp, function(err, result) {
      if (err) return cb(err);

      $log.debug('Intel TEE response', result);
      txp.signatures = result.Signatures;
      return wallet.signTxProposal(txp, cb);
    });
  };

  root.showMneumonicFromHardware = function(wallet, cb) {
    switch (wallet.getPrivKeyExternalSourceName()) {
      case root.externalSource.intelTEE.id:
        return intelTEE.showMneumonic(wallet.credentials.hwInfo.id, cb);
        break;
      default:
        cb('Error: unrecognized external source');
        break;
    }
  };

  root.showReceiveAddressFromHardware = function(wallet, address, cb) {
    switch (wallet.getPrivKeyExternalSourceName()) {
      case root.externalSource.intelTEE.id:
        root.getAddressObj(wallet, address, function(err, addrObj) {
          if (err) return cb(err);
          return intelTEE.showReceiveAddress(wallet.credentials.hwInfo.id, addrObj, cb);
        });
        break;
      default:
        cb('Error: unrecognized external source');
        break;
    }
  };

  root.invalidateCache = function(wallet) {
    if (wallet.cachedStatus)
      wallet.cachedStatus.isValid = false;

    if (wallet.completeHistory)
      wallet.completeHistory.isValid = false;

    if (wallet.cachedActivity)
      wallet.cachedActivity.isValid = false;

    if (wallet.cachedTxps)
      wallet.cachedTxps.isValid = false;
  };

  root.getStatus = function(wallet, opts, cb) {
    opts = opts || {};
    var walletId = wallet.id;

    function processPendingTxps(status) {
      var txps = status.pendingTxps;
      var now = Math.floor(Date.now() / 1000);

      /* To test multiple outputs...
      var txp = {
        message: 'test multi-output',
        fee: 1000,
        createdOn: new Date() / 1000,
        outputs: []
      };
      function addOutput(n) {
        txp.outputs.push({
          amount: 600,
          toAddress: '2N8bhEwbKtMvR2jqMRcTCQqzHP6zXGToXcK',
          message: 'output #' + (Number(n) + 1)
        });
      };
      lodash.times(150, addOutput);
      txps.push(txp);
      */

      lodash.each(txps, function(tx) {

        tx = txFormatService.processTx(wallet.coin, tx);

        // no future transactions...
        if (tx.createdOn > now)
          tx.createdOn = now;

        tx.wallet = wallet;

        if (!tx.wallet) {
          $log.error("no wallet at txp?");
          return;
        }

        var action = lodash.find(tx.actions, {
          copayerId: tx.wallet.copayerId
        });

        if (!action && tx.status == 'pending') {
          tx.pendingForUs = true;
        }

        if (action && action.type == 'accept') {
          tx.statusForUs = 'accepted';
        } else if (action && action.type == 'reject') {
          tx.statusForUs = 'rejected';
        } else {
          tx.statusForUs = 'pending';
        }

        if (!tx.deleteLockTime)
          tx.canBeRemoved = true;
      });

      wallet.pendingTxps = txps;
    };


    function get(cb) {
      wallet.getStatus({
        twoStep: true
      }, function(err, ret) {
        if (err) {
          if (err instanceof errors.NOT_AUTHORIZED) {
            return cb('WALLET_NOT_REGISTERED');
          }
          return cb(err);
        }

        return cb(null, ret);
      });
    };

    function cacheBalance(wallet, balance) {
      if (!balance) return;

      var config = configService.getSync().wallet;

      var cache = wallet.cachedStatus;

      // Address with Balance
      cache.balanceByAddress = balance.byAddress;

      // Total wallet balance is same regardless of 'spend unconfirmed funds' setting.
      cache.totalBalanceSat = balance.totalAmount;

      // Spend unconfirmed funds
      if (config.spendUnconfirmed) {
        cache.lockedBalanceSat = balance.lockedAmount;
        cache.availableBalanceSat = balance.availableAmount;
        cache.totalBytesToSendMax = balance.totalBytesToSendMax;
        cache.pendingAmount = 0;
        cache.spendableAmount = balance.totalAmount - balance.lockedAmount;
      } else {
        cache.lockedBalanceSat = balance.lockedConfirmedAmount;
        cache.availableBalanceSat = balance.availableConfirmedAmount;
        cache.totalBytesToSendMax = balance.totalBytesToSendConfirmedMax;
        cache.pendingAmount = balance.totalAmount - balance.totalConfirmedAmount;
        cache.spendableAmount = balance.totalConfirmedAmount - balance.lockedAmount;
      }

      // Selected unit
      cache.unitToSatoshi = config.settings.unitToSatoshi;
      cache.satToUnit = 1 / cache.unitToSatoshi;

      //STR
      cache.totalBalanceStr = txFormatService.formatAmountStr(wallet.coin, cache.totalBalanceSat);
      cache.lockedBalanceStr = txFormatService.formatAmountStr(wallet.coin, cache.lockedBalanceSat);
      cache.availableBalanceStr = txFormatService.formatAmountStr(wallet.coin, cache.availableBalanceSat);
      cache.spendableBalanceStr = txFormatService.formatAmountStr(wallet.coin, cache.spendableAmount);
      cache.pendingBalanceStr = txFormatService.formatAmountStr(wallet.coin, cache.pendingAmount);

      cache.alternativeName = config.settings.alternativeName;
      cache.alternativeIsoCode = config.settings.alternativeIsoCode;

      // Check address
      root.isAddressUsed(wallet, balance.byAddress, function(err, used) {
        if (used) {
          $log.debug('Address used. Creating new');
          // Force new address
          root.getAddress(wallet, true, function(err, addr) {
            $log.debug('New address: ', addr);
          });
        }
      });

      rateService.whenAvailable(function() {

        var totalBalanceAlternative = rateService.toFiat(cache.totalBalanceSat, cache.alternativeIsoCode, wallet.coin);
        var pendingBalanceAlternative = rateService.toFiat(cache.pendingAmount, cache.alternativeIsoCode, wallet.coin);
        var lockedBalanceAlternative = rateService.toFiat(cache.lockedBalanceSat, cache.alternativeIsoCode, wallet.coin);
        var spendableBalanceAlternative = rateService.toFiat(cache.spendableAmount, cache.alternativeIsoCode, wallet.coin);
        var alternativeConversionRate = rateService.toFiat(100000000, cache.alternativeIsoCode, wallet.coin);

        cache.totalBalanceAlternative = $filter('formatFiatAmount')(totalBalanceAlternative);
        cache.pendingBalanceAlternative = $filter('formatFiatAmount')(pendingBalanceAlternative);
        cache.lockedBalanceAlternative = $filter('formatFiatAmount')(lockedBalanceAlternative);
        cache.spendableBalanceAlternative = $filter('formatFiatAmount')(spendableBalanceAlternative);
        cache.alternativeConversionRate = $filter('formatFiatAmount')(alternativeConversionRate);

        cache.alternativeBalanceAvailable = true;
        cache.isRateAvailable = true;
      });
    };

    function isStatusCached() {
      return wallet.cachedStatus && wallet.cachedStatus.isValid;
    };

    function cacheStatus(status) {
      if (status.wallet && status.wallet.scanStatus == 'running') return;

      wallet.cachedStatus = status ||  {};
      var cache = wallet.cachedStatus;
      cache.statusUpdatedOn = Date.now();
      cache.isValid = true;
      cache.email = status.preferences ? status.preferences.email : null;
      cacheBalance(wallet, status.balance);
    };

    function walletStatusHash(status) {
      return status ? status.balance.totalAmount : wallet.totalBalanceSat;
    };

    function _getStatus(initStatusHash, tries, cb) {
      if (isStatusCached() && !opts.force) {
        $log.debug('Wallet status cache hit:' + wallet.id);
        cacheStatus(wallet.cachedStatus);
        processPendingTxps(wallet.cachedStatus);
        return cb(null, wallet.cachedStatus);
      };

      tries = tries || 0;

      $log.debug('Updating Status:', wallet.credentials.walletName, tries);
      get(function(err, status) {
        if (err) return cb(err);

        var currentStatusHash = walletStatusHash(status);
        $log.debug('Status update. hash:' + currentStatusHash + ' Try:' + tries);
        if (opts.untilItChanges &&
          initStatusHash == currentStatusHash &&
          tries < root.WALLET_STATUS_MAX_TRIES &&
          walletId == wallet.credentials.walletId) {
          return $timeout(function() {
            $log.debug('Retrying update... ' + walletId + ' Try:' + tries)
            return _getStatus(initStatusHash, ++tries, cb);
          }, root.WALLET_STATUS_DELAY_BETWEEN_TRIES * tries);
        }

        processPendingTxps(status);

        $log.debug('Got Wallet Status for:' + wallet.credentials.walletName);

        cacheStatus(status);

        wallet.scanning = status.wallet && status.wallet.scanStatus == 'running';

        return cb(null, status);
      });
    };

    _getStatus(walletStatusHash(), 0, cb);
  };

  var getSavedTxs = function(walletId, cb) {
    storageService.getTxHistory(walletId, function(err, txs) {
      if (err) return cb(err);

      var localTxs = [];

      if (!txs) {
        return cb(null, localTxs);
      }

      try {
        localTxs = JSON.parse(txs);
      } catch (ex) {
        $log.warn(ex);
      }
      return cb(null, lodash.compact(localTxs));
    });
  };

  var getTxsFromServer = function(wallet, skip, endingTxid, limit, cb) {
    var res = [];

    wallet.getTxHistory({
      skip: skip,
      limit: limit
    }, function(err, txsFromServer) {
      if (err) return cb(err);

      if (!txsFromServer.length)
        return cb();

      var res = lodash.takeWhile(txsFromServer, function(tx) {
        return tx.txid != endingTxid;
      });

      return cb(null, res, res.length >= limit);
    });
  };

  var removeAndMarkSoftConfirmedTx = function(txs) {
    return lodash.filter(txs, function(tx) {
      if (tx.confirmations >= root.SOFT_CONFIRMATION_LIMIT)
        return tx;
      tx.recent = true;
    });
  }

  var processNewTxs = function(wallet, txs) {
    var config = configService.getSync().wallet.settings;
    var now = Math.floor(Date.now() / 1000);
    var txHistoryUnique = {};
    var ret = [];
    wallet.hasUnsafeConfirmed = false;

    lodash.each(txs, function(tx) {
      tx = txFormatService.processTx(wallet.coin, tx);

      // no future transactions...
      if (tx.time > now)
        tx.time = now;

      if (tx.confirmations >= root.SAFE_CONFIRMATIONS) {
        tx.safeConfirmed = root.SAFE_CONFIRMATIONS + '+';
      } else {
        tx.safeConfirmed = false;
        wallet.hasUnsafeConfirmed = true;
      }

      if (tx.note) {
        delete tx.note.encryptedEditedByName;
        delete tx.note.encryptedBody;
      }

      if (!txHistoryUnique[tx.txid]) {
        ret.push(tx);
        txHistoryUnique[tx.txid] = true;
      } else {
        $log.debug('Ignoring duplicate TX in history: ' + tx.txid)
      }
    });

    return ret;
  };

  var updateOnProgress = {};
  var progressFn = {};
  var updateLocalTxHistory = function(wallet, opts, cb) {
    var FIRST_LIMIT = 5;
    var LIMIT = 50;
    var requestLimit = FIRST_LIMIT;
    var walletId = wallet.credentials.walletId;

    var opts = opts || {};
    progressFn[walletId] = opts.progressFn || function() {};
    var foundLimitTx = false;


    if (opts.feeLevels) {
      opts.lowAmount = root.getLowAmount(wallet);
    }

    var fixTxsUnit = function(txs) {
      if (!txs || !txs[0] || !txs[0].amountStr) return;

      var cacheCoin = txs[0].amountStr.split(' ')[1];

      if (cacheCoin == 'bits') {

        $log.debug('Fixing Tx Cache Unit to: ' + wallet.coin)
        lodash.each(txs, function(tx) {
          tx.amountStr = txFormatService.formatAmountStr(wallet.coin, tx.amount);
          tx.feeStr = txFormatService.formatAmountStr(wallet.coin, tx.fees);
        });
      }
    };

    if (updateOnProgress[wallet.id]) {
      $log.warn('History update already on progress for: '+ wallet.credentials.walletName);

      if (opts.progressFn) {
        $log.debug('Rewriting progressFn');
        progressFn[walletId] = opts.progressFn;
      }
      updateOnProgress[wallet.id].push(cb);
      return; // no callback call yet.
    }

    updateOnProgress[walletId] = [cb];

    getSavedTxs(walletId, function(err, txsFromLocal) {
      if (err)  {
        lodash.each(updateOnProgress[wallet.id], function(x) {
          x.apply(self,err);
        });
        updateOnProgress[wallet.id] = false;
      }

      fixTxsUnit(txsFromLocal);

      var confirmedTxs = removeAndMarkSoftConfirmedTx(txsFromLocal);
      var endingTxid = confirmedTxs[0] ? confirmedTxs[0].txid : null;
      var endingTs = confirmedTxs[0] ? confirmedTxs[0].time : null;

      // First update
      progressFn[walletId](txsFromLocal, 0);
      wallet.completeHistory = txsFromLocal;

      function getNewTxs(newTxs, skip, next) {
        getTxsFromServer(wallet, skip, endingTxid, requestLimit, function(err, res, shouldContinue) {
          if (err) {
            $log.warn(bwcError.msg(err, 'Server Error')); //TODO
            if (err instanceof errors.CONNECTION_ERROR || (err.message && err.message.match(/5../))) {
              $log.info('Retrying history download in 5 secs...');
              return $timeout(function() {
                return getNewTxs(newTxs, skip, next);
              }, 5000);
            };
            return next(err);
          }

          newTxs = newTxs.concat(processNewTxs(wallet, lodash.compact(res)));

          progressFn[walletId](newTxs.concat(txsFromLocal), newTxs.length);

          skip = skip + requestLimit;

          $log.debug('Syncing TXs. Got:' + newTxs.length + ' Skip:' + skip, ' EndingTxid:', endingTxid, ' Continue:', shouldContinue);

          // TODO Dirty <HACK>
          // do not sync all history, just looking for a single TX.
          if (opts.limitTx) {

            foundLimitTx = lodash.find(newTxs, {
              txid: opts.limitTx,
            });

            if (foundLimitTx) {
              $log.debug('Found limitTX: ' + opts.limitTx);
              return next(null, [foundLimitTx]);
            }
          }
          // </HACK>


          if (!shouldContinue) {
            $log.debug('Finished Sync: New / soft confirmed Txs: ' + newTxs.length);
            return next(null, newTxs);
          }

          requestLimit = LIMIT;
          getNewTxs(newTxs, skip, next);
        });
      };

      getNewTxs([], 0, function(err, txs) {
        if (err)  {
          lodash.each(updateOnProgress[wallet.id], function(x) {
            x.apply(self,err);
          });
          updateOnProgress[wallet.id] = false;
        }

        var newHistory = lodash.uniq(lodash.compact(txs.concat(confirmedTxs)), function(x) {
          return x.txid;
        });


        function updateNotes(cb2) {
          if (!endingTs) return cb2();

          $log.debug('Syncing notes from: ' + endingTs);
          wallet.getTxNotes({
            minTs: endingTs
          }, function(err, notes) {
            if (err) {
              $log.warn(err);
              return cb2();
            };
            lodash.each(notes, function(note) {
              $log.debug('Note for ' + note.txid);
              lodash.each(newHistory, function(tx) {
                if (tx.txid == note.txid) {
                  $log.debug('...updating note for ' + note.txid);
                  tx.note = note;
                }
              });
            });
            return cb2();
          });
        }

        function updateLowAmount(txs) {
          if (!opts.lowAmount) return;

          lodash.each(txs, function(tx) {
            tx.lowAmount = tx.amount < opts.lowAmount;
          });
        };

        updateLowAmount(txs);

        updateNotes(function() {

          // <HACK>
          if (foundLimitTx) {
            $log.debug('Tx history read until limitTx: ' + opts.limitTx);

            // in this case, only the orig cb is called.
            updateOnProgress[wallet.id] = false;
            return cb(null, newHistory);
          }
          // </HACK>

          var historyToSave = JSON.stringify(newHistory);

          lodash.each(txs, function(tx) {
            tx.recent = true;
          })

          $log.debug('Tx History synced. Total Txs: ' + newHistory.length);

          // Final update
          if (walletId == wallet.credentials.walletId) {
            wallet.completeHistory = newHistory;
          }

          return storageService.setTxHistory(historyToSave, walletId, function() {
            $log.debug('Tx History saved.');
            lodash.each(updateOnProgress[wallet.id], function(x) {
              x.apply(self);
            });
            updateOnProgress[wallet.id] = false;
          });
        });
      });
    });
  };

  root.getTxNote = function(wallet, txid, cb) {
    wallet.getTxNote({
      txid: txid
    }, function(err, note) {
      if (err) return cb(err);
      return cb(null, note);
    });
  };

  root.editTxNote = function(wallet, args, cb) {
    wallet.editTxNote(args, function(err, res) {
      return cb(err, res);
    });
  };

  root.getTxp = function(wallet, txpid, cb) {
    wallet.getTx(txpid, function(err, txp) {
      if (err) return cb(err);
      return cb(null, txp);
    });
  };

  root.getTx = function(wallet, txid, cb) {

    function finish(list) {
      var tx = lodash.find(list, {
        txid: txid
      });

      if (!tx) return cb('Could not get transaction');
      return cb(null, tx);
    };

    if (wallet.completeHistory && wallet.completeHistory.isValid) {
      finish(wallet.completeHistory);
    } else {
      root.getTxHistory(wallet, {
        limitTx: txid
      }, function(err, txHistory) {
        if (err) return cb(err);

        finish(txHistory);
      });
    }
  };


  root.clearTxHistory = function(wallet, cb) {
    root.invalidateCache(wallet);

    storageService.removeTxHistory(wallet.id, function(err) {
      if (err) {
        $log.error(err);
        return cb(err);
      }
      return cb();
    });
  };



  root.getTxHistory = function(wallet, opts, cb) {
    opts = opts || {};

    var walletId = wallet.credentials.walletId;

    if (!wallet.isComplete()) return cb();

    function isHistoryCached() {
      return wallet.completeHistory && wallet.completeHistory.isValid;
    };

    if (isHistoryCached() && !opts.force) {
      return cb(null, wallet.completeHistory);
    }

    $log.debug('Updating Transaction History: ' + wallet.credentials.walletName);

    updateLocalTxHistory(wallet, opts, function(err, txs) {
      if (err) return cb(err);

      if (opts.limitTx) {
        return cb(err, txs);
      }

      wallet.completeHistory.isValid = true;
      return cb(err, wallet.completeHistory);
    });
  };

  root.isEncrypted = function(wallet) {
    if (lodash.isEmpty(wallet)) return;
    var isEncrypted = wallet.isPrivKeyEncrypted();
    if (isEncrypted) $log.debug('Wallet is encrypted');
    return isEncrypted;
  };

  root.createTx = function(wallet, txp, cb) {
    if (lodash.isEmpty(txp) || lodash.isEmpty(wallet))
      return cb('MISSING_PARAMETER');

    wallet.createTxProposal(txp, function(err, createdTxp) {
      if (err) return cb(err);
      else {
        $log.debug('Transaction created');
        return cb(null, createdTxp);
      }
    });
  };

  root.publishTx = function(wallet, txp, cb) {
    if (lodash.isEmpty(txp) || lodash.isEmpty(wallet))
      return cb('MISSING_PARAMETER');

    wallet.publishTxProposal({
      txp: txp
    }, function(err, publishedTx) {
      if (err) return cb(err);
      else {
        $log.debug('Transaction published');
        return cb(null, publishedTx);
      }
    });
  };

  root.signTx = function(wallet, txp, password, cb) {
    if (!wallet || !txp || !cb)
      return cb('MISSING_PARAMETER');

    if (wallet.isPrivKeyExternal()) {
      switch (wallet.getPrivKeyExternalSourceName()) {
        case root.externalSource.ledger.id:
          return _signWithLedger(wallet, txp, cb);
        case root.externalSource.trezor.id:
          return _signWithTrezor(wallet, txp, cb);
        case root.externalSource.intelTEE.id:
          return _signWithIntelTEE(wallet, txp, cb);
        default:
          var msg = 'Unsupported External Key:' + wallet.getPrivKeyExternalSourceName();
          $log.error(msg);
          return cb(msg);
      }
    } else {

      try {
        wallet.signTxProposal(txp, password, function(err, signedTxp) {
          $log.debug('Transaction signed err:' + err);
          return cb(err, signedTxp);
        });
      } catch (e) {
        $log.warn('Error at signTxProposal:', e);
        return cb(e);
      }
    }
  };

  root.broadcastTx = function(wallet, txp, cb) {
    if (lodash.isEmpty(txp) || lodash.isEmpty(wallet))
      return cb('MISSING_PARAMETER');

    if (txp.status != 'accepted')
      return cb('TX_NOT_ACCEPTED');

    wallet.broadcastTxProposal(txp, function(err, broadcastedTxp, memo) {
      if (err)
        return cb(err);

      $log.debug('Transaction broadcasted');
      if (memo) $log.info(memo);

      return cb(null, broadcastedTxp);
    });
  };

  root.rejectTx = function(wallet, txp, cb) {
    if (lodash.isEmpty(txp) || lodash.isEmpty(wallet))
      return cb('MISSING_PARAMETER');

    wallet.rejectTxProposal(txp, null, function(err, rejectedTxp) {
      $log.debug('Transaction rejected');
      return cb(err, rejectedTxp);
    });
  };

  root.removeTx = function(wallet, txp, cb) {
    if (lodash.isEmpty(txp) || lodash.isEmpty(wallet))
      return cb('MISSING_PARAMETER');

    wallet.removeTxProposal(txp, function(err) {
      $log.debug('Transaction removed');

      root.invalidateCache(wallet);
      $rootScope.$emit('Local/TxAction', wallet.id);

      return cb(err);
    });
  };

  root.updateRemotePreferences = function(clients, prefs, cb) {
    prefs = prefs || {};
    cb = cb || function() {};

    if (!lodash.isArray(clients))
      clients = [clients];

    function updateRemotePreferencesFor(clients, prefs, next) {
      var wallet = clients.shift();
      if (!wallet) return next();
      $log.debug('Saving remote preferences', wallet.credentials.walletName, prefs);

      wallet.savePreferences(prefs, function(err) {

        if (err) {
          popupService.showAlert(bwcError.msg(err, gettextCatalog.getString('Could not save preferences on the server')));
          return next(err);
        }

        updateRemotePreferencesFor(clients, prefs, next);
      });
    };

    // Update this JIC.
    var config = configService.getSync();
    var walletSettings = config.wallet.settings;

    //prefs.email  (may come from arguments)
    prefs.email = config.emailNotifications.email;
    prefs.language = uxLanguage.getCurrentLanguage();
    // prefs.unit = walletSettings.unitCode; // TODO: remove, not used

    updateRemotePreferencesFor(lodash.clone(clients), prefs, function(err) {
      if (err) return cb(err);

      $log.debug('Remote preferences saved for' + lodash.map(clients, function(x) {
        return x.credentials.walletId;
      }).join(','));

      lodash.each(clients, function(c) {
        c.preferences = lodash.assign(prefs, c.preferences);
      });
      return cb();
    });
  };

  root.recreate = function(wallet, cb) {
    $log.debug('Recreating wallet:', wallet.id);
    ongoingProcess.set('recreating', true);
    wallet.recreateWallet(function(err) {
      wallet.notAuthorized = false;
      ongoingProcess.set('recreating', false);
      return cb(err);
    });
  };

  root.startScan = function(wallet, cb) {
    cb = cb || function() {};

    $log.debug('Scanning wallet ' + wallet.id);
    if (!wallet.isComplete()) return;

    wallet.scanning = true;
    wallet.startScan({
      includeCopayerBranches: true,
    }, function(err) {
      return cb(err);
    });
  };


  root.expireAddress = function(wallet, cb) {
    $log.debug('Cleaning Address ' + wallet.id);
    storageService.clearLastAddress(wallet.id, function(err) {
      return cb(err);
    });
  };

  // Check address
  root.isAddressUsed = function(wallet, byAddress, cb) {
    storageService.getLastAddress(wallet.id, function(err, addr) {
      var used = lodash.find(byAddress, {
        address: addr
      });
      return cb(err, used);
    });
  };

  var createAddress = function(wallet, cb) {
    $log.debug('Creating address for wallet:', wallet.id);

    wallet.createAddress({}, function(err, addr) {
      if (err) {
        var prefix = gettextCatalog.getString('Could not create address');
        if (err instanceof errors.CONNECTION_ERROR || (err.message && err.message.match(/5../))) {
          $log.warn(err);
          return $timeout(function() {
            createAddress(wallet, cb);
          }, 5000);
        } else if (err instanceof errors.MAIN_ADDRESS_GAP_REACHED || (err.message && err.message == 'MAIN_ADDRESS_GAP_REACHED')) {
          $log.warn(err);
          prefix = null;
          wallet.getMainAddresses({
            reverse: true,
            limit: 1
          }, function(err, addr) {
            if (err) return cb(err);
            return cb(null, addr[0].address);
          });
        }
        return bwcError.cb(err, prefix, cb);
      }
      return cb(null, addr.address);
    });
  };

  root.getMainAddresses = function(wallet, opts, cb) {
    opts = opts || {};
    opts.reverse = true;
    wallet.getMainAddresses(opts, function(err, addresses) {
      return cb(err, addresses);
    });
  };

  root.getBalance = function(wallet, opts, cb) {
    opts = opts || {};
    wallet.getBalance(opts, function(err, resp) {
      return cb(err, resp);
    });
  };


  // These 2 functions were taken from
  // https://github.com/bitpay/bitcore-wallet-service/blob/master/lib/model/txproposal.js#L243

  function getEstimatedSizeForSingleInput(wallet) {
    switch (wallet.credentials.addressType) {
      case 'P2PKH':
        return 147;
      default:
      case 'P2SH':
        return wallet.m * 72 + wallet.n * 36 + 44;
    }
  };


  root.getEstimatedTxSize = function(wallet, nbOutputs) {
    // Note: found empirically based on all multisig P2SH inputs and within m & n allowed limits.
    var safetyMargin = 0.02;

    var overhead = 4 + 4 + 9 + 9;
    var inputSize = getEstimatedSizeForSingleInput(wallet);
    var outputSize = 34;
    var nbInputs = 1; //Assume 1 input
    var nbOutputs = nbOutputs || 2; // Assume 2 outputs

    var size = overhead + inputSize * nbInputs + outputSize * nbOutputs;
    return parseInt((size * (1 + safetyMargin)).toFixed(0));
  };


  // Approx utxo amount, from which the uxto is economically redeemable
  root.getMinFee = function(wallet, nbOutputs) {
    var levels = feeService.cachedFeeLevels;
    var lowLevelRate = (lodash.find(levels[wallet.network], {
      level: 'normal',
    }).feePerKb / 1000).toFixed(0);

    var size = root.getEstimatedTxSize(wallet, nbOutputs);
      return size * lowLevelRate;
  };


  // Approx utxo amount, from which the uxto is economically redeemable
  root.getLowAmount = function(wallet, nbOutputs) {
    var minFee = root.getMinFee(wallet, nbOutputs);
    return parseInt(minFee / LOW_AMOUNT_RATIO);
  };



  root.getLowUtxos = function(wallet, cb) {

    wallet.getUtxos({
      coin: wallet.coin
    }, function(err, resp) {
      if (err || !resp || !resp.length) return cb();

      var minFee = root.getMinFee(wallet, resp.length);

      var balance = lodash.sum(resp, 'satoshis');

      // for 2 outputs
      var lowAmount = root.getLowAmount(wallet);
      var lowUtxos = lodash.filter(resp, function(x) {
        return x.satoshis < lowAmount;
      });

      var totalLow = lodash.sum(lowUtxos, 'satoshis');

      return cb(err, {
        allUtxos: resp || [],
        lowUtxos: lowUtxos || [],
        warning: minFee / balance > TOTAL_LOW_WARNING_RATIO,
        minFee: minFee,
      });
    });
  };

  root.getAddress = function(wallet, forceNew, cb) {
    storageService.getLastAddress(wallet.id, function(err, addr) {
      if (err) return cb(err);

      if (!forceNew && addr) return cb(null, addr);

      if (!wallet.isComplete())
        return cb('WALLET_NOT_COMPLETE');

      createAddress(wallet, function(err, _addr) {
        if (err) return cb(err, addr);
        storageService.storeLastAddress(wallet.id, _addr, function() {
          if (err) return cb(err);
          return cb(null, _addr);
        });
      });
    });
  };

  root.getAddressObj = function(wallet, address, cb) {
    wallet.getMainAddresses({
      reverse: true
    }, function(err, addr) {
      if (err) return cb(err);
      var addrObj = lodash.find(addr, function(a) {
        return a.address == address;
      });
      var err = null;
      if (!addrObj) {
        err = 'Error: specified address not in wallet';
      }
      return cb(err, addrObj);
    });
  };

  root.isReady = function(wallet, cb) {
    if (!wallet.isComplete())
      return cb('WALLET_NOT_COMPLETE');

    if (wallet.needsBackup)
      return cb('WALLET_NEEDS_BACKUP');
    return cb();
  };


  // An alert dialog
  var askPassword = function(name, title, cb) {
    var opts = {
      inputType: 'password',
      forceHTMLPrompt: true,
      class: 'text-warn'
    };
    popupService.showPrompt(title, name, opts, function(res) {
      if (!res) return cb();
      if (res) return cb(res)
    });
  };


  root.encrypt = function(wallet, cb) {
    var title = gettextCatalog.getString('Enter new spending password');
    var warnMsg = gettextCatalog.getString('Your wallet key will be encrypted. The Spending Password cannot be recovered. Be sure to write it down.');
    askPassword(warnMsg, title, function(password) {
      if (!password) return cb('no password');
      title = gettextCatalog.getString('Confirm your new spending password');
      askPassword(warnMsg, title, function(password2) {
        if (!password2 || password != password2)
          return cb('password mismatch');

        wallet.encryptPrivateKey(password);
        return cb();
      });
    });
  };


  root.decrypt = function(wallet, cb) {
    $log.debug('Disabling private key encryption for' + wallet.name);
    askPassword(null, gettextCatalog.getString('Enter Spending Password'), function(password) {
      if (!password) return cb('no password');

      try {
        wallet.decryptPrivateKey(password);
      } catch (e) {
        return cb(e);
      }
      return cb();
    });
  };

  root.handleEncryptedWallet = function(wallet, cb) {
    if (!root.isEncrypted(wallet)) return cb();

    askPassword(wallet.name, gettextCatalog.getString('Enter Spending Password'), function(password) {
      if (!password) return cb('No password');
      if (!wallet.checkPassword(password)) return cb('Wrong password');

      return cb(null, password);
    });
  };


  root.reject = function(wallet, txp, cb) {
    ongoingProcess.set('rejectTx', true);
    root.rejectTx(wallet, txp, function(err, txpr) {
      root.invalidateCache(wallet);
      ongoingProcess.set('rejectTx', false);

      if (err) return cb(err);

      $rootScope.$emit('Local/TxAction', wallet.id);
      return cb(null, txpr);
    });
  };


  root.onlyPublish = function(wallet, txp, cb, customStatusHandler) {
    ongoingProcess.set('sendingTx', true, customStatusHandler);
    root.publishTx(wallet, txp, function(err, publishedTxp) {
      root.invalidateCache(wallet);
      ongoingProcess.set('sendingTx', false, customStatusHandler);
      if (err) return cb(bwcError.msg(err));
      $rootScope.$emit('Local/TxAction', wallet.id);
      return cb();
    });
  };


  root.prepare = function(wallet, cb) {
    fingerprintService.check(wallet, function(err) {
      if (err) return cb(err);

      root.handleEncryptedWallet(wallet, function(err, password) {
        if (err) return cb(err);

        return cb(null, password);
      });
    });
  };

  root.publishAndSign = function (wallet, txp, cb, customStatusHandler, cbAfterBroadcastTx) {

    var publishFn = root.publishTx;

    // Already published?
    if (txp.status == 'pending') {
      publishFn = function(wallet, txp, cb) {
        return cb(null, txp);
      };
    }

    root.prepare(wallet, function(err, password) {
      if (err) return cb(bwcError.msg(err));

      ongoingProcess.set('sendingTx', true, customStatusHandler);

      publishFn(wallet, txp, function(err, publishedTxp) {
        ongoingProcess.set('sendingTx', false, customStatusHandler);
        if (err) return cb(bwcError.msg(err));

        ongoingProcess.set('signingTx', true, customStatusHandler);
        root.signTx(wallet, publishedTxp, password, function(err, signedTxp) {
          ongoingProcess.set('signingTx', false, customStatusHandler);
          root.invalidateCache(wallet);


          if (err) {
            $log.warn('sign error:' + err);
            var msg = err && err.message ?
              err.message :
              gettextCatalog.getString('The payment was created but could not be completed. Please try again from home screen');

            $rootScope.$emit('Local/TxAction', wallet.id);
            return cb(msg);
          }

          if (signedTxp.status == 'accepted') {
            ongoingProcess.set('broadcastingTx', true, customStatusHandler);
            root.broadcastTx(wallet, signedTxp, function (err, broadcastedTxp) {
              if (cbAfterBroadcastTx) cbAfterBroadcastTx(broadcastedTxp);
              ongoingProcess.set('broadcastingTx', false, customStatusHandler);
              if (err) return cb(bwcError.msg(err));

              $rootScope.$emit('Local/TxAction', wallet.id);
              return cb(null, broadcastedTxp);
            });
          } else {
            $rootScope.$emit('Local/TxAction', wallet.id);
            return cb(null, signedTxp);
          }
        });
      });
    });
  };

  root.getEncodedWalletInfo = function(wallet, password, cb) {
    var derivationPath = wallet.credentials.getBaseAddressDerivationPath();
    var encodingType = {
      mnemonic: 1,
      xpriv: 2,
      xpub: 3
    };
    var info;

    // not supported yet
    if (wallet.credentials.derivationStrategy != 'BIP44' || !wallet.canSign())
      return cb(gettextCatalog.getString('Exporting via QR not supported for this wallet'));

    var keys = root.getKeysWithPassword(wallet, password);

    if (keys.mnemonic) {
      info = {
        type: encodingType.mnemonic,
        data: keys.mnemonic,
      }
    } else {
      info = {
        type: encodingType.xpriv,
        data: keys.xPrivKey
      }
    }

    return cb(null, info.type + '|' + info.data + '|' + wallet.credentials.network.toLowerCase() + '|' + derivationPath + '|' + (wallet.credentials.mnemonicHasPassphrase));
  };

  root.setTouchId = function(wallet, enabled, cb) {

    var opts = {
      touchIdFor: {}
    };
    opts.touchIdFor[wallet.id] = enabled;

    fingerprintService.check(wallet, function(err) {
      if (err) {
        opts.touchIdFor[wallet.id] = !enabled;
        $log.debug('Error with fingerprint:' + err);
        return cb(err);
      }
      configService.set(opts, cb);
    });
  };

  root.getKeys = function(wallet, cb) {
    root.prepare(wallet, function(err, password) {
      if (err) return cb(err);
      var keys;

      try {
        keys = wallet.getKeys(password);
      } catch (e) {
        return cb(e);
      }

      return cb(null, keys);
    });
  };

  root.getKeysWithPassword = function(wallet, password) {
    try {
      return wallet.getKeys(password);
    } catch (e) {}
  }

  root.getSendMaxInfo = function(wallet, opts, cb) {
    opts = opts || {};
    wallet.getSendMaxInfo(opts, function(err, res) {
      return cb(err, res);
    });
  };

  root.getProtocolHandler = function(wallet) {
    if (wallet.coin== 'bch') return 'bitcoincash';
    //@empty modify to qybcoin
    // else return 'bitcoin';
    else return 'qybcoin';
  }


  root.copyCopayers = function(wallet, newWallet, cb) {
    var c = wallet.credentials;

    var walletPrivKey = bitcore.PrivateKey.fromString(c.walletPrivKey);

    var copayer = 1,
      i = 0,
      l = c.publicKeyRing.length;
    var mainErr = null;

    lodash.each(c.publicKeyRing, function(item) {
      var name = item.copayerName || ('copayer ' + copayer++);
      newWallet._doJoinWallet(newWallet.credentials.walletId, walletPrivKey, item.xPubKey, item.requestPubKey, name, {
        coin: newWallet.credentials.coin,
      }, function(err) {
        //Ignore error is copayer already in wallet
        if (err && !(err instanceof errors.COPAYER_IN_WALLET)) {
          mainErr = err;
        }

        if (++i == l) {
          return cb(mainErr);
        }
      });
    });
  };

  root.orderLuckymoney = function (opts, cb) {
    if (lodash.isEmpty(opts))
      return cb('MISSING_PARAMETER');

    wallet.orderLuckymoney(opts, function (err, res) {
      if (err) return cb(err);
      else {
        $log.debug('Luckymoney ordered');
        return cb(null, res);
      }
    });
  };

  return root;
});

'use strict';

angular.module('copayApp.controllers').controller('activityController',
  function ($timeout, $scope, $log, $ionicModal, lodash, txpModalService, profileService, walletService, ongoingProcess, popupService, gettextCatalog, $state) {
    $scope.openTxpModal = txpModalService.open;
    $scope.fetchingNotifications = true;

    $scope.$on("$ionicView.enter", function (event, data) {
      profileService.getNotifications(50, function (err, n) {
        if (err) {
          $log.error(err);
          return;
        }
        $scope.fetchingNotifications = false;
        $scope.notifications = n;
        $scope.uniqNotifications = lodash.uniq(n, 'txid');//just show uniq result, and uniqBy is the new methoed.

        profileService.getTxps({}, function (err, txps, n) {
          if (err) $log.error(err);
          $scope.txps = txps;
          $timeout(function () {
            $scope.$apply();
          });
        });
      });
    });

    $scope.openNotificationModal = function (n) {
      if (n.txid) {
        $state.transitionTo('tabs.wallet.tx-details', {
          txid: n.txid,
          walletId: n.walletId
        });
      } else {
        var txp = lodash.find($scope.txps, {
          id: n.txpId
        });
        if (txp) txpModalService.open(txp);
        else {
          ongoingProcess.set('loadingTxInfo', true);
          walletService.getTxp(n.wallet, n.txpId, function (err, txp) {
            var _txp = txp;
            ongoingProcess.set('loadingTxInfo', false);
            if (err) {
              $log.warn('No txp found');
              return popupService.showAlert(gettextCatalog.getString('Error'), gettextCatalog.getString('Transaction not found'));
            }
            txpModalService.open(_txp);
          });
        }
      }
    };
  });

'use strict';

angular.module('copayApp.controllers').controller('addressbookListController', function($scope, $log, $timeout, addressbookService, lodash, popupService, gettextCatalog, platformInfo) {

  var contacts;

  var initAddressbook = function() {
    addressbookService.list(function(err, ab) {
      if (err) $log.error(err);

      $scope.isEmptyList = lodash.isEmpty(ab);

      if (!$scope.isEmptyList) $scope.showAddIcon = true;
      else $scope.showAddIcon = false;

      contacts = [];
      lodash.each(ab, function(v, k) {
        contacts.push({
          name: lodash.isObject(v) ? v.name : v,
          address: k,
          email: lodash.isObject(v) ? v.email : null
        });
      });

      $scope.addressbook = lodash.clone(contacts);
      $timeout(function() {
        $scope.$apply();
      });
    });
  };

  $scope.findAddressbook = function(search) {
    if (!search || search.length < 2) {
      $scope.addressbook = contacts;
      $timeout(function() {
        $scope.$apply();
      }, 10);
      return;
    }

    var result = lodash.filter(contacts, function(item) {
      var val = item.name;
      return lodash.includes(val.toLowerCase(), search.toLowerCase());
    });

    $scope.addressbook = result;
  };

  $scope.$on("$ionicView.beforeEnter", function(event, data) {
    $scope.isChromeApp = platformInfo.isChromeApp;
    $scope.showAddIcon = false;
    $scope.addrSearch = { value: null };
    initAddressbook();
  });

});

'use strict';

angular.module('copayApp.controllers').controller('addressbookAddController', function($scope, $state, $stateParams, $timeout, $ionicHistory, gettextCatalog, addressbookService, popupService) {

  $scope.fromSendTab = $stateParams.fromSendTab;

  $scope.addressbookEntry = {
    'address': $stateParams.addressbookEntry || '',
    'name': '',
    'email': ''
  };

  $scope.onQrCodeScannedAddressBook = function(data, addressbookForm) {
    $timeout(function() {
      var form = addressbookForm;
      if (data && form) {
        data = data.replace(/^bitcoin(cash)?:/, '');
        form.address.$setViewValue(data);
        form.address.$isValid = true;
        form.address.$render();
      }
      $scope.$digest();
    }, 100);
  };

  $scope.add = function(addressbook) {
    $timeout(function() {
      addressbookService.add(addressbook, function(err, ab) {
        if (err) {
          popupService.showAlert(gettextCatalog.getString('Error'), err);
          return;
        }
        if ($scope.fromSendTab) $scope.goHome();
        else $ionicHistory.goBack();
      });
    }, 100);
  };

  $scope.goHome = function() {
    $ionicHistory.removeBackView();
    $state.go('tabs.home');
  };

});

'use strict';

angular.module('copayApp.controllers').controller('addressbookViewController', function($scope, $state, $timeout, lodash, addressbookService, popupService, $ionicHistory, platformInfo, gettextCatalog, bitcoreCash) {
  $scope.isChromeApp = platformInfo.isChromeApp;
  $scope.addressbookEntry = {};
  var coin;

  $scope.$on("$ionicView.beforeEnter", function(event, data) {
    $scope.addressbookEntry = {};
    $scope.addressbookEntry.name = data.stateParams.name;
    $scope.addressbookEntry.email = data.stateParams.email;
    $scope.addressbookEntry.address = data.stateParams.address;

    var cashAddress = bitcoreCash.Address.isValid($scope.addressbookEntry.address, 'livenet');
    if (cashAddress) {
      coin = 'bch';
    } else {
      coin = 'btc';
    }
  });

  $scope.sendTo = function() {
    $ionicHistory.removeBackView();
    $state.go('tabs.send');
    $timeout(function() {
      $state.transitionTo('tabs.send.amount', {
        toAddress: $scope.addressbookEntry.address,
        toName: $scope.addressbookEntry.name,
        toEmail: $scope.addressbookEntry.email,
        coin: coin
      });
    }, 100);
  };

  $scope.remove = function(addr) {
    var title = gettextCatalog.getString('Warning!');
    var message = gettextCatalog.getString('Are you sure you want to delete this contact?');
    popupService.showConfirm(title, message, null, null, function(res) {
      if (!res) return;
      addressbookService.remove(addr, function(err, ab) {
        if (err) {
          popupService.showAlert(gettextCatalog.getString('Error'), err);
          return;
        }
        $ionicHistory.goBack();
      });
    });
  };

});

'use strict';

angular.module('copayApp.controllers').controller('addressesController', function($scope, $log, $stateParams, $state, $timeout, $ionicHistory, $ionicScrollDelegate, popupService, gettextCatalog, ongoingProcess, lodash, profileService, walletService, bwcError, platformInfo, appConfigService, txFormatService, feeService) {
  var UNUSED_ADDRESS_LIMIT = 5;
  var BALANCE_ADDRESS_LIMIT = 5;
  var withBalance, cachedWallet;

  $scope.isCordova = platformInfo.isCordova;
  $scope.wallet = profileService.getWallet($stateParams.walletId);

  function resetValues() {
    $scope.loading = false;
    $scope.showInfo = false;
    $scope.showMore = false;
    $scope.allAddressesView = false;
    $scope.latestUnused = $scope.latestWithBalance = null;
    $scope.viewAll = {
      value: false
    };
  };

  $scope.init = function() {
    resetValues();
    $scope.loading = true;

    walletService.getMainAddresses($scope.wallet, {}, function(err, addresses) {
      if (err) {
        $scope.loading = false;
        return popupService.showAlert(bwcError.msg(err, gettextCatalog.getString('Could not update wallet')));
      }

      var allAddresses = addresses;

      walletService.getBalance($scope.wallet, {}, function(err, resp) {
        if (err) {
          $scope.loading = false;
          return popupService.showAlert(bwcError.msg(err, gettextCatalog.getString('Could not update wallet')));
        }

        withBalance = resp.byAddress;
        var idx = lodash.indexBy(withBalance, 'address');
        $scope.noBalance = lodash.reject(allAddresses, function(x) {
          return idx[x.address];
        });

        processPaths($scope.noBalance);
        processPaths(withBalance);

        $scope.latestUnused = lodash.slice($scope.noBalance, 0, UNUSED_ADDRESS_LIMIT);
        $scope.latestWithBalance = lodash.slice(withBalance, 0, BALANCE_ADDRESS_LIMIT);

        lodash.each(withBalance, function(a) {
          a.balanceStr = txFormatService.formatAmountStr($scope.wallet.coin, a.amount);
        });

        $scope.viewAll = {
          value: $scope.noBalance.length > UNUSED_ADDRESS_LIMIT || withBalance.length > BALANCE_ADDRESS_LIMIT
        };
        $scope.allAddresses = $scope.noBalance.concat(withBalance);

        cachedWallet = $scope.wallet.id;
        $scope.loading = false;
        $log.debug('Addresses cached for Wallet:', cachedWallet);
        $timeout(function() {
          $ionicScrollDelegate.resize();
          $scope.$digest();
        });
      });
    });


    walletService.getLowUtxos($scope.wallet, function(err, resp) {
      if (err) return;

      if (resp && resp.allUtxos && resp.allUtxos.length) {

        var allSum = lodash.sum(resp.allUtxos || 0, 'satoshis');
        var per = (resp.minFee / allSum) * 100;

        $scope.lowWarning = resp.warning;
        $scope.lowUtxosNb = resp.lowUtxos.length;
        $scope.allUtxosNb = resp.allUtxos.length;
        $scope.lowUtxosSum = txFormatService.formatAmountStr($scope.wallet.coin, lodash.sum(resp.lowUtxos || 0, 'satoshis'));
        $scope.allUtxosSum = txFormatService.formatAmountStr($scope.wallet.coin, allSum);
        $scope.minFee = txFormatService.formatAmountStr($scope.wallet.coin, resp.minFee || 0);
        $scope.minFeePer = per.toFixed(2) + '%';

      }
    });
  };

  function processPaths(list) {
    lodash.each(list, function(n) {
      n.path = n.path.replace(/^m/g, 'xpub');
    });
  };

  $scope.newAddress = function() {
    if ($scope.gapReached) return;

    ongoingProcess.set('generatingNewAddress', true);
    walletService.getAddress($scope.wallet, true, function(err, addr) {
      if (err) {
        ongoingProcess.set('generatingNewAddress', false);
        if (err.toString().match('MAIN_ADDRESS_GAP_REACHED')) {
          $scope.gapReached = true;
        } else {
          popupService.showAlert(err);
        }
        $timeout(function() {
          $scope.$digest();
        });
        return;
      }

      walletService.getMainAddresses($scope.wallet, {
        limit: 1
      }, function(err, _addr) {
        ongoingProcess.set('generatingNewAddress', false);
        if (err) return popupService.showAlert(gettextCatalog.getString('Error'), err);
        if (addr != _addr[0].address) return popupService.showAlert(gettextCatalog.getString('Error'), gettextCatalog.getString('New address could not be generated. Please try again.'));

        $scope.noBalance = [_addr[0]].concat($scope.noBalance);
        $scope.latestUnused = lodash.slice($scope.noBalance, 0, UNUSED_ADDRESS_LIMIT);
        $scope.viewAll = {
          value: $scope.noBalance.length > UNUSED_ADDRESS_LIMIT
        };
        $scope.$digest();
      });
    });
  };

  $scope.viewAllAddresses = function() {
    var fromView = $ionicHistory.currentStateName();
    var path;
    if (fromView.indexOf('settings') !== -1) {
      path = 'tabs.settings.allAddresses';
    } else {
      path = 'tabs.wallet.allAddresses';
    }
    $state.go(path, {
      walletId: $scope.wallet.id
    });
  };

  $scope.showInformation = function() {
    $timeout(function() {
      $scope.showInfo = !$scope.showInfo;
      $ionicScrollDelegate.resize();
    }, 10);
  };

  $scope.readMore = function() {
    $timeout(function() {
      $scope.showMore = !$scope.showMore;
      $ionicScrollDelegate.resize();
    }, 10);
  };

  $scope.scan = function() {
    walletService.startScan($scope.wallet);
    $ionicHistory.nextViewOptions({
      disableAnimate: true,
      historyRoot: true
    });
    $ionicHistory.clearHistory();
    $state.go('tabs.home').then(function() {
      $state.transitionTo('tabs.wallet', {
        walletId: $scope.wallet.credentials.walletId
      });
    });
  };

  $scope.sendByEmail = function() {
    function formatDate(ts) {
      var dateObj = new Date(ts * 1000);
      if (!dateObj) {
        $log.debug('Error formating a date');
        return 'DateError';
      }
      if (!dateObj.toJSON()) {
        return '';
      }
      return dateObj.toJSON();
    };

    ongoingProcess.set('sendingByEmail', true);
    $timeout(function() {
      var appName = appConfigService.nameCase;
      var body = appName + ' Wallet "' + $scope.wallet.name + '" Addresses\n  Only Main Addresses are  shown.\n\n';
      body += "\n";
      body += $scope.allAddresses.map(function(v) {
        return ('* ' + v.address + ' xpub' + v.path.substring(1) + ' ' + formatDate(v.createdOn));
      }).join("\n");
      ongoingProcess.set('sendingByEmail', false);

      window.plugins.socialsharing.shareViaEmail(
        body,
        appName + ' Addresses',
        null, // TO: must be null or an array
        null, // CC: must be null or an array
        null, // BCC: must be null or an array
        null, // FILES: can be null, a string, or an array
        function() {},
        function() {}
      );
    });
  };

  function isCachedWallet(walletId) {
    if (cachedWallet && cachedWallet == walletId) return true;
    else return false;
  };

  $scope.$on("$ionicView.afterEnter", function(event, data) {
    $scope.allAddressesView = data.stateName == 'tabs.receive.allAddresses' ? true : false;
    if (!isCachedWallet($stateParams.walletId)) $scope.init();
    else $log.debug('Addresses cached for Wallet:', $stateParams.walletId);
  });
});

'use strict';

angular.module('copayApp.controllers').controller('advancedSettingsController', function($scope, $log, configService, platformInfo, externalLinkService, gettextCatalog) {

  var updateConfig = function() {
    var config = configService.getSync();

    $scope.spendUnconfirmed = {
      value: config.wallet.spendUnconfirmed
    };
    $scope.recentTransactionsEnabled = {
      value: config.recentTransactions.enabled
    };
    $scope.hideNextSteps = {
      value: config.hideNextSteps.enabled
    };

  };

  $scope.spendUnconfirmedChange = function() {
    var opts = {
      wallet: {
        spendUnconfirmed: $scope.spendUnconfirmed.value
      }
    };
    configService.set(opts, function(err) {
      if (err) $log.debug(err);
    });
  };

  $scope.nextStepsChange = function() {
    var opts = {
      hideNextSteps: {
        enabled: $scope.hideNextSteps.value
      },
    };
    configService.set(opts, function(err) {
      if (err) $log.debug(err);
    });
  };

  $scope.recentTransactionsChange = function() {
    var opts = {
      recentTransactions: {
        enabled: $scope.recentTransactionsEnabled.value
      }
    };
    configService.set(opts, function(err) {
      if (err) $log.debug(err);
    });
  };

  $scope.$on("$ionicView.beforeEnter", function(event, data) {
    $scope.isWindowsPhoneApp = platformInfo.isCordova && platformInfo.isWP;
    updateConfig();
  });

});

'use strict';

angular.module('copayApp.controllers').controller('amazonController',
  function($scope, $timeout, $ionicModal, $log, $state, $ionicHistory, lodash, amazonService, externalLinkService, popupService) {

    $scope.openExternalLink = function(url) {
      externalLinkService.open(url);
    };

    var initAmazon = function() {
      amazonService.getPendingGiftCards(function(err, gcds) {
        if (err) $log.error(err);
        $scope.giftCards = gcds;
        $timeout(function() {
          $scope.$digest();
        });
      });
    };

    $scope.$on("$ionicView.beforeEnter", function(event, data) {
      $scope.network = amazonService.getNetwork();
      initAmazon();
    });
  });

'use strict';

angular.module('copayApp.controllers').controller('amazonCardsController',
  function($scope, $timeout, $ionicModal, $log, $ionicScrollDelegate, lodash, amazonService, platformInfo, externalLinkService, popupService, ongoingProcess, timeService) {

    var updateGiftCard;

    $scope.openExternalLink = function(url) {
      externalLinkService.open(url);
    };

    var checkIfCardNeedsUpdate = function(card) {
      // Continues normal flow (update card)
      if (card.status == 'PENDING' || card.status == 'invalid') {
        return true;
      }
      // Check if card status FAILURE for 24 hours
      if (card.status == 'FAILURE' && timeService.withinPastDay(card.date)) {
        return true;
      }
      // Success: do not update
      return false;
    };

    var updateGiftCards = function(cb) {
      amazonService.getPendingGiftCards(function(err, gcds) {
        if (err) {
          popupService.showAlert('Could not get gift cards', err);
          if (cb) return cb();
          else return;
        }
        $scope.giftCards = gcds;
        $timeout(function() {
          $scope.$digest();
          $ionicScrollDelegate.resize();
          if (cb) return cb();
        }, 100);
      });
    };

    $scope.updatePendingGiftCards = lodash.debounce(function() {
      $scope.updatingPending = {};
      updateGiftCards(function() {
        var index = 0;
        var gcds = $scope.giftCards;
        lodash.forEach(gcds, function(dataFromStorage) {

          updateGiftCard = checkIfCardNeedsUpdate(dataFromStorage);

          if (updateGiftCard) {
            $log.debug("Creating / Updating gift card");
            $scope.updatingPending[dataFromStorage.invoiceId] = true;

            amazonService.createGiftCard(dataFromStorage, function(err, giftCard) {

              $scope.updatingPending[dataFromStorage.invoiceId] = false;
              if (err) {
                $log.error('Error creating gift card:', err);
                giftCard = giftCard || {};
                giftCard['status'] = 'FAILURE';
              }

              if (giftCard.status != 'PENDING') {
                var newData = {};

                lodash.merge(newData, dataFromStorage, giftCard);

                if (newData.status == 'expired') {
                  amazonService.savePendingGiftCard(newData, {
                    remove: true
                  }, function(err) {
                    updateGiftCards();
                  });
                  return;
                }

                amazonService.savePendingGiftCard(newData, null, function(err) {
                  $log.debug("Amazon gift card updated");
                  updateGiftCards();
                });
              }
            });
          }
        });
      });

    }, 1000, {
      'leading': true
    });

    $scope.openCardModal = function(card) {
      $scope.card = card;
      $scope.updateGiftCard = updateGiftCard;

      $ionicModal.fromTemplateUrl('views/modals/amazon-card-details.html', {
        scope: $scope
      }).then(function(modal) {
        $scope.amazonCardDetailsModal = modal;
        $scope.amazonCardDetailsModal.show();
      });

      $scope.$on('modal.hidden', function() {
        $scope.updatePendingGiftCards();
      });
    };

    $scope.$on("$ionicView.beforeEnter", function(event, data) {
      $scope.invoiceId = data.stateParams.invoiceId;
      updateGiftCards(function() {
        if ($scope.invoiceId) {
          var card = lodash.find($scope.giftCards, {
            invoiceId: $scope.invoiceId
          });
          if (lodash.isEmpty(card)) {
            popupService.showAlert(null, 'Card not found');
            return;
          }
          updateGiftCard = checkIfCardNeedsUpdate(card);
          $scope.openCardModal(card);
        }
      });
    });

    $scope.$on("$ionicView.afterEnter", function(event, data) {
      $scope.updatePendingGiftCards();
    });
  });

'use strict';

angular.module('copayApp.controllers').controller('amountController', function($scope, $filter, $timeout, $ionicScrollDelegate, $ionicHistory, gettextCatalog, platformInfo, lodash, configService, rateService, $stateParams, $window, $state, $log, txFormatService, ongoingProcess, popupService, bwcError, payproService, profileService, bitcore, amazonService, nodeWebkitService) {
  var _id;
  var unitToSatoshi;
  var satToUnit;
  var unitDecimals;
  var satToBtc;
  var SMALL_FONT_SIZE_LIMIT = 10;
  var LENGTH_EXPRESSION_LIMIT = 19;
  var isNW = platformInfo.isNW;

  var unitIndex = 0;
  var altUnitIndex = 0;
  var availableUnits = [];
  var fiatCode;

  var fixedUnit;

  $scope.isChromeApp = platformInfo.isChromeApp;

  $scope.$on('$ionicView.leave', function() {
    angular.element($window).off('keydown');
  });

  $scope.$on("$ionicView.beforeEnter", function(event, data) {
    var config = configService.getSync().wallet.settings;

    function setAvailableUnits() {

      availableUnits = [];

      var hasBTCWallets = profileService.getWallets({
        coin: 'btc'
      }).length;

      if (hasBTCWallets) {
        availableUnits.push({
          name: 'QYBcoin',
          id: 'btc',
          shortName: 'QYB',
        });
      }


      var hasBCHWallets = profileService.getWallets({
        coin: 'bch'
      }).length;



      if (hasBCHWallets) {
        availableUnits.push({
          name: 'Qybcoin Cash',
          id: 'bch',
          shortName: 'dmb',
        });
      };

      unitIndex = 0;

      if (data.stateParams.coin) {
        var coins = data.stateParams.coin.split(',');
        var newAvailableUnits = [];

        lodash.each(coins, function(c) {
          var coin = lodash.find(availableUnits, {
            id: c
          });
          if (!coin) {
            $log.warn('Could not find desired coin:' + data.stateParams.coin)
          } else {
            newAvailableUnits.push(coin);
          }
        });

        if (newAvailableUnits.length > 0) {
          availableUnits = newAvailableUnits;
        }
      }


      //  currency have preference
      var fiatName;
      if (data.stateParams.currency) {
        fiatCode = data.stateParams.currency;
        altUnitIndex = unitIndex
        unitIndex = availableUnits.length;
      } else {
        fiatCode = config.alternativeIsoCode || 'USD';
        fiatName = config.alternanativeName || fiatCode;
        altUnitIndex = availableUnits.length;
      }

      availableUnits.push({
        name: fiatName || fiatCode,
        // TODO
        id: fiatCode,
        shortName: fiatCode,
        isFiat: true,
      });

      if (data.stateParams.fixedUnit) {
        fixedUnit = true;
      }
    };

    // Go to...
    _id = data.stateParams.id; // Optional (BitPay Card ID or Wallet ID)
    $scope.nextStep = data.stateParams.nextStep;


    setAvailableUnits();
    updateUnitUI();

    $scope.showMenu = $ionicHistory.backView() && ($ionicHistory.backView().stateName == 'tabs.send' || $ionicHistory.backView().stateName == 'tabs.bitpayCard' || $ionicHistory.backView().stateName == 'tabs.shapeshift.shift');
    $scope.recipientType = data.stateParams.recipientType || null;
    $scope.toAddress = data.stateParams.toAddress;
    $scope.toName = data.stateParams.toName;
    $scope.toEmail = data.stateParams.toEmail;
    $scope.toColor = data.stateParams.toColor;
    $scope.showSendMax = false;


    // Use only with ShapeShift
    $scope.toWalletId = data.stateParams.toWalletId;
    $scope.shiftMax = data.stateParams.shiftMax;
    $scope.shiftMin = data.stateParams.shiftMin;

    if (!$scope.nextStep && !data.stateParams.toAddress) {
      $log.error('Bad params at amount')
      throw ('bad params');
    }

    var reNr = /^[1234567890\.]$/;
    var reOp = /^[\*\+\-\/]$/;

    var disableKeys = angular.element($window).on('keydown', function(e) {
      if (!e.key) return;
      if (e.which === 8) { // you can add others here inside brackets.
        e.preventDefault();
        $scope.removeDigit();
      }

      if (e.key.match(reNr)) {
        $scope.pushDigit(e.key);
      } else if (e.key.match(reOp)) {
        $scope.pushOperator(e.key);
      } else if (e.keyCode === 86) {
        if (e.ctrlKey || e.metaKey) processClipboard();
      } else if (e.keyCode === 13) $scope.finish();

      $timeout(function() {
        $scope.$apply();
      });
    });
    $scope.specificAmount = $scope.specificAlternativeAmount = '';
    $scope.isCordova = platformInfo.isCordova;
    unitToSatoshi = config.unitToSatoshi;
    satToUnit = 1 / unitToSatoshi;
    satToBtc = 1 / 100000000;
    unitDecimals = config.unitDecimals;

    $scope.resetAmount();

    // in SAT ALWAYS
    if ($stateParams.toAmount) {
      $scope.amount = (($stateParams.toAmount) * satToUnit).toFixed(unitDecimals);
    }

    processAmount();

    $timeout(function() {
      $ionicScrollDelegate.resize();
    }, 10);
  });

  function paste(value) {
    $scope.amount = value;
    processAmount();
    $timeout(function() {
      $scope.$apply();
    });
  };

  function processClipboard() {
    if (!isNW) return;
    var value = nodeWebkitService.readFromClipboard();
    if (value && evaluate(value) > 0) paste(evaluate(value));
  };

  $scope.showSendMaxMenu = function() {
    $scope.showSendMax = true;
  };

  $scope.sendMax = function() {
    $scope.showSendMax = false;
    $scope.useSendMax = true;
    $scope.finish();
  };


  $scope.toggleAlternative = function() {
    if ($scope.amount && isExpression($scope.amount)) {
      var amount = evaluate(format($scope.amount));
      $scope.globalResult = '= ' + processResult(amount);
    }
  };

  function updateUnitUI() {
    $scope.unit = availableUnits[unitIndex].shortName;
    $scope.alternativeUnit = availableUnits[altUnitIndex].shortName;

    processAmount();
    $log.debug('Update unit coin @amount unit:' + $scope.unit + " alternativeUnit:" + $scope.alternativeUnit);
  };

  $scope.changeUnit = function() {
    if (fixedUnit) return;

    unitIndex++;
    if (unitIndex >= availableUnits.length) unitIndex = 0;


    if (availableUnits[unitIndex].isFiat) {
      // Always return to QYB... TODO?
      altUnitIndex = 0;
    } else {
      altUnitIndex = lodash.findIndex(availableUnits, {
        isFiat: true
      });
    }

    updateUnitUI();
  };


  $scope.changeAlternativeUnit = function() {

    // Do nothing is fiat is not main unit
    if (!availableUnits[unitIndex].isFiat) return;

    var nextCoin = lodash.findIndex(availableUnits, function(x) {
      if (x.isFiat) return false;
      if (x.id == availableUnits[altUnitIndex].id) return false;
      return true;
    });

    if (nextCoin >= 0) {
      altUnitIndex = nextCoin;
      updateUnitUI();
    }
  };

  function checkFontSize() {
    if ($scope.amount && $scope.amount.length >= SMALL_FONT_SIZE_LIMIT) $scope.smallFont = true;
    else $scope.smallFont = false;
  };

  $scope.pushDigit = function(digit) {
    if ($scope.amount && $scope.amount.length >= LENGTH_EXPRESSION_LIMIT) return;
    if ($scope.amount.indexOf('.') > -1 && digit == '.') return;
    if (availableUnits[unitIndex].isFiat && $scope.amount.indexOf('.') > -1 && $scope.amount[$scope.amount.indexOf('.') + 2]) return;

    $scope.amount = ($scope.amount + digit).replace('..', '.');
    checkFontSize();
    processAmount();
  };

  $scope.pushOperator = function(operator) {
    if (!$scope.amount || $scope.amount.length == 0) return;
    $scope.amount = _pushOperator($scope.amount);

    function _pushOperator(val) {
      if (!isOperator(lodash.last(val))) {
        return val + operator;
      } else {
        return val.slice(0, -1) + operator;
      }
    };
  };

  function isOperator(val) {
    var regex = /[\/\-\+\x\*]/;
    return regex.test(val);
  };

  function isExpression(val) {
    var regex = /^\.?\d+(\.?\d+)?([\/\-\+\*x]\d?\.?\d+)+$/;
    return regex.test(val);
  };

  $scope.removeDigit = function() {
    $scope.amount = ($scope.amount).toString().slice(0, -1);
    processAmount();
    checkFontSize();
  };

  $scope.resetAmount = function() {
    $scope.amount = $scope.alternativeAmount = $scope.globalResult = '';
    $scope.allowSend = false;
    checkFontSize();
  };

  function processAmount() {
    var formatedValue = format($scope.amount);
    var result = evaluate(formatedValue);
    $scope.allowSend = lodash.isNumber(result) && +result > 0;
    if (lodash.isNumber(result)) {
      $scope.globalResult = isExpression($scope.amount) ? '= ' + processResult(result) : '';

      if (availableUnits[unitIndex].isFiat) {

        var a = fromFiat(result);
        if (a) {
          $scope.alternativeAmount = txFormatService.formatAmount(a * unitToSatoshi, true);
        } else {
          if (result) {
            $scope.alternativeAmount = 'N/A';
          } else {
            $scope.alternativeAmount = null;
          }
          $scope.allowSend = false;
        }
      } else {
        $scope.alternativeAmount = $filter('formatFiatAmount')(toFiat(result));
      }
    }
  };

  function processResult(val) {
    if (availableUnits[unitIndex].isFiat) return $filter('formatFiatAmount')(val);
    else return txFormatService.formatAmount(val.toFixed(unitDecimals) * unitToSatoshi, true);
  };

  function fromFiat(val) {
    return parseFloat((rateService.fromFiat(val, fiatCode, availableUnits[altUnitIndex].id) * satToUnit).toFixed(unitDecimals));
  };

  function toFiat(val) {
    if (!rateService.getRate(fiatCode)) return;

    return parseFloat((rateService.toFiat(val * unitToSatoshi, fiatCode, availableUnits[unitIndex].id)).toFixed(2));
  };

  function evaluate(val) {
    var result;
    try {
      result = $scope.$eval(val);
    } catch (e) {
      return 0;
    }
    if (!lodash.isFinite(result)) return 0;
    return result;
  };

  function format(val) {
    if (!val) return;

    var result = val.toString();

    if (isOperator(lodash.last(val))) result = result.slice(0, -1);

    return result.replace('x', '*');
  };

  $scope.finish = function() {

    var unit = availableUnits[unitIndex];
    var _amount = evaluate(format($scope.amount));
    var coin = unit.id;
    if (unit.isFiat) {
      coin = availableUnits[altUnitIndex].id;
    }

    if ($scope.nextStep) {
      // @empty change to QYB
      $state.transitionTo($scope.nextStep, {
        id: _id,
        amount: $scope.useSendMax ? null : _amount,
        currency: 'QYB',
        coin: coin,
        useSendMax: $scope.useSendMax,
        toWalletId: $scope.toWalletId
      });
    } else {
      var amount = _amount;

      if (unit.isFiat) {
        amount = (fromFiat(amount) * unitToSatoshi).toFixed(0);
      } else {
        amount = (amount * unitToSatoshi).toFixed(0);
      }

      $state.transitionTo('tabs.send.confirm', {
        recipientType: $scope.recipientType,
        toAmount: amount,
        toAddress: $scope.toAddress,
        toName: $scope.toName,
        toEmail: $scope.toEmail,
        toColor: $scope.toColor,
        coin: coin,
        useSendMax: $scope.useSendMax
      });
    }
    $scope.useSendMax = null;
  };
});

'use strict';

angular.module('copayApp.controllers').controller('backController', function($scope, $state, $stateParams) {

  $scope.importGoBack = function() {
    if ($stateParams.fromOnboarding) $state.go('onboarding.welcome');
    else $state.go('tabs.add');
  };

  $scope.onboardingMailSkip = function() {
    $state.go('onboarding.backupRequest');
  }

});

'use strict';

angular.module('copayApp.controllers').controller('backupController',
  function($scope, $timeout, $log, $state, $stateParams, $ionicHistory, lodash, profileService, bwcService, walletService, ongoingProcess, popupService, gettextCatalog, $ionicModal) {
    $scope.wallet = profileService.getWallet($stateParams.walletId);
    $scope.viewTitle = $scope.wallet.name || $scope.wallet.credentials.walletName;
    $scope.n = $scope.wallet.n;
    var keys;

    $scope.credentialsEncrypted = $scope.wallet.isPrivKeyEncrypted();

    var isDeletedSeed = function() {
      if (!$scope.wallet.credentials.mnemonic && !$scope.wallet.credentials.mnemonicEncrypted)
        return true;

      return false;
    };

    var shuffledWords = function(words) {
      var sort = lodash.sortBy(words);

      return lodash.map(sort, function(w) {
        return {
          word: w,
          selected: false
        };
      });
    };

    $scope.setFlow = function(step) {
      if (!keys) return;

      var words = keys.mnemonic;
      $scope.data = {};

      $scope.mnemonicWords = words.split(/[\u3000\s]+/);
      $scope.shuffledMnemonicWords = shuffledWords($scope.mnemonicWords);
      $scope.mnemonicHasPassphrase = $scope.wallet.mnemonicHasPassphrase();
      $scope.useIdeograms = words.indexOf("\u3000") >= 0;
      $scope.data.passphrase = null;
      $scope.customWords = [];
      $scope.step = step || 1;
      $scope.selectComplete = false;
      $scope.backupError = false;

      words = lodash.repeat('x', 300);
      $timeout(function() {
        $scope.$apply();
      }, 10);
    };

    var backupError = function(err) {
      ongoingProcess.set('validatingWords', false);
      $log.debug('Failed to verify backup: ', err);
      $scope.backupError = true;

      $timeout(function() {
        $scope.$apply();
      }, 1);
    };

    function openConfirmBackupModal() {
      $ionicModal.fromTemplateUrl('views/includes/confirmBackupPopup.html', {
        scope: $scope,
        backdropClickToClose: false,
        hardwareBackButtonClose: false
      }).then(function(modal) {
        $scope.confirmBackupModal = modal;
        $scope.confirmBackupModal.show();
      });
    };

    var showBackupResult = function() {
      if ($scope.backupError) {
        var title = gettextCatalog.getString('Uh oh...');
        var message = gettextCatalog.getString("It's important that you write your backup phrase down correctly. If something happens to your wallet, you'll need this backup to recover your money. Please review your backup and try again.");
        popupService.showAlert(title, message, function() {
          $scope.setFlow(2);
        })
      } else {
        openConfirmBackupModal();
      }
    };

    $scope.closeBackupResultModal = function() {
      $scope.confirmBackupModal.hide();
      $scope.confirmBackupModal.remove();

      profileService.isDisclaimerAccepted(function(val) {
        if (val) {
          $ionicHistory.removeBackView();
          $state.go('tabs.home');
        } else $state.go('onboarding.disclaimer', {
          walletId: $stateParams.walletId,
          backedUp: true
        });
      });
    };

    $scope.copyRecoveryPhrase = function() {
      if ($scope.wallet.network == 'livenet') return null;
      else if (!$scope.wallet.credentials.mnemonic) return null;
      else return $scope.wallet.credentials.mnemonic;
    };

    var confirm = function(cb) {
      $scope.backupError = false;

      var customWordList = lodash.pluck($scope.customWords, 'word');

      if (!lodash.isEqual($scope.mnemonicWords, customWordList)) {
        return cb('Mnemonic string mismatch');
      }

      $timeout(function() {
        if ($scope.mnemonicHasPassphrase) {
          var walletClient = bwcService.getClient();
          var separator = $scope.useIdeograms ? '\u3000' : ' ';
          var customSentence = customWordList.join(separator);
          var passphrase = $scope.data.passphrase || '';

          try {
            walletClient.seedFromMnemonic(customSentence, {
              network: $scope.wallet.credentials.network,
              passphrase: passphrase,
              account: $scope.wallet.credentials.account
            });
          } catch (err) {
            walletClient.credentials.xPrivKey = lodash.repeat('x', 64);
            return cb(err);
          }

          if (walletClient.credentials.xPrivKey.substr(walletClient.credentials.xPrivKey) != keys.xPrivKey) {
            delete walletClient.credentials;
            return cb('Private key mismatch');
          }
        }

        profileService.setBackupFlag($scope.wallet.credentials.walletId);
        return cb();
      }, 1);
    };

    var finalStep = function() {
      ongoingProcess.set('validatingWords', true);
      confirm(function(err) {
        ongoingProcess.set('validatingWords', false);
        if (err) {
          backupError(err);
        }
        $timeout(function() {
          showBackupResult();
          return;
        }, 1);
      });
    };

    $scope.goToStep = function(n) {
      if (n == 1)
        $scope.setFlow();
      if (n == 2)
        $scope.step = 2;
      if (n == 3) {
        if (!$scope.mnemonicHasPassphrase)
          finalStep();
        else
          $scope.step = 3;
      }
      if (n == 4)
        finalStep();
    };

    $scope.addButton = function(index, item) {
      var newWord = {
        word: item.word,
        prevIndex: index
      };
      $scope.customWords.push(newWord);
      $scope.shuffledMnemonicWords[index].selected = true;
      $scope.shouldContinue();
    };

    $scope.removeButton = function(index, item) {
      if ($scope.loading) return;
      $scope.customWords.splice(index, 1);
      $scope.shuffledMnemonicWords[item.prevIndex].selected = false;
      $scope.shouldContinue();
    };

    $scope.shouldContinue = function() {
      if ($scope.customWords.length == $scope.shuffledMnemonicWords.length)
        $scope.selectComplete = true;
      else
        $scope.selectComplete = false;
    };

    $scope.$on("$ionicView.enter", function(event, data) {
      $scope.deleted = isDeletedSeed();
      if ($scope.deleted) {
        $log.debug('no mnemonics');
        return;
      }

      walletService.getKeys($scope.wallet, function(err, k) {
        if (err || !k) {
          $log.error('Could not get keys: ', err);
          $ionicHistory.goBack();
          return;
        }
        $scope.credentialsEncrypted = false;
        keys = k;
        $scope.setFlow();
      });
    });

  });

'use strict';

angular.module('copayApp.controllers').controller('bitpayCardController', function($scope, $timeout, $log, $state, lodash, bitpayCardService, moment, popupService, gettextCatalog, $ionicHistory, bitpayService, externalLinkService, timeService) {

  var self = this;
  $scope.dateRange = {
    value: 'last30Days'
  };
  $scope.network = bitpayService.getEnvironment().network;

  var setDateRange = function(preset) {
    var startDate, endDate;
    preset = preset ||  'last30Days';
    switch (preset) {
      case 'last30Days':
        startDate = moment().subtract(30, 'days').toISOString();
        endDate = moment().toISOString();
        break;
      case 'lastMonth':
        startDate = moment().startOf('month').subtract(1, 'month').toISOString();
        endDate = moment().startOf('month').toISOString();
        break;
      case 'all':
        startDate = null;
        endDate = null;
        break;
      default:
        return;
    }
    return {
      startDate: startDate,
      endDate: endDate
    };
  };

  var setGetStarted = function(history, cb) {

    // Is the card new?
    if (!lodash.isEmpty(history.transactionList))
      return cb();

    var dateRange = setDateRange('all');
    bitpayCardService.getHistory($scope.cardId, dateRange, function(err, history) {

      if (!err && lodash.isEmpty(history.transactionList))
        self.getStarted = true;

      return cb();
    });
  };

  this.update = function() {
    var dateRange = setDateRange($scope.dateRange.value);

    $scope.loadingHistory = true;
    bitpayCardService.getHistory($scope.cardId, dateRange, function(err, history) {

      $scope.loadingHistory = false;

      if (err) {
        $log.error(err);
        self.bitpayCardTransactionHistoryCompleted = null;
        self.bitpayCardTransactionHistoryConfirming = null;
        self.bitpayCardTransactionHistoryPreAuth = null;
        self.balance = null;
        popupService.showAlert(gettextCatalog.getString('Error'), gettextCatalog.getString('Could not get transactions'));
        return;
      }

      setGetStarted(history, function() {

        var txs = lodash.clone(history.txs);

        self.bitpayCardTransactionHistoryConfirming = bitpayCardService.filterTransactions('confirming', txs);
        self.bitpayCardTransactionHistoryCompleted = bitpayCardService.filterTransactions('completed', txs);
        self.bitpayCardTransactionHistoryPreAuth = bitpayCardService.filterTransactions('preAuth', txs);

        self.balance = history.currentCardBalance;
        self.updatedOn = null;

        if ($scope.dateRange.value == 'last30Days') {

          // TODO?
          // $log.debug('BitPay Card: storing cache history');
          // var cacheHistory = {
          //   balance: history.currentCardBalance,
          //   transactions: history.txs
          // };
          // bitpayCardService.setHistory($scope.cardId, cacheHistory, {}, function(err) {
          //   if (err) $log.error(err);
          //   $scope.historyCached = true;
          // });
        }
        $timeout(function() {
          $scope.$apply();
        });
      });
    });
  };

  $scope.createdWithinPastDay = function(tx) {
    var result = false;
    if (tx.date) {
      result = timeService.withinPastDay(tx.date);
    }
    return result;
  };

  this.openExternalLink = function(url) {
    var optIn = true;
    var title = null;
    var message = gettextCatalog.getString('Help and support information is available at the website.');
    var okText = gettextCatalog.getString('Open');
    var cancelText = gettextCatalog.getString('Go Back');
    externalLinkService.open(url, optIn, title, message, okText, cancelText);
  };

  this.viewOnBlockchain = function(transactionId) {
    var url = 'http://qyb.chainclub.one/tx/' + transactionId;
    var optIn = true;
    var title = null;
    var message = gettextCatalog.getString('View Transaction on Insight');
    var okText = gettextCatalog.getString('Open Insight');
    var cancelText = gettextCatalog.getString('Go Back');
    externalLinkService.open(url, optIn, title, message, okText, cancelText);
  };

  $scope.$on("$ionicView.beforeEnter", function(event, data) {
    $scope.cardId = data.stateParams.id;

    if (!$scope.cardId) {
      $ionicHistory.nextViewOptions({
        disableAnimate: true
      });
      $state.go('tabs.home');
    }


    bitpayCardService.get({
      cardId: $scope.cardId,
      noRefresh: true,
    }, function(err, cards) {

      if (cards && cards[0]) {
        self.lastFourDigits = cards[0].lastFourDigits;
        self.balance = cards[0].balance;
        self.currencySymbol = cards[0].currencySymbol;
        self.updatedOn = cards[0].updatedOn;
        self.currency = cards[0].currency;
      }
      self.update();
    });
  });
});

'use strict';
angular.module('copayApp.controllers').controller('bitpayCardIntroController', function($scope, $log, $state, $ionicHistory, storageService, externalLinkService, bitpayCardService, gettextCatalog, popupService, bitpayAccountService) {

  $scope.$on("$ionicView.beforeEnter", function(event, data) {
    if (data.stateParams && data.stateParams.secret) {
      var pairData = {
        secret: data.stateParams.secret,
        email: data.stateParams.email,
        otp: data.stateParams.otp
      };
      var pairingReason = gettextCatalog.getString('add your BitPay Visa card(s)');
      bitpayAccountService.pair(pairData, pairingReason, function(err, paired, apiContext) {
        if (err) {
          popupService.showAlert(gettextCatalog.getString('Error pairing BitPay Account'), err);
          return;
        }
        if (paired) {
          bitpayCardService.sync(apiContext, function(err, cards) {
            if (err) {
              popupService.showAlert(gettextCatalog.getString('Error updating Debit Cards'), err);
              return;
            }
            $ionicHistory.nextViewOptions({
              disableAnimate: true
            });
            $state.go('tabs.home').then(function() {
              if (cards[0]) {
                $state.transitionTo('tabs.bitpayCard', {
                  id: cards[0].id
                });
              }
            });
          });
        }
      });
    }

    bitpayAccountService.getAccounts(function(err, accounts) {
      if (err) {
        popupService.showAlert(gettextCatalog.getString('Error'), err);
        return;
      }
      $scope.accounts = accounts;
    });
  });

  $scope.bitPayCardInfo = function() {
    var url = 'https://bitpay.com/visa/faq';
    externalLinkService.open(url);
  };

  $scope.orderBitPayCard = function() {
    var url = 'https://bitpay.com/visa/get-started';
    externalLinkService.open(url);
  };

  $scope.connectBitPayCard = function() {
    if ($scope.accounts.length == 0) {
      startPairBitPayAccount();
    } else {
      showAccountSelector();
    }
  };

  var startPairBitPayAccount = function() {
    var url = 'https://bitpay.com/visa/dashboard/add-to-bitpay-wallet-confirm';
    externalLinkService.open(url);
  };

  var showAccountSelector = function() {
    $scope.accountSelectorTitle = gettextCatalog.getString('From BitPay account');
    $scope.showAccounts = ($scope.accounts != undefined);
  };

  $scope.onAccountSelect = function(account) {
    if (account == undefined) {
      startPairBitPayAccount();
    } else {
      bitpayCardService.sync(account.apiContext, function(err, data) {
        if (err) {
          popupService.showAlert(gettextCatalog.getString('Error'), err);
          return;
        }
        $state.go('tabs.home');
      });
    }
  };

});

'use strict';

angular.module('copayApp.controllers').controller('buyAmazonController', function($scope, $log, $state, $timeout, $filter, $ionicHistory, $ionicConfig, $ionicModal, lodash, amazonService, popupService, profileService, ongoingProcess, configService, walletService, payproService, bwcError, externalLinkService, platformInfo, gettextCatalog, txFormatService, emailService) {

  var coin = 'btc';
  var amount;
  var currency;
  var createdTx;
  var message;
  var invoiceId;
  var configWallet = configService.getSync().wallet;
  var FEE_TOO_HIGH_LIMIT_PER = 15;
  $scope.isCordova = platformInfo.isCordova;

  $scope.openExternalLink = function(url) {
    externalLinkService.open(url);
  };

  var _resetValues = function() {
    $scope.totalAmountStr = $scope.amount = $scope.invoiceFee = $scope.networkFee = $scope.totalAmount = $scope.wallet = null;
    createdTx = message = invoiceId = null;
  };

  var showErrorAndBack = function(title, msg) {
    title = title || gettextCatalog.getString('Error');
    $scope.sendStatus = '';
    $log.error(msg);
    msg = (msg && msg.errors) ? msg.errors[0].message : msg;
    popupService.showAlert(title, msg, function() {
      $ionicHistory.goBack();
    });
  };

  var showError = function(title, msg, cb) {
    cb = cb || function() {};
    title = title || gettextCatalog.getString('Error');
    $scope.sendStatus = '';
    $log.error(msg);
    msg = (msg && msg.errors) ? msg.errors[0].message : msg;
    popupService.showAlert(title, msg, cb);
  };

  var publishAndSign = function(wallet, txp, onSendStatusChange, cb) {
    if (!wallet.canSign() && !wallet.isPrivKeyExternal()) {
      var err = gettextCatalog.getString('No signing proposal: No private key');
      $log.info(err);
      return cb(err);
    }

    walletService.publishAndSign(wallet, txp, function(err, txp) {
      if (err) return cb(err);
      return cb(null, txp);
    }, onSendStatusChange);
  };

  var statusChangeHandler = function(processName, showName, isOn) {
    $log.debug('statusChangeHandler: ', processName, showName, isOn);
    if (processName == 'buyingGiftCard' && !isOn) {
      $scope.sendStatus = 'success';
      $timeout(function() {
        $scope.$digest();
      }, 100);
    } else if (showName) {
      $scope.sendStatus = showName;
    }
  };

  var satToFiat = function(sat, cb) {
    txFormatService.toFiat(coin, sat, $scope.currencyIsoCode, function(value) {
      return cb(value);
    });
  };

  var setTotalAmount = function(amountSat, invoiceFeeSat, networkFeeSat) {
    satToFiat(amountSat, function(a) {
      $scope.amount = Number(a);

      satToFiat(invoiceFeeSat, function(i) {
        $scope.invoiceFee = Number(i);

        satToFiat(networkFeeSat, function(n) {
          $scope.networkFee = Number(n);
          $scope.totalAmount = $scope.amount + $scope.invoiceFee + $scope.networkFee;
          $timeout(function() {
            $scope.$digest();
          });
        });
      });
    });
  };

  var createInvoice = function(data, cb) {
    amazonService.createBitPayInvoice(data, function(err, dataInvoice) {
      if (err) {
        var err_title = gettextCatalog.getString('Error creating the invoice');
        var err_msg;
        if (err && err.message && err.message.match(/suspended/i)) {
          err_title = gettextCatalog.getString('Service not available');
          err_msg = gettextCatalog.getString('Amazon.com is not available at this moment. Please try back later.');
        } else if (err && err.message) {
          err_msg = err.message;
        } else {
          err_msg = gettextCatalog.getString('Could not access to Amazon.com');
        };

        return cb({
          title: err_title,
          message: err_msg
        });
      }

      var accessKey = dataInvoice ? dataInvoice.accessKey : null;

      if (!accessKey) {
        return cb({
          message: gettextCatalog.getString('No access key defined')
        });
      }

      amazonService.getBitPayInvoice(dataInvoice.invoiceId, function(err, invoice) {
        if (err) {
          return cb({
            message: gettextCatalog.getString('Could not get the invoice')
          });
        }

        return cb(null, invoice, accessKey);
      });
    });
  };

  var createTx = function(wallet, invoice, message, cb) {
    var payProUrl = (invoice && invoice.paymentUrls) ? invoice.paymentUrls.BIP73 : null;

    if (!payProUrl) {
      return cb({
        title: gettextCatalog.getString('Error in Payment Protocol'),
        message: gettextCatalog.getString('Invalid URL')
      });
    }

    var outputs = [];
    var toAddress = invoice.bitcoinAddress;
    var amountSat = parseInt((invoice.btcDue * 100000000).toFixed(0)); // QYB to Satoshi

    outputs.push({
      'toAddress': toAddress,
      'amount': amountSat,
      'message': message
    });

    var txp = {
      toAddress: toAddress,
      amount: amountSat,
      outputs: outputs,
      message: message,
      payProUrl: payProUrl,
      excludeUnconfirmedUtxos: configWallet.spendUnconfirmed ? false : true,
      feeLevel: configWallet.settings.feeLevel || 'normal'
    };

    walletService.createTx(wallet, txp, function(err, ctxp) {
      if (err) {
        return cb({
          title: gettextCatalog.getString('Could not create transaction'),
          message: bwcError.msg(err)
        });
      }
      return cb(null, ctxp);
    });
  };

  var checkTransaction = lodash.throttle(function(count, dataSrc) {
    amazonService.createGiftCard(dataSrc, function(err, giftCard) {
      $log.debug("creating gift card " + count);
      if (err) {
        ongoingProcess.set('buyingGiftCard', false, statusChangeHandler);
        giftCard = giftCard || {};
        giftCard['status'] = 'FAILURE';
      }

      var now = moment().unix() * 1000;

      var newData = giftCard;
      newData['invoiceId'] = dataSrc.invoiceId;
      newData['accessKey'] = dataSrc.accessKey;
      newData['invoiceUrl'] = dataSrc.invoiceUrl;
      newData['amount'] = dataSrc.amount;
      newData['date'] = dataSrc.invoiceTime || now;
      newData['uuid'] = dataSrc.uuid;

      if (newData.status == 'expired') {
        amazonService.savePendingGiftCard(newData, {
          remove: true
        }, function(err) {
          $log.error(err);
          ongoingProcess.set('buyingGiftCard', false, statusChangeHandler);
          showError(null, gettextCatalog.getString('Gift card expired'));
        });
        return;
      }

      if (giftCard.status == 'PENDING' && count < 3) {
        $log.debug("Waiting for payment confirmation");

        amazonService.savePendingGiftCard(newData, null, function(err) {
          $log.debug("Saving gift card with status: " + newData.status);
        });

        checkTransaction(count + 1, dataSrc);
        return;
      }

      amazonService.savePendingGiftCard(newData, null, function(err) {
        ongoingProcess.set('buyingGiftCard', false, statusChangeHandler);
        $log.debug("Saved new gift card with status: " + newData.status);
        $scope.amazonGiftCard = newData;
      });
    });
  }, 8000, {
    'leading': true
  });

  var initialize = function(wallet) {
    var email = emailService.getEmailIfEnabled();
    var parsedAmount = txFormatService.parseAmount(coin, amount, currency);
    $scope.currencyIsoCode = parsedAmount.currency;
    $scope.amountUnitStr = parsedAmount.amountUnitStr;
    var dataSrc = {
      amount: parsedAmount.amount,
      currency: parsedAmount.currency,
      uuid: wallet.id,
      email: email
    };
    ongoingProcess.set('loadingTxInfo', true);
    createInvoice(dataSrc, function(err, invoice, accessKey) {
      if (err) {
        ongoingProcess.set('loadingTxInfo', false);
        showErrorAndBack(err.title, err.message);
        return;
      }
      // Sometimes API does not return this element;
      invoice['buyerPaidBtcMinerFee'] = invoice.buyerPaidBtcMinerFee || 0;
      var invoiceFeeSat = (invoice.buyerPaidBtcMinerFee * 100000000).toFixed();

      message = gettextCatalog.getString("{{amountStr}} for Amazon.com Gift Card", {
        amountStr: $scope.amountUnitStr
      });

      createTx(wallet, invoice, message, function(err, ctxp) {
        ongoingProcess.set('loadingTxInfo', false);
        if (err) {
          _resetValues();
          showError(err.title, err.message);
          return;
        }

        // Save in memory
        createdTx = ctxp;
        invoiceId = invoice.id;

        createdTx['giftData'] = {
          currency: dataSrc.currency,
          amount: dataSrc.amount,
          uuid: dataSrc.uuid,
          accessKey: accessKey,
          invoiceId: invoice.id,
          invoiceUrl: invoice.url,
          invoiceTime: invoice.invoiceTime
        };
        $scope.totalAmountStr = txFormatService.formatAmountStr(coin, ctxp.amount);

        // Warn: fee too high
        checkFeeHigh(Number(parsedAmount.amountSat), Number(invoiceFeeSat) + Number(ctxp.fee));

        setTotalAmount(parsedAmount.amountSat, invoiceFeeSat, ctxp.fee);
      });
    });
  };

  var checkFeeHigh = function(amount, fee) {
    var per = fee / (amount + fee) * 100;

    if (per > FEE_TOO_HIGH_LIMIT_PER) {
      $ionicModal.fromTemplateUrl('views/modals/fee-warning.html', {
        scope: $scope
      }).then(function(modal) {
        $scope.feeWarningModal = modal;
        $scope.feeWarningModal.show();
      });

      $scope.close = function() {
        $scope.feeWarningModal.hide();
      };
    }
  }

  $scope.$on("$ionicView.beforeLeave", function(event, data) {
    $ionicConfig.views.swipeBackEnabled(true);
  });

  $scope.$on("$ionicView.enter", function(event, data) {
    $ionicConfig.views.swipeBackEnabled(false);
  });

  $scope.$on("$ionicView.beforeEnter", function(event, data) {
    amount = data.stateParams.amount;
    currency = data.stateParams.currency;

    $scope.limitPerDayMessage = gettextCatalog.getString('Purchase Amount is limited to {{limitPerDay}} {{currency}} per day', {
      limitPerDay: amazonService.limitPerDay,
      currency: currency
    });

    if (amount > amazonService.limitPerDay) {
      showErrorAndBack(null, $scope.limitPerDayMessage);
      return;
    }

    $scope.network = amazonService.getNetwork();
    $scope.wallets = profileService.getWallets({
      onlyComplete: true,
      network: $scope.network,
      hasFunds: true,
      coin: coin
    });
    if (lodash.isEmpty($scope.wallets)) {
      showErrorAndBack(null, gettextCatalog.getString('No wallets available'));
      return;
    }
    $scope.onWalletSelect($scope.wallets[0]); // Default first wallet
  });

  $scope.buyConfirm = function() {
    if (!createdTx) {
      showError(null, gettextCatalog.getString('Transaction has not been created'));
      return;
    }
    var title = gettextCatalog.getString('Confirm');
    var okText = gettextCatalog.getString('OK');
    var cancelText = gettextCatalog.getString('Cancel');
    popupService.showConfirm(title, message, okText, cancelText, function(ok) {
      if (!ok) {
        $scope.sendStatus = '';
        return;
      }

      ongoingProcess.set('buyingGiftCard', true, statusChangeHandler);
      publishAndSign($scope.wallet, createdTx, function() {}, function(err, txSent) {
        if (err) {
          _resetValues();
          ongoingProcess.set('buyingGiftCard', false, statusChangeHandler);
          showError(gettextCatalog.getString('Could not send transaction'), err);
          return;
        }
        checkTransaction(1, createdTx.giftData);
      });
    });
  };

  $scope.showWalletSelector = function() {
    $scope.walletSelectorTitle = gettextCatalog.getString('Buy from');
    $scope.showWallets = true;
  };

  $scope.onWalletSelect = function(wallet) {
    $scope.wallet = wallet;
    initialize(wallet);
  };

  $scope.goBackHome = function() {
    $scope.sendStatus = '';
    $ionicHistory.nextViewOptions({
      disableAnimate: true,
      historyRoot: true
    });
    $ionicHistory.clearHistory();
    $state.go('tabs.home').then(function() {
      $ionicHistory.nextViewOptions({
        disableAnimate: true
      });
      $state.transitionTo('tabs.giftcards.amazon').then(function() {
        $state.transitionTo('tabs.giftcards.amazon.cards', {
          invoiceId: invoiceId
        });
      });
    });
  };
});

'use strict';

angular.module('copayApp.controllers').controller('buyAndSellCardController', function($scope, nextStepsService, $ionicScrollDelegate, buyAndSellService) {

  $scope.services = buyAndSellService.getLinked();

  $scope.toggle = function() {
    $scope.hide = !$scope.hide;
    $timeout(function() {
      $ionicScrollDelegate.resize();
      $scope.$apply();
    }, 10);
  };
});

'use strict';

angular.module('copayApp.controllers').controller('buyandsellController', function($scope, $ionicHistory, buyAndSellService, lodash) {

  $scope.$on("$ionicView.beforeEnter", function(event, data) {
    $scope.services = buyAndSellService.get();

    if (lodash.isEmpty($scope.services))
      $ionicHistory.goBack();
  });
});

'use strict';

angular.module('copayApp.controllers').controller('buyCoinbaseController', function($scope, $log, $state, $timeout, $ionicHistory, $ionicScrollDelegate, $ionicConfig, lodash, coinbaseService, popupService, profileService, ongoingProcess, walletService, txFormatService, externalLinkService) {

  var coin = 'btc';
  var amount;
  var currency;

  var showErrorAndBack = function(err) {
    $scope.sendStatus = '';
    $log.error(err);
    err = err.errors ? err.errors[0].message : err;
    popupService.showAlert('Error', err, function() {
      $ionicHistory.goBack();
    });
  };

  var showError = function(err) {
    $scope.sendStatus = '';
    $log.error(err);
    err = err.errors ? err.errors[0].message : err;
    popupService.showAlert('Error', err);
  };

  var statusChangeHandler = function (processName, showName, isOn) {
    $log.debug('statusChangeHandler: ', processName, showName, isOn);
    if ( processName == 'buyingBitcoin' && !isOn) {
      $scope.sendStatus = 'success';
      $timeout(function() {
        $scope.$digest();
      }, 100);
    } else if (showName) {
      $scope.sendStatus = showName;
    }
  };

  var processPaymentInfo = function() {
    ongoingProcess.set('connectingCoinbase', true);
    coinbaseService.init(function(err, res) {
      if (err) {
        ongoingProcess.set('connectingCoinbase', false);
        showErrorAndBack(err);
        return;
      }
      var accessToken = res.accessToken;

      coinbaseService.buyPrice(accessToken, coinbaseService.getAvailableCurrency(), function(err, b) {
        $scope.buyPrice = b.data || null;
      });

      $scope.paymentMethods = [];
      $scope.selectedPaymentMethodId = { value : null };
      coinbaseService.getPaymentMethods(accessToken, function(err, p) {
        if (err) {
          ongoingProcess.set('connectingCoinbase', false);
          showErrorAndBack(err);
          return;
        }

        var hasPrimary;
        var pm;
        for(var i = 0; i < p.data.length; i++) {
          pm = p.data[i];
          if (pm.allow_buy) {
            $scope.paymentMethods.push(pm);
          }
          if (pm.allow_buy && pm.primary_buy) {
            hasPrimary = true;
            $scope.selectedPaymentMethodId.value = pm.id;
          }
        }
        if (lodash.isEmpty($scope.paymentMethods)) {
          ongoingProcess.set('connectingCoinbase', false);
          var url = 'https://support.coinbase.com/customer/portal/articles/1148716-payment-methods-for-us-customers';
          var msg = 'No payment method available to buy';
          var okText = 'More info';
          var cancelText = 'Go Back';
          externalLinkService.open(url, true, null, msg, okText, cancelText, function() {
            $ionicHistory.goBack(-2);
          });
          return;
        }
        if (!hasPrimary) $scope.selectedPaymentMethodId.value = $scope.paymentMethods[0].id;
        $scope.buyRequest();
      });
    });
  };

  $scope.$on("$ionicView.beforeLeave", function(event, data) {
    $ionicConfig.views.swipeBackEnabled(true);
  });

  $scope.$on("$ionicView.enter", function(event, data) {
    $ionicConfig.views.swipeBackEnabled(false);
  });

  $scope.$on("$ionicView.beforeEnter", function(event, data) {
    $scope.isFiat = data.stateParams.currency != 'QYB' ? true : false;
    amount = data.stateParams.amount;
    currency = data.stateParams.currency;

    $scope.network = coinbaseService.getNetwork();
    $scope.wallets = profileService.getWallets({
      onlyComplete: true,
      network: $scope.network,
      coin: coin
    });

    if (lodash.isEmpty($scope.wallets)) {
      showErrorAndBack('No wallets available');
      return;
    }
    $scope.onWalletSelect($scope.wallets[0]); // Default first wallet
  });

  $scope.buyRequest = function() {
    ongoingProcess.set('connectingCoinbase', true);
    coinbaseService.init(function(err, res) {
      if (err) {
        ongoingProcess.set('connectingCoinbase', false);
        showErrorAndBack(err);
        return;
      }
      var accessToken = res.accessToken;
      var accountId = res.accountId;
      var dataSrc = {
        amount: amount,
        currency: currency,
        payment_method: $scope.selectedPaymentMethodId.value,
        quote: true
      };
      coinbaseService.buyRequest(accessToken, accountId, dataSrc, function(err, data) {
        ongoingProcess.set('connectingCoinbase', false);
        if (err) {
          showErrorAndBack(err);
          return;
        }
        $scope.buyRequestInfo = data.data;
        $timeout(function() {
          $scope.$apply();
        }, 100);
      });
    });
  };

  $scope.buyConfirm = function() {
    var message = 'Buy bitcoin for ' + $scope.amountUnitStr;
    var okText = 'Confirm';
    var cancelText = 'Cancel';
    popupService.showConfirm(null, message, okText, cancelText, function(ok) {
      if (!ok) return;

      ongoingProcess.set('buyingBitcoin', true, statusChangeHandler);
      coinbaseService.init(function(err, res) {
        if (err) {
          ongoingProcess.set('buyingBitcoin', false, statusChangeHandler);
          showError(err);
          return;
        }
        var accessToken = res.accessToken;
        var accountId = res.accountId;
        var dataSrc = {
          amount: amount,
          currency: currency,
          payment_method: $scope.selectedPaymentMethodId.value,
          commit: true
        };
        coinbaseService.buyRequest(accessToken, accountId, dataSrc, function(err, b) {
          if (err) {
            ongoingProcess.set('buyingBitcoin', false, statusChangeHandler);
            showError(err);
            return;
          }

          var processBuyTx = function (tx) {
            if (!tx) {
              ongoingProcess.set('buyingBitcoin', false, statusChangeHandler);
              showError('Transaction not found');
              return;
            }

            coinbaseService.getTransaction(accessToken, accountId, tx.id, function(err, updatedTx) {
              if (err) {
                ongoingProcess.set('buyingBitcoin', false, statusChangeHandler);
                showError(err);
                return;
              }
              walletService.getAddress($scope.wallet, false, function(err, walletAddr) {
                if (err) {
                  ongoingProcess.set('buyingBitcoin', false, statusChangeHandler);
                  showError(err);
                  return;
                }
                updatedTx.data['toAddr'] = walletAddr;
                updatedTx.data['status'] = 'pending'; // Forcing "pending" status to process later

                $log.debug('Saving transaction to process later...');
                coinbaseService.savePendingTransaction(updatedTx.data, {}, function(err) {
                  ongoingProcess.set('buyingBitcoin', false, statusChangeHandler);
                  if (err) $log.debug(err);
                });
              });
            });
          };

          var _processBuyOrder = function() {
            coinbaseService.getBuyOrder(accessToken, accountId, b.data.id, function (err, buyResp) {
              if (err) {
                ongoingProcess.set('buyingBitcoin', false, statusChangeHandler);
                showError(err);
                return;
              }
              var tx = buyResp.data ? buyResp.data.transaction : null;
              if (tx && tx.id) {
                processBuyTx(tx);
              } else {
                $timeout(function() {
                  _processBuyOrder();
                }, 5000);
              }
            });
          }

          $timeout(function() {
            var tx = b.data ? b.data.transaction : null;
            if (tx && tx.id) {
              processBuyTx(tx);
            }
            else {
              _processBuyOrder();
            }
          }, 8000);
        });
      });
    });
  };

  $scope.showWalletSelector = function() {
    $scope.walletSelectorTitle = 'Receive in';
    $scope.showWallets = true;
  };

  $scope.onWalletSelect = function(wallet) {
    $scope.wallet = wallet;
    var parsedAmount = txFormatService.parseAmount(
      coin,
      amount,
      currency);

    // Buy always in QYB
    amount = (parsedAmount.amountSat / 100000000).toFixed(8);
    currency = 'QYB';

    $scope.amountUnitStr = parsedAmount.amountUnitStr;
    ongoingProcess.set('calculatingFee', true);
    coinbaseService.checkEnoughFundsForFee(amount, function(err) {
      ongoingProcess.set('calculatingFee', false);
      if (err) {
        showErrorAndBack(err);
        return;
      }
      processPaymentInfo();
    });
  };

  $scope.goBackHome = function() {
    $scope.sendStatus = '';
    $ionicHistory.nextViewOptions({
      disableAnimate: true,
      historyRoot: true
    });
    $ionicHistory.clearHistory();
    $state.go('tabs.home').then(function() {
      $state.transitionTo('tabs.buyandsell.coinbase');
    });
  };
});

'use strict';

angular.module('copayApp.controllers').controller('buyGlideraController', function($scope, $log, $state, $timeout, $ionicHistory, $ionicConfig, lodash, glideraService, popupService, profileService, ongoingProcess, walletService, platformInfo, txFormatService) {

  var coin = 'btc';
  var amount;
  var currency;

  $scope.isCordova = platformInfo.isCordova;

  var showErrorAndBack = function(err) {
    $scope.sendStatus = '';
    $log.error(err);
    err = err.errors ? err.errors[0].message : err || '';
    popupService.showAlert('Error', err, function() {
      $ionicHistory.goBack();
    });
  };

  var showError = function(err) {
    $scope.sendStatus = '';
    $log.error(err);
    err = err.errors ? err.errors[0].message : err;
    popupService.showAlert('Error', err);
  };

  var statusChangeHandler = function (processName, showName, isOn) {
    $log.debug('statusChangeHandler: ', processName, showName, isOn);
    if ( processName == 'buyingBitcoin' && !isOn) {
      $scope.sendStatus = 'success';
      $timeout(function() {
        $scope.$digest();
      }, 100);
    } else if (showName) {
      $scope.sendStatus = showName;
    }
  };

  var processPaymentInfo = function() {
    ongoingProcess.set('connectingGlidera', true);
    glideraService.init(function(err, data) {
      if (err) {
        ongoingProcess.set('connectingGlidera', false);
        showErrorAndBack(err);
        return;
      }
      $scope.token = data.token;
      var price = {};
      if ($scope.isFiat) {
        price['fiat'] = amount;
      } else {
        price['qty'] = amount;
      }
      glideraService.buyPrice($scope.token, price, function(err, buy) {
        ongoingProcess.set('connectingGlidera', false);
        if (err) {
          showErrorAndBack(err);
          return;
        }
        $scope.buyInfo = buy;
      });
    });
  };

  $scope.$on("$ionicView.beforeLeave", function(event, data) {
    $ionicConfig.views.swipeBackEnabled(true);
  });

  $scope.$on("$ionicView.enter", function(event, data) {
    $ionicConfig.views.swipeBackEnabled(false);
  });

  $scope.$on("$ionicView.beforeEnter", function(event, data) {
    $scope.isFiat = data.stateParams.currency != 'QYB' ? true : false;
    amount = data.stateParams.amount;
    currency = data.stateParams.currency;

    $scope.network = glideraService.getNetwork();
    $scope.wallets = profileService.getWallets({
      onlyComplete: true,
      network: $scope.network,
      coin: coin
    });

    if (lodash.isEmpty($scope.wallets)) {
      showErrorAndBack('No wallets available');
      return;
    }
    $scope.onWalletSelect($scope.wallets[0]); // Default first wallet
  });

  var ask2FaCode = function(mode, cb) {
    if (mode != 'NONE') {
      // SHOW PROMPT
      var title = 'Please, enter the code below';
      var message;
      if (mode == 'PIN') {
        message = 'You have enabled PIN based two-factor authentication.';
      } else if (mode == 'AUTHENTICATOR') {
        message = 'Use an authenticator app (Authy or Google Authenticator).';
      } else {
        message = 'A SMS containing a confirmation code was sent to your phone.';
      }
      popupService.showPrompt(title, message, null, function(twoFaCode) {
        if (typeof twoFaCode == 'undefined') return cb();
        return cb(twoFaCode);
      });
    } else {
      return cb();
    }
  };

  $scope.buyConfirm = function() {
    var message = 'Buy bitcoin for ' + amount + ' ' + currency;
    var okText = 'Confirm';
    var cancelText = 'Cancel';
    popupService.showConfirm(null, message, okText, cancelText, function(ok) {
      if (!ok) return;
      ongoingProcess.set('buyingBitcoin', true, statusChangeHandler);
      glideraService.get2faCode($scope.token, function(err, tfa) {
        if (err) {
          ongoingProcess.set('buyingBitcoin', false, statusChangeHandler);
          showError(err);
          return;
        }
        ask2FaCode(tfa.mode, function(twoFaCode) {
          if (tfa.mode != 'NONE' && lodash.isEmpty(twoFaCode)) {
            ongoingProcess.set('buyingBitcoin', false, statusChangeHandler);
            showError('No code entered');
            return;
          }

          walletService.getAddress($scope.wallet, false, function(err, walletAddr) {
            if (err) {
              ongoingProcess.set('buyingBitcoin', false, statusChangeHandler);
              showError(err);
              return;
            }
            var data = {
              destinationAddress: walletAddr,
              qty: $scope.buyInfo.qty,
              priceUuid: $scope.buyInfo.priceUuid,
              useCurrentPrice: false,
              ip: null
            };
            glideraService.buy($scope.token, twoFaCode, data, function(err, data) {
              ongoingProcess.set('buyingBitcoin', false, statusChangeHandler);
              if (err) return showError(err);
              $log.info(data);
            });
          });
        });
      });
    });
  };

  $scope.showWalletSelector = function() {
    $scope.walletSelectorTitle = 'Receive in';
    $scope.showWallets = true;
  };

  $scope.onWalletSelect = function(wallet) {
    $scope.wallet = wallet;
    var parsedAmount = txFormatService.parseAmount(
      coin,
      amount,
      currency);

    amount = parsedAmount.amount;
    currency = parsedAmount.currency;
    $scope.amountUnitStr = parsedAmount.amountUnitStr;
    processPaymentInfo();
  };

  $scope.goBackHome = function() {
    $scope.sendStatus = '';
    $ionicHistory.nextViewOptions({
      disableAnimate: true,
      historyRoot: true
    });
    $ionicHistory.clearHistory();
    $state.go('tabs.home').then(function() {
      $state.transitionTo('tabs.buyandsell.glidera');
    });
  };
});

'use strict';

angular.module('copayApp.controllers').controller('buyMercadoLibreController', function($scope, $log, $state, $timeout, $filter, $ionicHistory, $ionicConfig, $ionicModal, lodash, mercadoLibreService, popupService, profileService, ongoingProcess, configService, walletService, payproService, bwcError, externalLinkService, platformInfo, txFormatService, gettextCatalog, emailService) {

  var coin = 'btc';
  var amount;
  var currency;
  var createdTx;
  var message;
  var invoiceId;
  var configWallet = configService.getSync().wallet;
  var FEE_TOO_HIGH_LIMIT_PER = 15;
  $scope.isCordova = platformInfo.isCordova;

  $scope.openExternalLink = function(url) {
    externalLinkService.open(url);
  };

  var _resetValues = function() {
    $scope.totalAmountStr = $scope.amount = $scope.invoiceFee = $scope.networkFee = $scope.totalAmount = $scope.wallet = null;
    createdTx = message = invoiceId = null;
  };

  var showErrorAndBack = function(title, msg) {
    title = title || gettextCatalog.getString('Error');
    $scope.sendStatus = '';
    $log.error(msg);
    msg = (msg && msg.errors) ? msg.errors[0].message : msg;
    popupService.showAlert(title, msg, function() {
      $ionicHistory.goBack();
    });
  };

  var showError = function(title, msg, cb) {
    cb = cb || function() {};
    title = title || gettextCatalog.getString('Error');
    $scope.sendStatus = '';
    $log.error(msg);
    msg = (msg && msg.errors) ? msg.errors[0].message : msg;
    popupService.showAlert(title, msg, cb);
  };

  var publishAndSign = function(wallet, txp, onSendStatusChange, cb) {
    if (!wallet.canSign() && !wallet.isPrivKeyExternal()) {
      var err = 'No signing proposal: No private key';
      $log.info(err);
      return cb(err);
    }

    walletService.publishAndSign(wallet, txp, function(err, txp) {
      if (err) return cb(err);
      return cb(null, txp);
    }, onSendStatusChange);
  };

  var statusChangeHandler = function(processName, showName, isOn) {
    $log.debug('statusChangeHandler: ', processName, showName, isOn);
    if (processName == 'Comprando Vale-Presente' && !isOn) {
      $scope.sendStatus = 'success';
      $timeout(function() {
        $scope.$digest();
      }, 100);
    } else if (showName) {
      $scope.sendStatus = showName;
    }
  };

  var satToFiat = function(sat, cb) {
    txFormatService.toFiat(coin, sat, $scope.currencyIsoCode, function(value) {
      return cb(value);
    });
  };

  var setTotalAmount = function(amountSat, invoiceFeeSat, networkFeeSat) {
    satToFiat(amountSat, function(a) {
      $scope.amount = Number(a);

      satToFiat(invoiceFeeSat, function(i) {
        $scope.invoiceFee = Number(i);

        satToFiat(networkFeeSat, function(n) {
          $scope.networkFee = Number(n);
          $scope.totalAmount = $scope.amount + $scope.invoiceFee + $scope.networkFee;
          $timeout(function() {
            $scope.$digest();
          });
        });
      });
    });
  };

  var createInvoice = function(data, cb) {
    mercadoLibreService.createBitPayInvoice(data, function(err, dataInvoice) {
      if (err) {
        var err_title = gettextCatalog.getString('Error creating the invoice');
        var err_msg;
        if (err && err.message && err.message.match(/suspended/i)) {
          err_title = gettextCatalog.getString('Service not available');
          err_msg = gettextCatalog.getString('Mercadolibre Gift Card Service is not available at this moment. Please try back later.');
        } else if (err && err.message) {
          err_msg = err.message;
        } else {
          err_msg = gettextCatalog.getString('Could not access Gift Card Service');
        };

        return cb({
          title: err_title,
          message: err_msg
        });
      }

      var accessKey = dataInvoice ? dataInvoice.accessKey : null;

      if (!accessKey) {
        return cb({
          message: gettextCatalog.getString('No access key defined')
        });
      }

      mercadoLibreService.getBitPayInvoice(dataInvoice.invoiceId, function(err, invoice) {
        if (err) {
          return cb({
            message: gettextCatalog.getString('Could not get the invoice')
          });
        }

        return cb(null, invoice, accessKey);
      });
    });
  };

  var createTx = function(wallet, invoice, message, cb) {
    var payProUrl = (invoice && invoice.paymentUrls) ? invoice.paymentUrls.BIP73 : null;

    if (!payProUrl) {
      return cb({
        title: gettextCatalog.getString('Error in Payment Protocol'),
        message: gettextCatalog.getString('Invalid URL')
      });
    }

    var outputs = [];
    var toAddress = invoice.bitcoinAddress;
    var amountSat = parseInt((invoice.btcDue * 100000000).toFixed(0)); // QYB to Satoshi

    outputs.push({
      'toAddress': toAddress,
      'amount': amountSat,
      'message': message
    });

    var txp = {
      toAddress: toAddress,
      amount: amountSat,
      outputs: outputs,
      message: message,
      payProUrl: payProUrl,
      excludeUnconfirmedUtxos: configWallet.spendUnconfirmed ? false : true,
      feeLevel: configWallet.settings.feeLevel || 'normal'
    };

    walletService.createTx(wallet, txp, function(err, ctxp) {
      if (err) {
        return cb({
          title: gettextCatalog.getString('Could not create transaction'),
          message: bwcError.msg(err)
        });
      }
      return cb(null, ctxp);
    });
  };

  var checkTransaction = lodash.throttle(function(count, dataSrc) {
    mercadoLibreService.createGiftCard(dataSrc, function(err, giftCard) {
      $log.debug("creating gift card " + count);
      if (err) {
        $scope.sendStatus = '';
        ongoingProcess.set('Comprando Vale-Presente', false, statusChangeHandler);
        giftCard = giftCard || {};
        giftCard['status'] = 'FAILURE';
      }

      if (giftCard && giftCard.cardStatus && (giftCard.cardStatus != 'active' && giftCard.cardStatus != 'inactive' && giftCard.cardStatus != 'expired')) {
        $scope.sendStatus = '';
        ongoingProcess.set('Comprando Vale-Presente', false, statusChangeHandler);
        giftCard = giftCard || {};
        giftCard['status'] = 'FAILURE';
      }

      var now = moment().unix() * 1000;

      var newData = giftCard;
      newData['invoiceId'] = dataSrc.invoiceId;
      newData['accessKey'] = dataSrc.accessKey;
      newData['invoiceUrl'] = dataSrc.invoiceUrl;
      newData['amount'] = dataSrc.amount;
      newData['currency'] = dataSrc.currency;
      newData['date'] = dataSrc.invoiceTime || now;
      newData['uuid'] = dataSrc.uuid;

      if (giftCard.status == 'PENDING' && count < 3) {
        $log.debug("Waiting for payment confirmation");

        mercadoLibreService.savePendingGiftCard(newData, null, function(err) {
          $log.debug("Saving gift card with status: " + newData.status);
        });

        checkTransaction(count + 1, dataSrc);
        return;
      }

      mercadoLibreService.savePendingGiftCard(newData, null, function(err) {
        ongoingProcess.set('Comprando Vale-Presente', false, statusChangeHandler);
        $log.debug("Saved new gift card with status: " + newData.status);
        $scope.mlGiftCard = newData;
      });
    });
  }, 8000, {
    'leading': true
  });

  var initialize = function(wallet) {
    var email = emailService.getEmailIfEnabled();
    var parsedAmount = txFormatService.parseAmount(coin, amount, currency);
    $scope.currencyIsoCode = parsedAmount.currency;
    $scope.amountUnitStr = parsedAmount.amountUnitStr;
    var dataSrc = {
      amount: parsedAmount.amount,
      currency: parsedAmount.currency,
      uuid: wallet.id,
      email: email
    };
    ongoingProcess.set('loadingTxInfo', true);
    createInvoice(dataSrc, function(err, invoice, accessKey) {
      if (err) {
        ongoingProcess.set('loadingTxInfo', false);
        showErrorAndBack(err.title, err.message);
        return;
      }
      // Sometimes API does not return this element;
      invoice['buyerPaidBtcMinerFee'] = invoice.buyerPaidBtcMinerFee || 0;
      var invoiceFeeSat = (invoice.buyerPaidBtcMinerFee * 100000000).toFixed();

      message = gettextCatalog.getString("{{amountStr}} for Mercado Livre Brazil Gift Card", {
        amountStr: $scope.amountUnitStr
      });

      createTx(wallet, invoice, message, function(err, ctxp) {
        ongoingProcess.set('loadingTxInfo', false);
        if (err) {
          _resetValues();
          showError(err.title, err.message);
          return;
        }

        // Save in memory
        createdTx = ctxp;
        invoiceId = invoice.id;

        createdTx['giftData'] = {
          currency: dataSrc.currency,
          amount: dataSrc.amount,
          uuid: dataSrc.uuid,
          accessKey: accessKey,
          invoiceId: invoice.id,
          invoiceUrl: invoice.url,
          invoiceTime: invoice.invoiceTime
        };
        $scope.totalAmountStr = txFormatService.formatAmountStr(coin, ctxp.amount);

        // Warn: fee too high
        checkFeeHigh(Number(parsedAmount.amountSat), Number(invoiceFeeSat) + Number(ctxp.fee));

        setTotalAmount(parsedAmount.amountSat, invoiceFeeSat, ctxp.fee);
      });
    });
  };

  var checkFeeHigh = function(amount, fee) {
    var per = fee / (amount + fee) * 100;

    if (per > FEE_TOO_HIGH_LIMIT_PER) {
      $ionicModal.fromTemplateUrl('views/modals/fee-warning.html', {
        scope: $scope
      }).then(function(modal) {
        $scope.feeWarningModal = modal;
        $scope.feeWarningModal.show();
      });

      $scope.close = function() {
        $scope.feeWarningModal.hide();
      };
    }
  }

  $scope.$on("$ionicView.beforeLeave", function(event, data) {
    $ionicConfig.views.swipeBackEnabled(true);
  });

  $scope.$on("$ionicView.enter", function(event, data) {
    $ionicConfig.views.swipeBackEnabled(false);
  });

  $scope.$on("$ionicView.beforeEnter", function(event, data) {
    amount = data.stateParams.amount;
    currency = data.stateParams.currency;

    if (amount > 2000 || amount < 50) {
      showErrorAndBack(null, gettextCatalog.getString('Purchase amount must be a value between 50 and 2000'));
      return;
    }

    $scope.network = mercadoLibreService.getNetwork();
    $scope.wallets = profileService.getWallets({
      onlyComplete: true,
      network: $scope.network,
      coin: coin
    });
    if (lodash.isEmpty($scope.wallets)) {
      showErrorAndBack(null, gettextCatalog.getString('No wallets available'));
      return;
    }
    $scope.onWalletSelect($scope.wallets[0]); // Default first wallet
  });

  $scope.buyConfirm = function() {

    if (!createdTx) {
      showError(null, gettextCatalog.getString('Transaction has not been created'));
      return;
    }

    var title = gettextCatalog.getString('Confirm');
    var okText = gettextCatalog.getString('Ok');
    var cancelText = gettextCatalog.getString('Cancel');
    popupService.showConfirm(title, message, okText, cancelText, function(ok) {
      if (!ok) {
        $scope.sendStatus = '';
        return;
      }

      ongoingProcess.set('Comprando Vale-Presente', true, statusChangeHandler);
      publishAndSign($scope.wallet, createdTx, function() {}, function(err, txSent) {
        if (err) {
          ongoingProcess.set('Comprando Vale-Presente', false, statusChangeHandler);
          showError(gettextCatalog.getString('Could not send transaction'), err);
          return;
        }
        checkTransaction(1, createdTx.giftData);
      });
    });
  };

  $scope.showWalletSelector = function() {
    $scope.walletSelectorTitle = 'Buy from';
    $scope.showWallets = true;
  };

  $scope.onWalletSelect = function(wallet) {
    $scope.wallet = wallet;
    initialize(wallet);
  };

  $scope.goBackHome = function() {
    $scope.sendStatus = '';
    $ionicHistory.nextViewOptions({
      disableAnimate: true,
      historyRoot: true
    });
    $ionicHistory.clearHistory();
    $state.go('tabs.home').then(function() {
      $ionicHistory.nextViewOptions({
        disableAnimate: true
      });
      $state.transitionTo('tabs.giftcards.mercadoLibre').then(function() {
        $state.transitionTo('tabs.giftcards.mercadoLibre.cards', {
          invoiceId: invoiceId
        });
      });
    });
  };
});

'use strict';

angular.module('copayApp.controllers').controller('coinbaseController', function($scope, $timeout, $ionicModal, $ionicHistory, $log, coinbaseService, lodash, platformInfo, ongoingProcess, popupService, externalLinkService) {

  var isNW = platformInfo.isNW;
  var isCordova = platformInfo.isCordova;

  var init = function() {
    $scope.currency = coinbaseService.getAvailableCurrency();
    coinbaseService.getStoredToken(function(at) {
      $scope.accessToken = at;

      // Update Access Token if necessary
      $scope.loading = true;
      coinbaseService.init(function(err, data) {
        $scope.loading = false;
        if (err || lodash.isEmpty(data)) {
          if (err) {
            $log.error(err);
            var errorId = err.errors ? err.errors[0].id : null;
            err = err.errors ? err.errors[0].message : err;
            popupService.showAlert('Error connecting to Coinbase', err, function() {
              if (errorId == 'revoked_token') {
                coinbaseService.logout(function() {});
              }
              $ionicHistory.goBack();
            });
          }
          return;
        }

        // Show rates
        coinbaseService.buyPrice(data.accessToken, $scope.currency, function(err, b) {
          $scope.buyPrice = b.data || null;
        });
        coinbaseService.sellPrice(data.accessToken, $scope.currency, function(err, s) {
          $scope.sellPrice = s.data || null;
        });

        // Updating accessToken and accountId
        $timeout(function() {
          $scope.accessToken = data.accessToken;
          $scope.accountId = data.accountId;
          $scope.updateTransactions();
          $scope.$apply();
        }, 100);
      });
    });
  };

  $scope.updateTransactions = function() {
    $log.debug('Getting transactions...');
    $scope.pendingTransactions = { data: {} };
    coinbaseService.getPendingTransactions($scope.pendingTransactions);
  };

  this.openAuthenticateWindow = function() {
    var oauthUrl = this.getAuthenticateUrl();
    if (!isNW) {
      externalLinkService.open(oauthUrl);
    } else {
      var self = this;
      var gui = require('nw.gui');
      gui.Window.open(oauthUrl, {
        focus: true,
        position: 'center'
      }, function(new_win) {
        new_win.on('loaded', function() {
          var title = new_win.window.document.title;
          $timeout(function() {
            if (title.indexOf('Coinbase') == -1) {
              $scope.code = title;
              self.submitOauthCode($scope.code);
              new_win.close();
            }
          }, 100);
        });
      });
    }
  }

  this.openSignupWindow = function() {
    var url = coinbaseService.getSignupUrl();
    var optIn = true;
    var title = 'Sign Up for Coinbase';
    var message = 'This will open Coinbase.com, where you can create an account.';
    var okText = 'Go to Coinbase';
    var cancelText = 'Back';
    externalLinkService.open(url, optIn, title, message, okText, cancelText);
  }

  this.openSupportWindow = function() {
    var url = coinbaseService.getSupportUrl();
    var optIn = true;
    var title = 'Coinbase Support';
    var message = 'You can email support@coinbase.com for direct support, or you can view their help center.';
    var okText = 'Open Help Center';
    var cancelText = 'Go Back';
    externalLinkService.open(url, optIn, title, message, okText, cancelText);
  }

  this.getAuthenticateUrl = function() {
    $scope.showOauthForm = isCordova || isNW ? false : true;
    return coinbaseService.getOauthCodeUrl();
  };

  this.toggleOauthForm = function() {
    $scope.showOauthForm = !$scope.showOauthForm;
  }

  this.submitOauthCode = function(code) {
    var self = this;
    ongoingProcess.set('connectingCoinbase', true);
    coinbaseService.getToken(code, function(err, accessToken) {
      ongoingProcess.set('connectingCoinbase', false);
      if (err) {
        popupService.showAlert('Error connecting to Coinbase', err);
        return;
      }
      $scope.accessToken = accessToken;
      init();
    });
  };

  this.openTxModal = function(tx) {
    $scope.tx = tx;

    $ionicModal.fromTemplateUrl('views/modals/coinbase-tx-details.html', {
      scope: $scope,
      animation: 'slide-in-up'
    }).then(function(modal) {
      $scope.modal = modal;
      $scope.modal.show();
    });
  };

  var self = this;
  $scope.$on("$ionicView.beforeEnter", function(event, data) {
    $scope.showOauthForm = false;
    if (data.stateParams && data.stateParams.code) {
      coinbaseService.getStoredToken(function(at) {
        if (!at) self.submitOauthCode(data.stateParams.code);
      });
    } else {
      init();
    }
  });
});

'use strict';

angular.module('copayApp.controllers').controller('confirmController', function($rootScope, $scope, $interval, $filter, $timeout, $ionicScrollDelegate, gettextCatalog, walletService, platformInfo, lodash, configService, $stateParams, $window, $state, $log, profileService, bitcore, bitcoreCash, txFormatService, ongoingProcess, $ionicModal, popupService, $ionicHistory, $ionicConfig, payproService, feeService, bwcError, txConfirmNotification, externalLinkService) {

  var countDown = null;
  var CONFIRM_LIMIT_USD = 20;
  var FEE_TOO_HIGH_LIMIT_PER = 15;

  var tx = {};

  // Config Related values
  var config = configService.getSync();
  var walletConfig = config.wallet;
  var unitToSatoshi = walletConfig.settings.unitToSatoshi;
  var unitDecimals = walletConfig.settings.unitDecimals;
  var satToUnit = 1 / unitToSatoshi;
  var configFeeLevel = walletConfig.settings.feeLevel ? walletConfig.settings.feeLevel : 'normal';


  // Platform info
  var isChromeApp = platformInfo.isChromeApp;
  var isCordova = platformInfo.isCordova;
  var isWindowsPhoneApp = platformInfo.isCordova && platformInfo.isWP;

  //custom fee flag
  var usingCustomFee = null;

  function refresh() {
    $timeout(function() {
      $scope.$apply();
    }, 10);
  }


  $scope.showWalletSelector = function() {
    $scope.walletSelector = true;
    refresh();
  };

  $scope.$on("$ionicView.beforeLeave", function(event, data) {
    $ionicConfig.views.swipeBackEnabled(true);
  });

  $scope.$on("$ionicView.enter", function(event, data) {
    $ionicConfig.views.swipeBackEnabled(false);
  });


  function exitWithError(err) {
    $log.info('Error setting wallet selector:' + err);
    popupService.showAlert(gettextCatalog.getString(), bwcError.msg(err), function() {
      $ionicHistory.nextViewOptions({
        disableAnimate: true,
        historyRoot: true
      });
      $ionicHistory.clearHistory();
      $state.go('tabs.send');
    });
  };

  function setNoWallet(msg, criticalError) {
    $scope.wallet = null;
    $scope.noWalletMessage = msg;
    $scope.criticalError = criticalError;
    $log.warn('Not ready to make the payment:' + msg);
    $timeout(function() {
      $scope.$apply();
    });
  };

  $scope.$on("$ionicView.beforeEnter", function(event, data) {

    function setWalletSelector(coin, network, minAmount, cb) {

      // no min amount? (sendMax) => look for no empty wallets
      minAmount = minAmount || 1;

      $scope.wallets = profileService.getWallets({
        onlyComplete: true,
        network: network,
        coin: coin
      });

      if (!$scope.wallets || !$scope.wallets.length) {
        setNoWallet(gettextCatalog.getString('No wallets available'), true);
        return cb();
      }

      var filteredWallets = [];
      var index = 0;
      var walletsUpdated = 0;

      lodash.each($scope.wallets, function(w) {
        walletService.getStatus(w, {}, function(err, status) {
          if (err || !status) {
            $log.error(err);
          } else {
            walletsUpdated++;
            w.status = status;

            if (!status.availableBalanceSat)
              $log.debug('No balance available in: ' + w.name);

            if (status.availableBalanceSat > minAmount) {
              filteredWallets.push(w);
            }
          }

          if (++index == $scope.wallets.length) {
            if (!walletsUpdated)
              return cb('Could not update any wallet');

            if (lodash.isEmpty(filteredWallets)) {
              setNoWallet(gettextCatalog.getString('Insufficient funds'), true);
            }
            $scope.wallets = lodash.clone(filteredWallets);
            return cb();
          }
        });
      });
    };

    // Setup $scope

    var B = data.stateParams.coin == 'bch' ? bitcoreCash : bitcore;
    var networkName;
    try {
      networkName = (new B.Address(data.stateParams.toAddress)).network.name;
    } catch (e) {
      var message = gettextCatalog.getString('Qyb only supports Qybcoin Cash using new version numbers addresses');
      var backText = gettextCatalog.getString('Go back');
      var learnText = gettextCatalog.getString('Learn more');
      popupService.showConfirm(null, message, backText, learnText, function(back) {
        $ionicHistory.nextViewOptions({
          disableAnimate: true,
          historyRoot: true
        });
        $state.go('tabs.send').then(function() {
          $ionicHistory.clearHistory();
          if (!back) {
            var url = 'https://support.bitpay.com/hc/en-us/articles/115004671663';
            externalLinkService.open(url);
          }
        });
      });
      return;
    }

    // Grab stateParams
    tx = {
      toAmount: parseInt(data.stateParams.toAmount),
      sendMax: data.stateParams.useSendMax == 'true' ? true : false,
      toAddress: data.stateParams.toAddress,
      description: data.stateParams.description,
      paypro: data.stateParams.paypro,

      feeLevel: configFeeLevel,
      spendUnconfirmed: walletConfig.spendUnconfirmed,

      // Vanity tx info (not in the real tx)
      recipientType: data.stateParams.recipientType || null,
      toName: data.stateParams.toName,
      toEmail: data.stateParams.toEmail,
      toColor: data.stateParams.toColor,
      network: networkName,
      coin: data.stateParams.coin,
      txp: {},
    };

    if (tx.coin && tx.coin == 'bch') tx.feeLevel = 'normal';

    // Other Scope vars
    $scope.isCordova = isCordova;
    $scope.isWindowsPhoneApp = isWindowsPhoneApp;
    $scope.showAddress = false;

    $scope.walletSelectorTitle = gettextCatalog.getString('Send from');

    setWalletSelector(tx.coin, tx.network, tx.toAmount, function(err) {
      if (err) {
        return exitWithError('Could not update wallets');
      }

      if ($scope.wallets.length > 1) {
        $scope.showWalletSelector();
      } else if ($scope.wallets.length) {
        setWallet($scope.wallets[0], tx);
      }
    });

  });


  function getSendMaxInfo(tx, wallet, cb) {
    if (!tx.sendMax) return cb();

    //ongoingProcess.set('retrievingInputs', true);
    walletService.getSendMaxInfo(wallet, {
      feePerKb: tx.feeRate,
      excludeUnconfirmedUtxos: !tx.spendUnconfirmed,
      returnInputs: true,
    }, cb);
  };


  function getTxp(tx, wallet, dryRun, cb) {

    // ToDo: use a credential's (or fc's) function for this
    if (tx.description && !wallet.credentials.sharedEncryptingKey) {
      var msg = gettextCatalog.getString('Could not add message to imported wallet without shared encrypting key');
      $log.warn(msg);
      return setSendError(msg);
    }

    if (tx.toAmount > Number.MAX_SAFE_INTEGER) {
      var msg = gettextCatalog.getString('Amount too big');
      $log.warn(msg);
      return setSendError(msg);
    }

    var txp = {};

    txp.outputs = [{
      'toAddress': tx.toAddress,
      'amount': tx.toAmount,
      'message': tx.description
    }];

    if (tx.sendMaxInfo) {
      txp.inputs = tx.sendMaxInfo.inputs;
      txp.fee = tx.sendMaxInfo.fee;
    } else {
      if (usingCustomFee) {
        txp.feePerKb = tx.feeRate;
      } else txp.feeLevel = tx.feeLevel;
    }

    txp.message = tx.description;

    if (tx.paypro) {
      txp.payProUrl = tx.paypro.url;
    }
    txp.excludeUnconfirmedUtxos = !tx.spendUnconfirmed;
    txp.dryRun = dryRun;
    walletService.createTx(wallet, txp, function(err, ctxp) {
      if (err) {
        setSendError(err);
        return cb(err);
      }
      return cb(null, ctxp);
    });
  };

  function updateTx(tx, wallet, opts, cb) {
    ongoingProcess.set('calculatingFee', true);

    if (opts.clearCache) {
      tx.txp = {};
    }

    $scope.tx = tx;

    function updateAmount() {
      if (!tx.toAmount) return;

      // Amount
      tx.amountStr = txFormatService.formatAmountStr(wallet.coin, tx.toAmount);
      tx.amountValueStr = tx.amountStr.split(' ')[0];
      tx.amountUnitStr = tx.amountStr.split(' ')[1];
      txFormatService.formatAlternativeStr(wallet.coin, tx.toAmount, function(v) {
        tx.alternativeAmountStr = v;
      });
    }

    updateAmount();
    refresh();

    // End of quick refresh, before wallet is selected.
    if (!wallet) {
      ongoingProcess.set('calculatingFee', false);
      return cb();
    }

    feeService.getFeeRate(wallet.coin, tx.network, tx.feeLevel, function(err, feeRate) {
      if (err) {
        ongoingProcess.set('calculatingFee', false);
        return cb(err);
      }

      if (!usingCustomFee) tx.feeRate = feeRate;
      tx.feeLevelName = feeService.feeOpts[tx.feeLevel];

      getSendMaxInfo(lodash.clone(tx), wallet, function(err, sendMaxInfo) {
        if (err) {
          ongoingProcess.set('calculatingFee', false);
          var msg = gettextCatalog.getString('Error getting SendMax information');
          return setSendError(msg);
        }

        if (sendMaxInfo) {

          $log.debug('Send max info', sendMaxInfo);

          if (tx.sendMax && sendMaxInfo.amount == 0) {
            ongoingProcess.set('calculatingFee', false);
            setNoWallet(gettextCatalog.getString('Insufficient funds'));
            popupService.showAlert(gettextCatalog.getString('Error'), gettextCatalog.getString('Not enough funds for fee'));
            return cb('no_funds');
          }

          tx.sendMaxInfo = sendMaxInfo;
          tx.toAmount = tx.sendMaxInfo.amount;
          updateAmount();
          ongoingProcess.set('calculatingFee', false);
          $timeout(function() {
            showSendMaxWarning(wallet, sendMaxInfo);
          }, 200);
        }

        // txp already generated for this wallet?
        if (tx.txp[wallet.id]) {
          ongoingProcess.set('calculatingFee', false);
          refresh();
          return cb();
        }

        getTxp(lodash.clone(tx), wallet, opts.dryRun, function(err, txp) {
          ongoingProcess.set('calculatingFee', false);
          if (err) {
            return cb(err);
          }

          txp.feeStr = txFormatService.formatAmountStr(wallet.coin, txp.fee);
          txFormatService.formatAlternativeStr(wallet.coin, txp.fee, function(v) {
            txp.alternativeFeeStr = v;
          });

          var per = (txp.fee / (txp.amount + txp.fee) * 100);
          txp.feeRatePerStr = per.toFixed(2) + '%';
          txp.feeTooHigh = per > FEE_TOO_HIGH_LIMIT_PER;

          if (txp.feeTooHigh) {
            $ionicModal.fromTemplateUrl('views/modals/fee-warning.html', {
              scope: $scope
            }).then(function(modal) {
              $scope.feeWarningModal = modal;
              $scope.feeWarningModal.show();
            });

            $scope.close = function() {
              $scope.feeWarningModal.hide();
            };
          }

          tx.txp[wallet.id] = txp;
          $log.debug('Confirm. TX Fully Updated for wallet:' + wallet.id, tx);
          refresh();

          return cb();
        });
      });
    });
  }

  function useSelectedWallet() {

    if (!$scope.useSendMax) {
      showAmount(tx.toAmount);
    }

    $scope.onWalletSelect($scope.wallet);
  }

  function setButtonText(isMultisig, isPayPro) {

    if (isPayPro) {
      if (isCordova && !isWindowsPhoneApp) {
        $scope.buttonText = gettextCatalog.getString('Slide to pay');
      } else {
        $scope.buttonText = gettextCatalog.getString('Click to pay');
      }
    } else if (isMultisig) {
      if (isCordova && !isWindowsPhoneApp) {
        $scope.buttonText = gettextCatalog.getString('Slide to accept');
      } else {
        $scope.buttonText = gettextCatalog.getString('Click to accept');
      }
    } else {
      if (isCordova && !isWindowsPhoneApp) {
        $scope.buttonText = gettextCatalog.getString('Slide to send');
      } else {
        $scope.buttonText = gettextCatalog.getString('Click to send');
      }
    }
  };


  $scope.toggleAddress = function() {
    $scope.showAddress = !$scope.showAddress;
  };


  function showSendMaxWarning(wallet, sendMaxInfo) {

    function verifyExcludedUtxos() {
      var warningMsg = [];
      if (sendMaxInfo.utxosBelowFee > 0) {
        warningMsg.push(gettextCatalog.getString("A total of {{amountBelowFeeStr}} were excluded. These funds come from UTXOs smaller than the network fee provided.", {
          amountBelowFeeStr: txFormatService.formatAmountStr(wallet.coin, sendMaxInfo.amountBelowFee)
        }));
      }

      if (sendMaxInfo.utxosAboveMaxSize > 0) {
        warningMsg.push(gettextCatalog.getString("A total of {{amountAboveMaxSizeStr}} were excluded. The maximum size allowed for a transaction was exceeded.", {
          amountAboveMaxSizeStr: txFormatService.formatAmountStr(wallet.coin, sendMaxInfo.amountAboveMaxSize)
        }));
      }
      return warningMsg.join('\n');
    };

    var msg = gettextCatalog.getString("{{fee}} will be deducted for bitcoin networking fees.", {
      fee: txFormatService.formatAmountStr(wallet.coin, sendMaxInfo.fee)
    });
    var warningMsg = verifyExcludedUtxos();

    if (!lodash.isEmpty(warningMsg))
      msg += '\n' + warningMsg;

    popupService.showAlert(null, msg, function() {});
  };

  $scope.onWalletSelect = function(wallet) {
    setWallet(wallet, tx);
  };

  $scope.showDescriptionPopup = function(tx) {
    var message = gettextCatalog.getString('Add description');
    var opts = {
      defaultText: tx.description
    };

    popupService.showPrompt(null, message, opts, function(res) {
      if (typeof res != 'undefined') tx.description = res;
      $timeout(function() {
        $scope.$apply();
      });
    });
  };

  function _paymentTimeControl(expirationTime) {
    $scope.paymentExpired = false;
    setExpirationTime();

    countDown = $interval(function() {
      setExpirationTime();
    }, 1000);

    function setExpirationTime() {
      var now = Math.floor(Date.now() / 1000);

      if (now > expirationTime) {
        setExpiredValues();
        return;
      }

      var totalSecs = expirationTime - now;
      var m = Math.floor(totalSecs / 60);
      var s = totalSecs % 60;
      $scope.remainingTimeStr = ('0' + m).slice(-2) + ":" + ('0' + s).slice(-2);
    };

    function setExpiredValues() {
      $scope.paymentExpired = true;
      $scope.remainingTimeStr = gettextCatalog.getString('Expired');
      if (countDown) $interval.cancel(countDown);
      $timeout(function() {
        $scope.$apply();
      });
    };
  };

  /* sets a wallet on the UI, creates a TXPs for that wallet */

  function setWallet(wallet, tx) {

    $scope.wallet = wallet;

    // If select another wallet
    tx.coin = wallet.coin;
    tx.feeLevel = wallet.coin == 'bch' ? 'normal' : configFeeLevel;
    usingCustomFee = null;

    setButtonText(wallet.credentials.m > 1, !!tx.paypro);

    if (tx.paypro)
      _paymentTimeControl(tx.paypro.expires);

    updateTx(tx, wallet, {
      dryRun: true
    }, function(err) {
      $timeout(function() {
        $ionicScrollDelegate.resize();
        $scope.$apply();
      }, 10);

    });

  };

  var setSendError = function(msg) {
    $scope.sendStatus = '';
    $timeout(function() {
      $scope.$apply();
    });
    popupService.showAlert(gettextCatalog.getString('Error at confirm'), bwcError.msg(msg));
  };

  $scope.openPPModal = function() {
    $ionicModal.fromTemplateUrl('views/modals/paypro.html', {
      scope: $scope
    }).then(function(modal) {
      $scope.payproModal = modal;
      $scope.payproModal.show();
    });
  };

  $scope.cancel = function() {
    $scope.payproModal.hide();
  };

  $scope.approve = function(tx, wallet, onSendStatusChange) {

    if (!tx || !wallet) return;

    if ($scope.paymentExpired) {
      popupService.showAlert(null, gettextCatalog.getString('This bitcoin payment request has expired.'));
      $scope.sendStatus = '';
      $timeout(function() {
        $scope.$apply();
      });
      return;
    }

    ongoingProcess.set('creatingTx', true, onSendStatusChange);
    getTxp(lodash.clone(tx), wallet, false, function(err, txp) {
      ongoingProcess.set('creatingTx', false, onSendStatusChange);
      if (err) return;

      // confirm txs for more that 20usd, if not spending/touchid is enabled
      function confirmTx(cb) {
        if (walletService.isEncrypted(wallet))
          return cb();

        var amountUsd = parseFloat(txFormatService.formatToUSD(wallet.coin, txp.amount));
        if (amountUsd <= CONFIRM_LIMIT_USD)
          return cb();

        var message = gettextCatalog.getString('Sending {{amountStr}} from your {{name}} wallet', {
          amountStr: tx.amountStr,
          name: wallet.name
        });
        var okText = gettextCatalog.getString('Confirm');
        var cancelText = gettextCatalog.getString('Cancel');
        popupService.showConfirm(null, message, okText, cancelText, function(ok) {
          return cb(!ok);
        });
      };

      function publishAndSign() {
        if (!wallet.canSign() && !wallet.isPrivKeyExternal()) {
          $log.info('No signing proposal: No private key');

          return walletService.onlyPublish(wallet, txp, function(err) {
            if (err) setSendError(err);
          }, onSendStatusChange);
        }

        walletService.publishAndSign(wallet, txp, function(err, txp) {
          if (err) return setSendError(err);
          if (config.confirmedTxsNotifications && config.confirmedTxsNotifications.enabled) {
            txConfirmNotification.subscribe(wallet, {
              txid: txp.txid
            });
          }
        }, onSendStatusChange);
      };

      confirmTx(function(nok) {
        if (nok) {
          $scope.sendStatus = '';
          $timeout(function() {
            $scope.$apply();
          });
          return;
        }
        publishAndSign();
      });
    });
  };

  function statusChangeHandler(processName, showName, isOn) {
    $log.debug('statusChangeHandler: ', processName, showName, isOn);
    if (
      (
        processName === 'broadcastingTx' ||
        ((processName === 'signingTx') && $scope.wallet.m > 1) ||
        (processName == 'sendingTx' && !$scope.wallet.canSign() && !$scope.wallet.isPrivKeyExternal())
      ) && !isOn) {
      $scope.sendStatus = 'success';
      $timeout(function() {
        $scope.$digest();
      }, 100);
    } else if (showName) {
      $scope.sendStatus = showName;
    }
  };

  $scope.statusChangeHandler = statusChangeHandler;

  $scope.onSuccessConfirm = function() {
    $scope.sendStatus = '';
    $ionicHistory.nextViewOptions({
      disableAnimate: true,
      historyRoot: true
    });
    $state.go('tabs.send').then(function() {
      $ionicHistory.clearHistory();
      $state.transitionTo('tabs.home');
    });
  };

  $scope.chooseFeeLevel = function(tx, wallet) {

    if (wallet.coin == 'bch') return;

    var scope = $rootScope.$new(true);
    scope.network = tx.network;
    scope.feeLevel = tx.feeLevel;
    scope.noSave = true;
    scope.coin = wallet.coin;

    if (usingCustomFee) {
      scope.customFeePerKB = tx.feeRate;
      scope.feePerSatByte = tx.feeRate / 1000;
    }

    $ionicModal.fromTemplateUrl('views/modals/chooseFeeLevel.html', {
      scope: scope,
      backdropClickToClose: false,
      hardwareBackButtonClose: false
    }).then(function(modal) {
      scope.chooseFeeLevelModal = modal;
      scope.openModal();
    });
    scope.openModal = function() {
      scope.chooseFeeLevelModal.show();
    };

    scope.hideModal = function(newFeeLevel, customFeePerKB) {
      scope.chooseFeeLevelModal.hide();
      $log.debug('New fee level choosen:' + newFeeLevel + ' was:' + tx.feeLevel);

      usingCustomFee = newFeeLevel == 'custom' ? true : false;

      if (tx.feeLevel == newFeeLevel && !usingCustomFee) return;

      tx.feeLevel = newFeeLevel;
      if (usingCustomFee) tx.feeRate = parseInt(customFeePerKB);

      updateTx(tx, wallet, {
        clearCache: true,
        dryRun: true
      }, function() {});
    };
  };

});

'use strict';

angular.module('copayApp.controllers').controller('copayersController',
  function($scope, $log, $timeout, $stateParams, $state, $rootScope, $ionicHistory, appConfigService, lodash, profileService, walletService, popupService, bwcError, platformInfo, gettextCatalog, ongoingProcess, pushNotificationsService) {

    var listener;
    var appName = appConfigService.userVisibleName;
    var appUrl = appConfigService.url;

    $scope.isCordova = platformInfo.isCordova;
    $scope.$on("$ionicView.beforeEnter", function(event, data) {
      $scope.wallet = profileService.getWallet(data.stateParams.walletId);
      updateWallet();
      $scope.shareIcon = platformInfo.isIOS ? 'iOS' : 'Android';
    
      listener = $rootScope.$on('bwsEvent', function(e, walletId, type, n) {
        if ($scope.wallet && walletId == $scope.wallet.id && type == ('NewCopayer' || 'WalletComplete'))
          updateWalletDebounced();
      });
    }); 

    $scope.$on("$ionicView.leave", function(event, data) {
      listener();
    });

    var updateWallet = function() {
      $log.debug('Updating wallet:' + $scope.wallet.name)
      walletService.getStatus($scope.wallet, {}, function(err, status) {
        if (err) {
          return popupService.showAlert(bwcError.msg(err, gettextCatalog.getString('Could not update wallet')));
        }
        $scope.wallet.status = status;
        $scope.copayers = $scope.wallet.status.wallet.copayers;
        $scope.secret = $scope.wallet.status.wallet.secret;
        $timeout(function() {
          $scope.$apply();
        });
        if (status.wallet.status == 'complete') {
          $scope.wallet.openWallet(function(err, status) {
            if (err) $log.error(err);
            $scope.clearNextView();
            $state.go('tabs.home').then(function() {
              $state.transitionTo('tabs.wallet', {
                walletId: $scope.wallet.credentials.walletId
              });
            });
          });
        }
      });
    };

    var updateWalletDebounced = lodash.debounce(updateWallet, 5000, true);

    $scope.showDeletePopup = function() {
      var title = gettextCatalog.getString('Confirm');
      var msg = gettextCatalog.getString('Are you sure you want to cancel and delete this wallet?');
      popupService.showConfirm(title, msg, null, null, function(res) {
        if (res) deleteWallet();
      });
    };

    function deleteWallet() {
      ongoingProcess.set('deletingWallet', true);
      profileService.deleteWalletClient($scope.wallet, function(err) {
        ongoingProcess.set('deletingWallet', false);
        if (err) {
          popupService.showAlert(gettextCatalog.getString('Error'), err.message || err);
        } else {
          pushNotificationsService.unsubscribe($scope.wallet);
          $scope.clearNextView();
          $state.go('tabs.home');
        }
      });
    };

    $scope.copySecret = function() {
      if ($scope.isCordova) {
        window.cordova.plugins.clipboard.copy($scope.secret);
        window.plugins.toast.showShortCenter(gettextCatalog.getString('Copied to clipboard'));
      }
    };

    $scope.shareSecret = function() {
      if ($scope.isCordova) {
        var message = gettextCatalog.getString('Join my {{appName}} Wallet. Here is the invitation code: {{secret}} You can download {{appName}} for your phone or desktop at {{appUrl}}', {
          secret: $scope.secret,
          appName: appName,
          appUrl: appUrl
        });
        window.plugins.socialsharing.share(message, gettextCatalog.getString('Invitation to share a {{appName}} Wallet', {
          appName: appName
        }), null, null);
      }
    };

    $scope.clearNextView = function() {
      listener(); // remove listener
      $ionicHistory.nextViewOptions({
        disableAnimate: true,
        historyRoot: true
      });
      $ionicHistory.clearHistory(); 
    };

  });

'use strict';

angular.module('copayApp.controllers').controller('createController',
  function($scope, $rootScope, $timeout, $log, lodash, $state, $ionicScrollDelegate, $ionicHistory, profileService, configService, gettextCatalog, ledger, trezor, intelTEE, derivationPathHelper, ongoingProcess, walletService, storageService, popupService, appConfigService, pushNotificationsService) {

    /* For compressed keys, m*73 + n*34 <= 496 */
    var COPAYER_PAIR_LIMITS = {
      1: 1,
      2: 2,
      3: 3,
      4: 4,
      5: 4,
      6: 4,
      7: 3,
      8: 3,
      9: 2,
      10: 2,
      11: 1,
      12: 1,
    };

    $scope.$on("$ionicView.beforeEnter", function(event, data) {
      $scope.formData = {};
      var defaults = configService.getDefaults();
      var config = configService.getSync();
      var tc = $state.current.name == 'tabs.add.create-personal' ? 1 : defaults.wallet.totalCopayers;
      $scope.formData.account = 1;
      $scope.formData.bwsurl = defaults.bws.url;
      $scope.TCValues = lodash.range(2, defaults.limits.totalCopayers + 1);
      $scope.formData.derivationPath = derivationPathHelper.default;
      $scope.formData.coin = data.stateParams.coin;

      $scope.setTotalCopayers(tc);
      updateRCSelect(tc);
      resetPasswordFields();
    });

    $scope.showAdvChange = function() {
      $scope.showAdv = !$scope.showAdv;
      $scope.encrypt = null;
      $scope.resizeView();
    };

    $scope.checkPassword = function(pw1, pw2) {
      if (pw1 && pw1.length > 0) {
        if (pw2 && pw2.length > 0) {
          if (pw1 == pw2) $scope.result = 'correct';
          else {
            $scope.formData.passwordSaved = null;
            $scope.result = 'incorrect';
          }
        } else
          $scope.result = null;
      } else
        $scope.result = null;
    };

    $scope.resizeView = function() {
      $timeout(function() {
        $ionicScrollDelegate.resize();
      }, 10);
      resetPasswordFields();
    };

    function resetPasswordFields() {
      $scope.formData.passphrase = $scope.formData.createPassphrase = $scope.formData.passwordSaved = $scope.formData.repeatPassword = $scope.result = null;
      $timeout(function() {
        $scope.$apply();
      });
    };

    function updateRCSelect(n) {
      $scope.formData.totalCopayers = n;
      var maxReq = COPAYER_PAIR_LIMITS[n];
      $scope.RCValues = lodash.range(1, maxReq + 1);
      $scope.formData.requiredCopayers = Math.min(parseInt(n / 2 + 1), maxReq);
    };

    function updateSeedSourceSelect(n) {
      var seedOptions = [{
        id: 'new',
        label: gettextCatalog.getString('Random'),
        supportsTestnet: true
      }, {
        id: 'set',
        label: gettextCatalog.getString('Specify Recovery Phrase...'),
        supportsTestnet: false
      }];

      $scope.formData.seedSource = seedOptions[0];

      /*

      Disable Hardware Wallets for BitPay distribution

      */

      if (appConfigService.name == 'qyb') {
        if (n > 1 && walletService.externalSource.ledger.supported)
          seedOptions.push({
            id: walletService.externalSource.ledger.id,
            label: walletService.externalSource.ledger.longName,
            supportsTestnet: walletService.externalSource.ledger.supportsTestnet
          });

        if (walletService.externalSource.trezor.supported) {
          seedOptions.push({
            id: walletService.externalSource.trezor.id,
            label: walletService.externalSource.trezor.longName,
            supportsTestnet: walletService.externalSource.trezor.supportsTestnet
          });
        }

        if (walletService.externalSource.intelTEE.supported) {
          seedOptions.push({
            id: walletService.externalSource.intelTEE.id,
            label: walletService.externalSource.intelTEE.longName,
            supportsTestnet: walletService.externalSource.intelTEE.supportsTestnet
          });
        }
      }

      $scope.seedOptions = seedOptions;
    };

    $scope.setTotalCopayers = function(tc) {
      $scope.formData.totalCopayers = tc;
      updateRCSelect(tc);
      updateSeedSourceSelect(tc);
    };

    $scope.create = function() {

      var opts = {
        name: $scope.formData.walletName,
        m: $scope.formData.requiredCopayers,
        n: $scope.formData.totalCopayers,
        myName: $scope.formData.totalCopayers > 1 ? $scope.formData.myName : null,
        networkName: $scope.formData.testnetEnabled && $scope.formData.coin != 'bch' ? 'testnet' : 'livenet',
        bwsurl: $scope.formData.bwsurl,
        singleAddress: $scope.formData.singleAddressEnabled,
        walletPrivKey: $scope.formData._walletPrivKey, // Only for testing
        coin: $scope.formData.coin
      };

      var setSeed = $scope.formData.seedSource.id == 'set';
      if (setSeed) {

        var words = $scope.formData.privateKey || '';
        if (words.indexOf(' ') == -1 && words.indexOf('prv') == 1 && words.length > 108) {
          opts.extendedPrivateKey = words;
        } else {
          opts.mnemonic = words;
        }
        opts.passphrase = $scope.formData.passphrase;

        var pathData = derivationPathHelper.parse($scope.formData.derivationPath);
        if (!pathData) {
          popupService.showAlert(gettextCatalog.getString('Error'), gettextCatalog.getString('Invalid derivation path'));
          return;
        }

        opts.account = pathData.account;
        opts.networkName = pathData.networkName;
        opts.derivationStrategy = pathData.derivationStrategy;

      } else {
        opts.passphrase = $scope.formData.createPassphrase;
      }

      if (setSeed && !opts.mnemonic && !opts.extendedPrivateKey) {
        popupService.showAlert(gettextCatalog.getString('Error'), gettextCatalog.getString('Please enter the wallet recovery phrase'));
        return;
      }

      if ($scope.formData.seedSource.id == walletService.externalSource.ledger.id || $scope.formData.seedSource.id == walletService.externalSource.trezor.id || $scope.formData.seedSource.id == walletService.externalSource.intelTEE.id) {
        if ($scope.formData.coin == 'bch') {
          popupService.showAlert(gettextCatalog.getString('Error'), gettextCatalog.getString('Hardware wallets are not yet supported with Qybcoin Cash'));
          return;
        }

        var account = $scope.formData.account;
        if (!account || account < 1) {
          popupService.showAlert(gettextCatalog.getString('Error'), gettextCatalog.getString('Invalid account number'));
          return;
        }

        if ($scope.formData.seedSource.id == walletService.externalSource.trezor.id || $scope.formData.seedSource.id == walletService.externalSource.intelTEE.id)
          account = account - 1;

        opts.account = account;
        ongoingProcess.set('connecting ' + $scope.formData.seedSource.id, true);

        var src;
        switch ($scope.formData.seedSource.id) {
          case walletService.externalSource.ledger.id:
            src = ledger;
            break;
          case walletService.externalSource.trezor.id:
            src = trezor;
            break;
          case walletService.externalSource.intelTEE.id:
            src = intelTEE;
            break;
          default:
            popupService.showAlert(gettextCatalog.getString('Error'), 'Invalid seed source id');
            return;
        }

        src.getInfoForNewWallet(opts.n > 1, account, opts.networkName, function(err, lopts) {
          ongoingProcess.set('connecting ' + $scope.formData.seedSource.id, false);
          if (err) {
            popupService.showAlert(gettextCatalog.getString('Error'), err);
            return;
          }
          opts = lodash.assign(lopts, opts);
          _create(opts);
        });
      } else {
        _create(opts);
      }
    };

    function _create(opts) {
      ongoingProcess.set('creatingWallet', true);
      $timeout(function() {
        profileService.createWallet(opts, function(err, client) {
          ongoingProcess.set('creatingWallet', false);
          if (err) {
            $log.warn(err);
            popupService.showAlert(gettextCatalog.getString('Error'), err);
            return;
          }

          walletService.updateRemotePreferences(client);
          pushNotificationsService.updateSubscription(client);

          if ($scope.formData.seedSource.id == 'set') {
            profileService.setBackupFlag(client.credentials.walletId);
          }

          $ionicHistory.removeBackView();

          if (!client.isComplete()) {
            $ionicHistory.nextViewOptions({
              disableAnimate: true
            });
            $state.go('tabs.home');
            $timeout(function() {
              $state.transitionTo('tabs.copayers', {
                walletId: client.credentials.walletId
              });
            }, 100);
          } else $state.go('tabs.home');
        });
      }, 300);
    }
  });

'use strict';

angular.module('copayApp.controllers').controller('customAmountController', function($scope, $ionicHistory, txFormatService, platformInfo, configService, profileService, walletService, popupService) {

  var showErrorAndBack = function(title, msg) {
    popupService.showAlert(title, msg, function() {
      $scope.close();
    });
  };

  var setProtocolHandler = function() {
    $scope.protocolHandler = walletService.getProtocolHandler($scope.wallet);
  }

  $scope.$on("$ionicView.beforeEnter", function(event, data) {
    var walletId = data.stateParams.id;

    if (!walletId) {
      showErrorAndBack('Error', 'No wallet selected');
      return;
    }

    $scope.showShareButton = platformInfo.isCordova ? (platformInfo.isIOS ? 'iOS' : 'Android') : null;

    $scope.wallet = profileService.getWallet(walletId);

    setProtocolHandler();

    walletService.getAddress($scope.wallet, false, function(err, addr) {
      if (!addr) {
        showErrorAndBack('Error', 'Could not get the address');
        return;
      }

      $scope.address = addr;

      $scope.coin = data.stateParams.coin;
      var parsedAmount = txFormatService.parseAmount(
        $scope.wallet.coin,
        data.stateParams.amount,
        data.stateParams.currency);

      // Amount in USD or QYB
      var amount = parsedAmount.amount;
      var currency = parsedAmount.currency;
      $scope.amountUnitStr = parsedAmount.amountUnitStr;

      if (currency != 'QYB' && currency != 'dmb') {
        // Convert to QYB or dmb
        var config = configService.getSync().wallet.settings;
        var amountUnit = txFormatService.satToUnit(parsedAmount.amountSat);
        var btcParsedAmount = txFormatService.parseAmount($scope.wallet.coin, amountUnit, $scope.wallet.coin);

        $scope.amountBtc = btcParsedAmount.amount;
        $scope.altAmountStr = btcParsedAmount.amountUnitStr;
      } else {
        $scope.amountBtc = amount; // QYB or dmb
        $scope.altAmountStr = txFormatService.formatAlternativeStr($scope.wallet.coin, parsedAmount.amountSat);
      }
    });
  });

  $scope.close = function() {
    $ionicHistory.nextViewOptions({
      disableAnimate: true
    });
    $ionicHistory.goBack(-2);
  };

  $scope.shareAddress = function() {
    if (!platformInfo.isCordova) return;
    var protocol = 'bitcoin';
    if ($scope.wallet.coin == 'bch') protocol += 'cash';
    var data = protocol + ':' + $scope.address + '?amount=' + $scope.amountBtc;
    window.plugins.socialsharing.share(data, null, null, null);
  }

  $scope.copyToClipboard = function() {
    var protocol = 'bitcoin';
    if ($scope.wallet.coin == 'bch') protocol += 'cash';
    return protocol + ':' + $scope.address + '?amount=' + $scope.amountBtc;
  };

});

'use strict';

angular.module('copayApp.controllers').controller('DevLoginController', function($scope, $rootScope, $routeParams, identityService) {

  var mail = $routeParams.mail;
  var password = $routeParams.password;

  var form = {};
  form.email = {};
  form.password = {};
  form.email.$modelValue = mail;
  form.password.$modelValue = password;

  identityService.open($scope, form);

});

'use strict';

angular.module('copayApp.controllers').controller('exportController',
  function($scope, $timeout, $log, $ionicHistory, $ionicScrollDelegate, backupService, walletService, storageService, profileService, platformInfo, gettextCatalog, $state, $stateParams, popupService, appConfigService) {
    var wallet = profileService.getWallet($stateParams.walletId);
    $scope.wallet = wallet;

    $scope.showAdvChange = function() {
      $scope.showAdv = !$scope.showAdv;
      $scope.resizeView();
    };

    $scope.resizeView = function() {
      $timeout(function() {
        $ionicScrollDelegate.resize();
      }, 10);
    };

    $scope.checkPassword = function(pw1, pw2) {
      if (pw1.length > 0) {
        if (pw2.length > 0) {
          if (pw1 == pw2) $scope.result = 'correct';
          else $scope.result = 'incorrect';
        } else
          $scope.result = null;
      } else
        $scope.result = null;
    };

    function getPassword(cb) {
      if ($scope.password) return cb(null, $scope.password);

      walletService.prepare(wallet, function(err, password) {
        if (err) return cb(err);
        $scope.password = password;
        return cb(null, password);
      });
    };

    $scope.generateQrCode = function() {
      if ($scope.formData.exportWalletInfo || !walletService.isEncrypted(wallet)) {
        $scope.file.value = false;
      }

      getPassword(function(err, password) {
        if (err) {
          popupService.showAlert(gettextCatalog.getString('Error'), err);
          return;
        }

        walletService.getEncodedWalletInfo(wallet, password, function(err, code) {
          if (err) {
            popupService.showAlert(gettextCatalog.getString('Error'), err);
            return;
          }

          if (!code)
            $scope.formData.supported = false;
          else {
            $scope.formData.supported = true;
            $scope.formData.exportWalletInfo = code;
          }

          $scope.file.value = false;
          $timeout(function() {
            $scope.$apply();
          });
        });
      });
    };

    var init = function() {
      $scope.formData = {};
      $scope.formData.password = $scope.formData.repeatpassword = '';
      $scope.isEncrypted = wallet.isPrivKeyEncrypted();
      $scope.isCordova = platformInfo.isCordova;
      $scope.isSafari = platformInfo.isSafari;
      $scope.formData.noSignEnabled = false;
      $scope.showAdvanced = false;
      $scope.wallet = wallet;
      $scope.canSign = wallet.canSign();
    };

    /*
      EXPORT WITHOUT PRIVATE KEY - PENDING
    */

    $scope.noSignEnabledChange = function() {
      if (!$scope.formData.supported) return;

      walletService.getEncodedWalletInfo(wallet, function(err, code) {
        if (err) {
          $log.error(err);
          $scope.formData.supported = false;
          $scope.formData.exportWalletInfo = null;
        } else {
          $scope.formData.supported = true;
          $scope.formData.exportWalletInfo = code;
        }
        $timeout(function() {
          $scope.$apply();
        }, 1);
      });
    };

    $scope.downloadWalletBackup = function() {
      getPassword(function(err, password) {
        if (err) {
          popupService.showAlert(gettextCatalog.getString('Error'), err);
          return;
        }

        $scope.getAddressbook(function(err, localAddressBook) {
          if (err) {
            popupService.showAlert(gettextCatalog.getString('Error'), gettextCatalog.getString('Failed to export'));
            return;
          }
          var opts = {
            noSign: $scope.formData.noSignEnabled,
            addressBook: localAddressBook,
            password: password
          };

          backupService.walletDownload($scope.formData.password, opts, function(err) {
            if (err) {
              popupService.showAlert(gettextCatalog.getString('Error'), gettextCatalog.getString('Failed to export'));
              return;
            }
            $ionicHistory.removeBackView();
            $state.go('tabs.home');
          });
        });
      });
    };

    $scope.getAddressbook = function(cb) {
      storageService.getAddressbook(wallet.credentials.network, function(err, addressBook) {
        if (err) return cb(err);

        var localAddressBook = [];
        try {
          localAddressBook = JSON.parse(addressBook);
        } catch (ex) {
          $log.warn(ex);
        }

        return cb(null, localAddressBook);
      });
    };

    $scope.getBackup = function(cb) {
      getPassword(function(err, password) {
        if (err) {
          popupService.showAlert(gettextCatalog.getString('Error'), err);
          return;
        }

        $scope.getAddressbook(function(err, localAddressBook) {
          if (err) {
            popupService.showAlert(gettextCatalog.getString('Error'), gettextCatalog.getString('Failed to export'));
            return cb(null);
          }
          var opts = {
            noSign: $scope.formData.noSignEnabled,
            addressBook: localAddressBook,
            password: password
          };

          var ew = backupService.walletExport($scope.formData.password, opts);
          if (!ew) {
            popupService.showAlert(gettextCatalog.getString('Error'), gettextCatalog.getString('Failed to export'));
          }
          return cb(ew);
        });
      });
    };

    $scope.viewWalletBackup = function() {
      $timeout(function() {
        $scope.getBackup(function(backup) {
          var ew = backup;
          if (!ew) return;
          $scope.backupWalletPlainText = ew;
        });
      }, 100);
    };

    $scope.copyWalletBackup = function() {
      $scope.getBackup(function(backup) {
        var ew = backup;
        if (!ew) return;
        window.cordova.plugins.clipboard.copy(ew);
        window.plugins.toast.showShortCenter(gettextCatalog.getString('Copied to clipboard'));
      });
    };

    $scope.sendWalletBackup = function() {
      window.plugins.toast.showShortCenter(gettextCatalog.getString('Preparing backup...'));
      var name = (wallet.credentials.walletName || wallet.credentials.walletId);
      if (wallet.alias) {
        name = wallet.alias + ' [' + name + ']';
      }
      $scope.getBackup(function(backup) {
        var ew = backup;
        if (!ew) return;

        if ($scope.formData.noSignEnabled)
          name = name + '(No Private Key)';

        var subject = appConfigService.nameCase + ' Wallet Backup: ' + name;
        var body = 'Here is the encrypted backup of the wallet ' + name + ': \n\n' + ew + '\n\n To import this backup, copy all text between {...}, including the symbols {}';
        window.plugins.socialsharing.shareViaEmail(
          body,
          subject,
          null, // TO: must be null or an array
          null, // CC: must be null or an array
          null, // BCC: must be null or an array
          null, // FILES: can be null, a string, or an array
          function() {},
          function() {}
        );
      });
    };

    $scope.$on("$ionicView.beforeEnter", function(event, data) {
      init();
      $scope.file = {
        value: true
      };
      $scope.formData.exportWalletInfo = null;
      $scope.password = null;
      $scope.result = null;
    });

  });

'use strict';

angular.module('copayApp.controllers').controller('completeController', function($scope, $stateParams, $timeout, $log, $ionicHistory, $state, $ionicNavBarDelegate, $ionicConfig, platformInfo, configService, storageService, lodash, appConfigService, gettextCatalog) {
  $scope.isCordova = platformInfo.isCordova;
  $scope.title = gettextCatalog.getString("Share {{appName}}", {
    appName: appConfigService.nameCase
  });

  var defaults = configService.getDefaults();
  var downloadUrl = appConfigService.name == 'qyb' ? defaults.download.qyb.url : defaults.download.bitpay.url;

  function quickFeedback(cb) {
    window.plugins.spinnerDialog.show();
    $timeout(window.plugins.spinnerDialog.hide, 300);
    $timeout(cb, 20);
  }

  $scope.shareFacebook = function() {
    quickFeedback(function() {
      window.plugins.socialsharing.shareVia($scope.shareFacebookVia, null, null, null, downloadUrl);
    });
  };

  $scope.shareTwitter = function() {
    quickFeedback(function() {
      window.plugins.socialsharing.shareVia($scope.shareTwitterVia, null, null, null, downloadUrl);
    });
  };

  $scope.shareGooglePlus = function() {
    quickFeedback(function() {
      window.plugins.socialsharing.shareVia($scope.shareGooglePlusVia, downloadUrl);
    });
  };

  $scope.shareEmail = function() {
    quickFeedback(function() {
      window.plugins.socialsharing.shareViaEmail(downloadUrl);
    });
  };

  $scope.shareWhatsapp = function() {
    quickFeedback(function() {
      window.plugins.socialsharing.shareViaWhatsApp(downloadUrl);
    });
  };

  $scope.shareMessage = function() {
    quickFeedback(function() {
      window.plugins.socialsharing.shareViaSMS(downloadUrl);
    });
  };

  $scope.$on("$ionicView.beforeLeave", function() {
    $ionicConfig.views.swipeBackEnabled(true);
  });

  $scope.$on("$ionicView.enter", function() {
    if (!$scope.fromSettings)
      $ionicConfig.views.swipeBackEnabled(false);
  });

  $scope.$on("$ionicView.beforeEnter", function(event, data) {
    $scope.score = (data.stateParams && data.stateParams.score) ? parseInt(data.stateParams.score) : null;
    $scope.skipped = (data.stateParams && data.stateParams.skipped) ? true : false;
    $scope.rated = (data.stateParams && data.stateParams.rated) ? true : false;
    $scope.fromSettings = (data.stateParams && data.stateParams.fromSettings) ? true : false;

    if (!$scope.fromSettings) {
      $ionicNavBarDelegate.showBackButton(false);
    } else {
      $ionicNavBarDelegate.showBackButton(true);
    }

    storageService.getFeedbackInfo(function(error, info) {
      var feedbackInfo = lodash.isString(info) ? JSON.parse(info) : null;
      feedbackInfo.sent = true;
      storageService.setFeedbackInfo(JSON.stringify(feedbackInfo), function() {});
    });

    if (!$scope.isCordova) return;
    $scope.animate = true;

    window.plugins.socialsharing.available(function(isAvailable) {
      // the boolean is only false on iOS < 6
      $scope.socialsharing = isAvailable;
      if (isAvailable) {
        window.plugins.socialsharing.canShareVia('com.apple.social.facebook', 'msg', null, null, null, function(e) {
          $scope.shareFacebookVia = 'com.apple.social.facebook';
          $scope.facebook = true;
        }, function(e) {
          window.plugins.socialsharing.canShareVia('com.facebook.katana', 'msg', null, null, null, function(e) {
            $scope.shareFacebookVia = 'com.facebook.katana';
            $scope.facebook = true;
          }, function(e) {
            $log.debug('facebook error: ' + e);
            $scope.facebook = false;
          });
        });
        window.plugins.socialsharing.canShareVia('com.apple.social.twitter', 'msg', null, null, null, function(e) {
          $scope.shareTwitterVia = 'com.apple.social.twitter';
          $scope.twitter = true;
        }, function(e) {
          window.plugins.socialsharing.canShareVia('com.twitter.android', 'msg', null, null, null, function(e) {
            $scope.shareTwitterVia = 'com.twitter.android';
            $scope.twitter = true;
          }, function(e) {
            $log.debug('twitter error: ' + e);
            $scope.twitter = false;
          });
        });
        window.plugins.socialsharing.canShareVia('com.google.android.apps.plus', 'msg', null, null, null, function(e) {
          $scope.shareGooglePlusVia = 'com.google.android.apps.plus';
          $scope.googleplus = true;
        }, function(e) {
          $log.debug('googlePlus error: ' + e);
          $scope.googleplus = false;
        });
        window.plugins.socialsharing.canShareViaEmail(function(e) {
          $scope.email = true;
        }, function(e) {
          $log.debug('email error: ' + e);
          $scope.email = false;
        });
        window.plugins.socialsharing.canShareVia('whatsapp', 'msg', null, null, null, function(e) {
          $scope.whatsapp = true;
        }, function(e) {
          $log.debug('whatsapp error: ' + e);
          $scope.whatsapp = false;
        });
      }
    }, 100);
  });

  $scope.close = function() {
    $ionicHistory.nextViewOptions({
      disableAnimate: false,
      historyRoot: true
    });
    if ($scope.score == 5) $ionicHistory.goBack(-3);
    else $ionicHistory.goBack(-2);
  };
});

'use strict';

angular.module('copayApp.controllers').controller('rateAppController', function($scope, $state, $stateParams, $window, lodash, externalLinkService, configService, platformInfo, feedbackService, ongoingProcess, popupService, appConfigService) {
  $scope.score = parseInt($stateParams.score);
  $scope.appName = appConfigService.nameCase;
  var isAndroid = platformInfo.isAndroid;
  var isIOS = platformInfo.isIOS;

  var config = configService.getSync();

  $scope.skip = function() {
    var dataSrc = {
      "Email": lodash.values(config.emailFor)[0] || ' ',
      "Feedback": ' ',
      "Score": $stateParams.score,
      "AppVersion": $window.version,
      "Platform": ionic.Platform.platform(),
      "DeviceVersion": ionic.Platform.version()
    };
    feedbackService.send(dataSrc, function(err) {
      if (err) {
        // try to send, but not essential, since the user didn't add a message
        $log.warn('Could not send feedback.');
      }
    });
    $state.go('tabs.rate.complete', {
      score: $stateParams.score,
      skipped: true
    });
  };

  $scope.sendFeedback = function() {
    $state.go('tabs.rate.send', {
      score: $scope.score
    });
  };

  $scope.goAppStore = function() {
    var defaults = configService.getDefaults();
    var url;
    if (isAndroid)
      url = $scope.appName == 'Qyb' ? defaults.rateApp.qyb.android : defaults.rateApp.bitpay.android;
    if (isIOS)
      url = $scope.appName == 'Qyb' ? defaults.rateApp.qyb.ios : defaults.rateApp.bitpay.ios;

    externalLinkService.open(url);
    $state.go('tabs.rate.complete', {
      score: $stateParams.score,
      skipped: true,
      rated: true
    });
  };
});

'use strict';

angular.module('copayApp.controllers').controller('rateCardController', function($scope, $state, $timeout, $log, gettextCatalog, platformInfo, storageService, appConfigService) {

  $scope.isCordova = platformInfo.isCordova;
  $scope.score = 0;
  $scope.appName = appConfigService.nameCase;

  $scope.goFeedbackFlow = function() {
    $scope.hideCard();
    if ($scope.isCordova && $scope.score == 5) {
      $state.go('tabs.rate.rateApp', {
        score: $scope.score
      });
    } else {
      $state.go('tabs.rate.send', {
        score: $scope.score
      });
    }
  };

  $scope.setScore = function(score) {
    $scope.score = score;
    switch ($scope.score) {
      case 1:
        $scope.button_title = gettextCatalog.getString("I think this app is terrible.");
        break;
      case 2:
        $scope.button_title = gettextCatalog.getString("I don't like it");
        break;
      case 3:
        $scope.button_title = gettextCatalog.getString("Meh - it's alright");
        break;
      case 4:
        $scope.button_title = gettextCatalog.getString("I like the app");
        break;
      case 5:
        $scope.button_title = gettextCatalog.getString("This app is fantastic!");
        break;
    }
    $timeout(function() {
      $scope.$apply();
    });
  };

  $scope.hideCard = function() {
    $log.debug('Feedback card dismissed.')
    storageService.getFeedbackInfo(function(error, info) {
      var feedbackInfo = JSON.parse(info);
      feedbackInfo.sent = true;
      storageService.setFeedbackInfo(JSON.stringify(feedbackInfo), function() {
        $scope.showRateCard.value = false;
        $timeout(function() {
          $scope.$apply();
        }, 100);
      });
    });
  }

});

'use strict';

angular.module('copayApp.controllers').controller('sendController', function($scope, $state, $log, $timeout, $stateParams, $ionicNavBarDelegate, $ionicHistory, $ionicConfig, $window, gettextCatalog, popupService, configService, lodash, feedbackService, ongoingProcess, platformInfo, appConfigService) {

  $scope.sendFeedback = function(feedback, goHome) {

    var config = configService.getSync();

    var dataSrc = {
      "Email": lodash.values(config.emailFor)[0] || ' ',
      "Feedback": goHome ? ' ' : feedback,
      "Score": $stateParams.score || ' ',
      "AppVersion": $window.version,
      "Platform": ionic.Platform.platform(),
      "DeviceVersion": ionic.Platform.version()
    };

    if (!goHome) ongoingProcess.set('sendingFeedback', true);
    feedbackService.send(dataSrc, function(err) {
      if (goHome) return;
      ongoingProcess.set('sendingFeedback', false);
      if (err) {
        popupService.showAlert(gettextCatalog.getString('Error'), gettextCatalog.getString('Feedback could not be submitted. Please try again later.'));
        return;
      }
      if (!$stateParams.score) {
        popupService.showAlert(gettextCatalog.getString('Thank you!'), gettextCatalog.getString('A member of the team will review your feedback as soon as possible.'), function() {
          $scope.feedback.value = '';
          $ionicHistory.nextViewOptions({
            disableAnimate: false,
            historyRoot: true
          });
          $ionicHistory.goBack();
        }, gettextCatalog.getString('Finish'));
        return;
      }
      $state.go('tabs.rate.complete', {
        score: $stateParams.score
      });
    });
    if (goHome) $state.go('tabs.home');
  };

  $scope.$on("$ionicView.beforeLeave", function(event, data) {
    $ionicConfig.views.swipeBackEnabled(true);
  });

  $scope.$on("$ionicView.enter", function(event, data) {
    if ($scope.score)
      $ionicConfig.views.swipeBackEnabled(false);
  });

  $scope.$on("$ionicView.beforeEnter", function(event, data) {
    $scope.isCordova = platformInfo.isCordova;
    $scope.score = (data.stateParams && data.stateParams.score) ? parseInt(data.stateParams.score) : null;
    $scope.feedback = {};

    switch ($scope.score) {
      case 1:
        $scope.reaction = "Ouch!";
        $scope.comment = gettextCatalog.getString("There's obviously something we're doing wrong.") + ' ' + gettextCatalog.getString("How could we improve your experience?");
        break;
      case 2:
        $scope.reaction = gettextCatalog.getString("Oh no!");
        $scope.comment = gettextCatalog.getString("There's obviously something we're doing wrong.") + ' ' + gettextCatalog.getString("How could we improve your experience?");
        break;
      case 3:
        $scope.reaction = "Hmm...";
        $scope.comment = gettextCatalog.getString("We'd love to do better.") + ' ' + gettextCatalog.getString("How could we improve your experience?");
        break;
      case 4:
        $scope.reaction = gettextCatalog.getString("Thanks!");
        $scope.comment = gettextCatalog.getString("That's exciting to hear. We'd love to earn that fifth star from you – how could we improve your experience?");
        break;
      case 5:
        $scope.reaction = gettextCatalog.getString("Thank you!");
        $scope.comment = gettextCatalog.getString("We're always looking for ways to improve {{appName}}.", {
          appName: appConfigService.nameCase
        }) + ' ' + gettextCatalog.getString("Is there anything we could do better?");
        break;
      default:
        $scope.justFeedback = true;
        $scope.comment = gettextCatalog.getString("We're always looking for ways to improve {{appName}}. How could we improve your experience?", {
          appName: appConfigService.nameCase
        });
        break;
    }
  });

  $scope.$on("$ionicView.afterEnter", function() {
    $scope.showForm = true;
  });

  $scope.goBack = function() {
    $ionicHistory.nextViewOptions({
      disableAnimate: false,
      historyRoot: true
    });
    $ionicHistory.goBack();
  };

});

'use strict';

angular.module('copayApp.controllers').controller('glideraController',
  function($scope, $timeout, $ionicModal, $log, storageService, glideraService, ongoingProcess, platformInfo, externalLinkService, popupService, lodash) {

    $scope.openExternalLink = function(url) {
      externalLinkService.open(url);
    };

    var init = function() {
      ongoingProcess.set('connectingGlidera', true);
      glideraService.init(function(err, data) {
        ongoingProcess.set('connectingGlidera', false);
        if (err) {
          popupService.showAlert('Error connecting Glidera', err + '. Please re-connect to Glidera');
          return;
        }
        if (!data || (data && !data.token)) return;

        $scope.account['token'] = data.token;
        $scope.account['status'] = data.status;
        $scope.account['txs'] = data.txs; 

        $timeout(function() {
          $scope.$digest();
          $scope.update();
        });
      });
    };

    $scope.update = function(opts) {
      $log.debug('Updating Glidera...');
      glideraService.updateStatus($scope.account);
    };

    $scope.getAuthenticateUrl = function() {
      return glideraService.getOauthCodeUrl();
    };

    $scope.submitOauthCode = function(code) {
      ongoingProcess.set('connectingGlidera', true);
      glideraService.authorize(code, function(err, data) {
        ongoingProcess.set('connectingGlidera', false);
        if (err) {
          popupService.showAlert('Authorisation error', err);
          return;
        }
        $scope.account['token'] = data.token;
        $scope.account['status'] = data.status;
        init();
      });
    };

    $scope.openTxModal = function(tx) {
      $scope.tx = tx;

      glideraService.getTransaction($scope.account.token, tx.transactionUuid, function(err, tx) {
        if (err) {
          popupService.showAlert('Error getting transaction', 'Could not get transactions');
          return;
        }
        $scope.tx = tx;
      });

      $ionicModal.fromTemplateUrl('views/modals/glidera-tx-details.html', {
        scope: $scope,
        backdropClickToClose: false,
        hardwareBackButtonClose: false,
        animation: 'slide-in-up'
      }).then(function(modal) {
        $scope.glideraTxDetailsModal = modal;
        $scope.glideraTxDetailsModal.show();
      });
    };

    $scope.openAuthenticateWindow = function() {
      $scope.openExternalLink($scope.getAuthenticateUrl());
      $scope.showOauthForm = true
    }

    $scope.openLoginWindow = function() {
      var glideraUrl = ($scope.network === 'testnet') ? 'https://sandbox.glidera.io/login' : 'https://glidera.io/login';
      $scope.openExternalLink(glideraUrl);
    }

    $scope.openSupportWindow = function() {
      var url = glideraService.getSupportUrl();
      var optIn = true;
      var title = 'Glidera Support';
      var message = 'You can email glidera at support@glidera.io for direct support, or you can contact Glidera on Twitter.';
      var okText = 'Tweet @GlideraInc';
      var cancelText = 'Go Back';
      externalLinkService.open(url, optIn, title, message, okText, cancelText);
    }

    $scope.toggleOauthForm = function() {
      $scope.showOauthForm = !$scope.showOauthForm;
    }

    $scope.$on("$ionicView.afterEnter", function(event, data) {
      $scope.network = glideraService.getNetwork();
      $scope.currency = glideraService.getCurrency();
      $scope.showOauthForm = false;
      $scope.account = {};
      if (data.stateParams && data.stateParams.code) {
        $scope.submitOauthCode(data.stateParams.code);
      } else {
        init();
      }
    });

  });

'use strict';

angular.module('copayApp.controllers').controller('headController', function($scope, appConfigService, $log) {
  $scope.appConfig = appConfigService;
  $log.info('Running head controller:' + appConfigService.nameCase)
});

'use strict';

angular.module('copayApp.controllers').controller('homeIntegrationsController', function($scope, homeIntegrationsService, $ionicScrollDelegate, $timeout) {

  $scope.hide = false;
  $scope.services = homeIntegrationsService.get();

  $scope.toggle = function() {
    $scope.hide = !$scope.hide;
    $timeout(function() {
      $ionicScrollDelegate.resize();
      $scope.$apply();
    }, 10);
  };

});

'use strict';

angular.module('copayApp.controllers').controller('importController',
  function($scope, $timeout, $log, $state, $stateParams, $ionicHistory, $ionicScrollDelegate, profileService, configService, sjcl, ledger, trezor, derivationPathHelper, platformInfo, bwcService, ongoingProcess, walletService, popupService, gettextCatalog, appConfigService, hwWallet) {

    var reader = new FileReader();
    var defaults = configService.getDefaults();
    var config = configService.getSync();
    var errors = bwcService.getErrors();

    $scope.init = function() {
      $scope.supportsLedger = platformInfo.supportsLedger;
      $scope.supportsTrezor = platformInfo.supportsTrezor;
      $scope.isCordova = platformInfo.isCordova;
      $scope.formData = {};
      $scope.formData.bwsurl = defaults.bws.url;
      $scope.formData.derivationPath = derivationPathHelper.default;
      $scope.formData.account = 1;
      $scope.formData.coin = $stateParams.coin;
      $scope.importErr = false;
      $scope.isCopay = appConfigService.name == 'qyb';
      $scope.fromHardwareWallet = {
        value: false
      };

      if ($stateParams.code)
        $scope.processWalletInfo($stateParams.code);

      $scope.seedOptions = [];

      if ($scope.supportsLedger) {
        $scope.seedOptions.push({
          id: walletService.externalSource.ledger.id,
          label: walletService.externalSource.ledger.longName,
        });
      }

      if ($scope.supportsTrezor) {
        $scope.seedOptions.push({
          id: walletService.externalSource.trezor.id,
          label: walletService.externalSource.trezor.longName,
        });
        $scope.formData.seedSource = $scope.seedOptions[0];
      }


      $scope.seedOptionsAll = [];

      $scope.seedOptionsAll.push({
        id: walletService.externalSource.ledger.id,
        label: walletService.externalSource.ledger.longName,
      });

      $scope.seedOptionsAll.push({
        id: walletService.externalSource.trezor.id,
        label: walletService.externalSource.trezor.longName,
      });
      $scope.formData.seedSourceAll = $scope.seedOptionsAll[0];


      $timeout(function() {
        $scope.$apply();
      });
    };

    $scope.switchTestnetOff = function() {
      $scope.formData.testnetEnabled = false;
      $scope.setDerivationPath();
      $scope.resizeView();
      $timeout(function() {
        $scope.$apply();
      });
    };

    $scope.processWalletInfo = function(code) {
      if (!code) return;

      $scope.importErr = false;
      var parsedCode = code.split('|');

      if (parsedCode.length != 5) {
        /// Trying to import a malformed wallet export QR code
        popupService.showAlert(gettextCatalog.getString('Error'), gettextCatalog.getString('Incorrect code format'));
        return;
      }

      var info = {
        type: parsedCode[0],
        data: parsedCode[1],
        network: parsedCode[2],
        derivationPath: parsedCode[3],
        hasPassphrase: parsedCode[4] == 'true' ? true : false
      };

      if (info.type == 1 && info.hasPassphrase)
        popupService.showAlert(gettextCatalog.getString('Error'), gettextCatalog.getString('Password required. Make sure to enter your password in advanced options'));

      $scope.formData.derivationPath = info.derivationPath;
      $scope.formData.testnetEnabled = info.network == 'testnet' ? true : false;

      $timeout(function() {
        $scope.formData.words = info.data;
        $scope.$apply();
      }, 1);
    };

    var _importBlob = function(str, opts) {
      var str2, err;
      try {
        str2 = sjcl.decrypt($scope.formData.password, str);
      } catch (e) {
        err = gettextCatalog.getString('Could not decrypt file, check your password');
        $log.warn(e);
      };

      if (err) {
        popupService.showAlert(gettextCatalog.getString('Error'), err);
        return;
      }

      ongoingProcess.set('importingWallet', true);
      opts.compressed = null;
      opts.password = null;

      $timeout(function() {
        profileService.importWallet(str2, opts, function(err, client) {
          ongoingProcess.set('importingWallet', false);
          if (err) {
            popupService.showAlert(gettextCatalog.getString('Error'), err);
            return;

          }
          finish(client);
        });
      }, 100);
    };

    var _importExtendedPrivateKey = function(xPrivKey, opts) {
      ongoingProcess.set('importingWallet', true);
      $timeout(function() {
        profileService.importExtendedPrivateKey(xPrivKey, opts, function(err, client) {
          ongoingProcess.set('importingWallet', false);
          if (err) {
            if (err instanceof errors.NOT_AUTHORIZED) {
              $scope.importErr = true;
            } else {
              popupService.showAlert(gettextCatalog.getString('Error'), err);
            }
            return $timeout(function() {
              $scope.$apply();
            });
          }
          finish(client);
        });
      }, 100);
    };

    /*
      IMPORT FROM PUBLIC KEY - PENDING

    var _importExtendedPublicKey = function(xPubKey, opts) {
      ongoingProcess.set('importingWallet', true);
      $timeout(function() {
        profileService.importExtendedPublicKey(opts, function(err, walletId) {
          ongoingProcess.set('importingWallet', false);
          if (err) {
            $scope.error = err;
            return $timeout(function() {
              $scope.$apply();
            });
          }

          profileService.setBackupFlag(walletId);
           if ($stateParams.fromOnboarding) {
             profileService.setDisclaimerAccepted(function(err) {
               if (err) $log.error(err);
             });
           }

          $state.go('tabs.home');
        });
      }, 100);
    };
    */

    var _importMnemonic = function(words, opts) {
      ongoingProcess.set('importingWallet', true);

      $timeout(function() {
        profileService.importMnemonic(words, opts, function(err, client) {

          ongoingProcess.set('importingWallet', false);

          if (err) {
            if (err instanceof errors.NOT_AUTHORIZED) {
              $scope.importErr = true;
            } else {
              popupService.showAlert(gettextCatalog.getString('Error'), err);
            }
            return $timeout(function() {
              $scope.$apply();
            });
          }
          finish(client);
        });
      }, 100);
    };

    $scope.setDerivationPath = function() {
      $scope.formData.derivationPath = $scope.formData.testnetEnabled ? derivationPathHelper.defaultTestnet : derivationPathHelper.default;
    };

    $scope.getFile = function() {
      // If we use onloadend, we need to check the readyState.
      reader.onloadend = function(evt) {
        if (evt.target.readyState == FileReader.DONE) { // DONE == 2
          var opts = {};
          opts.bwsurl = $scope.formData.bwsurl;
          opts.coin = $scope.formData.coin;
          _importBlob(evt.target.result, opts);
        }
      }
    };

    $scope.importBlob = function(form) {
      if (form.$invalid) {
        popupService.showAlert(gettextCatalog.getString('Error'), gettextCatalog.getString('There is an error in the form'));
        return;
      }

      var backupFile = $scope.formData.file;
      var backupText = $scope.formData.backupText;
      var password = $scope.formData.password;

      if (!backupFile && !backupText) {
        popupService.showAlert(gettextCatalog.getString('Error'), gettextCatalog.getString('Please, select your backup file'));
        return;
      }

      if (backupFile) {
        reader.readAsBinaryString(backupFile);
      } else {
        var opts = {};
        opts.bwsurl = $scope.formData.bwsurl;
        opts.coin = $scope.formData.coin;
        _importBlob(backupText, opts);
      }
    };

    $scope.importMnemonic = function(form) {
      if (form.$invalid) {
        popupService.showAlert(gettextCatalog.getString('Error'), gettextCatalog.getString('There is an error in the form'));
        return;
      }

      var opts = {};

      if ($scope.formData.bwsurl)
        opts.bwsurl = $scope.formData.bwsurl;

      var pathData = derivationPathHelper.parse($scope.formData.derivationPath);

      if (!pathData) {
        popupService.showAlert(gettextCatalog.getString('Error'), gettextCatalog.getString('Invalid derivation path'));
        return;
      }

      opts.account = pathData.account;
      opts.networkName = pathData.networkName;
      opts.derivationStrategy = pathData.derivationStrategy;
      opts.coin = $scope.formData.coin;

      var words = $scope.formData.words || null;

      if (!words) {
        popupService.showAlert(gettextCatalog.getString('Error'), gettextCatalog.getString('Please enter the recovery phrase'));
        return;
      } else if (words.indexOf('xprv') == 0 || words.indexOf('tprv') == 0) {
        return _importExtendedPrivateKey(words, opts);
      } else if (words.indexOf('xpub') == 0 || words.indexOf('tpuv') == 0) {
        return _importExtendedPublicKey(words, opts);
      } else {
        var wordList = words.split(/[\u3000\s]+/);

        if ((wordList.length % 3) != 0) {
          popupService.showAlert(gettextCatalog.getString('Error'), gettextCatalog.getString('Wrong number of recovery words: ') + wordList.length);
          return;
        }
      }

      opts.passphrase = $scope.formData.passphrase || null;

      if ($scope.fromHardwareWallet.value) {
        $log.debug('Importing seed from hardware wallet');
        $log.warn('This wont work for Intel TEE wallets');

        var id = $scope.formData.seedSourceAll.id;
        var isMultisig = opts.derivationStrategy == 'BIP48';
        var account = opts.account;
        opts.entropySourcePath = 'm/' + hwWallet.getEntropyPath(id, isMultisig, account);
      }

      _importMnemonic(words, opts);
    };

    $scope.importTrezor = function(account, isMultisig) {
      trezor.getInfoForNewWallet(isMultisig, account, 'livenet', function(err, lopts) {
        ongoingProcess.clear();
        if (err) {
          popupService.showAlert(gettextCatalog.getString('Error'), err);
          return;
        }

        lopts.externalSource = walletService.externalSource.trezor.id;
        lopts.bwsurl = $scope.formData.bwsurl;
        lopts.account = account;
        ongoingProcess.set('importingWallet', true);
        $log.debug('Import opts', lopts);

        profileService.importExtendedPublicKey(lopts, function(err, wallet) {
          ongoingProcess.set('importingWallet', false);
          if (err) {
            popupService.showAlert(gettextCatalog.getString('Error'), err);
            return;
          }
          finish(wallet);
        });
      }, 100);
    };

    $scope.importHW = function(form) {
      if (form.$invalid || $scope.formData.account < 0) {
        popupService.showAlert(gettextCatalog.getString('Error'), gettextCatalog.getString('There is an error in the form'));
        return;
      }

      $scope.importErr = false;

      var account = $scope.formData.account;

      if ($scope.formData.seedSource.id == walletService.externalSource.trezor.id) {
        if (account < 1) {
          popupService.showAlert(gettextCatalog.getString('Error'), gettextCatalog.getString('Invalid account number'));
          return;
        }
        account = account - 1;
      }

      switch ($scope.formData.seedSource.id) {
        case (walletService.externalSource.ledger.id):
          ongoingProcess.set('connectingledger', true);
          $scope.importLedger(account);
          break;
        case (walletService.externalSource.trezor.id):
          ongoingProcess.set('connectingtrezor', true);
          $scope.importTrezor(account, $scope.formData.isMultisig);
          break;
        default:
          throw ('Error: bad source id');
      };
    };

    $scope.importLedger = function(account) {
      ledger.getInfoForNewWallet(true, account, 'livenet', function(err, lopts) {
        ongoingProcess.clear();
        if (err) {
          popupService.showAlert(gettextCatalog.getString('Error'), err);
          return;
        }

        lopts.externalSource = lopts.externalSource = walletService.externalSource.ledger.id;
        lopts.bwsurl = $scope.formData.bwsurl;
        lopts.account = account;
        ongoingProcess.set('importingWallet', true);
        $log.debug('Import opts', lopts);

        profileService.importExtendedPublicKey(lopts, function(err, wallet) {
          ongoingProcess.set('importingWallet', false);
          if (err) {
            popupService.showAlert(gettextCatalog.getString('Error'), err);
            return;
          }
          finish(wallet);
        });
      }, 100);
    };

    var finish = function(wallet) {
      walletService.updateRemotePreferences(wallet);

      profileService.setBackupFlag(wallet.credentials.walletId);
      if ($stateParams.fromOnboarding) {
        profileService.setDisclaimerAccepted(function(err) {
          if (err) $log.error(err);
        });
      }
      $ionicHistory.removeBackView();
      $state.go('tabs.home', {
        fromOnboarding: $stateParams.fromOnboarding
      });
    };

    $scope.showAdvChange = function() {
      $scope.showAdv = !$scope.showAdv;
      $timeout(function() {
        $scope.resizeView();
      }, 100);
    };

    $scope.resizeView = function() {
      $timeout(function() {
        $ionicScrollDelegate.resize();
      }, 10);
    };

    $scope.$on("$ionicView.afterEnter", function(event, data) {
      $scope.showAdv = false;
      $scope.init();
    });

  });

'use strict';

angular.module('copayApp.controllers').controller('joinController',
  function($scope, $rootScope, $timeout, $state, $ionicHistory, $ionicScrollDelegate, profileService, configService, storageService, applicationService, gettextCatalog, lodash, ledger, trezor, intelTEE, derivationPathHelper, ongoingProcess, walletService, $log, $stateParams, popupService, appConfigService) {

    $scope.$on("$ionicView.beforeEnter", function(event, data) {
      var defaults = configService.getDefaults();
      var config = configService.getSync();
      $scope.formData = {};
      $scope.formData.bwsurl = defaults.bws.url;
      $scope.formData.derivationPath = derivationPathHelper.default;
      $scope.formData.account = 1;
      $scope.formData.secret = null;
      $scope.formData.coin = data.stateParams.coin;
      resetPasswordFields();
      updateSeedSourceSelect();
    });

    $scope.showAdvChange = function() {
      $scope.showAdv = !$scope.showAdv;
      $scope.encrypt = null;
      $scope.resizeView();
    };

    $scope.checkPassword = function(pw1, pw2) {
      if (pw1 && pw1.length > 0) {
        if (pw2 && pw2.length > 0) {
          if (pw1 == pw2) $scope.result = 'correct';
          else {
            $scope.formData.passwordSaved = null;
            $scope.result = 'incorrect';
          }
        } else
          $scope.result = null;
      } else
        $scope.result = null;
    };

    $scope.resizeView = function() {
      $timeout(function() {
        $ionicScrollDelegate.resize();
      }, 10);
      resetPasswordFields();
    };

    function resetPasswordFields() {
      $scope.formData.passphrase = $scope.formData.createPassphrase = $scope.formData.passwordSaved = $scope.formData.repeatPassword = $scope.result = null;
      $timeout(function() {
        $scope.$apply();
      });
    };

    $scope.onQrCodeScannedJoin = function(data) {
      $scope.formData.secret = data;
      $scope.$apply();
    };

    if ($stateParams.url) {
      var data = $stateParams.url;
      data = data.replace('qyb:', '');
      $scope.onQrCodeScannedJoin(data);
    }

    function updateSeedSourceSelect() {
      $scope.seedOptions = [{
        id: 'new',
        label: gettextCatalog.getString('Random'),
      }, {
        id: 'set',
        label: gettextCatalog.getString('Specify Recovery Phrase...'),
      }];
      $scope.formData.seedSource = $scope.seedOptions[0];
      /*

      Disable Hardware Wallets

      */

      if (appConfigService.name == 'qyb') {
        if (walletService.externalSource.ledger.supported) {
          $scope.seedOptions.push({
            id: walletService.externalSource.ledger.id,
            label: walletService.externalSource.ledger.longName
          });
        }

        if (walletService.externalSource.trezor.supported) {
          $scope.seedOptions.push({
            id: walletService.externalSource.trezor.id,
            label: walletService.externalSource.trezor.longName
          });
        }

        if (walletService.externalSource.intelTEE.supported) {
          $scope.seedOptions.push({
            id: walletService.externalSource.intelTEE.id,
            label: walletService.externalSource.intelTEE.longName
          });
        }
      }
    };

    $scope.join = function() {

      var opts = {
        secret: $scope.formData.secret,
        myName: $scope.formData.myName,
        bwsurl: $scope.formData.bwsurl,
        coin: $scope.formData.coin
      }

      var setSeed = $scope.formData.seedSource.id == 'set';
      if (setSeed) {
        var words = $scope.formData.privateKey;
        if (words.indexOf(' ') == -1 && words.indexOf('prv') == 1 && words.length > 108) {
          opts.extendedPrivateKey = words;
        } else {
          opts.mnemonic = words;
        }
        opts.passphrase = $scope.formData.passphrase;

        var pathData = derivationPathHelper.parse($scope.formData.derivationPath);
        if (!pathData) {
          popupService.showAlert(gettextCatalog.getString('Error'), gettextCatalog.getString('Invalid derivation path'));
          return;
        }
        opts.account = pathData.account;
        opts.networkName = pathData.networkName;
        opts.derivationStrategy = pathData.derivationStrategy;
      } else {
        opts.passphrase = $scope.formData.createPassphrase;
      }

      opts.walletPrivKey = $scope._walletPrivKey; // Only for testing


      if (setSeed && !opts.mnemonic && !opts.extendedPrivateKey) {
        popupService.showAlert(gettextCatalog.getString('Error'), gettextCatalog.getString('Please enter the wallet recovery phrase'));
        return;
      }

      if ($scope.formData.seedSource.id == walletService.externalSource.ledger.id || $scope.formData.seedSource.id == walletService.externalSource.trezor.id || $scope.formData.seedSource.id == walletService.externalSource.intelTEE.id) {
        if ($scope.formData.coin == 'bch') {
          popupService.showAlert(gettextCatalog.getString('Error'), gettextCatalog.getString('Hardware wallets are not yet supported with Qybcoin Cash'));
          return;
        }

        var account = $scope.formData.account;
        if (!account || account < 1) {
          popupService.showAlert(gettextCatalog.getString('Error'), gettextCatalog.getString('Invalid account number'));
          return;
        }

        if ($scope.formData.seedSource.id == walletService.externalSource.trezor.id || $scope.formData.seedSource.id == walletService.externalSource.intelTEE.id)
          account = account - 1;

        opts.account = account;
        opts.isMultisig = true;
        ongoingProcess.set('connecting' + $scope.formData.seedSource.id, true);

        var src;
        switch ($scope.formData.seedSource.id) {
          case walletService.externalSource.ledger.id:
            src = ledger;
            break;
          case walletService.externalSource.trezor.id:
            src = trezor;
            break;
          case walletService.externalSource.intelTEE.id:
            src = intelTEE;
            break;
          default:
            popupService.showAlert(gettextCatalog.getString('Error'), 'Invalid seed source id');
            return;
        }

        // TODO: cannot currently join an intelTEE testnet wallet (need to detect from the secret)
        src.getInfoForNewWallet(true, account, 'livenet', function(err, lopts) {
          ongoingProcess.set('connecting' + $scope.formData.seedSource.id, false);
          if (err) {
            popupService.showAlert(gettextCatalog.getString('Error'), err);
            return;
          }
          opts = lodash.assign(lopts, opts);
          _join(opts);
        });
      } else {

        _join(opts);
      }
    };

    function _join(opts) {
      ongoingProcess.set('joiningWallet', true);
      $timeout(function() {
        profileService.joinWallet(opts, function(err, client) {
          ongoingProcess.set('joiningWallet', false);
          if (err) {
            popupService.showAlert(gettextCatalog.getString('Error'), err);
            return;
          }

          walletService.updateRemotePreferences(client);
          $ionicHistory.removeBackView();

          if (!client.isComplete()) {
            $ionicHistory.nextViewOptions({
              disableAnimate: true
            });
            $state.go('tabs.home');
            $timeout(function() {
              $state.transitionTo('tabs.copayers', {
                walletId: client.credentials.walletId
              });
            });
          } else $state.go('tabs.home');
        });
      });
    };
  });

'use strict';

angular.module('copayApp.controllers').controller('lockSetupController', function($state, $rootScope, $scope, $timeout, $log, configService, gettextCatalog, fingerprintService, profileService, lodash, applicationService) {

  function init() {
    $scope.options = [
      {
        method: 'none',
        label: gettextCatalog.getString('Disabled'),
        disabled: false,
      },
      {
        method: 'pin',
        label: gettextCatalog.getString('Lock by PIN'),
        needsBackup: false,
        disabled: false,
      },
    ];

    if (fingerprintService.isAvailable()) {
      $scope.options.push({
        method: 'fingerprint',
        label: gettextCatalog.getString('Lock by Fingerprint'),
        needsBackup: false,
        disabled: false,
      });
    }

    initMethodSelector();
    processWallets();
  };

  $scope.$on("$ionicView.beforeEnter", function(event) {
    init();
  });

  function getSavedMethod() {
    var config = configService.getSync();
    if (config.lock && config.lock.method) return config.lock.method;
    return 'none';
  };

  function initMethodSelector() {
    function disable(method) {
      lodash.find($scope.options, {
        method: method
      }).disabled = true;
    };

    var savedMethod = getSavedMethod();

    lodash.each($scope.options, function(o) {
      o.disabled = false;
    });

    // HACK: Disable until we allow to change between methods directly
    if (fingerprintService.isAvailable()) {
      switch (savedMethod) {
        case 'pin':
          disable('fingerprint');
          break;
        case 'fingerprint':
          disable('pin');
          break;
      }
    }

    $scope.currentOption = lodash.find($scope.options, {
      method: savedMethod
    });
    $timeout(function() {
      $scope.$apply();
    });
  };

  function processWallets() {
    var wallets = profileService.getWallets();
    var singleLivenetWallet = wallets.length == 1 && wallets[0].network == 'livenet' && wallets[0].needsBackup;
    var atLeastOneLivenetWallet = lodash.any(wallets, function(w) {
      return w.network == 'livenet' && w.needsBackup;
    });

    if (singleLivenetWallet) {
      $scope.errorMsg = gettextCatalog.getString('Backup your wallet before using this function');
      disableOptsUntilBackup();
    } else if (atLeastOneLivenetWallet) {
      $scope.errorMsg = gettextCatalog.getString('Backup all livenet wallets before using this function');
      disableOptsUntilBackup();
    } else {
      enableOptsAfterBackup();
      $scope.errorMsg = null;
    }

    function enableOptsAfterBackup() {
      $scope.options[1].needsBackup = false;
      if ($scope.options[2]) $scope.options[2].needsBackup = false;
    };

    function disableOptsUntilBackup() {
      $scope.options[1].needsBackup = true;
      if ($scope.options[2]) $scope.options[2].needsBackup = true;
    };

    $timeout(function() {
      $scope.$apply();
    });
  };

  $scope.select = function(selectedMethod) {
    var savedMethod = getSavedMethod();
    if (savedMethod == selectedMethod) return;

    if (selectedMethod == 'none') {
      disableMethod(savedMethod);
    } else {
      enableMethod(selectedMethod);
    }
  };

  function disableMethod(method) {
    switch (method) {
      case 'pin':
        applicationService.pinModal('disable');
        break;
      case 'fingerprint':
        fingerprintService.check('unlockingApp', function(err) {
          if (err) init();
          else saveConfig('none');
        });
        break;
    }
  };

  function enableMethod(method) {
    switch (method) {
      case 'pin':
        applicationService.pinModal('setup');
        break;
      case 'fingerprint':
        saveConfig('fingerprint');
        break;
    }
  };

  function saveConfig(method) {
    var opts = {
      lock: {
        method: method,
        value: null,
      }
    };

    configService.set(opts, function(err) {
      if (err) $log.debug(err);
      initMethodSelector();
    });
  };

  $rootScope.$on('pinModalClosed', function() {
    init()
  });

});

'use strict';

angular.module('copayApp.controllers').controller('luckymoneyController',
  function ($scope, $rootScope, $timeout, $log, lodash, $state, $ionicScrollDelegate, $ionicHistory, profileService, configService, gettextCatalog, ledger, trezor, intelTEE, derivationPathHelper, ongoingProcess, walletService, storageService, popupService, appConfigService, pushNotificationsService, $filter, $interval, platformInfo, $window, bitcore, bitcoreCash, txFormatService, $ionicModal, $ionicConfig, feeService, bwcError, txConfirmNotification, externalLinkService, bwcService) {


    var LUCKYMONEY_FEE = 1000000;

    var luckymoneyId;
    var txid;

    var unitToSatoshi;
    var unitIndex = 0;
    var altUnitIndex = 0;
    var availableUnits = [];
    var fiatCode;

    var countDown = null;
    var CONFIRM_LIMIT_USD = 99999;
    var FEE_TOO_HIGH_LIMIT_PER = 15;

    var tx = {};

    // Config Related values
    var config = configService.getSync();
    var walletConfig = config.wallet;
    var unitToSatoshi = walletConfig.settings.unitToSatoshi;
    var unitDecimals = walletConfig.settings.unitDecimals;
    var satToUnit = 1 / unitToSatoshi;
    var configFeeLevel = walletConfig.settings.feeLevel ? walletConfig.settings.feeLevel : 'normal';


    // Platform info
    var isChromeApp = platformInfo.isChromeApp;
    var isCordova = platformInfo.isCordova;
    var isWindowsPhoneApp = platformInfo.isCordova && platformInfo.isWP;

    //custom fee flag
    var usingCustomFee = null;

    $scope.$on("$ionicView.beforeEnter", function (event, data) {

      $scope.formData = { coin: "btc", ltype: "random" };
      var defaults = configService.getDefaults();
      var config = walletConfig.settings;
      function setAvailableUnits() {

        availableUnits = [];

        var hasBTCWallets = profileService.getWallets({
          coin: 'btc'
        }).length;

        if (hasBTCWallets) {
          availableUnits.push({
            name: 'QYBcoin',
            id: 'btc',
            shortName: 'QYB',
          });
        }


        var hasBCHWallets = profileService.getWallets({
          coin: 'bch'
        }).length;



        if (hasBCHWallets) {
          availableUnits.push({
            name: 'Qybcoin Cash',
            id: 'bch',
            shortName: 'dmb',
          });
        };

        unitIndex = 0;

        //  currency have preference
        var fiatName;
        fiatCode = config.alternativeIsoCode || 'USD';
        fiatName = config.alternanativeName || fiatCode;
        altUnitIndex = availableUnits.length;

        availableUnits.push({
          name: fiatName || fiatCode,
          // TODO
          id: fiatCode,
          shortName: fiatCode,
          isFiat: true,
        });
      };
      setAvailableUnits();
      unitToSatoshi = config.unitToSatoshi;
      luckymoneyId = undefined;
      txid = undefined;
      $scope.walletSelector = false;
      $timeout(function () {
        $ionicScrollDelegate.resize();
      }, 10);
    });


    $scope.$on("$ionicView.beforeLeave", function (event, data) {
      $ionicConfig.views.swipeBackEnabled(true);
    });

    $scope.$on("$ionicView.enter", function (event, data) {
      $ionicConfig.views.swipeBackEnabled(false);
    });

    function amountChanged() {
      var amount = $scope.formData.amount;
      var quantity = $scope.formData.quantity;
      if (!isNaN(amount)) {
        $scope.formData.amount = amount = parseFloat((parseFloat(amount)).toFixed(unitDecimals));
      }
      if (!isNaN(parseInt(quantity))) {
        $scope.formData.quantity = quantity = parseInt(quantity);
      }
      if ($scope.formData.ltype == 'fixed' && amount) {
        if (quantity) {
          $scope.formData.totalAmount = ((amount * quantity) + (quantity * LUCKYMONEY_FEE / unitToSatoshi)).toFixed(unitDecimals);
        } else {
          $scope.formData.totalAmount = amount.toFixed(unitDecimals);
        }
      } else if ($scope.formData.ltype == 'random' && amount && quantity) {
        $scope.formData.totalAmount = (amount + (quantity * LUCKYMONEY_FEE / unitToSatoshi)).toFixed(unitDecimals);
      } else {
        $scope.formData.totalAmount = (parseFloat(0)).toFixed(unitDecimals);
      }

    };

    $scope.$watch("formData.amount", amountChanged);
    $scope.$watch("formData.quantity", amountChanged);



    $scope.order = function (toAddress) {

      var opts = {
        amount: $scope.formData.amount,
        quantity: $scope.formData.quantity,
        ltype: $scope.formData.ltype,
        comment: $scope.formData.comment
      };

      ongoingProcess.set('orderingLuckymoney', true);
      var walletClient = bwcService.getClient();
      walletClient.orderLuckymoney(opts, function (err, luckymoney) {
        ongoingProcess.set('orderingLuckymoney', false);
        if (err) {
          popupService.showAlert(null, err);
          return;
        } else {
          createTx(luckymoney);
        }
      });
    };

    var createTx = function (luckymoney) {
      var toAmount = parseFloat($scope.formData.totalAmount) * unitToSatoshi;
      var toAddress = "QN4HR1W3dpom9rBQjBuwjFvvt4ezmFMd9q";// luckymoney.address;
      luckymoneyId = luckymoney.luckymoneyId;

      function setWalletSelector(coin, network, minAmount, cb) {

        // no min amount? (sendMax) => look for no empty wallets
        minAmount = minAmount || 1;

        $scope.wallets = profileService.getWallets({
          onlyComplete: true,
          network: network,
          coin: coin
        });

        if (!$scope.wallets || !$scope.wallets.length) {
          setNoWallet(gettextCatalog.getString('No wallets available'), true);
          return cb();
        }

        var filteredWallets = [];
        var index = 0;
        var walletsUpdated = 0;

        lodash.each($scope.wallets, function (w) {
          walletService.getStatus(w, {}, function (err, status) {
            if (err || !status) {
              $log.error(err);
            } else {
              walletsUpdated++;
              w.status = status;

              if (!status.availableBalanceSat)
                $log.debug('No balance available in: ' + w.name);

              if (status.availableBalanceSat > minAmount) {
                filteredWallets.push(w);
              }
            }

            if (++index == $scope.wallets.length) {
              if (!walletsUpdated)
                return cb('Could not update any wallet');

              if (lodash.isEmpty(filteredWallets)) {
                setNoWallet(gettextCatalog.getString('Insufficient funds'), true);
              }
              $scope.wallets = lodash.clone(filteredWallets);
              return cb();
            }
          });
        });
      };

      // Setup $scope

      var B = $scope.formData.coin == 'bch' ? bitcoreCash : bitcore;
      var networkName;
      try {
        networkName = (new B.Address(toAddress)).network.name;
      } catch (e) {
        var message = gettextCatalog.getString('Qyb only supports Qybcoin Cash using new version numbers addresses');
        popupService.showAlert(null, message);

        //var backText = gettextCatalog.getString('Go back');
        //var learnText = gettextCatalog.getString('Learn more');
        //popupService.showConfirm(null, message, backText, learnText, function (back) {
        //  $ionicHistory.nextViewOptions({
        //    disableAnimate: true,
        //    historyRoot: true
        //  });
        //  $state.go('tabs.send').then(function () {
        //    $ionicHistory.clearHistory();
        //    if (!back) {
        //      var url = 'https://support.bitpay.com/hc/en-us/articles/115004671663';
        //      externalLinkService.open(url);
        //    }
        //  });
        //});
        return;
      }

      // Grab stateParams
      tx = {
        toAmount: toAmount,
        sendMax: false,
        toAddress: toAddress,
        description: "",
        paypro: "",

        feeLevel: configFeeLevel,
        spendUnconfirmed: false,

        // Vanity tx info (not in the real tx)
        recipientType: "wallet",
        toName: "",
        toEmail: "",
        toColor: "",
        network: networkName,
        coin: $scope.formData.coin,
        txp: {},
      };

      if (tx.coin && tx.coin == 'bch') tx.feeLevel = 'normal';

      $scope.walletSelectorTitle = gettextCatalog.getString('Send from');

      setWalletSelector(tx.coin, tx.network, tx.toAmount, function (err) {
        if (err) {
          return exitWithError('Could not update wallets');
        }

        //if ($scope.wallets.length > 1) {
        //  $scope.showWalletSelector();
        //} else if ($scope.wallets.length) {
        //  setWallet($scope.wallets[0], tx);
        //}

        if ($scope.wallets.length > 0) {
          setWallet($scope.wallets[0], tx, function (err) {
            if (!err) {
              $scope.showWalletSelector();
            }
          });
        } else {
          //   setNoWallet(gettextCatalog.getString('No wallets available'), true);
        }

      });


      //lunckymoneyService.createLuckymoney($scope.formData
      //  , function (err, lunckyMoney) {

      //    $state.transitionTo('tabs.luckymoney.confirm', {
      //      recipientType: "wallet",
      //      toAmount: amount,
      //      toAddress: lunckyMoney.address,
      //      toName: "",
      //      toEmail: "",
      //      toColor: "",
      //      coin: lunckyMoney.coin,
      //      useSendMax: false
      //    });

      //  });



      //var unit = availableUnits[unitIndex];
      //var amount = evaluate($scope.formData.totalAmount);

      //if (unit.isFiat) {
      //  amount = (fromFiat(amount) * unitToSatoshi).toFixed(0);
      //} else {
      //  amount = (amount * unitToSatoshi).toFixed(0);
      //}

      //$state.transitionTo('tabs.luckymoney.confirm', {
      //  recipientType: "wallet",
      //  toAmount: amount,
      //  toAddress: "QN4HR1W3dpom9rBQjBuwjFvvt4ezmFMd9q",
      //  toName: "",
      //  toEmail: "",
      //  toColor: "",
      //  coin: $scope.formData.coin,
      //  useSendMax: false
      //});
    };

    //$scope.amountChanged = function () {
    //  var quantity = Number($scope.formData.quantity);
    //  var amount = Number($scope.formData.amount);
    //  if ($scope.formData.ltype == 'fixed' && amount) {
    //    if (quantity) {
    //      $scope.formData.totalAmount = ((quantity * LUCKYMONEY_FEE / unitToSatoshi) + (amount * quantity)).toFixed(LUCKYMONEY_DECIMALS);
    //    } else {
    //      $scope.formData.totalAmount = amount.toFixed(unitDecimals);
    //    }
    //  } else if ($scope.formData.ltype == 'random' && amount && quantity) {
    //    $scope.formData.totalAmount = ((quantity * 0.01) + LUCKYMONEY_FEE / unitToSatoshi).toFixed(LUCKYMONEY_DECIMALS);
    //  } else {
    //    $scope.formData.totalAmount = "0.00";
    //  }
    //  // formFocus(false);
    //};

    $scope.statusChangeHandler = statusChangeHandler;

    $scope.showWalletSelector = function () {
      $scope.walletSelector = true;
      refresh();
    };

    $scope.goHome = function () {
      $ionicHistory.removeBackView();
      $state.go('tabs.home');
    };

    $scope.goHistory = function () {
      $ionicHistory.removeBackView();
      $state.go('tabs.luckymoney.history');

    };

    $scope.changeLtype = function (ltype) {
      $scope.formData.amount = "";
      $scope.formData.totalAmount = "";
      $scope.formData.ltype = ltype;
    };

    $scope.approve = function (onSendStatusChange) {
      var tx = $scope.tx;
      var wallet = $scope.wallet;
      if (!tx || !wallet) return;

      if ($scope.paymentExpired) {
        popupService.showAlert(null, gettextCatalog.getString('This bitcoin payment request has expired.'));
        $scope.sendStatus = '';
        $timeout(function () {
          $scope.$apply();
        });
        return;
      }

      ongoingProcess.set('creatingTx', true, onSendStatusChange);
      getTxp(lodash.clone(tx), wallet, false, function (err, txp) {
        ongoingProcess.set('creatingTx', false, onSendStatusChange);
        if (err) return;

        // confirm txs for more that 20usd, if not spending/touchid is enabled
        function confirmTx(cb) {
          if (walletService.isEncrypted(wallet))
            return cb();

          var amountUsd = parseFloat(txFormatService.formatToUSD(wallet.coin, txp.amount));
          if (amountUsd <= CONFIRM_LIMIT_USD)
            return cb();

          var message = gettextCatalog.getString('Sending {{amountStr}} from your {{name}} wallet', {
            amountStr: tx.amountStr,
            name: wallet.name
          });
          var okText = gettextCatalog.getString('Confirm');
          var cancelText = gettextCatalog.getString('Cancel');
          popupService.showConfirm(null, message, okText, cancelText, function (ok) {
            return cb(!ok);
          });
        };

        function publishAndSign() {
          if (!wallet.canSign() && !wallet.isPrivKeyExternal()) {
            $log.info('No signing proposal: No private key');

            return walletService.onlyPublish(wallet, txp, function (err) {
              if (err) setSendError(err);
            }, onSendStatusChange);
          }

          walletService.publishAndSign(wallet, txp, function (err, txp) {
            if (err) return setSendError(err);
            
            if (config.confirmedTxsNotifications && config.confirmedTxsNotifications.enabled) {
              txConfirmNotification.subscribe(wallet, {
                txid: txp.txid
              });
            }
          }, onSendStatusChange, function (txp) {
            txid = txp.txid ;
          });
        };

        confirmTx(function (nok) {
          if (nok) {
            $scope.sendStatus = '';
            $timeout(function () {
              $scope.$apply();
            });
            return;
          }
          publishAndSign();
        });
      });
    };


    function isOperator(val) {
      var regex = /[\/\-\+\x\*]/;
      return regex.test(val);
    };

    function evaluate(val) {
      var result;
      try {
        result = $scope.$eval(val);
      } catch (e) {
        return 0;
      }
      if (!lodash.isFinite(result)) return 0;
      return result;
    };

    function format(val) {
      if (!val) return;

      var result = val.toString();

      if (isOperator(lodash.last(val))) result = result.slice(0, -1);

      return result.replace('x', '*');
    };

    function refresh() {
      $timeout(function () {
        $scope.$apply();
      }, 10);
    }

    function setWallet(wallet, tx, cb) {

      $scope.wallet = wallet;

      updateTx(tx, wallet, {
        dryRun: true
      }, function (err) {
        cb(err);
        $timeout(function () {
          $ionicScrollDelegate.resize();
          $scope.$apply();
        }, 10);

      });

    };


    function updateTx(tx, wallet, opts, cb) {
      ongoingProcess.set('calculatingFee', true);

      if (opts.clearCache) {
        tx.txp = {};
      }

      $scope.tx = tx;

      function updateAmount() {
        if (!tx.toAmount) return;

        // Amount
        tx.amountStr = txFormatService.formatAmountStr(wallet.coin, tx.toAmount);
        tx.amountValueStr = tx.amountStr.split(' ')[0];
        tx.amountUnitStr = tx.amountStr.split(' ')[1];
        txFormatService.formatAlternativeStr(wallet.coin, tx.toAmount, function (v) {
          tx.alternativeAmountStr = v;
        });
      }

      updateAmount();
      refresh();

      // End of quick refresh, before wallet is selected.
      if (!wallet) {
        ongoingProcess.set('calculatingFee', false);
        return cb();
      }

      feeService.getFeeRate(wallet.coin, tx.network, tx.feeLevel, function (err, feeRate) {
        if (err) {
          ongoingProcess.set('calculatingFee', false);
          return cb(err);
        }

        if (!usingCustomFee) tx.feeRate = feeRate;
        tx.feeLevelName = feeService.feeOpts[tx.feeLevel];

        getSendMaxInfo(lodash.clone(tx), wallet, function (err, sendMaxInfo) {
          if (err) {
            ongoingProcess.set('calculatingFee', false);
            var msg = gettextCatalog.getString('Error getting SendMax information');
            return setSendError(msg);
          }

          if (sendMaxInfo) {

            $log.debug('Send max info', sendMaxInfo);

            if (tx.sendMax && sendMaxInfo.amount == 0) {
              ongoingProcess.set('calculatingFee', false);
              setNoWallet(gettextCatalog.getString('Insufficient funds'));
              popupService.showAlert(gettextCatalog.getString('Error'), gettextCatalog.getString('Not enough funds for fee'));
              return cb('no_funds');
            }

            tx.sendMaxInfo = sendMaxInfo;
            tx.toAmount = tx.sendMaxInfo.amount;
            updateAmount();
            ongoingProcess.set('calculatingFee', false);
            $timeout(function () {
              showSendMaxWarning(wallet, sendMaxInfo);
            }, 200);
          }

          // txp already generated for this wallet?
          if (tx.txp[wallet.id]) {
            ongoingProcess.set('calculatingFee', false);
            refresh();
            return cb();
          }

          getTxp(lodash.clone(tx), wallet, opts.dryRun, function (err, txp) {
            ongoingProcess.set('calculatingFee', false);
            if (err) {
              return cb(err);
            }

            txp.feeStr = txFormatService.formatAmountStr(wallet.coin, txp.fee);
            txFormatService.formatAlternativeStr(wallet.coin, txp.fee, function (v) {
              txp.alternativeFeeStr = v;
            });

            var per = (txp.fee / (txp.amount + txp.fee) * 100);
            txp.feeRatePerStr = per.toFixed(2) + '%';
            txp.feeTooHigh = per > FEE_TOO_HIGH_LIMIT_PER;

            if (txp.feeTooHigh) {
              $ionicModal.fromTemplateUrl('views/modals/fee-warning.html', {
                scope: $scope
              }).then(function (modal) {
                $scope.feeWarningModal = modal;
                $scope.feeWarningModal.show();
              });

              $scope.close = function () {
                $scope.feeWarningModal.hide();
              };
            }

            tx.txp[wallet.id] = txp;
            $log.debug('Confirm. TX Fully Updated for wallet:' + wallet.id, tx);
            refresh();

            return cb();
          });
        });
      });
    }


    function setNoWallet(msg, criticalError) {
      $scope.wallet = null;
      $scope.noWalletMessage = msg;
      $scope.criticalError = criticalError;
      popupService.showAlert(msg);
      $log.warn('Not ready to make the payment:' + msg);
      $timeout(function () {
        $scope.$apply();
      });
    };



    function getSendMaxInfo(tx, wallet, cb) {
      if (!tx.sendMax) return cb();

      //ongoingProcess.set('retrievingInputs', true);
      walletService.getSendMaxInfo(wallet, {
        feePerKb: tx.feeRate,
        excludeUnconfirmedUtxos: !tx.spendUnconfirmed,
        returnInputs: true,
      }, cb);
    };


    function getTxp(tx, wallet, dryRun, cb) {

      // ToDo: use a credential's (or fc's) function for this
      if (tx.description && !wallet.credentials.sharedEncryptingKey) {
        var msg = gettextCatalog.getString('Could not add message to imported wallet without shared encrypting key');
        $log.warn(msg);
        return setSendError(msg);
      }

      if (tx.toAmount > Number.MAX_SAFE_INTEGER) {
        var msg = gettextCatalog.getString('Amount too big');
        $log.warn(msg);
        return setSendError(msg);
      }

      var txp = {};

      txp.outputs = [{
        'toAddress': tx.toAddress,
        'amount': tx.toAmount,
        'message': tx.description
      }];

      if (tx.sendMaxInfo) {
        txp.inputs = tx.sendMaxInfo.inputs;
        txp.fee = tx.sendMaxInfo.fee;
      } else {
        if (usingCustomFee) {
          txp.feePerKb = tx.feeRate;
        } else txp.feeLevel = tx.feeLevel;
      }

      txp.message = tx.description;

      if (tx.paypro) {
        txp.payProUrl = tx.paypro.url;
      }
      txp.excludeUnconfirmedUtxos = !tx.spendUnconfirmed;
      txp.dryRun = dryRun;
      walletService.createTx(wallet, txp, function (err, ctxp) {
        if (err) {
          setSendError(err);
          return cb(err);
        }
        return cb(null, ctxp);
      });
    };

    function useSelectedWallet() {

      if (!$scope.useSendMax) {
        showAmount(tx.toAmount);
      }

      $scope.onWalletSelect($scope.wallet);
    }

    function setButtonText(isMultisig, isPayPro) {

      if (isPayPro) {
        if (isCordova && !isWindowsPhoneApp) {
          $scope.buttonText = gettextCatalog.getString('Slide to pay');
        } else {
          $scope.buttonText = gettextCatalog.getString('Click to pay');
        }
      } else if (isMultisig) {
        if (isCordova && !isWindowsPhoneApp) {
          $scope.buttonText = gettextCatalog.getString('Slide to accept');
        } else {
          $scope.buttonText = gettextCatalog.getString('Click to accept');
        }
      } else {
        if (isCordova && !isWindowsPhoneApp) {
          $scope.buttonText = gettextCatalog.getString('Slide to send');
        } else {
          $scope.buttonText = gettextCatalog.getString('Click to send');
        }
      }
    };


    function showSendMaxWarning(wallet, sendMaxInfo) {

      function verifyExcludedUtxos() {
        var warningMsg = [];
        if (sendMaxInfo.utxosBelowFee > 0) {
          warningMsg.push(gettextCatalog.getString("A total of {{amountBelowFeeStr}} were excluded. These funds come from UTXOs smaller than the network fee provided.", {
            amountBelowFeeStr: txFormatService.formatAmountStr(wallet.coin, sendMaxInfo.amountBelowFee)
          }));
        }

        if (sendMaxInfo.utxosAboveMaxSize > 0) {
          warningMsg.push(gettextCatalog.getString("A total of {{amountAboveMaxSizeStr}} were excluded. The maximum size allowed for a transaction was exceeded.", {
            amountAboveMaxSizeStr: txFormatService.formatAmountStr(wallet.coin, sendMaxInfo.amountAboveMaxSize)
          }));
        }
        return warningMsg.join('\n');
      };

      var msg = gettextCatalog.getString("{{fee}} will be deducted for bitcoin networking fees.", {
        fee: txFormatService.formatAmountStr(wallet.coin, sendMaxInfo.fee)
      });
      var warningMsg = verifyExcludedUtxos();

      if (!lodash.isEmpty(warningMsg))
        msg += '\n' + warningMsg;

      popupService.showAlert(null, msg, function () { });
    };


    function _paymentTimeControl(expirationTime) {
      $scope.paymentExpired = false;
      setExpirationTime();

      countDown = $interval(function () {
        setExpirationTime();
      }, 1000);

      function setExpirationTime() {
        var now = Math.floor(Date.now() / 1000);

        if (now > expirationTime) {
          setExpiredValues();
          return;
        }

        var totalSecs = expirationTime - now;
        var m = Math.floor(totalSecs / 60);
        var s = totalSecs % 60;
        $scope.remainingTimeStr = ('0' + m).slice(-2) + ":" + ('0' + s).slice(-2);
      };

      function setExpiredValues() {
        $scope.paymentExpired = true;
        $scope.remainingTimeStr = gettextCatalog.getString('Expired');
        if (countDown) $interval.cancel(countDown);
        $timeout(function () {
          $scope.$apply();
        });
      };
    };


    var setSendError = function (msg) {
      $scope.sendStatus = '';
      $timeout(function () {
        $scope.$apply();
      });
      popupService.showAlert(gettextCatalog.getString('Error at confirm'), bwcError.msg(msg));
    };


    function statusChangeHandler(processName, showName, isOn) {
      $log.debug('statusChangeHandler: ', processName, showName, isOn);
      if (
        (
          processName === 'broadcastingTx' ||
          ((processName === 'signingTx') && $scope.wallet.m > 1) ||
          (processName == 'sendingTx' && !$scope.wallet.canSign() && !$scope.wallet.isPrivKeyExternal())
        ) && !isOn) {

        //$scope.sendStatus = 'success';

        //ajax
        var walletClient = bwcService.getClient();
        walletClient.payLuckymoney(luckymoneyId, txid, function (err, luckymoney) {
          if (err) {
            popupService.showAlert(null, err);
            return;
          }
        });
        //$ionicHistory.clearHistory();
        //$state.transitionTo('tabs.luckymoney.share', {
        //  luckymoneyId: luckymoneyId
        //});

        $scope.sendStatus = '';
        $ionicHistory.nextViewOptions({
          disableAnimate: true,
          historyRoot: true
        });
        $ionicHistory.clearHistory();
        $state.go('tabs.luckymoney.share', {
          luckymoneyId: luckymoneyId
        });

        //$state.go('tabs.luckymoney.share', {
        //  luckymoneyId: luckymoneyId
        //});
      } else if (showName) {
        $scope.sendStatus = showName;
      }
    };

  });

'use strict';

angular.module('copayApp.controllers').controller('mercadoLibreController',
  function($scope, $timeout, $log, mercadoLibreService, externalLinkService, popupService) {

    $scope.openExternalLink = function(url) {
      externalLinkService.open(url);
    };

    var init = function() {
      mercadoLibreService.getPendingGiftCards(function(err, gcds) {
        if (err) $log.error(err);
        $scope.giftCards = gcds;
        $timeout(function() {
          $scope.$digest();
        });
      });
    };

    $scope.$on("$ionicView.beforeEnter", function(event, data) {
      $scope.network = mercadoLibreService.getNetwork();
      init();
    });
  });

'use strict';

angular.module('copayApp.controllers').controller('mercadoLibreCardsController',
  function($scope, $timeout, $ionicModal, $log, $ionicScrollDelegate, lodash, mercadoLibreService, platformInfo, externalLinkService, popupService, ongoingProcess, timeService) {

    var updateGiftCard;

    $scope.openExternalLink = function(url) {
      externalLinkService.open(url);
    };

    var checkIfCardNeedsUpdate = function(card) {
      // Continues normal flow (update card)
      if (card.status == 'PENDING') {
        return true;
      }
      // Check if card status FAILURE for 24 hours
      if (card.status == 'FAILURE' && timeService.withinPastDay(card.date)) {
        return true;
      }
      // Success: do not update
      return false;
    };

    var updateGiftCards = function(cb) {
      mercadoLibreService.getPendingGiftCards(function(err, gcds) {
        if (err) {
          popupService.showAlert('Could not get gift cards', err);
          if (cb) return cb();
          else return;
        }
        $scope.giftCards = gcds;
        $timeout(function() {
          $scope.$digest();
          $ionicScrollDelegate.resize();
          if (cb) return cb();
        }, 100);
      });
    };

    $scope.updatePendingGiftCards = lodash.debounce(function() {
      updateGiftCards(function() {
        var index = 0;
        var gcds = $scope.giftCards;
        lodash.forEach(gcds, function(dataFromStorage) {

          updateGiftCard = checkIfCardNeedsUpdate(dataFromStorage);

          if (updateGiftCard) {
            $log.debug("Creating / Updating gift card");

            mercadoLibreService.createGiftCard(dataFromStorage, function(err, giftCard) {

              if (err) {
                $log.error('Error creating gift card:', (err.message || err));
                giftCard = giftCard || {};
                giftCard['status'] = 'FAILURE';
              }

              if (giftCard.status != 'PENDING') {
                var newData = {};

                if (!giftCard.status) dataFromStorage.status = null; // Fix error from server

                var cardStatus = giftCard.cardStatus;
                if (cardStatus && (cardStatus != 'active' && cardStatus != 'inactive' && cardStatus != 'expired'))
                  giftCard.status = 'FAILURE';

                lodash.merge(newData, dataFromStorage, giftCard);

                mercadoLibreService.savePendingGiftCard(newData, null, function(err) {
                  $log.debug("Mercado Libre gift card updated");
                  updateGiftCards();
                });
              }
            });
          }
        });
      });

    }, 1000, {
      'leading': true
    });

    $scope.openCardModal = function(card) {
      $scope.card = card;

      $ionicModal.fromTemplateUrl('views/modals/mercadolibre-card-details.html', {
        scope: $scope
      }).then(function(modal) {
        $scope.mercadoLibreCardDetailsModal = modal;
        $scope.mercadoLibreCardDetailsModal.show();
      });

      $scope.$on('modal.hidden', function() {
        $scope.updatePendingGiftCards();
      });
    };

    $scope.$on("$ionicView.beforeEnter", function(event, data) {
      $scope.invoiceId = data.stateParams.invoiceId;
      updateGiftCards(function() {
        if ($scope.invoiceId) {
          var card = lodash.find($scope.giftCards, {
            invoiceId: $scope.invoiceId
          });
          if (lodash.isEmpty(card)) {
            popupService.showAlert(null, 'Card not found');
            return;
          }
          $scope.openCardModal(card);
        }
      });
    });

    $scope.$on("$ionicView.afterEnter", function(event, data) {
      $scope.updatePendingGiftCards();
    });
  });

'use strict';

angular.module('copayApp.controllers').controller('amazonCardDetailsController', function($scope, $log, $timeout, $ionicScrollDelegate, bwcError, amazonService, lodash, ongoingProcess, popupService, externalLinkService) {

  $scope.cancelGiftCard = function() {
    ongoingProcess.set('cancelingGiftCard', true);
    amazonService.cancelGiftCard($scope.card, function(err, data) {
      ongoingProcess.set('cancelingGiftCard', false);
      if (err) {
        popupService.showAlert('Error canceling gift card', bwcError.msg(err));
        return;
      }
      $scope.card.cardStatus = data.cardStatus;
      $timeout(function() {
        $ionicScrollDelegate.resize();
        $ionicScrollDelegate.scrollTop();
      }, 10);
      amazonService.savePendingGiftCard($scope.card, null, function(err) {
        $scope.refreshGiftCard();
      });
    });
  };

  $scope.remove = function() {
    amazonService.savePendingGiftCard($scope.card, {
      remove: true
    }, function(err) {
      $scope.cancel();
    });
  };

  $scope.refreshGiftCard = function() {
    if (!$scope.updateGiftCard) return;
    ongoingProcess.set('updatingGiftCard', true);
    amazonService.getPendingGiftCards(function(err, gcds) {
      if (lodash.isEmpty(gcds)) {
        $timeout(function() {
          ongoingProcess.set('updatingGiftCard', false);
        }, 1000);
      }
      if (err) {
        popupService.showAlert('Error', err);
        return;
      }
      var index = 0;
      lodash.forEach(gcds, function(dataFromStorage) {
        if (++index == Object.keys(gcds).length) {
          $timeout(function() {
            ongoingProcess.set('updatingGiftCard', false);
          }, 1000);
        }
        if (dataFromStorage.invoiceId == $scope.card.invoiceId) {
          $log.debug("creating gift card");
          amazonService.createGiftCard(dataFromStorage, function(err, giftCard) {
            if (err) {
              popupService.showAlert('Error', bwcError.msg(err));
              return;
            }
            if (!lodash.isEmpty(giftCard) && giftCard.status != 'PENDING') {
              var newData = {};

              lodash.merge(newData, dataFromStorage, giftCard);

              if (newData.status == 'expired') {
                amazonService.savePendingGiftCard(newData, {
                  remove: true
                }, function(err) {
                  $scope.cancel();
                });
                return;
              }

              amazonService.savePendingGiftCard(newData, null, function(err) {
                $log.debug("Amazon gift card updated");
                $scope.card = newData;
                $timeout(function() {
                  $scope.$digest();
                });
              });
            } else $log.debug("Pending gift card not available yet");
          });
        }
      });
    });
  };

  $scope.cancel = function() {
    $scope.amazonCardDetailsModal.hide();
  };

  $scope.openExternalLink = function(url) {
    externalLinkService.open(url);
  };

});

'use strict';

angular.module('copayApp.controllers').controller('bitpayCardConfirmationController', function($scope, $timeout, $state, bitpayCardService) {

  $scope.ok = function() {
    bitpayCardService.logout(function() {
      $state.go('bitpayCard.main');
    });
    $scope.cancel();
  };

  $scope.cancel = function() {
    $scope.bitpayCardConfirmationModal.hide();
  };

});

'use strict';

angular.module('copayApp.controllers').controller('coinbaseTxDetailsController', function($scope, coinbaseService, popupService) {

  $scope.remove = function() {
    coinbaseService.setCredentials();
    $scope.updateRequired = false;
    var message = 'Are you sure you want to remove this transaction?';
    popupService.showConfirm(null, message, null, null, function(ok) {
      if (!ok) {
        return;
      }
      coinbaseService.savePendingTransaction($scope.tx, {
        remove: true
      }, function(err) {
        $scope.updateRequired = true;
        $scope.close();
      });
    });
  };

  $scope.close = function() {
    $scope.modal.hide().then(function() {
      if ($scope.updateRequired) $scope.updateTransactions();
    });
  };

});

'use strict';

angular.module('copayApp.controllers').controller('confirmationController', function($scope) {

  $scope.ok = function() {
    $scope.loading = true;
    $scope.okAction();
    $scope.confirmationModal.hide();
  };

  $scope.cancel = function() {
    $scope.confirmationModal.hide();
  };

});

'use strict';

angular.module('copayApp.controllers').controller('feeLevelsController', function($scope, $timeout, $log, lodash, gettextCatalog, configService, feeService, ongoingProcess, popupService) {

  var FEE_MULTIPLIER = 10;
  var FEE_MIN = 0;

  var showErrorAndClose = function(title, msg) {
    title = title || gettextCatalog.getString('Error');
    $log.error(msg);
    popupService.showAlert(title, msg, function() {
      $scope.chooseFeeLevelModal.hide();
    });

  };

  var getMinRecommended = function() {
    var value = lodash.find($scope.feeLevels[$scope.network], {
      level: 'superEconomy'
    });
    return parseInt((value.feePerKb / 1000).toFixed());
  };

  var getMaxRecommended = function() {
    var value = lodash.find($scope.feeLevels[$scope.network], {
      level: 'urgent'
    });
    return parseInt((value.feePerKb / 1000).toFixed());
  };

  $scope.ok = function() {
    $scope.customFeePerKB = $scope.customFeePerKB ? ($scope.customSatPerByte.value * 1000).toFixed() : null;
    $scope.hideModal($scope.feeLevel, $scope.customFeePerKB);
  };

  $scope.setFeesRecommended = function() {
    $scope.maxFeeRecommended = getMaxRecommended();
    $scope.minFeeRecommended = getMinRecommended();
    $scope.minFeeAllowed = FEE_MIN;
    $scope.maxFeeAllowed = $scope.maxFeeRecommended * FEE_MULTIPLIER;
  };

  $scope.checkFees = function(feePerSatByte) {
    var fee = Number(feePerSatByte);

    if (fee <= $scope.minFeeAllowed) $scope.showError = true;
    else $scope.showError = false;

    if (fee > $scope.minFeeAllowed && fee < $scope.minFeeRecommended) $scope.showMinWarning = true;
    else $scope.showMinWarning = false;

    if (fee < $scope.maxFeeAllowed && fee > $scope.maxFeeRecommended) $scope.showMaxWarning = true;
    else $scope.showMaxWarning = false;
  };

  $scope.updateFeeRate = function() {
    var value = lodash.find($scope.feeLevels[$scope.network], {
      level: $scope.feeLevel
    });

    // If no custom fee
    if (value) {
      $scope.customFeePerKB = null;
      $scope.feePerSatByte = (value.feePerKb / 1000).toFixed();
      $scope.avgConfirmationTime = value.nbBlocks * 10;
    } else {
      $scope.avgConfirmationTime = null;
      $scope.customSatPerByte = { value: Number($scope.feePerSatByte) };
      $scope.customFeePerKB = ($scope.feePerSatByte * 1000).toFixed();
    }

    // Warnings
    $scope.setFeesRecommended();
    $scope.checkFees($scope.feePerSatByte);

    $timeout(function() {
      $scope.$apply();
    });
  };

  $scope.$watch(
    "selectedFee.value",
    function ( newValue, oldValue ) {
      if (newValue != oldValue) {
        $log.debug('New fee level: ' + newValue);
        $scope.feeLevel = $scope.selectedFee.value;
        $scope.updateFeeRate();
      }
    }
  );

  // From parent controller
  // $scope.network
  // $scope.feeLevel
  //
  // IF usingCustomFee
  // $scope.customFeePerKB
  // $scope.feePerSatByte

  if (lodash.isEmpty($scope.feeLevel)) showErrorAndClose(null, gettextCatalog.getString('Fee level is not defined') );
  $scope.selectedFee = { value: $scope.feeLevel };

  $scope.feeOpts = feeService.feeOpts;
  $scope.loadingFee = true;
  feeService.getFeeLevels($scope.coin, function(err, levels) {
    $scope.loadingFee = false;
    if (err || lodash.isEmpty(levels)) {
      showErrorAndClose(null, err);
      return;
    }
    if (lodash.isEmpty(levels)) {
      showErrorAndClose(null, gettextCatalog.getString('Could not get fee levels'));
      return;
    }
    $scope.feeLevels = levels;
    $scope.updateFeeRate();
  });

});

'use strict';

angular.module('copayApp.controllers').controller('glideraTxDetailsController', function($scope) {

  $scope.cancel = function() {
    $scope.glideraTxDetailsModal.hide();
  };

});

'use strict';

angular.module('copayApp.controllers').controller('mercadoLibreCardDetailsController', function($scope, mercadoLibreService, externalLinkService, gettextCatalog) {

  $scope.remove = function() {
    mercadoLibreService.savePendingGiftCard($scope.card, {
      remove: true
    }, function(err) {
      $scope.close();
    });
  };

  $scope.close = function() {
    $scope.mercadoLibreCardDetailsModal.hide();
  };

  $scope.openExternalLink = function(url) {
    externalLinkService.open(url);
  };

  $scope.openRedeemLink = function() {
    var url;
    var isSandbox = mercadoLibreService.getNetwork() == 'testnet' ? true : false;
    if (isSandbox) url = 'https://beta.mercadolivre.com.br/vale-presente/resgate';
    else url = 'https://www.mercadolivre.com.br/vale-presente/resgate';
    $scope.openExternalLink(url);
  }

  $scope.openSupportWebsite = function() {
    var url = 'https://help.bitpay.com/requestHelp';
    var optIn = true;
    var title = null;
    var message = gettextCatalog.getString('Help and support information is available at the website.');
    var okText = gettextCatalog.getString('Open');
    var cancelText = gettextCatalog.getString('Go Back');
    externalLinkService.open(url, optIn, title, message, okText, cancelText);
  };

});

'use strict';

angular.module('copayApp.controllers').controller('pinController', function($state, $interval, $stateParams, $ionicHistory, $timeout, $scope, $log, configService, appConfigService, applicationService) {
  var ATTEMPT_LIMIT = 3;
  var ATTEMPT_LOCK_OUT_TIME = 5 * 60;
  var currentPin;
  currentPin = $scope.confirmPin = '';

  $scope.match = $scope.error = $scope.disableButtons = false;
  $scope.currentAttempts = 0;
  $scope.appName = appConfigService.name;

  configService.whenAvailable(function(config) {
    if (!config.lock) return;
    $scope.bannedUntil = config.lock.bannedUntil || null;
    if ($scope.bannedUntil) {
      var now = Math.floor(Date.now() / 1000);
      if (now < $scope.bannedUntil) {
        $scope.error = $scope.disableButtons = true;
        lockTimeControl($scope.bannedUntil);
      }
    }
  });

  function getSavedMethod() {
    var config = configService.getSync();
    if (config.lock) return config.lock.method;
    return 'none';
  };

  function checkAttempts() {
    $scope.currentAttempts += 1;
    $log.debug('Attempts to unlock:', $scope.currentAttempts);
    if ($scope.currentAttempts === ATTEMPT_LIMIT) {
      $scope.currentAttempts = 0;
      var bannedUntil = Math.floor(Date.now() / 1000) + ATTEMPT_LOCK_OUT_TIME;
      saveFailedAttempt(bannedUntil);
    }
  };

  function lockTimeControl(bannedUntil) {
    setExpirationTime();

    var countDown = $interval(function() {
      setExpirationTime();
    }, 1000);

    function setExpirationTime() {
      var now = Math.floor(Date.now() / 1000);
      if (now > bannedUntil) {
        if (countDown) reset();
      } else {
        $scope.disableButtons = true;
        var totalSecs = bannedUntil - now;
        var m = Math.floor(totalSecs / 60);
        var s = totalSecs % 60;
        $scope.expires = ('0' + m).slice(-2) + ":" + ('0' + s).slice(-2);
      }
    };

    function reset() {
      $scope.expires = $scope.error = $scope.disableButtons = null;
      currentPin = $scope.confirmPin = '';
      $interval.cancel(countDown);
      $timeout(function() {
        $scope.$apply();
      });
      return;
    };
  };

  $scope.getFilledClass = function(limit) {
    return currentPin.length >= limit ? 'filled-' + $scope.appName : null;
  };

  $scope.delete = function() {
    if ($scope.disableButtons) return;
    if (currentPin.length > 0) {
      currentPin = currentPin.substring(0, currentPin.length - 1);
      $scope.error = false;
      $scope.updatePin();
    }
  };

  $scope.isComplete = function() {
    if (currentPin.length < 4) return false;
    else return true;
  };

  $scope.updatePin = function(value) {
    if ($scope.disableButtons) return;
    $scope.error = false;
    if (value && !$scope.isComplete()) {
      currentPin = currentPin + value;
      $timeout(function() {
        $scope.$apply();
      });
    }
    $scope.save();
  };

  function isMatch(pin) {
    var config = configService.getSync();
    return config.lock.value == pin;
  };

  $scope.save = function() {
    if (!$scope.isComplete()) return;
    var savedMethod = getSavedMethod();

    switch ($scope.action) {
      case 'setup':
        applyAndCheckPin();
        break;
      case 'disable':
        if (isMatch(currentPin)) {
          deletePin();
        } else {
          showError();
          checkAttempts();
        }
        break;
      case 'check':
        if (isMatch(currentPin)) {
          $scope.hideModal();
          return;
        }
        showError();
        checkAttempts();
        break;
    }
  };

  function showError() {
    $timeout(function() {
      $scope.confirmPin = currentPin = '';
      $scope.error = true;
    }, 200);

    $timeout(function() {
      $scope.$apply();
    });
  };

  function applyAndCheckPin() {
    if (!$scope.confirmPin) {
      $timeout(function() {
        $scope.confirmPin = currentPin;
        currentPin = '';
      }, 200);
    } else {
      if ($scope.confirmPin == currentPin)
        savePin($scope.confirmPin);
      else {
        $scope.confirmPin = currentPin = '';
        $scope.error = true;
      }
    }
    $timeout(function() {
      $scope.$apply();
    });
  };

  function deletePin() {
    var opts = {
      lock: {
        method: 'none',
        value: null,
        bannedUntil: null,
      }
    };

    configService.set(opts, function(err) {
      if (err) $log.debug(err);
      $scope.hideModal();
    });
  };

  function savePin(value) {
    var opts = {
      lock: {
        method: 'pin',
        value: value,
        bannedUntil: null,
      }
    };

    configService.set(opts, function(err) {
      if (err) $log.debug(err);
      $scope.hideModal();
    });
  };

  function saveFailedAttempt(bannedUntil) {
    var opts = {
      lock: {
        bannedUntil: bannedUntil,
      }
    };

    configService.set(opts, function(err) {
      if (err) $log.debug(err);
      lockTimeControl(bannedUntil);
    });
  };

});

'use strict';

angular.module('copayApp.controllers').controller('searchController', function($scope, $interval, $timeout, $filter, $log, $ionicModal, $ionicPopover, $state, $stateParams, $ionicScrollDelegate, bwcError, profileService, lodash, configService, gettext, gettextCatalog, platformInfo, walletService) {

  var HISTORY_SHOW_LIMIT = 10;
  var currentTxHistoryPage = 0;
  var wallet;
  var isCordova = platformInfo.isCordova;

  $scope.updateSearchInput = function(search) {
    if (isCordova)
      window.plugins.toast.hide();
    currentTxHistoryPage = 0;
    throttleSearch(search);
    $timeout(function() {
      $ionicScrollDelegate.resize();
    }, 10);
  }

  var throttleSearch = lodash.throttle(function(search) {

    function filter(search) {
      $scope.filteredTxHistory = [];

      function computeSearchableString(tx) {
        var addrbook = '';
        if (tx.addressTo && $scope.addressbook && $scope.addressbook[tx.addressTo]) addrbook = $scope.addressbook[tx.addressTo].name || $scope.addressbook[tx.addressTo] || '';
        var searchableDate = computeSearchableDate(new Date(tx.time * 1000));
        var message = tx.message ? tx.message : '';
        var comment = tx.note ? tx.note.body : '';
        var addressTo = tx.addressTo ? tx.addressTo : '';
        var txid = tx.txid ? tx.txid : '';
        return ((tx.amountStr + message + addressTo + addrbook + searchableDate + comment + txid).toString()).toLowerCase();
      }

      function computeSearchableDate(date) {
        var day = ('0' + date.getDate()).slice(-2).toString();
        var month = ('0' + (date.getMonth() + 1)).slice(-2).toString();
        var year = date.getFullYear();
        return [month, day, year].join('/');
      };

      if (lodash.isEmpty(search)) {
        $scope.txHistoryShowMore = false;
        return [];
      }

      $scope.filteredTxHistory = lodash.filter($scope.completeTxHistory, function(tx) {
        if (!tx.searcheableString) tx.searcheableString = computeSearchableString(tx);
        return lodash.includes(tx.searcheableString, search.toLowerCase());
      });

      if ($scope.filteredTxHistory.length > HISTORY_SHOW_LIMIT) $scope.txHistoryShowMore = true;
      else $scope.txHistoryShowMore = false;
      return $scope.filteredTxHistory;
    };

    $scope.txHistorySearchResults = filter(search).slice(0, HISTORY_SHOW_LIMIT);

    if (isCordova)
      window.plugins.toast.showShortBottom(gettextCatalog.getString('Matches: ' + $scope.filteredTxHistory.length));

    $timeout(function() {
      $scope.$apply();
    });

  }, 1000);

  $scope.moreSearchResults = function() {
    currentTxHistoryPage++;
    $scope.showHistory();
    $scope.$broadcast('scroll.infiniteScrollComplete');
  };

  $scope.showHistory = function() {
    $scope.txHistorySearchResults = $scope.filteredTxHistory ? $scope.filteredTxHistory.slice(0, (currentTxHistoryPage + 1) * HISTORY_SHOW_LIMIT) : [];
    $scope.txHistoryShowMore = $scope.filteredTxHistory.length > $scope.txHistorySearchResults.length;
  };

});

'use strict';

angular.module('copayApp.controllers').controller('txpDetailsController', function($scope, $rootScope, $timeout, $interval, $log, ongoingProcess, platformInfo, $ionicScrollDelegate, txFormatService, bwcError, gettextCatalog, lodash, walletService, popupService, $ionicHistory, feeService) {
  var isGlidera = $scope.isGlidera;
  var GLIDERA_LOCK_TIME = 6 * 60 * 60;
  var now = Math.floor(Date.now() / 1000);
  var countDown;

  $scope.init = function() {
    $scope.loading = null;
    $scope.isCordova = platformInfo.isCordova;
    $scope.isWindowsPhoneApp = platformInfo.isCordova && platformInfo.isWP;
    $scope.copayers = $scope.wallet.status.wallet.copayers;
    $scope.copayerId = $scope.wallet.credentials.copayerId;
    $scope.isShared = $scope.wallet.credentials.n > 1;
    $scope.canSign = $scope.wallet.canSign() || $scope.wallet.isPrivKeyExternal();
    $scope.color = $scope.wallet.color;
    $scope.data = {};
    displayFeeValues();
    initActionList();
    checkPaypro();
    applyButtonText();
  };

  function displayFeeValues() {
    txFormatService.formatAlternativeStr($scope.wallet.coin, $scope.tx.fee, function(v) {
      $scope.tx.feeFiatStr = v;
    });
    $scope.tx.feeRateStr = ($scope.tx.fee / ($scope.tx.amount + $scope.tx.fee) * 100).toFixed(2) + '%';
    $scope.tx.feeLevelStr = feeService.feeOpts[$scope.tx.feeLevel];
  };

  function applyButtonText() {
    var lastSigner = lodash.filter($scope.tx.actions, {
      type: 'accept'
    }).length == $scope.tx.requiredSignatures - 1;

    if (lastSigner) {
      if ($scope.isCordova && !$scope.isWindowsPhoneApp) {
        $scope.buttonText = gettextCatalog.getString('Slide to send');
      } else {
        $scope.buttonText = gettextCatalog.getString('Click to send');
      }
      $scope.successText = gettextCatalog.getString('Payment Sent');
    } else {
      if ($scope.isCordova && !$scope.isWindowsPhoneApp) {
        $scope.buttonText = gettextCatalog.getString('Slide to accept');
      } else {
        $scope.buttonText = gettextCatalog.getString('Click to accept');
      }
      $scope.successText = gettextCatalog.getString('Payment Accepted');
    }
  };

  function initActionList() {
    $scope.actionList = [];

    if (!$scope.isShared) return;

    var actionDescriptions = {
      created: gettextCatalog.getString('Proposal Created'),
      accept: gettextCatalog.getString('Accepted'),
      reject: gettextCatalog.getString('Rejected'),
      broadcasted: gettextCatalog.getString('Broadcasted'),
    };

    $scope.actionList.push({
      type: 'created',
      time: $scope.tx.createdOn,
      description: actionDescriptions['created'],
      by: $scope.tx.creatorName
    });

    lodash.each($scope.tx.actions, function(action) {
      $scope.actionList.push({
        type: action.type,
        time: action.createdOn,
        description: actionDescriptions[action.type],
        by: action.copayerName
      });
    });

    $timeout(function() {
      $scope.actionList.reverse();
    }, 10);
  };

  function checkPaypro() {
    if ($scope.tx.payProUrl && !platformInfo.isChromeApp) {
      $scope.wallet.fetchPayPro({
        payProUrl: $scope.tx.payProUrl,
      }, function(err, paypro) {
        if (err) return;
        $scope.tx.paypro = paypro;
        paymentTimeControl($scope.tx.paypro.expires);
        $timeout(function() {
          $ionicScrollDelegate.resize();
        }, 10);
      });
    }
  };

  function paymentTimeControl(expirationTime) {
    $scope.paymentExpired = false;
    setExpirationTime();

    countDown = $interval(function() {
      setExpirationTime();
    }, 1000);

    function setExpirationTime() {
      var now = Math.floor(Date.now() / 1000);
      if (now > expirationTime) {
        $scope.paymentExpired = true;
        if (countDown) $interval.cancel(countDown);
        return;
      }
      var totalSecs = expirationTime - now;
      var m = Math.floor(totalSecs / 60);
      var s = totalSecs % 60;
      $scope.expires = ('0' + m).slice(-2) + ":" + ('0' + s).slice(-2);
    };
  };

  $scope.$on('accepted', function(event) {
    $scope.sign();
  });

  // ToDo: use tx.customData instead of tx.message
  if ($scope.tx.message === 'Glidera transaction' && isGlidera) {
    $scope.tx.isGlidera = true;
    if ($scope.tx.canBeRemoved) {
      $scope.tx.canBeRemoved = (Date.now() / 1000 - ($scope.tx.ts || $scope.tx.createdOn)) > GLIDERA_LOCK_TIME;
    }
  }

  var setError = function(err, prefix) {
    $scope.sendStatus = '';
    $scope.loading = false;
    popupService.showAlert(gettextCatalog.getString('Error'), bwcError.msg(err, prefix));
  };

  $scope.sign = function(onSendStatusChange) {
    $scope.loading = true;
    walletService.publishAndSign($scope.wallet, $scope.tx, function(err, txp) {
      $scope.$emit('UpdateTx');
      if (err) return setError(err, gettextCatalog.getString('Could not send payment'));
      success();
    }, onSendStatusChange);
  };

  $scope.reject = function(txp) {
    var title = gettextCatalog.getString('Warning!');
    var msg = gettextCatalog.getString('Are you sure you want to reject this transaction?');
    popupService.showConfirm(title, msg, null, null, function(res) {
      if (res) {
        $scope.loading = true;

        walletService.reject($scope.wallet, $scope.tx, function(err, txpr) {
          if (err)
            return setError(err, gettextCatalog.getString('Could not reject payment'));

          $scope.close();
        });
      }
    });
  };

  $scope.remove = function() {
    var title = gettextCatalog.getString('Warning!');
    var msg = gettextCatalog.getString('Are you sure you want to remove this transaction?');
    popupService.showConfirm(title, msg, null, null, function(res) {
      if (res) {
        ongoingProcess.set('removeTx', true);
        walletService.removeTx($scope.wallet, $scope.tx, function(err) {
          ongoingProcess.set('removeTx', false);

          // Hacky: request tries to parse an empty response
          if (err && !(err.message && err.message.match(/Unexpected/))) {
            $scope.$emit('UpdateTx');
            return setError(err, gettextCatalog.getString('Could not delete payment proposal'));
          }

          $scope.close();
        });
      }
    });
  };

  $scope.broadcast = function(txp) {
    $scope.loading = true;

    $timeout(function() {
      ongoingProcess.set('broadcastingTx', true);
      walletService.broadcastTx($scope.wallet, $scope.tx, function(err, txpb) {
        ongoingProcess.set('broadcastingTx', false);

        if (err) {
          return setError(err, gettextCatalog.getString('Could not broadcast payment'));
        }

        $scope.close();
      });
    }, 10);
  };

  $scope.getShortNetworkName = function() {
    return $scope.wallet.credentials.networkName.substring(0, 4);
  };

  var updateTxInfo = function(eventName) {
    $scope.wallet.getTx($scope.tx.id, function(err, tx) {
      if (err) {
        if (err.message && err.message == 'Transaction proposal not found' &&
          (eventName == 'transactionProposalRemoved' || eventName == 'TxProposalRemoved')) {
          $scope.tx.removed = true;
          $scope.tx.canBeRemoved = false;
          $scope.tx.pendingForUs = false;
          $scope.$apply();
        }
        return;
      }

      var action = lodash.find(tx.actions, {
        copayerId: $scope.wallet.credentials.copayerId
      });

      $scope.tx = txFormatService.processTx($scope.wallet.coin, tx);

      if (!action && tx.status == 'pending')
        $scope.tx.pendingForUs = true;

      $scope.updateCopayerList();
      initActionList();
      $scope.$apply();
    });
  };

  var bwsEvent = $rootScope.$on('bwsEvent', function(e, walletId, type, n) {
    lodash.each([
        'TxProposalRejectedBy',
        'TxProposalAcceptedBy',
        'transactionProposalRemoved',
        'TxProposalRemoved',
        'NewOutgoingTx',
        'UpdateTx'
    ], function(eventName) {
      if (walletId == $scope.wallet.id && type == eventName) {
        updateTxInfo(eventName);
      }
    });
  });

  $scope.updateCopayerList = function() {
    lodash.map($scope.copayers, function(cp) {
      lodash.each($scope.tx.actions, function(ac) {
        if (cp.id == ac.copayerId) {
          cp.action = ac.type;
        }
      });
    });
  };

  function statusChangeHandler(processName, showName, isOn) {
    $log.debug('statusChangeHandler: ', processName, showName, isOn);
    if (showName) {
      $scope.sendStatus = showName;
    }
  }

  function success() {
    $scope.sendStatus = 'success';
    $scope.$digest();
  }

  $scope.statusChangeHandler = statusChangeHandler;

  $scope.onConfirm = function() {
    $scope.sign(statusChangeHandler);
  };

  $scope.onSuccessConfirm = function() {
    $ionicHistory.nextViewOptions({
      disableAnimate: true
    });
    $scope.close();
  };

  $scope.close = function() {
    bwsEvent();
    $scope.loading = null;
    $scope.txpDetailsModal.hide();
  };
});

'use strict';

angular.module('copayApp.controllers').controller('txStatusController', function($scope, $timeout) {

  if ($scope.cb) $timeout($scope.cb, 100);

  $scope.cancel = function() {
    $scope.txStatusModal.hide();
  };

});

'use strict';

angular.module('copayApp.controllers').controller('walletsController', function($scope, $timeout, bwcError, profileService) {

  $scope.selectWallet = function(walletId) {

    var client = profileService.getClient(walletId);
    $scope.errorSelectedWallet = {};

    profileService.isReady(client, function(err) {
      if (err) {
        $scope.errorSelectedWallet[walletId] = bwcError.msg(err);
        $timeout(function() {
          $scope.$apply();
        });
        return;
      }

      $scope.$emit('walletSelected', walletId);
    });
  };

  $scope.cancel = function() {
    $scope.walletsModal.hide();
  };

});

'use strict';

angular.module('copayApp.controllers').controller('nextStepsController', function($scope, nextStepsService, $ionicScrollDelegate, $timeout) {

  $scope.hide = false;
  $scope.services = nextStepsService.get();

  $scope.toggle = function() {
    $scope.hide = !$scope.hide;
    $timeout(function() {
      $ionicScrollDelegate.resize();
      $scope.$apply();
    }, 10);
  };

});

'use strict';

angular.module('copayApp.controllers').controller('backupRequestController', function($scope, $state, $stateParams, $ionicConfig, popupService, gettextCatalog) {

  $scope.walletId = $stateParams.walletId;

  $scope.$on("$ionicView.enter", function() {
    $ionicConfig.views.swipeBackEnabled(false);
  });

  $scope.$on("$ionicView.beforeLeave", function() {
    $ionicConfig.views.swipeBackEnabled(true);
  });

  $scope.openPopup = function() {

    var title = gettextCatalog.getString('Watch out!');
    var message = gettextCatalog.getString('If this device is replaced or this app is deleted, neither you nor BitPay can recover your funds without a backup.');
    var okText = gettextCatalog.getString('I understand');
    var cancelText = gettextCatalog.getString('Go back');
    popupService.showConfirm(title, message, okText, cancelText, function(val) {
      if (val) {
        var title = gettextCatalog.getString('Are you sure you want to skip it?');
        var message = gettextCatalog.getString('You can create a backup later from your wallet settings.');
        var okText = gettextCatalog.getString('Yes, skip');
        var cancelText = gettextCatalog.getString('Go back');
        popupService.showConfirm(title, message, okText, cancelText, function(val) {
          if (val) {
            $state.go('onboarding.disclaimer', {
              walletId: $scope.walletId,
              backedUp: false
            });
          }
        });
      }
    });
  }

});

'use strict';

angular.module('copayApp.controllers').controller('backupWarningController', function($scope, $state, $timeout, $stateParams, $ionicModal) {

  $scope.walletId = $stateParams.walletId;
  $scope.fromState = $stateParams.from == 'onboarding' ? $stateParams.from + '.backupRequest' : $stateParams.from;
  $scope.toState = $stateParams.from + '.backup';

  $scope.openPopup = function() {
    $ionicModal.fromTemplateUrl('views/includes/screenshotWarningModal.html', {
      scope: $scope,
      backdropClickToClose: true,
      hardwareBackButtonClose: true
    }).then(function(modal) {
      $scope.warningModal = modal;
      $scope.warningModal.show();
    });

    $scope.close = function() {
      $scope.warningModal.remove();
      $timeout(function() {
        $state.go($scope.toState, {
          walletId: $scope.walletId
        });
      }, 200);
    };
  }

  $scope.goBack = function() {
    $state.go($scope.fromState, {
      walletId: $scope.walletId
    });
  };

});

'use strict';

angular.module('copayApp.controllers').controller('collectEmailController', function($scope, $state, $log, $timeout, $http, $httpParamSerializer, $ionicConfig, profileService, configService, walletService, appConfigService, emailService) {

  var wallet, walletId;
  $scope.data = {};
  // Get more info: https://mashe.hawksey.info/2014/07/google-sheets-as-a-database-insert-with-apps-script-using-postget-methods-with-ajax-example/
  var URL = "https://script.google.com/macros/s/AKfycbwQXvUw6-Ix0cRLMi7hBB8dlgNTCTgwfNIQRds6RypPV7dO8evW/exec";

  var _post = function(dataSrc) {
    return {
      method: 'POST',
      url: URL,
      headers: {
        'content-type': 'application/x-www-form-urlencoded; charset=UTF-8'
      },
      data: $httpParamSerializer(dataSrc)
    };
  };

  $scope.$on("$ionicView.beforeLeave", function() {
    $ionicConfig.views.swipeBackEnabled(true);
  });

  $scope.$on("$ionicView.enter", function() {
    $ionicConfig.views.swipeBackEnabled(false);
  });

  $scope.$on("$ionicView.beforeEnter", function(event, data) {
    walletId = data.stateParams.walletId;
    wallet = profileService.getWallet(walletId);
    $scope.data.accept = true;
  });

  var collectEmail = function() {
    var dataSrc = {
      "App": appConfigService.nameCase,
      "Email": $scope.data.email,
      "Platform": ionic.Platform.platform(),
      "DeviceVersion": ionic.Platform.version()
    };

    $http(_post(dataSrc)).then(function() {
      $log.info("SUCCESS: Email collected");
    }, function(err) {
      $log.error("ERROR: Could not collect email");
    });
  };

  $scope.save = function() {
    $scope.disableButton = true;
    $timeout(function() {
      var enabled = true; // Set enabled email: true

      emailService.updateEmail({
        enabled: enabled,
        email: enabled ? $scope.data.email : null
      });
          
      if ($scope.data.accept) collectEmail();

      $timeout(function() {
        $scope.goNextView();
      }, 200);
    }, 200);
  };

  $scope.goNextView = function() {
    $state.go('onboarding.backupRequest', {
      walletId: walletId
    });
  };

  $scope.confirm = function(emailForm) {
    if (emailForm.$invalid) return;
    $scope.confirmation = true;
  };

  $scope.cancel = function() {
    $scope.confirmation = false;
    $timeout(function() {
      $scope.$digest();
    }, 1);
  };

});

'use strict';

angular.module('copayApp.controllers').controller('disclaimerController', function($scope, $timeout, $state, $log, $ionicModal, $ionicConfig, profileService, uxLanguage, externalLinkService, storageService, $stateParams, startupService, $rootScope) {

  $scope.$on("$ionicView.afterEnter", function() {
    startupService.ready();
  });

  $scope.$on("$ionicView.beforeEnter", function() {
    $scope.lang = uxLanguage.currentLanguage;
    $scope.terms = {};
    $scope.accepted = {};
    $scope.accepted.first = $scope.accepted.second = $scope.accepted.third = false;
    $scope.backedUp = $stateParams.backedUp == 'false' ? false : true;
    $scope.resume = $stateParams.resume || false;
    $scope.shrinkView = false;
  });

  $scope.$on("$ionicView.enter", function() {
    if ($scope.backedUp || $scope.resume) $ionicConfig.views.swipeBackEnabled(false);
  });

  $scope.$on("$ionicView.beforeLeave", function() {
    $ionicConfig.views.swipeBackEnabled(true);
  });

  $scope.confirm = function() {
    profileService.setDisclaimerAccepted(function(err) {
      if (err) $log.error(err);
      else {
        $state.go('tabs.home', {
          fromOnboarding: true
        });
      }
    });
  };

  $scope.openExternalLink = function(url, target) {
    externalLinkService.open(url, target);
  };

  $scope.openTerms = function() {
    $scope.shrinkView = !$scope.shrinkView;
  }

  $scope.goBack = function() {
    $state.go('onboarding.backupRequest', {
      walletId: $stateParams.walletId
    });
  }


});

'use strict';

angular.module('copayApp.controllers').controller('termsController', function($scope, $log, $state, appConfigService, uxLanguage, profileService, externalLinkService, gettextCatalog) {
  $scope.lang = uxLanguage.currentLanguage;

  $scope.confirm = function() {
    profileService.setDisclaimerAccepted(function(err) {
      if (err) $log.error(err);
      else {
        $state.go('tabs.home', {
          fromOnboarding: true
        });
      }
    });
  };

  $scope.openExternalLink = function() {
    var url = appConfigService.disclaimerUrl;
    var optIn = true;
    var title = gettextCatalog.getString('View Terms of Service');
    var message = gettextCatalog.getString('The official English Terms of Service are available on the BitPay website.');
    var okText = gettextCatalog.getString('Open Website');
    var cancelText = gettextCatalog.getString('Go Back');
    externalLinkService.open(url, optIn, title, message, okText, cancelText);
  };

});

'use strict';
angular.module('copayApp.controllers').controller('tourController',
  function($scope, $state, $log, $timeout, $filter, ongoingProcess, profileService, rateService, popupService, gettextCatalog) {

    $scope.data = {
      index: 0
    };

    $scope.options = {
      loop: false,
      pagination: false,
      effect: 'flip',
      speed: 500,
      spaceBetween: 100
    }

    $scope.$on("$ionicSlides.sliderInitialized", function(event, data) {
      $scope.slider = data.slider;
    });

    $scope.$on("$ionicSlides.slideChangeStart", function(event, data) {
      $scope.data.index = data.slider.activeIndex;
    });

    $scope.$on("$ionicSlides.slideChangeEnd", function(event, data) {});

    $scope.$on("$ionicView.enter", function(event, data) {
      rateService.whenAvailable(function() {
        var localCurrency = 'USD';
        var btcAmount = 1;
        var rate = rateService.toFiat(btcAmount * 1e8, localCurrency, 'btc');
        $scope.localCurrencySymbol = '$';
        $scope.localCurrencyPerBtc = $filter('formatFiatAmount')(parseFloat(rate.toFixed(2), 10));
        $timeout(function() {
          $scope.$apply();
        })
      });
    });

    var retryCount = 0;
    $scope.createDefaultWallet = function() {
      ongoingProcess.set('creatingWallet', true);
      $timeout(function() {
        profileService.createDefaultWallet(function(err, walletClient) {
          if (err) {
            $log.warn(err);

            return $timeout(function() {
              $log.warn('Retrying to create default wallet.....:' + ++retryCount);
              if (retryCount > 3) {
                ongoingProcess.set('creatingWallet', false);
                popupService.showAlert(
                  gettextCatalog.getString('Cannot Create Wallet'), err,
                  function() {
                    retryCount = 0;
                    return $scope.createDefaultWallet();
                  }, gettextCatalog.getString('Retry'));
              } else {
                return $scope.createDefaultWallet();
              }
            }, 2000);
          };
          ongoingProcess.set('creatingWallet', false);
          var wallet = walletClient;
          var walletId = wallet.credentials.walletId;
/*
          $state.go('onboarding.collectEmail', {
            walletId: walletId
          });
*/
            
          $state.go('onboarding.backupRequest', {
            walletId: walletId
          });
            
        });
      }, 300);
    };

    $scope.goBack = function() {
      if ($scope.data.index != 0) $scope.slider.slidePrev();
      else $state.go('onboarding.welcome');
    }

    $scope.slideNext = function() {
      if ($scope.data.index != 2) $scope.slider.slideNext();
      else $state.go('onboarding.welcome');
    }
  });

'use strict';

angular.module('copayApp.controllers').controller('welcomeController', function($scope, $state, $timeout, $ionicConfig, $log, profileService, startupService, storageService) {

  $scope.$on("$ionicView.afterEnter", function() {
    startupService.ready();
  });

  $scope.$on("$ionicView.enter", function() {
    $ionicConfig.views.swipeBackEnabled(false);
  });

  $scope.$on("$ionicView.beforeLeave", function() {
    $ionicConfig.views.swipeBackEnabled(true);
  });

  $scope.createProfile = function() {
    $log.debug('Creating profile');
    profileService.createProfile(function(err) {
      if (err) $log.warn(err);
    });
  };

});

angular.module('copayApp.controllers').controller('paperWalletController',
  function($scope, $timeout, $log, $ionicModal, $ionicHistory, feeService, popupService, gettextCatalog, platformInfo, configService, profileService, $state, bitcore, ongoingProcess, txFormatService, $stateParams, walletService) {

    function _scanFunds(cb) {
      function getPrivateKey(scannedKey, isPkEncrypted, passphrase, cb) {
        if (!isPkEncrypted) return cb(null, scannedKey);
        $scope.wallet.decryptBIP38PrivateKey(scannedKey, passphrase, null, cb);
      };

      function getBalance(privateKey, cb) {
        $scope.wallet.getBalanceFromPrivateKey(privateKey, cb);
      };

      function checkPrivateKey(privateKey) {
        try {
          new bitcore.PrivateKey(privateKey, 'livenet');
        } catch (err) {
          return false;
        }
        return true;
      };

      getPrivateKey($scope.scannedKey, $scope.isPkEncrypted, $scope.passphrase, function(err, privateKey) {
        if (err) return cb(err);
        if (!checkPrivateKey(privateKey)) return cb(new Error('Invalid private key'));

        getBalance(privateKey, function(err, balance) {
          if (err) return cb(err);
          return cb(null, privateKey, balance);
        });
      });
    };

    $scope.scanFunds = function() {
      ongoingProcess.set('scanning', true);
      $timeout(function() {
        _scanFunds(function(err, privateKey, balance) {
          ongoingProcess.set('scanning', false);
          if (err) {
            $log.error(err);
            popupService.showAlert(gettextCatalog.getString('Error scanning funds:'), err || err.toString());
            $state.go('tabs.home');
          } else {
            $scope.privateKey = privateKey;
            $scope.balanceSat = balance;
            if ($scope.balanceSat <= 0)
              popupService.showAlert(gettextCatalog.getString('Error'), gettextCatalog.getString('Not funds found'));
            $scope.balance = txFormatService.formatAmountStr($scope.wallet.coin, balance);
          }
          $scope.$apply();
        });
      }, 100);
    };

    function _sweepWallet(cb) {
      walletService.getAddress($scope.wallet, true, function(err, destinationAddress) {
        if (err) return cb(err);

        $scope.wallet.buildTxFromPrivateKey($scope.privateKey, destinationAddress, null, function(err, testTx) {
          if (err) return cb(err);
          var rawTxLength = testTx.serialize().length;
          feeService.getCurrentFeeRate('btc', 'livenet', function(err, feePerKb) {
            var opts = {};
            opts.fee = Math.round((feePerKb * rawTxLength) / 2000);
            $scope.wallet.buildTxFromPrivateKey($scope.privateKey, destinationAddress, opts, function(err, tx) {
              if (err) return cb(err);
              $scope.wallet.broadcastRawTx({
                rawTx: tx.serialize(),
                network: 'livenet'
              }, function(err, txid) {
                if (err) return cb(err);
                return cb(null, destinationAddress, txid);
              });
            });
          });
        });
      });
    };

    $scope.sweepWallet = function() {
      ongoingProcess.set('sweepingWallet', true);
      $scope.sending = true;

      $timeout(function() {
        _sweepWallet(function(err, destinationAddress, txid) {
          ongoingProcess.set('sweepingWallet', false);
          $scope.sending = false;
          if (err) {
            $log.error(err);
            popupService.showAlert(gettextCatalog.getString('Error sweeping wallet:'), err || err.toString());
          } else {
            $scope.sendStatus = 'success';
          }
          $scope.$apply();
        });
      }, 100);
    };

    $scope.onSuccessConfirm = function() {
      $state.go('tabs.home');
    };

    $scope.onWalletSelect = function(wallet) {
      $scope.wallet = wallet;
    };

    $scope.showWalletSelector = function() {
      if ($scope.singleWallet) return;
      $scope.walletSelectorTitle = gettextCatalog.getString('Transfer to');
      $scope.showWallets = true;
    };

    $scope.$on("$ionicView.beforeEnter", function(event, data) {
      $scope.scannedKey = (data.stateParams && data.stateParams.privateKey) ? data.stateParams.privateKey : null;
      $scope.isPkEncrypted = $scope.scannedKey ? ($scope.scannedKey.substring(0, 2) == '6P') : null;
      $scope.sendStatus = null;
      $scope.error = false;

      $scope.wallets = profileService.getWallets({
        onlyComplete: true,
        network: 'livenet',
      });
      $scope.singleWallet = $scope.wallets.length == 1;

      if (!$scope.wallets || !$scope.wallets.length) {
        $scope.noMatchingWallet = true;
        return;
      }
    });

    $scope.$on("$ionicView.enter", function(event, data) {
      $scope.wallet = $scope.wallets[0];
      if (!$scope.wallet) return;
      if (!$scope.isPkEncrypted) $scope.scanFunds();
      else {
        var message = gettextCatalog.getString('Private key encrypted. Enter password');
        popupService.showPrompt(null, message, null, function(res) {
          $scope.passphrase = res;
          $scope.scanFunds();
        });
      }
    });

  });

'use strict';
angular.module('copayApp.controllers').controller('paymentUriController',
  function($rootScope, $scope, $stateParams, $location, $timeout, $ionicHistory, profileService, configService, lodash, bitcore, $state) {
    function strip(number) {
      return (parseFloat(number.toPrecision(12)));
    };

    // Build bitcoinURI with querystring
    this.init = function() {
      var query = [];
      this.bitcoinURI = $stateParams.url;

      var URI = bitcore.URI;
      var isUriValid = URI.isValid(this.bitcoinURI);
      if (!URI.isValid(this.bitcoinURI)) {
        this.error = true;
        return;
      }
      var uri = new URI(this.bitcoinURI);

      if (uri && uri.address) {
        var config = configService.getSync().wallet.settings;
        var unitToSatoshi = config.unitToSatoshi;
        var satToUnit = 1 / unitToSatoshi;
        var unitName = config.unitName;

        if (uri.amount) {
          uri.amount = strip(uri.amount * satToUnit) + ' ' + unitName;
        }
        uri.network = uri.address.network.name;
        this.uri = uri;
      }
    };

    this.getWallets = function(network) {

      $scope.wallets = [];
      lodash.forEach(profileService.getWallets(network), function(w) {
        var client = profileService.getClient(w.id);
        profileService.isReady(client, function(err) {
          if (err) return;
          $scope.wallets.push(w);
        })
      });
    };

    this.selectWallet = function(wid) {
      var self = this;
      profileService.setAndStoreFocus(wid, function() {});
      $ionicHistory.removeBackView();
      $state.go('tabs.home');
      $timeout(function() {
        $rootScope.$emit('paymentUri', self.bitcoinURI);
      }, 1000);
    };
  });

'use strict';

angular.module('copayApp.controllers').controller('preferencesController',
  function($scope, $rootScope, $timeout, $log, $ionicHistory, configService, profileService, fingerprintService, walletService, platformInfo, externalLinkService, gettextCatalog) {
    var wallet;
    var walletId;

    $scope.hiddenBalanceChange = function() {
      var opts = {
        balance: {
          enabled: $scope.hiddenBalance.value
        }
      };
      profileService.toggleHideBalanceFlag(walletId, function(err) {
        if (err) $log.error(err);
      });
    };

    $scope.encryptChange = function() {
      if (!wallet) return;
      var val = $scope.encryptEnabled.value;

      if (val && !walletService.isEncrypted(wallet)) {
        $log.debug('Encrypting private key for', wallet.name);
        walletService.encrypt(wallet, function(err) {
          if (err) {
            $log.warn(err);

            // ToDo show error?
            $scope.encryptEnabled.value = false;
            $timeout(function() {
              $scope.$apply();
            });
            return;
          }
          profileService.updateCredentials(JSON.parse(wallet.export()), function() {
            $log.debug('Wallet encrypted');
            return;
          });
        })
      } else if (!val && walletService.isEncrypted(wallet)) {
        walletService.decrypt(wallet, function(err) {
          if (err) {
            $log.warn(err);

            // ToDo show error?
            $scope.encryptEnabled.value = true;
            $timeout(function() {
              $scope.$apply();
            });
            return;
          }
          profileService.updateCredentials(JSON.parse(wallet.export()), function() {
            $log.debug('Wallet decrypted');
            return;
          });
        })
      }
    };

    $scope.openWikiSpendingPassword = function() {
      var url = 'https://github.com/bitpay/qyb/wiki/COPAY---FAQ#what-the-spending-password-does';
      var optIn = true;
      var title = null;
      var message = gettextCatalog.getString('Read more in our Wiki');
      var okText = gettextCatalog.getString('Open');
      var cancelText = gettextCatalog.getString('Go Back');
      externalLinkService.open(url, optIn, title, message, okText, cancelText);
    };

    $scope.touchIdChange = function() {
      var newStatus = $scope.touchIdEnabled.value;
      walletService.setTouchId(wallet, !!newStatus, function(err) {
        if (err) {
          $scope.touchIdEnabled.value = !newStatus;
          $timeout(function() {
            $scope.$apply();
          }, 1);
          return;
        }
        $log.debug('Touch Id status changed: ' + newStatus);
      });
    };

    $scope.$on("$ionicView.beforeEnter", function(event, data) {
      wallet = profileService.getWallet(data.stateParams.walletId);
      walletId = wallet.credentials.walletId;
      $scope.wallet = wallet;
      $scope.isWindowsPhoneApp = platformInfo.isCordova && platformInfo.isWP;
      $scope.externalSource = null;

      if (!wallet)
        return $ionicHistory.goBack();

      var config = configService.getSync();

      $scope.hiddenBalance = {
        value: $scope.wallet.balanceHidden
      };

      $scope.encryptEnabled = {
        value: walletService.isEncrypted(wallet)
      };

      $scope.touchIdAvailable = fingerprintService.isAvailable();
      $scope.touchIdEnabled = {
        value: config.touchIdFor ? config.touchIdFor[walletId] : null
      };

      $scope.deleted = false;
      if (wallet.credentials && !wallet.credentials.mnemonicEncrypted && !wallet.credentials.mnemonic) {
        $scope.deleted = true;
      }
    });
  });

'use strict';

angular.module('copayApp.controllers').controller('preferencesAbout',
  function($scope, $window, appConfigService, gettextCatalog, externalLinkService) {

    $scope.title = gettextCatalog.getString('About') + ' ' + appConfigService.nameCase;
    $scope.version = $window.version;
    $scope.commitHash = $window.commitHash;

    $scope.openExternalLink = function() {
      //var url = 'https://github.com/bitpay/' + appConfigService.gitHubRepoName + '/tree/' + $window.commitHash + '';
      var url = "https://github.com/blockchainclub/qyb-wallet-clients/tree"+ $window.commitHash + '';
      var optIn = true;
      var title = gettextCatalog.getString('Open GitHub Project');
      var message = gettextCatalog.getString('You can see the latest developments and contribute to this open source app by visiting our project on GitHub.');
      var okText = gettextCatalog.getString('Open GitHub');
      var cancelText = gettextCatalog.getString('Go Back');
      externalLinkService.open(url, optIn, title, message, okText, cancelText);
    };
  });

'use strict';

angular.module('copayApp.controllers').controller('preferencesAdvancedController', function($scope, $timeout, $state, $stateParams, profileService) {
  var wallet = profileService.getWallet($stateParams.walletId);
  $scope.network = wallet.network;
  $scope.wallet = wallet;

  $scope.goToAddresses = function() {
    $state.go('tabs.settings.addresses', {
      walletId: $stateParams.walletId,
    });
  };

  $timeout(function() {
    $scope.$apply();
  }, 1);
});

'use strict';

angular.module('copayApp.controllers').controller('preferencesAliasController',
  function($scope, $timeout, $stateParams, $ionicHistory, configService, profileService, walletService) {
    var wallet = profileService.getWallet($stateParams.walletId);
    var walletId = wallet.credentials.walletId;
    var config = configService.getSync();

    $scope.walletName = wallet.credentials.walletName;
    $scope.walletAlias = config.aliasFor && config.aliasFor[walletId] ? config.aliasFor[walletId] : wallet.credentials.walletName;
    $scope.alias = {
      value: $scope.walletAlias
    };

    $scope.save = function() {
      var opts = {
        aliasFor: {}
      };

      opts.aliasFor[walletId] = $scope.alias.value;

      configService.set(opts, function(err) {
        if (err) $log.warn(err);
        $ionicHistory.goBack();
      });
    };
  });

'use strict';

angular.module('copayApp.controllers').controller('preferencesAltCurrencyController',
  function($scope, $log, $timeout, $ionicHistory, configService, rateService, lodash, profileService, walletService, storageService) {

    var next = 10;
    var completeAlternativeList = [];

    function init() {
      var unusedCurrencyList = [{
        isoCode: 'LTL'
      }, {
        isoCode: 'QYB'
      }];
      rateService.whenAvailable(function() {

        $scope.listComplete = false;

        var idx = lodash.indexBy(unusedCurrencyList, 'isoCode');
        var idx2 = lodash.indexBy($scope.lastUsedAltCurrencyList, 'isoCode');

        completeAlternativeList = lodash.reject(rateService.listAlternatives(true), function(c) {
          return idx[c.isoCode] || idx2[c.isoCode];
        });

        $scope.altCurrencyList = completeAlternativeList.slice(0, 10);

        $timeout(function() {
          $scope.$apply();
        });
      });
    }

    $scope.loadMore = function() {
      $timeout(function() {
        $scope.altCurrencyList = completeAlternativeList.slice(0, next);
        next += 10;
        $scope.listComplete = $scope.altCurrencyList.length >= completeAlternativeList.length;
        $scope.$broadcast('scroll.infiniteScrollComplete');
      }, 100);
    };

    $scope.findCurrency = function(search) {
      if (!search) init();
      $scope.altCurrencyList = lodash.filter(completeAlternativeList, function(item) {
        var val = item.name
        var val2 = item.isoCode;
        return lodash.includes(val.toLowerCase(), search.toLowerCase()) || lodash.includes(val2.toLowerCase(), search.toLowerCase());
      });
      $timeout(function() {
        $scope.$apply();
      });
    };

    $scope.save = function(newAltCurrency) {
      var opts = {
        wallet: {
          settings: {
            alternativeName: newAltCurrency.name,
            alternativeIsoCode: newAltCurrency.isoCode,
          }
        }
      };

      configService.set(opts, function(err) {
        if (err) $log.warn(err);

        $ionicHistory.goBack();
        saveLastUsed(newAltCurrency);
        walletService.updateRemotePreferences(profileService.getWallets());
      });
    };

    function saveLastUsed(newAltCurrency) {
      $scope.lastUsedAltCurrencyList.unshift(newAltCurrency);
      $scope.lastUsedAltCurrencyList = lodash.uniq($scope.lastUsedAltCurrencyList, 'isoCode');
      $scope.lastUsedAltCurrencyList = $scope.lastUsedAltCurrencyList.slice(0, 3);
      storageService.setLastCurrencyUsed(JSON.stringify($scope.lastUsedAltCurrencyList), function() {});
    };

    $scope.$on("$ionicView.beforeEnter", function(event, data) {
      var config = configService.getSync();
      $scope.currentCurrency = config.wallet.settings.alternativeIsoCode;

      storageService.getLastCurrencyUsed(function(err, lastUsedAltCurrency) {
        $scope.lastUsedAltCurrencyList = lastUsedAltCurrency ? JSON.parse(lastUsedAltCurrency) : [];
        init();
      });
    });
  });

'use strict';

angular.module('copayApp.controllers').controller('preferencesBitpayCardController',
  function($scope, $state, $timeout, $ionicHistory, bitpayCardService, popupService, gettextCatalog, $log) {

    $scope.remove = function(card) {
      var msg = gettextCatalog.getString('Are you sure you would like to remove your BitPay Card ({{lastFourDigits}}) from this device?', {
        lastFourDigits: card.lastFourDigits
      });
      popupService.showConfirm(null, msg, null, null, function(res) {
        $log.info('Removing bitpay card:' + card.eid)
        if (res) 
          remove(card.eid);
      });
    };

    var remove = function(cardEid) {
      bitpayCardService.remove(cardEid, function(err) {
        if (err) {
          return popupService.showAlert(gettextCatalog.getString('Error'), gettextCatalog.getString('Could not remove card'));
        }
        $ionicHistory.clearHistory();
        $timeout(function() {
          $state.go('tabs.home');
        }, 100);
      });
    };

    $scope.$on("$ionicView.beforeEnter", function(event, data) {
      bitpayCardService.getCards(function(err, data) {
        if (err) return;

        $scope.bitpayCards = data;
      });
    });

  });

'use strict';

angular.module('copayApp.controllers').controller('preferencesBitpayServicesController',
  function($rootScope, $scope, $state, $timeout, $ionicHistory, bitpayAccountService, bitpayCardService, popupService, gettextCatalog) {

    $scope.removeAccount = function(account) {
      var title = gettextCatalog.getString('Remove BitPay Account?');
      var msg = gettextCatalog.getString('Removing your BitPay account will remove all associated BitPay account data from this device. Are you sure you would like to remove your BitPay Account ({{email}}) from this device?', {
        email: account.email
      });
      popupService.showConfirm(title, msg, null, null, function(res) {
        if (res) {
          removeAccount(account);
        }
      });
    };

    $scope.removeCard = function(card) {
      var title = gettextCatalog.getString('Remove BitPay Card?');
      var msg = gettextCatalog.getString('Are you sure you would like to remove your BitPay Card ({{lastFourDigits}}) from this device?', {
        lastFourDigits: card.lastFourDigits
      });
      popupService.showConfirm(title, msg, null, null, function(res) {
        if (res) {
          removeCard(card);
        }
      });
    };

    var removeAccount = function(account) {
      bitpayAccountService.removeAccount(account, function(err) {
        if (err) {
          return popupService.showAlert(gettextCatalog.getString('Error'), gettextCatalog.getString('Could not remove account'));
        }
        setScope(function() {
          // If there are no paired accounts then change views.
          if ($scope.bitpayAccounts.length == 0) {
            $state.go('tabs.settings').then(function() {
              $ionicHistory.clearHistory();
              $state.go('tabs.home');
            });
          }
        });
      });
    };

    var removeCard = function(card) {
      bitpayCardService.remove(card.id, function(err) {
        if (err) {
          return popupService.showAlert(gettextCatalog.getString('Error'), gettextCatalog.getString('Could not remove card'));
        }
        setScope();
      });
    };

    var setScope = function(cb) {
      bitpayAccountService.getAccounts(function(err, accounts) {
        if (err) return;
        $scope.bitpayAccounts = accounts;

        bitpayCardService.getCards(function(err, cards) {
          if (err) return;
          $scope.bitpayCards = cards;
          if (cb) {
            cb();
          }
          $timeout(function(){
            $rootScope.$apply();
          }, 10);
        });
      });
    };

    $scope.$on("$ionicView.beforeEnter", function(event, data) {
      setScope();
    });

  });

'use strict';

angular.module('copayApp.controllers').controller('preferencesBwsUrlController',
  function($scope, $log, $stateParams, configService, applicationService, profileService, storageService, appConfigService) {
    $scope.success = null;

    var wallet = profileService.getWallet($stateParams.walletId);
    $scope.wallet = wallet;

    var walletId = wallet.credentials.walletId;
    var defaults = configService.getDefaults();
    var config = configService.getSync();
    $scope.appName = appConfigService.nameCase;
    $scope.bwsurl = {
      value: (config.bwsFor && config.bwsFor[walletId]) || defaults.bws.url
    };

    $scope.resetDefaultUrl = function() {
      $scope.bwsurl.value = defaults.bws.url;
    };

    $scope.save = function() {

      var bws;
      switch ($scope.bwsurl.value) {
        case 'prod':
        case 'production':
          //bws = 'https://bws.bitpay.com/bws/api'
          //bws = 'http://1943h2623o.51mypc.cn/bws/api'
          bws = 'http://api.qyb.chainclub.one/bws/api'
          break;
        case 'sta':
        case 'staging':
          //bws = 'https://bws-staging.b-pay.net/bws/api'
          //bws = 'http://1943h2623o.51mypc.cn/bws/api'
          bws = 'http://api.qyb.chainclub.one/bws/api'
          break;
        case 'loc':
        case 'local':
          //bws = 'https://bws.bitpay.com/bws/api'
          //bws = 'http://1943h2623o.51mypc.cn/bws/api'
          bws = 'http://api.qyb.chainclub.one/bws/api'
          break;
      };
      if (bws) {
        $log.info('Using BWS URL Alias to ' + bws);
        $scope.bwsurl.value = bws;
      }

      var opts = {
        bwsFor: {}
      };
      opts.bwsFor[walletId] = $scope.bwsurl.value;

      configService.set(opts, function(err) {
        if (err) $log.debug(err);
        storageService.setCleanAndScanAddresses(walletId, function() {
          applicationService.restart();
        });
      });
    };
  });

'use strict';

angular.module('copayApp.controllers').controller('preferencesCashController',
  function($rootScope, $timeout, $scope, $state, $ionicHistory, gettextCatalog, lodash, ongoingProcess, profileService, walletService, $log, txFormatService, bwcError, pushNotificationsService, bwcService, externalLinkService) {
    var wallet;
    var errors = bwcService.getErrors();
    $scope.error = null;
    $scope.walletDisabled = '#667';

    $scope.$on("$ionicView.beforeEnter", function(event, data) {
      updateAllWallets();
    });

    $scope.openRecoveryToolLink = function() {
      var url = 'https://bitpay.github.io/copay-recovery/';
      var optIn = true;
      var title = null;
      var message = gettextCatalog.getString('Open the recovery tool.');
      var okText = gettextCatalog.getString('Open');
      var cancelText = gettextCatalog.getString('Go Back');
      externalLinkService.open(url, optIn, title, message, okText, cancelText);
    };

    var goHome = function() {
      $ionicHistory.nextViewOptions({
        disableAnimate: true,
        historyRoot: true
      });
      $ionicHistory.clearHistory();
      $state.go('tabs.settings').then(function() {
        $state.transitionTo('tabs.home');
      });
    }

    var updateAllWallets = function() {
      var walletsQYB = profileService.getWallets({
        coin: 'btc',
        onlyComplete: true,
        network: 'livenet'
      });

      // Filter out already duplicated wallets
      var walletsBCH = profileService.getWallets({
        coin: 'bch',
        network: 'livenet'
      });
      var xPubKeyIndex = lodash.indexBy(walletsBCH, "credentials.xPubKey");

      walletsQYB = lodash.filter(walletsQYB, function(w) {
        return !xPubKeyIndex[w.credentials.xPubKey];
      });

      var availableWallets = [];
      var nonEligibleWallets = [];

      lodash.each(walletsQYB, function(w) {
        if (w.credentials.derivationStrategy != 'BIP44') {
          w.excludeReason = gettextCatalog.getString('Non BIP44 wallet');
          nonEligibleWallets.push(w);
        } else if (!w.canSign()) {
          w.excludeReason = gettextCatalog.getString('Read only wallet');
          nonEligibleWallets.push(w);
        } else if (w.needsBackup) {
          w.excludeReason = gettextCatalog.getString('Backup needed');
          nonEligibleWallets.push(w);
        } else {
          availableWallets.push(w);
        }
      });

      $scope.availableWallets = availableWallets;
      $scope.nonEligibleWallets = nonEligibleWallets;

      var i = availableWallets.length;
      var j = 0;
      lodash.each(availableWallets, function(wallet) {
        walletService.getBalance(wallet, {
          coin: 'bch'
        }, function(err, balance) {
          if (err) {
            wallet.error = (err === 'WALLET_NOT_REGISTERED') ? gettextCatalog.getString('Wallet not registered') : bwcError.msg(err);
            $log.error(err);
            return;
          }

          wallet.error = null;
          wallet.bchBalance = txFormatService.formatAmountStr('bch', balance.availableAmount);
          if (++j == i) {
            //Done
            $timeout(function() {
              $rootScope.$apply();
            }, 10);
          }
        });
      });
    };

    $scope.duplicate = function(wallet) {
      $scope.error = null;
      $log.debug('Duplicating wallet for dmb:' + wallet.id + ':' + wallet.name);

      var opts = {};
      opts.name = wallet.name + '[dmb]';
      opts.m = wallet.m;
      opts.n = wallet.n;
      opts.myName = wallet.credentials.copayerName;
      opts.networkName = wallet.network;
      opts.coin = 'bch';
      opts.walletPrivKey = wallet.credentials.walletPrivKey;
      opts.compliantDerivation = wallet.credentials.compliantDerivation;


      function setErr(err, cb) {

        if (!cb) cb = function() {};

        $scope.error = bwcError.cb(err, gettextCatalog.getString('Could not duplicate'), function() {
          return cb(err);
        });
        $timeout(function() {
          $rootScope.$apply();
        }, 10);
      }

      function importOrCreate(cb) {
        walletService.getStatus(wallet, {}, function(err, status) {
          if (err) return cb(err);

          opts.singleAddress = status.wallet.singleAddress;

          // first try to import
          profileService.importExtendedPrivateKey(opts.extendedPrivateKey, opts, function(err, newWallet) {
            if (err && !(err instanceof errors.NOT_AUTHORIZED)) {
              return setErr(err, cb);
            }
            if (err) {
              // create and store a wallet
              return profileService.createWallet(opts, function(err, newWallet) {
                if (err) return setErr(err, cb);
                return cb(null, newWallet, true);
              });
            }
            return cb(null, newWallet);
          });
        });
      };

      // Multisig wallets? add Copayers
      function addCopayers(newWallet, isNew, cb) {
        if (!isNew) return cb();
        if (wallet.n == 1) return cb();

        $log.info('Adding copayers for dmb wallet config:' + wallet.m + '-' + wallet.n);

        walletService.copyCopayers(wallet, newWallet, function(err) {
          if (err) return setErr(err, cb);

          return cb();
        });
      };

      walletService.getKeys(wallet, function(err, keys) {
        if (err) {
          $scope.error = err;
          return $timeout(function() {
            $rootScope.$apply();
          }, 10);
        }
        opts.extendedPrivateKey = keys.xPrivKey;
        ongoingProcess.set('duplicatingWallet', true);
        importOrCreate(function(err, newWallet, isNew) {
          if (err) {
            ongoingProcess.set('duplicatingWallet', false);
            return;
          }
          walletService.updateRemotePreferences(newWallet);
          pushNotificationsService.updateSubscription(newWallet);

          addCopayers(newWallet, isNew, function(err) {
            ongoingProcess.set('duplicatingWallet', false);
            if (err)
              return setErr(err);

            if (isNew)
              walletService.startScan(newWallet, function() {});

            goHome();
          });
        });
      });
    }
  });

'use strict';

angular.module('copayApp.controllers').controller('preferencesCoinbaseController', function($scope, $timeout, $log, $state, $ionicHistory, lodash, ongoingProcess, popupService, coinbaseService) {

  $scope.revokeToken = function() {
    popupService.showConfirm('Coinbase', 'Are you sure you would like to log out of your Coinbase account?', null, null, function(res) {
      if (res) {
        coinbaseService.logout(function() {
          $ionicHistory.clearHistory();
          $timeout(function() {
            $state.go('tabs.home');
          }, 100);
        });
      }
    });
  };

  $scope.$on("$ionicView.enter", function(event, data){
    ongoingProcess.set('connectingCoinbase', true);
    coinbaseService.init(function(err, data) {
      if (err || lodash.isEmpty(data)) {
        ongoingProcess.set('connectingCoinbase', false);
        if (err) {
          $log.error(err);
          var errorId = err.errors ? err.errors[0].id : null;
          err = err.errors ? err.errors[0].message : err;
          popupService.showAlert('Error connecting to Coinbase', err, function() {
            if (errorId == 'revoked_token') {
              coinbaseService.logout(function() {});
              $ionicHistory.goBack();
            }
          });
        }
        return;
      }
      var accessToken = data.accessToken;
      var accountId = data.accountId;
      coinbaseService.getAccount(accessToken, accountId, function(err, account) {
        ongoingProcess.set('connectingCoinbase', false);
        $scope.coinbaseAccount = account.data;
      });
      coinbaseService.getCurrentUser(accessToken, function(err, user) {
        $scope.coinbaseUser = user.data;
      });
    });
  });

});

'use strict';

angular.module('copayApp.controllers').controller('preferencesColorController', function($scope, $timeout, $log, $stateParams, $ionicHistory, configService, profileService) {
  var wallet = profileService.getWallet($stateParams.walletId);
  $scope.wallet = wallet;
  var walletId = wallet.credentials.walletId;
  var config = configService.getSync();
  config.colorFor = config.colorFor || {};

  var retries = 3;
  $scope.colorCount = getColorCount();
  setCurrentColorIndex();

  $scope.save = function(i) {
    var color = indexToColor(i);
    if (!color) return;

    var opts = {
      colorFor: {}
    };
    opts.colorFor[walletId] = color;

    configService.set(opts, function(err) {
      if (err) $log.warn(err);
      $ionicHistory.goBack();
    });
  };

  function getColorDefault() {
    return rgb2hex(window.getComputedStyle(document.getElementsByClassName('wallet-color-default')[0]).color);
  };

  function getColorCount() {
    var count = window.getComputedStyle(document.getElementsByClassName('wallet-color-count')[0]).content;
    return parseInt(count.replace(/[^0-9]/g, ''));
  };

  function setCurrentColorIndex() {
    try {
      $scope.currentColorIndex = colorToIndex(config.colorFor[walletId] || getColorDefault());
    } catch(e) {
      // Wait for DOM to render and try again.
      $timeout(function() {
        if (retries > 0) {
          retries -= 1;
          setCurrentColorIndex();
        }
      }, 100);
    }
  };

  function colorToIndex(color) {
    for (var i = 0; i < $scope.colorCount; i++) {
      if (indexToColor(i) == color.toLowerCase()) {
        return i;
      }
    }
    return undefined;
  };

  function indexToColor(i) {
    // Expect an exception to be thrown if can't getComputedStyle().
    return rgb2hex(window.getComputedStyle(document.getElementsByClassName('wallet-color-' + i)[0]).backgroundColor);
  };

  function rgb2hex(rgb) {
    rgb = rgb.match(/^rgba?[\s+]?\([\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?/i);
    return (rgb && rgb.length === 4) ? "#" +
      ("0" + parseInt(rgb[1],10).toString(16)).slice(-2) +
      ("0" + parseInt(rgb[2],10).toString(16)).slice(-2) +
      ("0" + parseInt(rgb[3],10).toString(16)).slice(-2) : '';
  };

});

'use strict';

angular.module('copayApp.controllers').controller('preferencesDeleteWalletController',
  function($scope, $ionicHistory, gettextCatalog, lodash, profileService, $state, ongoingProcess, popupService, pushNotificationsService) {

    $scope.$on("$ionicView.beforeEnter", function(event, data) {
      if (!data.stateParams || !data.stateParams.walletId) {
        popupService.showAlert(null, gettextCatalog.getString('No wallet selected'), function() {
          $ionicHistory.goBack();
        });
        return;
      }
      $scope.wallet = profileService.getWallet(data.stateParams.walletId);
      if (!$scope.wallet) {
        popupService.showAlert(null, gettextCatalog.getString('No wallet found'), function() {
          $ionicHistory.goBack();
        });
        return;
      }
      $scope.walletName = $scope.wallet.name;
    });

    $scope.showDeletePopup = function() {
      var title = gettextCatalog.getString('Warning!');
      var message = gettextCatalog.getString('Are you sure you want to delete this wallet?');
      popupService.showConfirm(title, message, null, null, function(res) {
        if (res) deleteWallet();
      });
    };

    function deleteWallet() {
      ongoingProcess.set('deletingWallet', true);
      profileService.deleteWalletClient($scope.wallet, function(err) {
        ongoingProcess.set('deletingWallet', false);
        if (err) {
          popupService.showAlert(gettextCatalog.getString('Error'), err.message || err);
        } else {
          pushNotificationsService.unsubscribe($scope.wallet);
          $ionicHistory.nextViewOptions({
            disableAnimate: true,
            historyRoot: true
          });
          $ionicHistory.clearHistory();
          $state.go('tabs.settings').then(function() {
            $state.transitionTo('tabs.home');
          });
        }
      });
    };
  });

'use strict';

angular.module('copayApp.controllers').controller('preferencesExternalController', function($scope, $stateParams, lodash, gettextCatalog, popupService, profileService, walletService) {
  var wallet = profileService.getWallet($stateParams.walletId);

  $scope.externalSource = lodash.find(walletService.externalSource, function(source) {
    return source.id == wallet.getPrivKeyExternalSourceName();
  });

  if ($scope.externalSource.isEmbeddedHardware) {
    $scope.hardwareConnected = $scope.externalSource.version.length > 0;

    $scope.showMneumonicFromHardwarePopup = function() {
      var title = gettextCatalog.getString('Warning!');
      var message = gettextCatalog.getString('Are you being watched? Anyone with your recovery phrase can access or spend your bitcoin.');
      popupService.showConfirm(title, message, null, null, function(res) {
        if (res) {
          walletService.showMneumonicFromHardware(wallet, function(err) {
            if (err) {
              popupService.showAlert(gettextCatalog.getString('Error'), err.message || err);
            }
          });
        }
      });
    };    
  }

});
'use strict';

angular.module('copayApp.controllers').controller('preferencesFeeController', function($scope, $timeout, $ionicHistory, lodash, gettextCatalog, configService, feeService, ongoingProcess, popupService) {

  $scope.save = function(newFee) {

    $scope.currentFeeLevel = newFee;

    if ($scope.currentFeeLevel != 'custom') updateCurrentValues();
    else showCustomFeePrompt();

    if ($scope.noSave) return;

    var opts = {
      wallet: {
        settings: {
          feeLevel: newFee
        }
      }
    };

    configService.set(opts, function(err) {
      if (err) $log.debug(err);
      $timeout(function() {
        $scope.$apply();
      });
    });
  };

  $scope.$on("$ionicView.beforeEnter", function(event, data) {
    $scope.init();
  });

  $scope.init = function() {
    var coin = 'btc'; // TODO: only QYB in preferences
    $scope.network = $scope.network || 'livenet';
    $scope.feeOpts = feeService.feeOpts;
    $scope.currentFeeLevel = $scope.feeLevel || feeService.getCurrentFeeLevel();
    $scope.loadingFee = true;
    feeService.getFeeLevels(coin, function(err, levels) {
      $scope.loadingFee = false;
      if (err) {
        //Error is already formatted
        popupService.showAlert(err);
        return;
      }
      $scope.feeLevels = levels;
      updateCurrentValues();
      $timeout(function() {
        $scope.$apply();
      });
    });
  };

  var updateCurrentValues = function() {
    if (lodash.isEmpty($scope.feeLevels) || lodash.isEmpty($scope.currentFeeLevel)) return;

    var value = lodash.find($scope.feeLevels[$scope.network], {
      level: $scope.currentFeeLevel
    });

    if (lodash.isEmpty(value)) {
      $scope.feePerSatByte = $scope.currentFeeLevel == 'custom' ? $scope.feePerSatByte : null;
      $scope.avgConfirmationTime = null;
      setMinWarning();
      setMaxWarning();
      return;
    }

    $scope.feePerSatByte = (value.feePerKb / 1000).toFixed();
    $scope.avgConfirmationTime = value.nbBlocks * 10;
    $scope.invalidCustomFeeEntered = false;
    setMinWarning();
    setMaxWarning();
  };

  $scope.chooseNewFee = function() {
    $scope.hideModal($scope.currentFeeLevel, $scope.customFeePerKB);
  };

  var showCustomFeePrompt = function() {
    $scope.invalidCustomFeeEntered = true;
    $scope.showMaxWarning = false;
    $scope.showMinWarning = false;
    popupService.showPrompt(gettextCatalog.getString('Custom Fee'), gettextCatalog.getString('Set your own fee in satoshis/byte'), null, function(text) {
      if (!text || !parseInt(text) || parseInt(text) <= 0) return;
      $scope.feePerSatByte = parseInt(text);
      $scope.customFeePerKB = ($scope.feePerSatByte * 1000).toFixed();
      setMaxWarning();
      setMinWarning();
      $timeout(function() {
        $scope.$apply();
      });
    });
  };

  $scope.getMinimumRecommeded = function() {
    var value = lodash.find($scope.feeLevels[$scope.network], {
      level: 'superEconomy'
    });
    return parseInt((value.feePerKb / 1000).toFixed());
  };

  var setMinWarning = function() {
    if (parseInt($scope.feePerSatByte) < $scope.getMinimumRecommeded()) $scope.showMinWarning = true;
    else $scope.showMinWarning = false;
  };

  var setMaxWarning = function() {
    if (parseInt($scope.feePerSatByte) > 1000) {
      $scope.showMaxWarning = true;
      $scope.invalidCustomFeeEntered = true;
    } else {
      $scope.showMaxWarning = false;
      $scope.invalidCustomFeeEntered = false;
    }
  };

});

'use strict';

angular.module('copayApp.controllers').controller('preferencesGlideraController',
  function($scope, $timeout, $state, $ionicHistory, glideraService, popupService) {

    $scope.revokeToken = function() {
      popupService.showConfirm('Glidera', 'Are you sure you would like to log out of your Glidera account?', null, null, function(res) {
        if (res) {
          glideraService.remove(function() {
            $ionicHistory.clearHistory();
            $timeout(function() {
              $state.go('tabs.home');
            }, 100);
          });
        }
      });
    };

    $scope.$on("$ionicView.afterEnter", function(event, data){
      glideraService.updateStatus($scope.account);
    });

    $scope.$on("$ionicView.beforeEnter", function(event, data){
      $scope.account = {};
      glideraService.init(function(err, glidera) {
        if (err || !glidera) {
          if (err) popupService.showAlert('Error connecting Glidera', err);
          return;
        }
        $scope.account['token'] = glidera.token;
        $scope.account['permissions'] = glidera.permissions;
        $scope.account['status'] = glidera.status;
      });
    });

  });

'use strict';

angular.module('copayApp.controllers').controller('preferencesHistory',
  function($scope, $log, $stateParams, $timeout, $state, $ionicHistory, storageService, platformInfo, profileService, lodash, appConfigService, walletService) {
    $scope.wallet = profileService.getWallet($stateParams.walletId);
    $scope.csvReady = false;
    $scope.isCordova = platformInfo.isCordova;
    $scope.appName = appConfigService.nameCase;


    // TODO : move this to walletService.
    $scope.csvHistory = function(cb) {
      var allTxs = [];

      function getHistory(cb) {
        storageService.getTxHistory($scope.wallet.id, function(err, txs) {
          if (err) return cb(err);

          var txsFromLocal = [];
          try {
            txsFromLocal = JSON.parse(txs);
          } catch (ex) {
            $log.warn(ex);
          }

          allTxs.push(txsFromLocal);
          return cb(null, lodash.compact(lodash.flatten(allTxs)));
        });
      };

      $log.debug('Generating CSV from History');
      getHistory(function(err, txs) {
        if (err || lodash.isEmpty(txs)) {
          if (err) {
            $log.warn('Failed to generate CSV:', err);
            $scope.err = err;
          } else {
            $log.warn('Failed to generate CSV: no transactions');
            $scope.err = 'no transactions';
          }
          if (cb) return cb(err);
          return;
        }
        $log.debug('Wallet Transaction History Length:', txs.length);

        $scope.satToUnit = 1 / $scope.unitToSatoshi;
        var data = txs;
        var satToBtc = 1 / 100000000;
        $scope.csvContent = [];
        $scope.csvFilename = $scope.appName + '-' + $scope.wallet.name + '.csv';
        $scope.csvHeader = ['Date', 'Destination', 'Description', 'Amount', 'Currency', 'Txid', 'Creator', 'Copayers', 'Comment'];

        var _amount, _note, _copayers, _creator, _comment;
        data.forEach(function(it, index) {
          var amount = it.amount;

          if (it.action == 'moved')
            amount = 0;

          _copayers = '';
          _creator = '';

          if (it.actions && it.actions.length > 1) {
            for (var i = 0; i < it.actions.length; i++) {
              _copayers += it.actions[i].copayerName + ':' + it.actions[i].type + ' - ';
            }
            _creator = (it.creatorName && it.creatorName != 'undefined') ? it.creatorName : '';
          }
          _amount = (it.action == 'sent' ? '-' : '') + (amount * satToBtc).toFixed(8);
          _note = it.message || '';
          _comment = it.note ? it.note.body : '';

          if (it.action == 'moved')
            _note += ' Moved:' + (it.amount * satToBtc).toFixed(8)

          $scope.csvContent.push({
            'Date': formatDate(it.time * 1000),
            'Destination': it.addressTo || '',
            'Description': _note,
            'Amount': _amount,
            'Currency': 'QYB',
            'Txid': it.txid,
            'Creator': _creator,
            'Copayers': _copayers,
            'Comment': _comment
          });

          if (it.fees && (it.action == 'moved' || it.action == 'sent')) {
            var _fee = (it.fees * satToBtc).toFixed(8)
            $scope.csvContent.push({
              'Date': formatDate(it.time * 1000),
              'Destination': 'Qybcoin Network Fees',
              'Description': '',
              'Amount': '-' + _fee,
              'Currency': 'QYB',
              'Txid': '',
              'Creator': '',
              'Copayers': ''
            });
          }
        });

        $scope.csvReady = true;
        $timeout(function() {
          $scope.$apply();
        }, 100);

        if (cb)
          return cb();
        return;
      });

      function formatDate(date) {
        var dateObj = new Date(date);
        if (!dateObj) {
          $log.debug('Error formating a date');
          return 'DateError'
        }
        if (!dateObj.toJSON()) {
          return '';
        }

        return dateObj.toJSON();
      };
    };

    $scope.clearTransactionHistory = function() {
      $log.info('Removing Transaction history ' + $scope.wallet.id);

      walletService.clearTxHistory($scope.wallet, function(err) {

        if (err) {
          $log.error(err);
          return;
        }

        $log.info('Transaction history cleared for :' + $scope.wallet.id);

        $ionicHistory.removeBackView();
        $state.go('tabs.home');
        $timeout(function() {
          $state.transitionTo('tabs.wallet', {
            walletId: $scope.wallet.id,
            clearCache: true
          });
        }, 100);
      });
    };

    $scope.$on("$ionicView.enter", function(event, data) {
      $scope.csvHistory();
    });
  });

'use strict';

angular.module('copayApp.controllers').controller('preferencesInformation',
  function($scope, $log, $ionicHistory, platformInfo, lodash, profileService, configService, $stateParams, $state, walletService) {
    var wallet = profileService.getWallet($stateParams.walletId);
    $scope.wallet = wallet;

    var walletId = wallet.id;
    var config = configService.getSync();
    var colorCounter = 1;
    var BLACK_WALLET_COLOR = '#202020';
    $scope.isCordova = platformInfo.isCordova;
    config.colorFor = config.colorFor || {};

    $scope.saveBlack = function() {
      function save(color) {
        var opts = {
          colorFor: {}
        };
        opts.colorFor[walletId] = color;

        configService.set(opts, function(err) {
          $ionicHistory.removeBackView();
          $state.go('tabs.home');
          if (err) $log.warn(err);
        });
      };

      if (colorCounter != 5) return colorCounter++;
      save(BLACK_WALLET_COLOR);
    };

    $scope.$on("$ionicView.enter", function(event, data) {
      var c = wallet.credentials;
      var basePath = c.getBaseAddressDerivationPath();

      $scope.wallet = wallet;
      $scope.walletName = c.walletName;
      $scope.walletId = c.walletId;
      $scope.network = c.network;
      $scope.addressType = c.addressType || 'P2SH';
      $scope.derivationStrategy = c.derivationStrategy || 'BIP45';
      $scope.basePath = basePath;
      $scope.M = c.m;
      $scope.N = c.n;
      $scope.pubKeys = lodash.pluck(c.publicKeyRing, 'xPubKey');
      $scope.externalSource = null;
      $scope.canSign = wallet.canSign();

      if (wallet.isPrivKeyExternal()) {
        $scope.externalSource = lodash.find(walletService.externalSource, function(source) {
          return source.id == wallet.getPrivKeyExternalSourceName();
        }).name;
      }
    });

  });

'use strict';

angular.module('copayApp.controllers').controller('preferencesLanguageController',
  function($scope, $log, $ionicHistory, configService, profileService, uxLanguage, walletService, externalLinkService, gettextCatalog) {

    $scope.availableLanguages = uxLanguage.getLanguages();

    $scope.openExternalLink = function() {
      var url = 'https://crowdin.com/project/qyb';
      var optIn = true;
      var title = gettextCatalog.getString('Open Translation Community');
      var message = gettextCatalog.getString('You can make contributions by signing up on our Crowdin community translation website. We’re looking forward to hearing from you!');
      var okText = gettextCatalog.getString('Open Crowdin');
      var cancelText = gettextCatalog.getString('Go Back');
      externalLinkService.open(url, optIn, title, message, okText, cancelText);
    };

    $scope.save = function(newLang) {
      var opts = {
        wallet: {
          settings: {
            defaultLanguage: newLang
          }
        }
      };

      uxLanguage._set(newLang);
      configService.set(opts, function(err) {
        if (err) $log.warn(err);
        walletService.updateRemotePreferences(profileService.getWallets());
      });

      $ionicHistory.goBack();
    };

    $scope.$on("$ionicView.beforeEnter", function(event, data) {
      $scope.currentLanguage = uxLanguage.getCurrentLanguage();
    });
  });

'use strict';

angular.module('copayApp.controllers').controller('preferencesLogs',
  function($scope, historicLog, lodash, configService, gettextCatalog) {

    var config = configService.getSync();
    var logLevels = historicLog.getLevels();
    var selectedLevel;

    $scope.logOptions = lodash.indexBy(logLevels, 'level');

    var filterLogs = function(weight) {
      $scope.filteredLogs = historicLog.get(weight);
    };

    $scope.setOptionSelected = function(level) {
      var weight = $scope.logOptions[level].weight;
      $scope.fillClass = 'fill-bar-' + level;
      filterLogs(weight);
      lodash.each($scope.logOptions, function(opt) {
        opt.selected = opt.weight <= weight ? true : false;
        opt.head = opt.weight == weight;
      });

      // Save the setting.
      var opts = {
        log: {
          filter: level
        }
      };
      configService.set(opts, function(err) {
        if (err) $log.debug(err);
      });
    };

    $scope.prepareLogs = function() {
      var log = 'Qyb Session Logs\n Be careful, this could contain sensitive private data\n\n';
      log += '\n\n';
      log += historicLog.get().map(function(v) {
        return '[' + v.timestamp + '][' + v.level + ']' + v.msg;
      }).join('\n');

      return log;
    };

    $scope.sendLogs = function() {
      var body = $scope.prepareLogs();

      window.plugins.socialsharing.shareViaEmail(
        body,
        'Qyb Logs',
        null, // TO: must be null or an array
        null, // CC: must be null or an array
        null, // BCC: must be null or an array
        null, // FILES: can be null, a string, or an array
        function() {},
        function() {}
      );
    };

    $scope.showOptionsMenu = function() {
      $scope.showOptions = true;
    };

    $scope.$on("$ionicView.beforeEnter", function(event, data) {
      selectedLevel = lodash.has(config, 'log.filter') ? historicLog.getLevel(config.log.filter) : historicLog.getDefaultLevel();
      $scope.setOptionSelected(selectedLevel.level);
    });

    $scope.$on("$ionicView.enter", function(event, data) {
      filterLogs(selectedLevel.weight);
    });
  });

'use strict';

angular.module('copayApp.controllers').controller('preferencesNotificationsController', function($scope, $log, $timeout, appConfigService, lodash, configService, platformInfo, pushNotificationsService, emailService) {
  var updateConfig = function() {
    var config = configService.getSync();
    $scope.appName = appConfigService.nameCase;
    $scope.PNEnabledByUser = true;
    $scope.usePushNotifications = platformInfo.isCordova && !platformInfo.isWP;
    $scope.isIOSApp = platformInfo.isIOS && platformInfo.isCordova;

    $scope.pushNotifications = {
      value: config.pushNotificationsEnabled
    };

    var isConfirmedTxsNotificationsEnabled = config.confirmedTxsNotifications ? config.confirmedTxsNotifications.enabled : false;
    $scope.confirmedTxsNotifications = {
      value: isConfirmedTxsNotificationsEnabled
    };

    $scope.latestEmail = {
      value: emailService.getEmailIfEnabled()
    };

    $scope.newEmail = lodash.clone($scope.latestEmail);
    var isEmailEnabled = config.emailNotifications ? config.emailNotifications.enabled : false;

    $scope.emailNotifications = {
      value: isEmailEnabled && $scope.newEmail.value ? true : false
    };

    $timeout(function() {
      $scope.$apply();
    });
  };

  $scope.pushNotificationsChange = function() {
    if (!$scope.pushNotifications) return;
    var opts = {
      pushNotificationsEnabled: $scope.pushNotifications.value
    };
    configService.set(opts, function(err) {
      if (err) $log.debug(err);
      if (opts.pushNotificationsEnabled)
        pushNotificationsService.init();
      else
        pushNotificationsService.disable();
    });
  };

  $scope.confirmedTxsNotificationsChange = function() {
    if (!$scope.pushNotifications) return;
    var opts = {
      confirmedTxsNotifications: {
        enabled: $scope.confirmedTxsNotifications.value
      }
    };
    configService.set(opts, function(err) {
      if (err) $log.debug(err);
    });
  };

  $scope.emailNotificationsChange = function() {
    var opts = {
      enabled: $scope.emailNotifications.value,
      email: $scope.newEmail.value
    };

    $scope.latestEmail = {
      value: emailService.getEmailIfEnabled()
    };

    emailService.updateEmail(opts);
  };

  $scope.save = function() {
    emailService.updateEmail({
      enabled: $scope.emailNotifications.value,
      email: $scope.newEmail.value
    });

    $scope.latestEmail = {
      value: $scope.newEmail.value
    };

    $timeout(function() {
      $scope.$apply();
    });
  };

  $scope.$on("$ionicView.enter", function(event, data) {
    updateConfig();
  });
});

'use strict';

angular.module('copayApp.controllers').controller('preferencesPrivateKeyController', function($scope, $log, $timeout, $ionicHistory, profileService, walletService) {

  $scope.$on("$ionicView.beforeEnter", function(event, data) {
    if (!data.stateParams || !data.stateParams.walletId) {
      popupService.showAlert(null, gettextCatalog.getString('No wallet selected'), function() {
        $ionicHistory.goBack();
      });
      return;
    }
    $scope.wallet = profileService.getWallet(data.stateParams.walletId);
    $scope.credentialsEncrypted = $scope.wallet.isPrivKeyEncrypted();
    walletService.getKeys($scope.wallet, function(err, k) {
      if (err || !k) {
        $log.error('Could not get keys: ', err);
        $ionicHistory.goBack();
        return;
      }
      $timeout(function() {
        $scope.xPrivKey = k.xPrivKey;
        $scope.credentialsEncrypted = false;
      }, 100);
    });
  });
});

'use strict';

angular.module('copayApp.controllers').controller('proposalsController',
  function($timeout, $scope, profileService, $log, txpModalService, addressbookService, timeService) {

    $scope.fetchingProposals = true;

    $scope.$on("$ionicView.enter", function(event, data) {
      addressbookService.list(function(err, ab) {
        if (err) $log.error(err);
        $scope.addressbook = ab || {};

        profileService.getTxps(50, function(err, txps) {
          $scope.fetchingProposals = false;
          if (err) {
            $log.error(err);
            return;
          }
          $scope.txps = txps;
          $timeout(function() {
            $scope.$apply();
          });
        });
      });
    });

    $scope.openTxpModal = txpModalService.open;

    $scope.createdWithinPastDay = function(time) {
      return timeService.withinPastDay(time);
    };
  });

'use strict';

angular.module('copayApp.controllers').controller('sellCoinbaseController', function($scope, $log, $state, $timeout, $ionicHistory, $ionicScrollDelegate, $ionicConfig, lodash, coinbaseService, popupService, profileService, ongoingProcess, walletService, appConfigService, configService, txFormatService, externalLinkService) {

  var coin = 'btc';
  var amount;
  var currency;

  var showErrorAndBack = function(err) {
    $scope.sendStatus = '';
    $log.error(err);
    err = err.errors ? err.errors[0].message : err;
    popupService.showAlert('Error', err, function() {
      $ionicHistory.goBack();
    });
  };

  var showError = function(err) {
    $scope.sendStatus = '';
    $log.error(err);
    err = err.errors ? err.errors[0].message : err;
    popupService.showAlert('Error', err);
  };

  var publishAndSign = function (wallet, txp, onSendStatusChange, cb) {
    if (!wallet.canSign() && !wallet.isPrivKeyExternal()) {
      var err = 'No signing proposal: No private key';
      $log.info(err);
      return cb(err);
    }

    walletService.publishAndSign(wallet, txp, function(err, txp) {
      if (err) return cb(err);
      return cb(null, txp);
    }, onSendStatusChange);
  };

  var processPaymentInfo = function() {
    ongoingProcess.set('connectingCoinbase', true);
    coinbaseService.init(function(err, res) {
      if (err) {
        ongoingProcess.set('connectingCoinbase', false);
        showErrorAndBack(coinbaseService.getErrorsAsString(err.errors));
        return;
      }
      var accessToken = res.accessToken;

      coinbaseService.sellPrice(accessToken, coinbaseService.getAvailableCurrency(), function(err, s) {
        $scope.sellPrice = s.data || null;
      });

      $scope.paymentMethods = [];
      $scope.selectedPaymentMethodId = { value : null };
      coinbaseService.getPaymentMethods(accessToken, function(err, p) {
        if (err) {
          ongoingProcess.set('connectingCoinbase', false);
          showErrorAndBack(coinbaseService.getErrorsAsString(err.errors));
          return;
        }
        var hasPrimary;
        var pm;
        for(var i = 0; i < p.data.length; i++) {
          pm = p.data[i];
          if (pm.allow_sell) {
            $scope.paymentMethods.push(pm);
          }
          if (pm.allow_sell && pm.primary_sell) {
            hasPrimary = true;
            $scope.selectedPaymentMethodId.value = pm.id;
          }
        }
        if (lodash.isEmpty($scope.paymentMethods)) {
          ongoingProcess.set('connectingCoinbase', false);
          var url = 'https://support.coinbase.com/customer/portal/articles/1148716-payment-methods-for-us-customers';
          var msg = 'No payment method available to sell';
          var okText = 'More info';
          var cancelText = 'Go Back';
          externalLinkService.open(url, true, null, msg, okText, cancelText, function() {
            $ionicHistory.goBack(-2);
          });
          return;
        }
        if (!hasPrimary) $scope.selectedPaymentMethodId.value = $scope.paymentMethods[0].id;
        $scope.sellRequest();
      });
    });
  };

  var checkTransaction = lodash.throttle(function(count, txp) {
    $log.warn('Check if transaction has been received by Coinbase. Try ' + count + '/5');
    // TX amount in QYB
    var satToBtc = 1 / 100000000;
    var amountQYB = (txp.amount * satToBtc).toFixed(8);
    coinbaseService.init(function(err, res) {
      if (err) {
        $log.error(err);
        checkTransaction(count, txp);
        return;
      }
      var accessToken = res.accessToken;
      var accountId = res.accountId;
      var sellPrice = null;

      coinbaseService.sellPrice(accessToken, coinbaseService.getAvailableCurrency(), function(err, sell) {
        if (err) {
          $log.debug(coinbaseService.getErrorsAsString(err.errors));
          checkTransaction(count, txp);
          return;
        }
        sellPrice = sell.data;

        coinbaseService.getTransactions(accessToken, accountId, function(err, ctxs) {
          if (err) {
            $log.debug(coinbaseService.getErrorsAsString(err.errors));
            checkTransaction(count, txp);
            return;
          }

          var coinbaseTransactions = ctxs.data;
          var txFound = false;
          var ctx;
          for(var i = 0; i < coinbaseTransactions.length; i++) {
            ctx = coinbaseTransactions[i];
            if (ctx.type == 'send' && ctx.from && ctx.amount.amount == amountQYB ) {
              $log.warn('Transaction found!', ctx);
              txFound = true;
              $log.debug('Saving transaction to process later...');
              ctx['payment_method'] = $scope.selectedPaymentMethodId.value;
              ctx['status'] = 'pending'; // Forcing "pending" status to process later
              ctx['price_sensitivity'] = $scope.selectedPriceSensitivity.data;
              ctx['sell_price_amount'] = sellPrice ? sellPrice.amount : '';
              ctx['sell_price_currency'] = sellPrice ? sellPrice.currency : 'USD';
              ctx['description'] = appConfigService.nameCase + ' Wallet: ' + $scope.wallet.name;
              coinbaseService.savePendingTransaction(ctx, null, function(err) {
                ongoingProcess.set('sellingBitcoin', false, statusChangeHandler);
                if (err) $log.debug(coinbaseService.getErrorsAsString(err.errors));
              });
              return;
            }
          }
          if (!txFound) {
            // Transaction sent, but could not be verified by Coinbase.com
            $log.warn('Transaction not found in Coinbase. Will try 5 times...');
            if (count < 5) {
              checkTransaction(count + 1, txp);
            } else {
              ongoingProcess.set('sellingBitcoin', false, statusChangeHandler);
              showError('No transaction found');
              return;
            }
          }
        });
      });
    });
  }, 8000, {
    'leading': true
  });

  var statusChangeHandler = function (processName, showName, isOn) {
    $log.debug('statusChangeHandler: ', processName, showName, isOn);
    if ( processName == 'sellingBitcoin' && !isOn) {
      $scope.sendStatus = 'success';
      $timeout(function() {
        $scope.$digest();
      }, 100);
    } else if (showName) {
      $scope.sendStatus = showName;
    }
  };

  $scope.$on("$ionicView.beforeLeave", function(event, data) {
    $ionicConfig.views.swipeBackEnabled(true);
  });

  $scope.$on("$ionicView.enter", function(event, data) {
    $ionicConfig.views.swipeBackEnabled(false);
  });

  $scope.$on("$ionicView.beforeEnter", function(event, data) {
    $scope.isFiat = data.stateParams.currency != 'QYB' ? true : false;
    amount = data.stateParams.amount;
    currency = data.stateParams.currency;

    $scope.priceSensitivity = coinbaseService.priceSensitivity;
    $scope.selectedPriceSensitivity = { data: coinbaseService.selectedPriceSensitivity };

    $scope.network = coinbaseService.getNetwork();
    $scope.wallets = profileService.getWallets({
      m: 1, // Only 1-signature wallet
      onlyComplete: true,
      network: $scope.network,
      hasFunds: true,
      coin: coin
    });

    if (lodash.isEmpty($scope.wallets)) {
      showErrorAndBack('No wallet available to operate with Coinbase');
      return;
    }
    $scope.onWalletSelect($scope.wallets[0]); // Default first wallet
  });

  $scope.sellRequest = function() {
    ongoingProcess.set('connectingCoinbase', true);
    coinbaseService.init(function(err, res) {
      if (err) {
        ongoingProcess.set('connectingCoinbase', false);
        showErrorAndBack(coinbaseService.getErrorsAsString(err.errors));
        return;
      }
      var accessToken = res.accessToken;
      var accountId = res.accountId;
      var dataSrc = {
        amount: amount,
        currency: currency,
        payment_method: $scope.selectedPaymentMethodId.value,
        quote: true
      };
      coinbaseService.sellRequest(accessToken, accountId, dataSrc, function(err, data) {
        ongoingProcess.set('connectingCoinbase', false);
        if (err) {
          showErrorAndBack(coinbaseService.getErrorsAsString(err.errors));
          return;
        }
        $scope.sellRequestInfo = data.data;
        $timeout(function() {
          $scope.$apply();
        }, 100);
      });
    });
  };

  $scope.sellConfirm = function() {
    var config = configService.getSync();
    var configWallet = config.wallet;
    var walletSettings = configWallet.settings;

    var message = 'Selling bitcoin for ' + amount + ' ' + currency;
    var okText = 'Confirm';
    var cancelText = 'Cancel';
    popupService.showConfirm(null, message, okText, cancelText, function(ok) {
      if (!ok) return;

      ongoingProcess.set('sellingBitcoin', true, statusChangeHandler);
      coinbaseService.init(function(err, res) {
        if (err) {
          ongoingProcess.set('sellingBitcoin', false, statusChangeHandler);
          showError(coinbaseService.getErrorsAsString(err.errors));
          return;
        }
        var accessToken = res.accessToken;
        var accountId = res.accountId;

        var dataSrc = {
          name: 'Received from ' + appConfigService.nameCase
        };
        coinbaseService.createAddress(accessToken, accountId, dataSrc, function(err, data) {
          if (err) {
            ongoingProcess.set('sellingBitcoin', false, statusChangeHandler);
            showError(coinbaseService.getErrorsAsString(err.errors));
            return;
          }
          var outputs = [];
          var toAddress = data.data.address;
          var amountSat = parseInt(($scope.sellRequestInfo.amount.amount * 100000000).toFixed(0));
          var comment = 'Sell bitcoin (Coinbase)';

          outputs.push({
            'toAddress': toAddress,
            'amount': amountSat,
            'message': comment
          });

          var txp = {
            toAddress: toAddress,
            amount: amountSat,
            outputs: outputs,
            message: comment,
            payProUrl: null,
            excludeUnconfirmedUtxos: configWallet.spendUnconfirmed ? false : true,
            feeLevel: walletSettings.feeLevel || 'normal'
          };

          walletService.createTx($scope.wallet, txp, function(err, ctxp) {
            if (err) {
              ongoingProcess.set('sellingBitcoin', false, statusChangeHandler);
              showError(err);
              return;
            }
            $log.debug('Transaction created.');
            publishAndSign($scope.wallet, ctxp, function() {}, function(err, txSent) {
              if (err) {
                ongoingProcess.set('sellingBitcoin', false, statusChangeHandler);
                showError(err);
                return;
              }
              $log.debug('Transaction broadcasted. Wait for Coinbase confirmation...');
              checkTransaction(1, txSent);
            });
          });
        });
      });
    });
  };

  $scope.showWalletSelector = function() {
    $scope.walletSelectorTitle = 'Sell From';
    $scope.showWallets = true;
  };

  $scope.onWalletSelect = function(wallet) {
    $scope.wallet = wallet;
    var parsedAmount = txFormatService.parseAmount(
      coin,
      amount,
      currency);

    amount = parsedAmount.amount;
    currency = parsedAmount.currency;
    $scope.amountUnitStr = parsedAmount.amountUnitStr;
    processPaymentInfo();
  };

  $scope.goBackHome = function() {
    $scope.sendStatus = '';
    $ionicHistory.nextViewOptions({
      disableAnimate: true,
      historyRoot: true
    });
    $ionicHistory.clearHistory();
    $state.go('tabs.home').then(function() {
      $state.transitionTo('tabs.buyandsell.coinbase');
    });
  };

});

'use strict';

angular.module('copayApp.controllers').controller('sellGlideraController', function($scope, $log, $state, $timeout, $ionicHistory, $ionicConfig, lodash, glideraService, popupService, profileService, ongoingProcess, walletService, configService, platformInfo, txFormatService) {

  var coin = 'btc';
  var amount;
  var currency;

  $scope.isCordova = platformInfo.isCordova;

  var showErrorAndBack = function(err) {
    $scope.sendStatus = '';
    $log.error(err);
    err = err.errors ? err.errors[0].message : err;
    popupService.showAlert('Error', err, function() {
      $ionicHistory.goBack();
    });
  };

  var showError = function(err) {
    $scope.sendStatus = '';
    $log.error(err);
    err = err.errors ? err.errors[0].message : err;
    popupService.showAlert('Error', err);
  };

  var statusChangeHandler = function (processName, showName, isOn) {
    $log.debug('statusChangeHandler: ', processName, showName, isOn);
    if ( processName == 'sellingBitcoin' && !isOn) {
      $scope.sendStatus = 'success';
      $timeout(function() {
        $scope.$digest();
      }, 100);
    } else if (showName) {
      $scope.sendStatus = showName;
    }
  };

  var processPaymentInfo = function() {
    ongoingProcess.set('connectingGlidera', true);
    glideraService.init(function(err, data) {
      if (err) {
        ongoingProcess.set('connectingGlidera', false);
        showErrorAndBack(err);
        return;
      }
      $scope.token = data.token;
      var price = {};
      if ($scope.isFiat) {
        price['fiat'] = amount;
      } else {
        price['qty'] = amount;
      }
      glideraService.sellPrice($scope.token, price, function(err, sell) {
        ongoingProcess.set('connectingGlidera', false);
        if (err) {
          showErrorAndBack(err);
          return;
        }
        $scope.sellInfo = sell;
      });
    });
  };

  $scope.$on("$ionicView.beforeLeave", function(event, data) {
    $ionicConfig.views.swipeBackEnabled(true);
  });

  $scope.$on("$ionicView.enter", function(event, data) {
    $ionicConfig.views.swipeBackEnabled(false);
  });

  $scope.$on("$ionicView.beforeEnter", function(event, data) {
    // @empty changed
    // $scope.isFiat = data.stateParams.currency != 'BTC' ? true : false;
    $scope.isFiat = data.stateParams.currency != 'QYB' ? true : false;
    amount = data.stateParams.amount;
    currency = data.stateParams.currency;

    $scope.network = glideraService.getNetwork();
    $scope.wallets = profileService.getWallets({
      m: 1, // Only 1-signature wallet
      onlyComplete: true,
      network: $scope.network,
      hasFunds: true,
      coin: coin
    });

    if (lodash.isEmpty($scope.wallets)) {
      showErrorAndBack('Insufficient funds');
      return;
    }
    $scope.onWalletSelect($scope.wallets[0]); // Default first wallet
  });

  var ask2FaCode = function(mode, cb) {
    if (mode != 'NONE') {
      // SHOW PROMPT
      var title = 'Please, enter the code below';
      var message;
      if (mode == 'PIN') {
        message = 'You have enabled PIN based two-factor authentication.';
      } else if (mode == 'AUTHENTICATOR') {
        message = 'Use an authenticator app (Authy or Google Authenticator).';
      } else {
        message = 'A SMS containing a confirmation code was sent to your phone.';
      }
      popupService.showPrompt(title, message, null, function(twoFaCode) {
        if (typeof twoFaCode == 'undefined') return cb();
        return cb(twoFaCode);
      });
    } else {
      return cb();
    }
  };

  $scope.sellConfirm = function() {
    var message = 'Sell bitcoin for ' + amount + ' ' + currency;
    var okText = 'Confirm';
    var cancelText = 'Cancel';
    popupService.showConfirm(null, message, okText, cancelText, function(ok) {
      if (!ok) return;
      ongoingProcess.set('sellingBitcoin', true, statusChangeHandler);
      glideraService.get2faCode($scope.token, function(err, tfa) {
        if (err) {
          ongoingProcess.set('sellingBitcoin', false, statusChangeHandler);
          showError(err);
          return;
        }
        ask2FaCode(tfa.mode, function(twoFaCode) {
          if (tfa.mode != 'NONE' && lodash.isEmpty(twoFaCode)) {
            ongoingProcess.set('sellingBitcoin', false, statusChangeHandler);
            showError('No code entered');
            return;
          }

          var outputs = [];
          var config = configService.getSync();
          var configWallet = config.wallet;
          var walletSettings = configWallet.settings;

          walletService.getAddress($scope.wallet, null, function(err, refundAddress) {
            if (!refundAddress) {
              ongoingProcess.set('sellingBitcoin', false, statusChangeHandler);
              showError('Could not create address');
              return;
            }
            glideraService.getSellAddress($scope.token, function(err, sellAddress) {
              if (!sellAddress || err) {
                ongoingProcess.set('sellingBitcoin', false, statusChangeHandler);
                showError(err);
                return;
              }
              var amount = parseInt(($scope.sellInfo.qty * 100000000).toFixed(0));
              var comment = 'Glidera transaction';

              outputs.push({
                'toAddress': sellAddress,
                'amount': amount,
                'message': comment
              });

              var txp = {
                toAddress: sellAddress,
                amount: amount,
                outputs: outputs,
                message: comment,
                payProUrl: null,
                excludeUnconfirmedUtxos: configWallet.spendUnconfirmed ? false : true,
                feeLevel: walletSettings.feeLevel || 'normal',
                customData: {
                  'glideraToken': $scope.token
                }
              };

              walletService.createTx($scope.wallet, txp, function(err, createdTxp) {
                if (err) {
                  ongoingProcess.set('sellingBitcoin', false, statusChangeHandler);
                  showError(err);
                  return;
                }
                walletService.prepare($scope.wallet, function(err, password) {
                  if (err) {
                    ongoingProcess.set('sellingBitcoin', false, statusChangeHandler);
                    showError(err);
                    return;
                  }
                  walletService.publishTx($scope.wallet, createdTxp, function(err, publishedTxp) {
                    if (err) {
                      ongoingProcess.set('sellingBitcoin', false, statusChangeHandler);
                      showError(err);
                      return;
                    }
                    walletService.signTx($scope.wallet, publishedTxp, password, function(err, signedTxp) {
                      if (err) {
                        ongoingProcess.set('sellingBitcoin', false, statusChangeHandler);
                        showError(err);
                        walletService.removeTx($scope.wallet, signedTxp, function(err) {
                          if (err) $log.debug(err);
                        });
                        return;
                      }
                      var rawTx = signedTxp.raw;
                      var data = {
                        refundAddress: refundAddress,
                        signedTransaction: rawTx,
                        priceUuid: $scope.sellInfo.priceUuid,
                        useCurrentPrice: $scope.sellInfo.priceUuid ? false : true,
                        ip: null
                      };
                      glideraService.sell($scope.token, twoFaCode, data, function(err, data) {
                        ongoingProcess.set('sellingBitcoin', false, statusChangeHandler);
                        if (err) return showError(err);
                        $log.info(data);
                      });
                    });
                  });
                });
              });
            });
          });
        });
      });
    });
  };

  $scope.showWalletSelector = function() {
    $scope.walletSelectorTitle = 'Sell From';
    $scope.showWallets = true;
  };

  $scope.onWalletSelect = function(wallet) {
    $scope.wallet = wallet;
    var parsedAmount = txFormatService.parseAmount(
      coin,
      amount,
      currency);

    amount = parsedAmount.amount;
    currency = parsedAmount.currency;
    $scope.amountUnitStr = parsedAmount.amountUnitStr;
    processPaymentInfo();
  };

  $scope.goBackHome = function() {
    $scope.sendStatus = '';
    $ionicHistory.nextViewOptions({
      disableAnimate: true,
      historyRoot: true
    });
    $ionicHistory.clearHistory();
    $state.go('tabs.home').then(function() {
      $state.transitionTo('tabs.buyandsell.glidera');
    });
  };

});

'use strict';

angular.module('copayApp.controllers').controller('shapeshiftController',
  function($rootScope, $scope, $timeout, $log, $ionicScrollDelegate, lodash, shapeshiftService, externalLinkService) {

    var listeners = [];
    $scope.openExternalLink = function(url) {
      externalLinkService.open(url);
    };

    var updateShift = lodash.debounce(function(shifts) {
      if (lodash.isEmpty(shifts.data)) return;
      lodash.forEach(shifts.data, function(dataFromStorage) {
        if (dataFromStorage.status == 'complete') return;
        shapeshiftService.getStatus(dataFromStorage.address, function(err, st) {
          if (err) return;

          $scope.shifts.data[st.address]['status'] = st.status;
          shapeshiftService.saveShapeshift($scope.shifts.data[st.address], null, function(err) {
            $log.debug("Saved shift with status: " + st.status);
          });
          $timeout(function() {
            $scope.$digest();
          }, 100);
        });
      });
    }, 1000, {
      'leading': true
    });


    var init = function() {
      shapeshiftService.getShapeshift(function(err, ss) {
        if (err) $log.error(err);

        $scope.shifts = { data: ss };
        $timeout(function() {
          updateShift($scope.shifts);
          $scope.$digest();
          $ionicScrollDelegate.resize();
        }, 1000);
      });
    };

    $scope.update = function() {
      updateShift($scope.shifts);
    };

    $scope.$on("$ionicView.beforeEnter", function(event, data) {
      $scope.network = shapeshiftService.getNetwork();
      $scope.shifts = { data: {} };

      listeners = [
        $rootScope.$on('bwsEvent', function(e, walletId, type) {
          if (type == 'NewBlock') updateShift($scope.shifts);
        })
      ];

      init();
    });

    $scope.$on("$ionicView.leave", function(event, data) {
      lodash.each(listeners, function(x) {
        x();
      });
    });
  });

'use strict';

angular.module('copayApp.controllers').controller('shapeshiftConfirmController', function($scope, $log, $state, $timeout, $ionicHistory, $ionicConfig, lodash, popupService, profileService, ongoingProcess, configService, walletService, bwcError, externalLinkService, platformInfo, gettextCatalog, txFormatService, shapeshiftService, bitcore, bitcoreCash) {

  var amount;
  var currency;
  var fromWalletId;
  var toWalletId;
  var createdTx;
  var message;
  var configWallet = configService.getSync().wallet;
  $scope.currencyIsoCode = 'USD'; // Only USD
  $scope.isCordova = platformInfo.isCordova;

  $scope.openExternalLink = function(url) {
    externalLinkService.open(url);
  };

  var showErrorAndBack = function(title, msg) {
    title = title || gettextCatalog.getString('Error');
    $scope.sendStatus = '';
    $log.error(msg);
    msg = (msg && msg.errors) ? msg.errors[0].message : msg;
    popupService.showAlert(title, msg, function() {
      $ionicHistory.goBack();
    });
  };

  var publishAndSign = function(wallet, txp, onSendStatusChange, cb) {
    if (!wallet.canSign() && !wallet.isPrivKeyExternal()) {
      var err = gettextCatalog.getString('No signing proposal: No private key');
      $log.info(err);
      return cb(err);
    }

    walletService.publishAndSign(wallet, txp, function(err, txp) {
      if (err) return cb(err);
      return cb(null, txp);
    }, onSendStatusChange);
  };

  var statusChangeHandler = function(processName, showName, isOn) {
    $log.debug('statusChangeHandler: ', processName, showName, isOn);
    if (processName == 'sendingTx' && !isOn) {
      $scope.sendStatus = 'success';
      $timeout(function() {
        $scope.$digest();
      }, 100);
    } else if (showName) {
      $scope.sendStatus = showName;
    }
  };

  var satToFiat = function(coin, sat, isoCode, cb) {
    txFormatService.toFiat(coin, sat, isoCode, function(value) {
      return cb(value);
    });
  };

  var setFiatTotalAmount = function(amountSat, feeSat, withdrawalSat) {
    satToFiat($scope.toWallet.coin, withdrawalSat, $scope.currencyIsoCode, function(w) {
      $scope.fiatWithdrawal = Number(w);

      satToFiat($scope.fromWallet.coin, amountSat, $scope.currencyIsoCode, function(a) {
        $scope.fiatAmount = Number(a);

        satToFiat($scope.fromWallet.coin, feeSat, $scope.currencyIsoCode, function(i) {
          $scope.fiatFee = Number(i);

          $scope.fiatTotalAmount = $scope.fiatAmount + $scope.fiatFee;
          $timeout(function() { $scope.$digest(); }, 100);
        });
      });
    });
  };

  var saveShapeshiftData = function() {
    var address = $scope.shapeInfo.deposit;
    var status;
    var now = moment().unix() * 1000;

    shapeshiftService.getStatus(address, function(err, st) {
      var newData = {
        address: address,
        status: st.status,
        date: now,
        amount: $scope.amountStr,
        title: $scope.fromWallet.coin.toUpperCase() + ' to ' + $scope.toWallet.coin.toUpperCase()
      };

      shapeshiftService.saveShapeshift(newData, null, function(err) {
        $log.debug("Saved shift with status: " + newData.status);
      });
    });
  };

  var createTx = function(wallet, toAddress, cb) {
    var parsedAmount = txFormatService.parseAmount(wallet.coin, amount, currency);
    $scope.amountUnitStr = parsedAmount.amountUnitStr;

    message = 'ShapeShift: ' + $scope.fromWallet.coin.toUpperCase() + ' to ' + $scope.toWallet.coin.toUpperCase();
    var outputs = [];

    outputs.push({
      'toAddress': toAddress,
      'amount': parsedAmount.amountSat,
      'message': message
    });

    var txp = {
      toAddress: toAddress,
      amount: parsedAmount.amountSat,
      outputs: outputs,
      message: message,
      excludeUnconfirmedUtxos: configWallet.spendUnconfirmed ? false : true,
      feeLevel: configWallet.settings.feeLevel || 'normal',
      customData: {
        'shapeShift': toAddress
      }
    };

    walletService.createTx(wallet, txp, function(err, ctxp) {
      if (err) {
        return cb({
          title: gettextCatalog.getString('Could not create transaction'),
          message: bwcError.msg(err)
        });
      }
      return cb(null, ctxp);
    });
  };

  var getLegacyAddressFormat = function(addr, coin) {
    if (coin == 'btc') return addr;
    var a = bitcoreCash.Address(addr).toObject();
    return bitcore.Address.fromObject(a).toString();
  };

  var getNewAddressFormat = function(addr, coin) {
    if (coin == 'btc') return addr;
    var a = bitcore.Address(addr).toObject();
    return bitcoreCash.Address.fromObject(a).toString();
  };

  var getCoinPair = function() {
    return $scope.fromWallet.coin + '_' + $scope.toWallet.coin;
  };

  var createShift = function() {
    ongoingProcess.set('connectingShapeshift', true);

    walletService.getAddress($scope.toWallet, false, function(err, withdrawalAddress) {
      if (err) {
        ongoingProcess.set('connectingShapeshift', false);
        showErrorAndBack('Could not get address');
        return;
      }
      withdrawalAddress = getLegacyAddressFormat(withdrawalAddress, $scope.toWallet.coin);

      walletService.getAddress($scope.fromWallet, false, function(err, returnAddress) {
        if (err) {
          ongoingProcess.set('connectingShapeshift', false);
          showErrorAndBack('Could not get address');
          return;
        }
        returnAddress = getLegacyAddressFormat(returnAddress, $scope.fromWallet.coin);

        var data = {
          withdrawal: withdrawalAddress,
          pair: getCoinPair(),
          returnAddress: returnAddress
        }
        shapeshiftService.shift(data, function(err, shapeData) {
          if (err || shapeData.error) {
            ongoingProcess.set('connectingShapeshift', false);
            showErrorAndBack(err || shapeData.error);
            return;
          }

          var toAddress = getNewAddressFormat(shapeData.deposit, $scope.fromWallet.coin);

          createTx($scope.fromWallet, toAddress, function(err, ctxp) {
            if (err) {
              ongoingProcess.set('connectingShapeshift', false);
              showErrorAndBack(err.title, err.message);
              return;
            }

            // Save in memory
            createdTx = ctxp;
            $scope.shapeInfo = shapeData;

            shapeshiftService.getRate(getCoinPair(), function(err, r) {
              ongoingProcess.set('connectingShapeshift', false);
              var rateUnit = r.rate;
              var amountUnit = txFormatService.satToUnit(ctxp.amount);
              var withdrawalSat = Number((rateUnit * amountUnit * 100000000).toFixed());

              // Fee rate
              var per = (ctxp.fee / (ctxp.amount + ctxp.fee) * 100);
              $scope.feeRatePerStr = per.toFixed(2) + '%';

              // Amount + Unit
              $scope.amountStr = txFormatService.formatAmountStr($scope.fromWallet.coin, ctxp.amount);
              $scope.withdrawalStr = txFormatService.formatAmountStr($scope.toWallet.coin, withdrawalSat);
              $scope.feeStr = txFormatService.formatAmountStr($scope.fromWallet.coin, ctxp.fee);
              $scope.totalAmountStr = txFormatService.formatAmountStr($scope.fromWallet.coin, ctxp.amount + ctxp.fee);

              // Convert to fiat
              setFiatTotalAmount(ctxp.amount, ctxp.fee, withdrawalSat);
            });
          });
        });
      });
    });
  };

  $scope.$on("$ionicView.beforeLeave", function(event, data) {
    $ionicConfig.views.swipeBackEnabled(true);
  });

  $scope.$on("$ionicView.enter", function(event, data) {
    $ionicConfig.views.swipeBackEnabled(false);
  });

  $scope.$on("$ionicView.beforeEnter", function(event, data) {
    var useSendMax = data.stateParams.useSendMax == 'true' ? true : false;
    amount = data.stateParams.amount;
    currency = data.stateParams.currency;
    fromWalletId = data.stateParams.id;
    toWalletId = data.stateParams.toWalletId;

    $scope.network = shapeshiftService.getNetwork();
    $scope.fromWallet = profileService.getWallet(fromWalletId);
    $scope.toWallet = profileService.getWallet(toWalletId);

    if (lodash.isEmpty($scope.fromWallet) || lodash.isEmpty($scope.toWallet)) {
      showErrorAndBack(null, gettextCatalog.getString('No wallet found'));
      return;
    }

    shapeshiftService.getLimit(getCoinPair(), function(err, lim) {
      var min = Number(lim.min);
      var max = Number(lim.limit);

      if (useSendMax) amount = max;

      var amountNumber = Number(amount);
      if (amountNumber < min) {
        showErrorAndBack(null, gettextCatalog.getString('Minimum amount required is {{minAmount}}', {
          minAmount: min
        }));
        return;
      }
      if (amountNumber > max) {
        showErrorAndBack(null, gettextCatalog.getString('Maximum amount allowed is {{maxAmount}}', {
          maxAmount: max
        }));
        return;
      }
      createShift();
    });


  });

  $scope.confirmTx = function() {
    if (!createdTx) {
      showErrorAndBack(null, gettextCatalog.getString('Transaction has not been created'));
      return;
    }
    var title = gettextCatalog.getString('Confirm to shift {{fromCoin}} to {{toCoin}}', {
      fromCoin: $scope.fromWallet.coin.toUpperCase(),
      toCoin: $scope.toWallet.coin.toUpperCase()
    });
    var okText = gettextCatalog.getString('OK');
    var cancelText = gettextCatalog.getString('Cancel');
    popupService.showConfirm(title, '', okText, cancelText, function(ok) {
      if (!ok) {
        $scope.sendStatus = '';
        $timeout(function() {
          $scope.$apply();
        });
        return;
      }

      ongoingProcess.set('sendingTx', true, statusChangeHandler);
      publishAndSign($scope.fromWallet, createdTx, function() {}, function(err, txSent) {
        ongoingProcess.set('sendingTx', false, statusChangeHandler);
        if (err) {
          showErrorAndBack(gettextCatalog.getString('Could not send transaction'), err);
          return;
        }
        $scope.txSent = txSent;
        $timeout(function() { saveShapeshiftData(); }, 2000);
        $timeout(function() { $scope.$digest(); }, 100);
      });
    });
  };

  $scope.goBackHome = function() {
    $scope.sendStatus = '';
    $ionicHistory.nextViewOptions({
      disableAnimate: true,
      historyRoot: true
    });
    $ionicHistory.clearHistory();
    $state.go('tabs.home').then(function() {
      $ionicHistory.nextViewOptions({
        disableAnimate: true
      });
      $state.transitionTo('tabs.shapeshift');
    });
  };
});

'use strict';

angular.module('copayApp.controllers').controller('shapeshiftShiftController',
  function($scope, $ionicHistory, $timeout, $log, $state, profileService, popupService, lodash, shapeshiftService, gettextCatalog) {

    var defaultCoin = 'btc';
    var walletsBtc = [];
    var walletsBch = [];

    var showErrorAndBack = function(title, msg) {
      title = title || gettextCatalog.getString('Error');
      $scope.sendStatus = '';
      $log.error(msg);
      msg = (msg && msg.errors) ? msg.errors[0].message : msg;
      popupService.showAlert(title, msg, function() {
        $ionicHistory.goBack();
      });
    };

    var showToWallets = function() {
      $scope.toWallets = $scope.fromWallet.coin == 'btc' ? walletsBch : walletsBtc;
      $scope.onToWalletSelect($scope.toWallets[0]);

      var pair = $scope.fromWallet.coin + '_' + $scope.toWallet.coin;
      shapeshiftService.getRate(pair, function(err, rate) {
        $scope.rate = rate;
      });
      shapeshiftService.getLimit(pair, function(err, limit) {
        $scope.limit = limit;
      });

      $timeout(function() { $scope.$digest(); }, 100);
    }

    $scope.onFromWalletSelect = function(wallet) {
      $scope.fromWallet = wallet;
      showToWallets();
    };

    $scope.onToWalletSelect = function(wallet) {
      $scope.toWallet = wallet;
    }

    $scope.$on("$ionicView.beforeEnter", function(event, data) {

      $scope.network = shapeshiftService.getNetwork();
      walletsBtc = profileService.getWallets({
        onlyComplete: true,
        network: $scope.network,
        coin: 'btc'
      });

      walletsBch = profileService.getWallets({
        onlyComplete: true,
        network: $scope.network,
        coin: 'bch'
      });

      if (lodash.isEmpty(walletsBtc) || lodash.isEmpty(walletsBch)) {
        showErrorAndBack(null, gettextCatalog.getString('No wallets available to use ShapeShift'));
        return;
      }

      $scope.fromWallets = lodash.filter(walletsBtc.concat(walletsBch), function(w) {
        // Available balance and 1-signature wallet
        return w.status.balance.availableAmount > 0 && w.credentials.m == 1;
      });

      $scope.onFromWalletSelect($scope.fromWallets[0]);

      $scope.fromWalletSelectorTitle = 'From';
      $scope.toWalletSelectorTitle = 'To';

      $scope.showFromWallets = false;
      $scope.showToWallets = false;
    });

    $scope.showFromWalletSelector = function() {
      $scope.showFromWallets = true;
    }

    $scope.showToWalletSelector = function() {
      $scope.showToWallets = true;
    }

    $scope.setAmount = function() {
      $state.go('tabs.shapeshift.amount', {
        coin: $scope.fromWallet.coin,
        id: $scope.fromWallet.id,
        toWalletId: $scope.toWallet.id,
        shiftMax: $scope.limit.limit + ' ' + $scope.fromWallet.coin.toUpperCase(),
        shiftMin: $scope.limit.min + ' ' + $scope.fromWallet.coin.toUpperCase()
      });
    };
  });

'use strict';

angular.module('copayApp.controllers').controller('tabHomeController',
  function ($rootScope, $timeout, $scope, $state, $stateParams, $ionicModal, $ionicScrollDelegate, $window, gettextCatalog, lodash, popupService, ongoingProcess, externalLinkService, latestReleaseService, profileService, walletService, configService, $log, platformInfo, storageService, txpModalService, appConfigService, startupService, addressbookService, feedbackService, bwcError, nextStepsService, buyAndSellService, homeIntegrationsService, bitpayCardService, pushNotificationsService, timeService) {
    var wallet;
    var listeners = [];
    var notifications = [];
    $scope.externalServices = {};
    $scope.openTxpModal = txpModalService.open;
    $scope.version = $window.version;
    $scope.name = appConfigService.nameCase;
    $scope.homeTip = $stateParams.fromOnboarding;
    $scope.isCordova = platformInfo.isCordova;
    $scope.isAndroid = platformInfo.isAndroid;
    $scope.isWindowsPhoneApp = platformInfo.isCordova && platformInfo.isWP;
    $scope.isNW = platformInfo.isNW;
    $scope.showRateCard = {};
    $scope.serverMessage = null;

    $scope.$on("$ionicView.afterEnter", function () {
      startupService.ready();
    });

    $scope.$on("$ionicView.beforeEnter", function (event, data) {
      if (!$scope.homeTip) {
        storageService.getHomeTipAccepted(function (error, value) {
          $scope.homeTip = (value == 'accepted') ? false : true;
        });
      }

      if ($scope.isNW) {
        latestReleaseService.checkLatestRelease(function (err, newRelease) {
          if (err) {
            $log.warn(err);
            return;
          }
          if (newRelease) {
            $scope.newRelease = true;
            $scope.updateText = gettextCatalog.getString('There is a new version of {{appName}} available', {
              appName: $scope.name
            });
          }
        });
      }

      storageService.getFeedbackInfo(function (error, info) {

        if ($scope.isWindowsPhoneApp) {
          $scope.showRateCard.value = false;
          return;
        }
        if (!info) {
          initFeedBackInfo();
        } else {
          var feedbackInfo = JSON.parse(info);
          //Check if current version is greater than saved version
          var currentVersion = $scope.version;
          var savedVersion = feedbackInfo.version;
          var isVersionUpdated = feedbackService.isVersionUpdated(currentVersion, savedVersion);
          if (!isVersionUpdated) {
            initFeedBackInfo();
            return;
          }
          var now = moment().unix();
          var timeExceeded = (now - feedbackInfo.time) >= 24 * 7 * 60 * 60;
          $scope.showRateCard.value = timeExceeded && !feedbackInfo.sent;
          $timeout(function () {
            $scope.$apply();
          });
        }
      });

      function initFeedBackInfo() {
        var feedbackInfo = {};
        feedbackInfo.time = moment().unix();
        feedbackInfo.version = $scope.version;
        feedbackInfo.sent = false;
        storageService.setFeedbackInfo(JSON.stringify(feedbackInfo), function () {
          $scope.showRateCard.value = false;
        });
      };
    });

    $scope.$on("$ionicView.enter", function (event, data) {
      updateAllWallets();

      addressbookService.list(function (err, ab) {
        if (err) $log.error(err);
        $scope.addressbook = ab || {};
      });

      listeners = [
        $rootScope.$on('bwsEvent', function (e, walletId, type, n) {
          var wallet = profileService.getWallet(walletId);
          updateWallet(wallet);
          if ($scope.recentTransactionsEnabled) getNotifications();

        }),
        $rootScope.$on('Local/TxAction', function (e, walletId) {
          $log.debug('Got action for wallet ' + walletId);
          var wallet = profileService.getWallet(walletId);
          updateWallet(wallet);
          if ($scope.recentTransactionsEnabled) getNotifications();
        })
      ];


      $scope.buyAndSellItems = buyAndSellService.getLinked();
      $scope.homeIntegrations = homeIntegrationsService.get();

      bitpayCardService.get({}, function (err, cards) {
        $scope.bitpayCardItems = cards;
      });

      configService.whenAvailable(function (config) {
        $scope.recentTransactionsEnabled = config.recentTransactions.enabled;
        if ($scope.recentTransactionsEnabled) getNotifications();

        if (config.hideNextSteps.enabled) {
          $scope.nextStepsItems = null;
        } else {
          $scope.nextStepsItems = nextStepsService.get();
        }

        pushNotificationsService.init();

        $timeout(function () {
          $ionicScrollDelegate.resize();
          $scope.$apply();
        }, 10);
      });
    });

    $scope.$on("$ionicView.leave", function (event, data) {
      lodash.each(listeners, function (x) {
        x();
      });
    });

    $scope.createdWithinPastDay = function (time) {
      return timeService.withinPastDay(time);
    };

    $scope.goToDownload = function () {
      var url = 'https://github.com/bitpay/qyb/releases/latest';
      var optIn = true;
      var title = gettextCatalog.getString('Update Available');
      var message = gettextCatalog.getString('An update to this app is available. For your security, please update to the latest version.');
      var okText = gettextCatalog.getString('View Update');
      var cancelText = gettextCatalog.getString('Go Back');
      externalLinkService.open(url, optIn, title, message, okText, cancelText);
    };

    $scope.openServerMessageLink = function () {
      var url = $scope.serverMessage.link;
      externalLinkService.open(url);
    };

    $scope.openNotificationModal = function (n) {
      wallet = profileService.getWallet(n.walletId);

      if (n.txid) {
        $state.transitionTo('tabs.wallet.tx-details', {
          txid: n.txid,
          walletId: n.walletId
        });
      } else {
        var txp = lodash.find($scope.txps, {
          id: n.txpId
        });
        if (txp) {
          txpModalService.open(txp);
        } else {
          ongoingProcess.set('loadingTxInfo', true);
          walletService.getTxp(wallet, n.txpId, function (err, txp) {
            var _txp = txp;
            ongoingProcess.set('loadingTxInfo', false);
            if (err) {
              $log.warn('No txp found');
              return popupService.showAlert(gettextCatalog.getString('Error'), gettextCatalog.getString('Transaction not found'));
            }
            txpModalService.open(_txp);
          });
        }
      }
    };

    $scope.openWallet = function (wallet) {
      if (!wallet.isComplete()) {
        return $state.go('tabs.copayers', {
          walletId: wallet.credentials.walletId
        });
      }

      $state.go('tabs.wallet', {
        walletId: wallet.credentials.walletId
      });
    };

    var updateTxps = function () {
      profileService.getTxps({
        limit: 3
      }, function (err, txps, n) {
        if (err) $log.error(err);
        $scope.txps = txps;
        $scope.txpsN = n;
        $timeout(function () {
          $ionicScrollDelegate.resize();
          $scope.$apply();
        }, 10);
      })
    };

    var updateAllWallets = function () {
      var wallets = [];
      $scope.walletsBtc = profileService.getWallets({ coin: 'btc' });
      $scope.walletsBch = profileService.getWallets({ coin: 'bch' });

      lodash.each($scope.walletsBtc, function (wBtc) {
        wallets.push(wBtc);
      });

      lodash.each($scope.walletsBch, function (wBch) {
        wallets.push(wBch);
      });

      if (lodash.isEmpty(wallets)) return;

      var i = wallets.length;
      var j = 0;

      var foundMessage = false;

      lodash.each(wallets, function (wallet) {
        walletService.getStatus(wallet, {}, function (err, status) {
          if (err) {

            wallet.error = (err === 'WALLET_NOT_REGISTERED') ? gettextCatalog.getString('Wallet not registered') : bwcError.msg(err);

            $log.error(err);
          } else {
            wallet.error = null;
            wallet.status = status;

            if (!foundMessage && !lodash.isEmpty(status.serverMessage)) {
              $scope.serverMessage = status.serverMessage;
              foundMessage = true;
            }

            // TODO service refactor? not in profile service
            profileService.setLastKnownBalance(wallet.id, wallet.status.totalBalanceStr, function () { });
          }
          if (++j == i) {
            updateTxps();
          }
        });
      });
    };

    var updateWallet = function (wallet) {
      $log.debug('Updating wallet:' + wallet.name)
      walletService.getStatus(wallet, {}, function (err, status) {
        if (err) {
          $log.error(err);
          return;
        }
        wallet.status = status;
        updateTxps();
      });
    };

    var getNotifications = function () {
      profileService.getNotifications({
        limit: 3
      }, function (err, notifications, total) {
        if (err) {
          $log.error(err);
          return;
        }
        $scope.notifications = notifications;
        $scope.uniqNotifications = lodash.uniq(notifications, 'txid');//uniqBy is the new metod.;
        //$scope.notificationsN = total;
        $scope.notificationsN = $scope.notifications.length;
        $timeout(function () {
          $ionicScrollDelegate.resize();
          $scope.$apply();
        }, 10);
      });
    };

    $scope.hideHomeTip = function () {
      storageService.setHomeTipAccepted('accepted', function () {
        $scope.homeTip = false;
        $timeout(function () {
          $scope.$apply();
        })
      });
    };


    $scope.onRefresh = function () {
      $timeout(function () {
        $scope.$broadcast('scroll.refreshComplete');
      }, 300);
      updateAllWallets();
    };


  });

'use strict';

angular.module('copayApp.controllers').controller('tabReceiveController', function($rootScope, $scope, $timeout, $log, $ionicModal, $state, $ionicHistory, $ionicPopover, storageService, platformInfo, walletService, profileService, configService, lodash, gettextCatalog, popupService, bwcError) {

  var listeners = [];
  $scope.isCordova = platformInfo.isCordova;
  $scope.isNW = platformInfo.isNW;

  $scope.requestSpecificAmount = function() {
    $state.go('tabs.paymentRequest.amount', {
      id: $scope.wallet.credentials.walletId,
      coin: $scope.wallet.coin
    });
  };

  $scope.setAddress = function(newAddr) {
    $scope.addr = null;
    if (!$scope.wallet || $scope.generatingAddress || !$scope.wallet.isComplete()) return;
    $scope.generatingAddress = true;
    walletService.getAddress($scope.wallet, newAddr, function(err, addr) {
      $scope.generatingAddress = false;

      if (err) {
        //Error is already formated
        popupService.showAlert(err);
      }

      $scope.addr = addr;
      $timeout(function() {
        $scope.$apply();
      }, 10);
    });
  };

  $scope.goCopayers = function() {
    $ionicHistory.removeBackView();
    $ionicHistory.nextViewOptions({
      disableAnimate: true
    });
    $state.go('tabs.home');
    $timeout(function() {
      $state.transitionTo('tabs.copayers', {
        walletId: $scope.wallet.credentials.walletId
      });
    }, 100);
  };

  $scope.openBackupNeededModal = function() {
    $ionicModal.fromTemplateUrl('views/includes/backupNeededPopup.html', {
      scope: $scope,
      backdropClickToClose: false,
      hardwareBackButtonClose: false
    }).then(function(modal) {
      $scope.BackupNeededModal = modal;
      $scope.BackupNeededModal.show();
    });
  };

  $scope.close = function() {
    $scope.BackupNeededModal.hide();
    $scope.BackupNeededModal.remove();
  };

  $scope.doBackup = function() {
    $scope.close();
    $scope.goToBackupFlow();
  };

  $scope.goToBackupFlow = function() {
    $state.go('tabs.receive.backupWarning', {
      from: 'tabs.receive',
      walletId: $scope.wallet.credentials.walletId
    });
  };

  $scope.shouldShowReceiveAddressFromHardware = function() {
    var wallet = $scope.wallet;
    if (wallet.isPrivKeyExternal() && wallet.credentials.hwInfo) {
      return (wallet.credentials.hwInfo.name == walletService.externalSource.intelTEE.id);
    } else {
      return false;
    }
  };

  $scope.showReceiveAddressFromHardware = function() {
    var wallet = $scope.wallet;
    if (wallet.isPrivKeyExternal() && wallet.credentials.hwInfo) {
      walletService.showReceiveAddressFromHardware(wallet, $scope.addr, function() {});
    }
  };

  $scope.$on("$ionicView.beforeEnter", function(event, data) {
    $scope.wallets = profileService.getWallets();
    $scope.singleWallet = $scope.wallets.length == 1;

    if (!$scope.wallets[0]) return;

    // select first wallet if no wallet selected previously
    var selectedWallet = checkSelectedWallet($scope.wallet, $scope.wallets);
    $scope.onWalletSelect(selectedWallet);

    $scope.showShareButton = platformInfo.isCordova ? (platformInfo.isIOS ? 'iOS' : 'Android') : null;

    listeners = [
      $rootScope.$on('bwsEvent', function(e, walletId, type, n) {
        // Update current address
        if ($scope.wallet && walletId == $scope.wallet.id && type == 'NewIncomingTx') $scope.setAddress(true);
      })
    ];
  });

  $scope.$on("$ionicView.leave", function(event, data) {
    lodash.each(listeners, function(x) {
      x();
    });
  });

  var checkSelectedWallet = function(wallet, wallets) {
    if (!wallet) return wallets[0];
    var w = lodash.find(wallets, function(w) {
      return w.id == wallet.id;
    });
    if (!w) return wallets[0];
    return wallet;
  }

  var setProtocolHandler = function() {
    $scope.protocolHandler = walletService.getProtocolHandler($scope.wallet);
  }

  $scope.onWalletSelect = function(wallet) {
    $scope.wallet = wallet;
    setProtocolHandler();
    $scope.setAddress();
  };

  $scope.showWalletSelector = function() {
    if ($scope.singleWallet) return;
    $scope.walletSelectorTitle = gettextCatalog.getString('Select a wallet');
    $scope.showWallets = true;
  };

  $scope.shareAddress = function() {
    if (!$scope.isCordova) return;
    // @empty modify to qybcoin
    var protocol = 'qybcoin';
    if ($scope.wallet.coin == 'bch') protocol += 'cash';
    window.plugins.socialsharing.share(protocol + ':' + $scope.addr, null, null, null);
  }
});
'use strict';

angular.module('copayApp.controllers').controller('tabScanController', function($scope, $log, $timeout, scannerService, incomingData, $state, $ionicHistory, $rootScope) {

  var scannerStates = {
    unauthorized: 'unauthorized',
    denied: 'denied',
    unavailable: 'unavailable',
    loading: 'loading',
    visible: 'visible'
  };
  $scope.scannerStates = scannerStates;

  function _updateCapabilities(){
    var capabilities = scannerService.getCapabilities();
    $scope.scannerIsAvailable = capabilities.isAvailable;
    $scope.scannerHasPermission = capabilities.hasPermission;
    $scope.scannerIsDenied = capabilities.isDenied;
    $scope.scannerIsRestricted = capabilities.isRestricted;
    $scope.canEnableLight = capabilities.canEnableLight;
    $scope.canChangeCamera = capabilities.canChangeCamera;
    $scope.canOpenSettings = capabilities.canOpenSettings;
  }

  function _handleCapabilities(){
    // always update the view
    $timeout(function(){
      if(!scannerService.isInitialized()){
        $scope.currentState = scannerStates.loading;
      } else if(!$scope.scannerIsAvailable){
        $scope.currentState = scannerStates.unavailable;
      } else if($scope.scannerIsDenied){
        $scope.currentState = scannerStates.denied;
      } else if($scope.scannerIsRestricted){
        $scope.currentState = scannerStates.denied;
      } else if(!$scope.scannerHasPermission){
        $scope.currentState = scannerStates.unauthorized;
      }
      $log.debug('Scan view state set to: ' + $scope.currentState);
    });
  }

  function _refreshScanView(){
    _updateCapabilities();
    _handleCapabilities();
    if($scope.scannerHasPermission){
      activate();
    }
  }

  // This could be much cleaner with a Promise API
  // (needs a polyfill for some platforms)
  $rootScope.$on('scannerServiceInitialized', function(){
    $log.debug('Scanner initialization finished, reinitializing scan view...');
    _refreshScanView();
  });

  $scope.$on("$ionicView.afterEnter", function() {
    // try initializing and refreshing status any time the view is entered
    if(!scannerService.isInitialized()){
      scannerService.gentleInitialize();
    }
    activate();
  });

  function activate(){
    scannerService.activate(function(){
      _updateCapabilities();
      _handleCapabilities();
      $log.debug('Scanner activated, setting to visible...');
      $scope.currentState = scannerStates.visible;
        // pause to update the view
        $timeout(function(){
          scannerService.scan(function(err, contents){
          if(err){
            $log.debug('Scan canceled.');
          } else if ($state.params.passthroughMode) {
            $rootScope.scanResult = contents;
            goBack();
          } else {
            handleSuccessfulScan(contents);
          }
          });
          // resume preview if paused
          scannerService.resumePreview();
        });
    });
  }
  $scope.activate = activate;

  $scope.authorize = function(){
    scannerService.initialize(function(){
      _refreshScanView();
    });
  };

  $scope.$on("$ionicView.afterLeave", function() {
    scannerService.deactivate();
  });

  function handleSuccessfulScan(contents){
    $log.debug('Scan returned: "' + contents + '"');
    scannerService.pausePreview();
    incomingData.redir(contents);
  }

  $rootScope.$on('incomingDataMenu.menuHidden', function() {
    activate();
  });

  $scope.openSettings = function(){
    scannerService.openSettings();
  };

  $scope.attemptToReactivate = function(){
    scannerService.reinitialize();
  };

  $scope.toggleLight = function(){
    scannerService.toggleLight(function(lightEnabled){
      $scope.lightActive = lightEnabled;
      $scope.$apply();
    });
  };

  $scope.toggleCamera = function(){
    $scope.cameraToggleActive = true;
    scannerService.toggleCamera(function(status){
    // (a short delay for the user to see the visual feedback)
      $timeout(function(){
        $scope.cameraToggleActive = false;
        $log.debug('Camera toggle control deactivated.');
      }, 200);
    });
  };

  $scope.canGoBack = function(){
    return $state.params.passthroughMode;
  };
  function goBack(){
    $ionicHistory.nextViewOptions({
      disableAnimate: true
    });
    $ionicHistory.backView().go();
  }
  $scope.goBack = goBack;
});

'use strict';

angular.module('copayApp.controllers').controller('tabSendController', function($scope, $rootScope, $log, $timeout, $ionicScrollDelegate, addressbookService, profileService, lodash, $state, walletService, incomingData, popupService, platformInfo, bwcError, gettextCatalog, scannerService, bitcoreCash, externalLinkService) {

  var originalList;
  var CONTACTS_SHOW_LIMIT;
  var currentContactsPage;
  $scope.isChromeApp = platformInfo.isChromeApp;
  $scope.serverMessage = null;

  var hasWallets = function() {
    $scope.wallets = profileService.getWallets({
      onlyComplete: true
    });
    $scope.hasWallets = lodash.isEmpty($scope.wallets) ? false : true;
  };

  // THIS is ONLY to show the 'buy bitcoins' message
  // does not has any other function.

  var updateHasFunds = function() {

    if ($rootScope.everHasFunds) {
      $scope.hasFunds = true;
      return;
    }

    $scope.hasFunds = false;
    var foundMessage = false;
    var index = 0;
    lodash.each($scope.wallets, function(w) {
      walletService.getStatus(w, {}, function(err, status) {

        ++index;
        if (err && !status) {
          $log.error(err);
          // error updating the wallet. Probably a network error, do not show
          // the 'buy bitcoins' message.

          $scope.hasFunds = true;
        } else if (status.availableBalanceSat > 0) {
          $scope.hasFunds = true;
          $rootScope.everHasFunds = true;

          if (!foundMessage && !lodash.isEmpty(status.serverMessage)) {
            $scope.serverMessage = status.serverMessage;
            foundMessage = true;
          }
        }

        if (index == $scope.wallets.length) {
          $scope.checkingBalance = false;
          $timeout(function() {
            $scope.$apply();
          });
        }
      });
    });
  };

  var updateWalletsList = function() {

    var networkResult = lodash.countBy($scope.wallets, 'network');

    $scope.showTransferCard = $scope.hasWallets && (networkResult.livenet > 1 || networkResult.testnet > 1);

    if ($scope.showTransferCard) {
      var walletsToTransfer = $scope.wallets;
      if (!(networkResult.livenet > 1)) {
        walletsToTransfer = lodash.filter(walletsToTransfer, function(item) {
          return item.network == 'testnet';
        });
      }
      if (!(networkResult.testnet > 1)) {
        walletsToTransfer = lodash.filter(walletsToTransfer, function(item) {
          return item.network == 'livenet';
        });
      }
      var walletList = [];
      lodash.each(walletsToTransfer, function(v) {
        walletList.push({
          color: v.color,
          name: v.name,
          recipientType: 'wallet',
          coin: v.coin,
          network: v.network,
          getAddress: function(cb) {
            walletService.getAddress(v, false, cb);
          },
        });
      });
      originalList = originalList.concat(walletList);
    }
  }

  var getCoin = function(address) {
    var cashAddress = bitcoreCash.Address.isValid(address, 'livenet');
    if (cashAddress) {
      return 'bch';
    }
    return 'btc';
  };

  var updateContactsList = function(cb) {
    addressbookService.list(function(err, ab) {
      if (err) $log.error(err);

      $scope.hasContacts = lodash.isEmpty(ab) ? false : true;
      if (!$scope.hasContacts) return cb();

      var completeContacts = [];
      lodash.each(ab, function(v, k) {
        completeContacts.push({
          name: lodash.isObject(v) ? v.name : v,
          address: k,
          email: lodash.isObject(v) ? v.email : null,
          recipientType: 'contact',
          coin: getCoin(k),
          getAddress: function(cb) {
            return cb(null, k);
          },
        });
      });
      var contacts = completeContacts.slice(0, (currentContactsPage + 1) * CONTACTS_SHOW_LIMIT);
      $scope.contactsShowMore = completeContacts.length > contacts.length;
      originalList = originalList.concat(contacts);
      return cb();
    });
  };

  var updateList = function() {
    $scope.list = lodash.clone(originalList);
    $timeout(function() {
      $ionicScrollDelegate.resize();
      $scope.$apply();
    }, 10);
  };

  $scope.openScanner = function() {
    var isWindowsPhoneApp = platformInfo.isCordova && platformInfo.isWP;

    if (!isWindowsPhoneApp) {
      $state.go('tabs.scan');
      return;
    }

    scannerService.useOldScanner(function(err, contents) {
      if (err) {
        popupService.showAlert(gettextCatalog.getString('Error'), err);
        return;
      }
      incomingData.redir(contents);
    });
  };

  $scope.showMore = function() {
    currentContactsPage++;
    updateWalletsList();
  };

  $scope.searchInFocus = function() {
    $scope.searchFocus = true;
  };

  $scope.searchBlurred = function() {
    if ($scope.formData.search == null || $scope.formData.search.length == 0) {
      $scope.searchFocus = false;
    }
  };

  $scope.findContact = function(search) {

    if (incomingData.redir(search)) {
      return;
    }

    if (!search || search.length < 2) {
      $scope.list = originalList;
      $timeout(function() {
        $scope.$apply();
      });
      return;
    }

    var result = lodash.filter(originalList, function(item) {
      var val = item.name;
      return lodash.includes(val.toLowerCase(), search.toLowerCase());
    });

    $scope.list = result;
  };

  $scope.goToAmount = function(item) {
    $timeout(function() {
      item.getAddress(function(err, addr) {
        if (err || !addr) {
          //Error is already formated
          return popupService.showAlert(err);
        }
        $log.debug('Got toAddress:' + addr + ' | ' + item.name);
        return $state.transitionTo('tabs.send.amount', {
          recipientType: item.recipientType,
          toAddress: addr,
          toName: item.name,
          toEmail: item.email,
          toColor: item.color,
          coin: item.coin
        })
      });
    });
  };

  $scope.openServerMessageLink = function() {
    var url = $scope.serverMessage.link;
    externalLinkService.open(url);
  };

  // This could probably be enhanced refactoring the routes abstract states
  $scope.createWallet = function() {
    $state.go('tabs.home').then(function() {
      $state.go('tabs.add.create-personal');
    });
  };

  $scope.buyBitcoin = function() {
    $state.go('tabs.home').then(function() {
      $state.go('tabs.buyandsell');
    });
  };

  $scope.$on("$ionicView.beforeEnter", function(event, data) {
    $scope.checkingBalance = true;
    $scope.formData = {
      search: null
    };
    originalList = [];
    CONTACTS_SHOW_LIMIT = 10;
    currentContactsPage = 0;
    hasWallets();
  });

  $scope.$on("$ionicView.enter", function(event, data) {
    if (!$scope.hasWallets) {
      $scope.checkingBalance = false;
      return;
    }
    updateHasFunds();
    updateWalletsList();
    updateContactsList(function() {
      updateList();
    });
  });
});

'use strict';

angular.module('copayApp.controllers').controller('tabSettingsController', function($rootScope, $timeout, $scope, appConfigService, $ionicModal, $log, lodash, uxLanguage, platformInfo, profileService, feeService, configService, externalLinkService, bitpayAccountService, bitpayCardService, storageService, glideraService, gettextCatalog, buyAndSellService) {

  var updateConfig = function() {
    $scope.currentLanguageName = uxLanguage.getCurrentLanguageName();
    $scope.feeOpts = feeService.feeOpts;
    $scope.currentFeeLevel = feeService.getCurrentFeeLevel();
    $scope.walletsBtc = profileService.getWallets({ coin: 'btc' });
    $scope.walletsBch = profileService.getWallets({ coin: 'bch' });
    $scope.buyAndSellServices = buyAndSellService.getLinked();

    configService.whenAvailable(function(config) {
      $scope.selectedAlternative = {
        name: config.wallet.settings.alternativeName,
        isoCode: config.wallet.settings.alternativeIsoCode
      };

      // TODO move this to a generic service
      bitpayAccountService.getAccounts(function(err, data) {
        if (err) $log.error(err);
        $scope.bitpayAccounts = !lodash.isEmpty(data);

        $timeout(function() {
          $rootScope.$apply();
        }, 10);
      });


      // TODO move this to a generic service
      bitpayCardService.getCards(function(err, cards) {
        if (err) $log.error(err);
        $scope.bitpayCards = cards && cards.length > 0;

        $timeout(function() {
          $rootScope.$apply();
        }, 10);
      });
    });
  };

  $scope.openExternalLink = function() {
    var appName = appConfigService.name;
    var url = appName == 'qyb' ? 'https://github.com/bitpay/qyb/issues' : 'https://help.bitpay.com/bitpay-app';
    var optIn = true;
    var title = null;
    var message = gettextCatalog.getString('Help and support information is available at the website.');
    var okText = gettextCatalog.getString('Open');
    var cancelText = gettextCatalog.getString('Go Back');
    externalLinkService.open(url, optIn, title, message, okText, cancelText);
  };

  $scope.$on("$ionicView.beforeEnter", function(event, data) {
    $scope.isCordova = platformInfo.isCordova;
    $scope.isWindowsPhoneApp = platformInfo.isCordova && platformInfo.isWP;
    $scope.isDevel = platformInfo.isDevel;
    $scope.appName = appConfigService.nameCase;
    configService.whenAvailable(function(config) {
      $scope.locked = config.lock && config.lock.method;
      if (!$scope.locked || $scope.locked == 'none')
        $scope.method = gettextCatalog.getString('Disabled');
      else
        $scope.method = $scope.locked.charAt(0).toUpperCase() + config.lock.method.slice(1);
    });
  });



  $scope.$on("$ionicView.enter", function(event, data) {
    updateConfig();
  });

});

'use strict';

angular.module('copayApp.controllers').controller('tabsController', function($rootScope, $log, $scope, $state, $stateParams, $timeout, platformInfo, incomingData, lodash, popupService, gettextCatalog, scannerService) {

  $scope.onScan = function(data) {
    if (!incomingData.redir(data)) {
      popupService.showAlert(gettextCatalog.getString('Error'), gettextCatalog.getString('Invalid data'));
    }
  };

  $scope.setScanFn = function(scanFn) {
    $scope.scan = function() {
      $log.debug('Scanning...');
      scanFn();
    };
  };

  $scope.importInit = function() {
    $scope.fromOnboarding = $stateParams.fromOnboarding;
    $timeout(function() {
      $scope.$apply();
    }, 1);
  };

  $scope.chooseScanner = function() {

    var isWindowsPhoneApp = platformInfo.isCordova && platformInfo.isWP;

    if (!isWindowsPhoneApp) {
      $state.go('tabs.scan');
      return;
    }

    scannerService.useOldScanner(function(err, contents) {
      if (err) {
        popupService.showAlert(gettextCatalog.getString('Error'), err);
        return;
      }
      incomingData.redir(contents);
    });

  };

});

'use strict';

angular.module('copayApp.controllers').controller('topUpController', function($scope, $log, $state, $timeout, $ionicHistory, $ionicConfig, $ionicModal, lodash, popupService, profileService, ongoingProcess, walletService, configService, platformInfo, bitpayService, bitpayCardService, payproService, bwcError, txFormatService, sendMaxService, gettextCatalog, externalLinkService) {

  var FEE_TOO_HIGH_LIMIT_PER = 15;
  $scope.isCordova = platformInfo.isCordova;
  var coin = 'btc';
  var cardId;
  var useSendMax;
  var amount;
  var currency;
  var createdTx;
  var message;
  var configWallet = configService.getSync().wallet;

  var _resetValues = function() {
    $scope.totalAmountStr = $scope.amount = $scope.invoiceFee = $scope.networkFee = $scope.totalAmount = $scope.wallet = null;
    createdTx = message = null;
  };

  var showErrorAndBack = function(title, msg) {
    title = title || gettextCatalog.getString('Error');
    $scope.sendStatus = '';
    $log.error(msg);
    msg = msg.errors ? msg.errors[0].message : msg;
    popupService.showAlert(title, msg, function() {
      $ionicHistory.goBack();
    });
  };

  var showError = function(title, msg, cb) {
    cb = cb || function() {};
    title = title || gettextCatalog.getString('Error');
    $scope.sendStatus = '';
    $log.error(msg);
    msg = msg.errors ? msg.errors[0].message : msg;
    popupService.showAlert(title, msg, cb);
  };

  var satToFiat = function(sat, cb) {
    txFormatService.toFiat(coin, sat, $scope.currencyIsoCode, function(value) {
      return cb(value);
    });
  };

  var publishAndSign = function(wallet, txp, onSendStatusChange, cb) {
    if (!wallet.canSign() && !wallet.isPrivKeyExternal()) {
      var err = gettextCatalog.getString('No signing proposal: No private key');
      $log.info(err);
      return cb(err);
    }

    walletService.publishAndSign(wallet, txp, function(err, txp) {
      if (err) return cb(err);
      return cb(null, txp);
    }, onSendStatusChange);
  };

  var statusChangeHandler = function(processName, showName, isOn) {
    $log.debug('statusChangeHandler: ', processName, showName, isOn);
    if (processName == 'topup' && !isOn) {
      $scope.sendStatus = 'success';
      $timeout(function() {
        $scope.$digest();
      }, 100);
    } else if (showName) {
      $scope.sendStatus = showName;
    }
  };

  var setTotalAmount = function(amountSat, invoiceFeeSat, networkFeeSat) {
    satToFiat(amountSat, function(a) {
      $scope.amount = Number(a);

      satToFiat(invoiceFeeSat, function(i) {
        $scope.invoiceFee = Number(i);

        satToFiat(networkFeeSat, function(n) {
          $scope.networkFee = Number(n);
          $scope.totalAmount = $scope.amount + $scope.invoiceFee + $scope.networkFee;
          $timeout(function() {
            $scope.$digest();
          });
        });
      });
    });
  };

  var createInvoice = function(data, cb) {
    bitpayCardService.topUp(cardId, data, function(err, invoiceId) {
      if (err) {
        return cb({
          title: gettextCatalog.getString('Could not create the invoice'),
          message: err
        });
      }

      bitpayCardService.getInvoice(invoiceId, function(err, inv) {
        if (err) {
          return cb({
            title: gettextCatalog.getString('Could not get the invoice'),
            message: err
          });
        }
        return cb(null, inv);
      });
    });
  };

  var createTx = function(wallet, invoice, message, cb) {
    var payProUrl = (invoice && invoice.paymentUrls) ? invoice.paymentUrls.BIP73 : null;

    if (!payProUrl) {
      return cb({
        title: gettextCatalog.getString('Error in Payment Protocol'),
        message: gettextCatalog.getString('Invalid URL')
      });
    }

    var outputs = [];
    var toAddress = invoice.bitcoinAddress;
    var amountSat = parseInt((invoice.btcDue * 100000000).toFixed(0)); // QYB to Satoshi

    outputs.push({
      'toAddress': toAddress,
      'amount': amountSat,
      'message': message
    });

    var txp = {
      toAddress: toAddress,
      amount: amountSat,
      outputs: outputs,
      message: message,
      payProUrl: payProUrl,
      excludeUnconfirmedUtxos: configWallet.spendUnconfirmed ? false : true,
      feeLevel: configWallet.settings.feeLevel || 'normal'
    };

    walletService.createTx(wallet, txp, function(err, ctxp) {
      if (err) {
        return cb({
          title: gettextCatalog.getString('Could not create transaction'),
          message: bwcError.msg(err)
        });
      }
      return cb(null, ctxp);
    });
  };

  var calculateAmount = function(wallet, cb) {
    // Global variables defined beforeEnter
    var a = amount;
    var c = currency;

    if (useSendMax) {
      sendMaxService.getInfo(wallet, function(err, maxValues) {
        if (err) {
          return cb({
            title: null,
            message: err
          })
        }

        if (maxValues.amount == 0) {
          return cb({
            message: gettextCatalog.getString('Insufficient funds for fee')
          });
        }

        var maxAmountBtc = Number((maxValues.amount / 100000000).toFixed(8));

        createInvoice({
          amount: maxAmountBtc,
          currency: 'QYB'
        }, function(err, inv) {
          if (err) return cb(err);

          var invoiceFeeSat = parseInt((inv.buyerPaidBtcMinerFee * 100000000).toFixed());
          var newAmountSat = maxValues.amount - invoiceFeeSat;

          if (newAmountSat <= 0) {
            return cb({
              message: gettextCatalog.getString('Insufficient funds for fee')
            });
          }

          return cb(null, newAmountSat, 'sat');
        });
      });
    } else {
      return cb(null, a, c);
    }
  };

  var checkFeeHigh = function(amount, fee) {
    var per = fee / (amount + fee) * 100;

    if (per > FEE_TOO_HIGH_LIMIT_PER) {
      $ionicModal.fromTemplateUrl('views/modals/fee-warning.html', {
        scope: $scope
      }).then(function(modal) {
        $scope.feeWarningModal = modal;
        $scope.feeWarningModal.show();
      });

      $scope.close = function() {
        $scope.feeWarningModal.hide();
      };
    }
  }

  var initializeTopUp = function(wallet, parsedAmount) {
    $scope.amountUnitStr = parsedAmount.amountUnitStr;
    var dataSrc = {
      amount: parsedAmount.amount,
      currency: parsedAmount.currency
    };
    ongoingProcess.set('loadingTxInfo', true);
    createInvoice(dataSrc, function(err, invoice) {
      if (err) {
        ongoingProcess.set('loadingTxInfo', false);
        showErrorAndBack(err.title, err.message);
        return;
      }

      // Sometimes API does not return this element;
      invoice['buyerPaidBtcMinerFee'] = invoice.buyerPaidBtcMinerFee || 0;
      var invoiceFeeSat = (invoice.buyerPaidBtcMinerFee * 100000000).toFixed();

      message = gettextCatalog.getString("Top up {{amountStr}} to debit card ({{cardLastNumber}})", {
        amountStr: $scope.amountUnitStr,
        cardLastNumber: $scope.lastFourDigits
      });

      createTx(wallet, invoice, message, function(err, ctxp) {
        ongoingProcess.set('loadingTxInfo', false);
        if (err) {
          _resetValues();
          showError(err.title, err.message);
          return;
        }

        // Save TX in memory
        createdTx = ctxp;

        $scope.totalAmountStr = txFormatService.formatAmountStr(coin, ctxp.amount);

        // Warn: fee too high
        checkFeeHigh(Number(parsedAmount.amountSat), Number(invoiceFeeSat) + Number(ctxp.fee));

        setTotalAmount(parsedAmount.amountSat, invoiceFeeSat, ctxp.fee);

      });

    });

  };

  $scope.$on("$ionicView.beforeLeave", function(event, data) {
    $ionicConfig.views.swipeBackEnabled(true);
  });

  $scope.$on("$ionicView.enter", function(event, data) {
    $ionicConfig.views.swipeBackEnabled(false);
  });

  $scope.$on("$ionicView.beforeEnter", function(event, data) {

    cardId = data.stateParams.id;
    useSendMax = data.stateParams.useSendMax;
    amount = data.stateParams.amount;
    currency = data.stateParams.currency;

    bitpayCardService.get({
      cardId: cardId,
      noRefresh: true
    }, function(err, card) {
      if (err) {
        showErrorAndBack(null, err);
        return;
      }
      bitpayCardService.setCurrencySymbol(card[0]);
      $scope.lastFourDigits = card[0].lastFourDigits;
      $scope.currencySymbol = card[0].currencySymbol;
      $scope.currencyIsoCode = card[0].currency;

      $scope.wallets = profileService.getWallets({
        onlyComplete: true,
        network: bitpayService.getEnvironment().network,
        hasFunds: true,
        coin: coin
      });

      if (lodash.isEmpty($scope.wallets)) {
        showErrorAndBack(null, gettextCatalog.getString('No wallets available'));
        return;
      }

      bitpayCardService.getRates($scope.currencyIsoCode, function(err, r) {
        if (err) $log.error(err);
        $scope.rate = r.rate;
      });

      $scope.onWalletSelect($scope.wallets[0]); // Default first wallet
    });
  });

  $scope.topUpConfirm = function() {

    if (!createdTx) {
      showError(null, gettextCatalog.getString('Transaction has not been created'));
      return;
    }

    var title = gettextCatalog.getString('Confirm');
    var okText = gettextCatalog.getString('OK');
    var cancelText = gettextCatalog.getString('Cancel');
    popupService.showConfirm(title, message, okText, cancelText, function(ok) {
      if (!ok) {
        $scope.sendStatus = '';
        return;
      }

      ongoingProcess.set('topup', true, statusChangeHandler);
      publishAndSign($scope.wallet, createdTx, function() {}, function(err, txSent) {
        if (err) {
          _resetValues();
          ongoingProcess.set('topup', false, statusChangeHandler);
          showError(gettextCatalog.getString('Could not send transaction'), err);
          return;
        }
        ongoingProcess.set('topup', false, statusChangeHandler);
      });
    });
  };

  $scope.showWalletSelector = function() {
    $scope.walletSelectorTitle = gettextCatalog.getString('From');
    $scope.showWallets = true;
  };

  $scope.onWalletSelect = function(wallet) {
    $scope.wallet = wallet;
    ongoingProcess.set('retrievingInputs', true);
    calculateAmount(wallet, function(err, a, c) {
      ongoingProcess.set('retrievingInputs', false);
      if (err) {
        _resetValues();
        showError(err.title, err.message, function() {
          $scope.showWalletSelector();
        });
        return;
      }
      var parsedAmount = txFormatService.parseAmount(coin, a, c);
      initializeTopUp(wallet, parsedAmount);
    });
  };

  $scope.goBackHome = function() {
    $scope.sendStatus = '';
    $ionicHistory.nextViewOptions({
      disableAnimate: true,
      historyRoot: true
    });
    $ionicHistory.clearHistory();
    $state.go('tabs.home').then(function() {
      $state.transitionTo('tabs.bitpayCard', {
        id: cardId
      });
    });
  };

  $scope.openExternalLink = function(url) {
    externalLinkService.open(url);
  };

});

'use strict';

angular.module('copayApp.controllers').controller('txDetailsController', function($rootScope, $log, $ionicHistory, $scope, $timeout, walletService, lodash, gettextCatalog, profileService, externalLinkService, popupService, ongoingProcess, txFormatService, txConfirmNotification, feeService, configService) {

  var txId;
  var listeners = [];
  var config = configService.getSync();
  var blockexplorerUrl;

  $scope.$on("$ionicView.beforeEnter", function(event, data) {
    txId = data.stateParams.txid;
    $scope.title = gettextCatalog.getString('Transaction');
    $scope.wallet = profileService.getWallet(data.stateParams.walletId);
    $scope.color = $scope.wallet.color;
    $scope.copayerId = $scope.wallet.credentials.copayerId;
    $scope.isShared = $scope.wallet.credentials.n > 1;
    $scope.txsUnsubscribedForNotifications = config.confirmedTxsNotifications ? !config.confirmedTxsNotifications.enabled : true;

    if ($scope.wallet.coin == 'bch') {
      blockexplorerUrl = 'bch-insight.bitpay.com';
    } else {
      blockexplorerUrl = 'qyb.chainclub.one';
    }

    txConfirmNotification.checkIfEnabled(txId, function(res) {
      $scope.txNotification = {
        value: res
      };
    });

    updateTx();

    listeners = [
      $rootScope.$on('bwsEvent', function(e, walletId, type, n) {
        if (type == 'NewBlock' && n && n.data && n.data.network == 'livenet') {
          updateTxDebounced({
            hideLoading: true
          });
        }
      })
    ];
  });

  $scope.$on("$ionicView.leave", function(event, data) {
    lodash.each(listeners, function(x) {
      x();
    });
  });

  $scope.readMore = function() {
    var url = 'https://github.com/bitpay/qyb/wiki/COPAY---FAQ#amount-too-low-to-spend';
    var optIn = true;
    var title = null;
    var message = gettextCatalog.getString('Read more in our Wiki');
    var okText = gettextCatalog.getString('Open');
    var cancelText = gettextCatalog.getString('Go Back');
    externalLinkService.open(url, optIn, title, message, okText, cancelText);
  };

  function updateMemo() {
    walletService.getTxNote($scope.wallet, $scope.btx.txid, function(err, note) {
      if (err) {
        $log.warn('Could not fetch transaction note: ' + err);
        return;
      }
      if (!note) return;

      $scope.btx.note = note;
      $scope.$apply();
    });
  }

  function initActionList() {
    $scope.actionList = [];
    if ($scope.btx.action != 'sent' || !$scope.isShared) return;

    var actionDescriptions = {
      created: gettextCatalog.getString('Proposal Created'),
      accept: gettextCatalog.getString('Accepted'),
      reject: gettextCatalog.getString('Rejected'),
      broadcasted: gettextCatalog.getString('Broadcasted'),
    };

    $scope.actionList.push({
      type: 'created',
      time: $scope.btx.createdOn,
      description: actionDescriptions['created'],
      by: $scope.btx.creatorName
    });

    lodash.each($scope.btx.actions, function(action) {
      $scope.actionList.push({
        type: action.type,
        time: action.createdOn,
        description: actionDescriptions[action.type],
        by: action.copayerName
      });
    });

    $scope.actionList.push({
      type: 'broadcasted',
      time: $scope.btx.time,
      description: actionDescriptions['broadcasted'],
    });

    $timeout(function() {
      $scope.actionList.reverse();
    }, 10);
  }

  var updateTx = function(opts) {
    opts = opts || {};
    if (!opts.hideLoading) ongoingProcess.set('loadingTxInfo', true);
    walletService.getTx($scope.wallet, txId, function(err, tx) {
      if (!opts.hideLoading) ongoingProcess.set('loadingTxInfo', false);
      if (err) {
        $log.warn('Error getting transaction: ' + err);
        $ionicHistory.goBack();
        return popupService.showAlert(gettextCatalog.getString('Error'), gettextCatalog.getString('Transaction not available at this time'));
      }

      $scope.btx = txFormatService.processTx($scope.wallet.coin, tx);
      txFormatService.formatAlternativeStr($scope.wallet.coin, tx.fees, function(v) {
        $scope.btx.feeFiatStr = v;
        $scope.btx.feeRateStr = ($scope.btx.fees / ($scope.btx.amount + $scope.btx.fees) * 100).toFixed(2) + '%';
      });

      if ($scope.btx.action != 'invalid') {
        if ($scope.btx.action == 'sent') $scope.title = gettextCatalog.getString('Sent Funds');
        if ($scope.btx.action == 'received') $scope.title = gettextCatalog.getString('Received Funds');
        if ($scope.btx.action == 'moved') $scope.title = gettextCatalog.getString('Moved Funds');
      }

      updateMemo();
      initActionList();
      getFiatRate();
      $timeout(function() {
        $scope.$digest();
      });

      feeService.getFeeLevels($scope.wallet.coin, function(err, levels) {
        if (err) return;
        walletService.getLowAmount($scope.wallet, levels, function(err, amount) {
          if (err) return;
          $scope.btx.lowAmount = tx.amount < amount;

          $timeout(function() {
            $scope.$apply();
          });

        });
      });
    });
  };

  var updateTxDebounced = lodash.debounce(updateTx, 5000);

  $scope.showCommentPopup = function() {
    var opts = {};
    if ($scope.btx.message) {
      opts.defaultText = $scope.btx.message;
    }
    if ($scope.btx.note && $scope.btx.note.body) opts.defaultText = $scope.btx.note.body;

    popupService.showPrompt($scope.wallet.name, gettextCatalog.getString('Memo'), opts, function(text) {
      if (typeof text == "undefined") return;

      $scope.btx.note = {
        body: text
      };
      $log.debug('Saving memo');

      var args = {
        txid: $scope.btx.txid,
        body: text
      };

      walletService.editTxNote($scope.wallet, args, function(err, res) {
        if (err) {
          $log.debug('Could not save tx comment ' + err);
        }
      });
    });
  };

  $scope.viewOnBlockchain = function() {
    var btx = $scope.btx;
    var url = 'http://' + ($scope.getShortNetworkName() == 'test' ? 'test-' : '') + blockexplorerUrl + '/tx/' + btx.txid;
    var optIn = true;
    var title = null;
    var message = gettextCatalog.getString('View Transaction on Insight');
    var okText = gettextCatalog.getString('Open Insight');
    var cancelText = gettextCatalog.getString('Go Back');
    externalLinkService.open(url, optIn, title, message, okText, cancelText);
  };

  $scope.getShortNetworkName = function() {
    var n = $scope.wallet.credentials.network;
    return n.substring(0, 4);
  };

  var getFiatRate = function() {
    $scope.alternativeIsoCode = $scope.wallet.status.alternativeIsoCode;
    $scope.wallet.getFiatRate({
      code: $scope.alternativeIsoCode,
      ts: $scope.btx.time * 1000
    }, function(err, res) {
      if (err) {
        $log.debug('Could not get historic rate');
        return;
      }
      if (res && res.rate) {
        $scope.rateDate = res.fetchedOn;
        $scope.rate = res.rate;
      }
    });
  };

  $scope.txConfirmNotificationChange = function() {
    if ($scope.txNotification.value) {
      txConfirmNotification.subscribe($scope.wallet, {
        txid: txId
      });
    } else {
      txConfirmNotification.unsubscribe($scope.wallet, txId);
    }
  };

});
'use strict';

angular.module('copayApp.controllers').controller('versionController', function() {
  this.version = window.version;
  this.commitHash = window.commitHash;
});

'use strict';

angular.module('copayApp.controllers').controller('walletDetailsController', function($scope, $rootScope, $interval, $timeout, $filter, $log, $ionicModal, $ionicPopover, $state, $stateParams, $ionicHistory, profileService, lodash, configService, platformInfo, walletService, txpModalService, externalLinkService, popupService, addressbookService, storageService, $ionicScrollDelegate, $window, bwcError, gettextCatalog, timeService, feeService, appConfigService) {

  var HISTORY_SHOW_LIMIT = 10;
  var currentTxHistoryPage = 0;
  var listeners = [];
  $scope.txps = [];
  $scope.completeTxHistory = [];
  $scope.openTxpModal = txpModalService.open;
  $scope.isCordova = platformInfo.isCordova;
  $scope.isAndroid = platformInfo.isAndroid;
  $scope.isIOS = platformInfo.isIOS;

  $scope.amountIsCollapsible = !$scope.isAndroid;

  $scope.openExternalLink = function(url, target) {
    externalLinkService.open(url, target);
  };

  var setPendingTxps = function(txps) {

    /* Uncomment to test multiple outputs */

    // var txp = {
    //   message: 'test multi-output',
    //   fee: 1000,
    //   createdOn: new Date() / 1000,
    //   outputs: [],
    //   wallet: $scope.wallet
    // };
    //
    // function addOutput(n) {
    //   txp.outputs.push({
    //     amount: 600,
    //     toAddress: '2N8bhEwbKtMvR2jqMRcTCQqzHP6zXGToXcK',
    //     message: 'output #' + (Number(n) + 1)
    //   });
    // };
    // lodash.times(15, addOutput);
    // txps.push(txp);

    if (!txps) {
      $scope.txps = [];
      return;
    }
    $scope.txps = lodash.sortBy(txps, 'createdOn').reverse();
  };

  var analyzeUtxosDone;

  var analyzeUtxos = function() {
    if (analyzeUtxosDone) return;

    walletService.getLowUtxos($scope.wallet, function(err, resp) {
      if (err || !resp) return;
      analyzeUtxosDone = true;
      $scope.lowUtxosWarning = resp.warning;
    });
  };

  var updateStatus = function(force) {
    $scope.updatingStatus = true;
    $scope.updateStatusError = null;
    $scope.walletNotRegistered = false;

    walletService.getStatus($scope.wallet, {
      force: !!force,
    }, function(err, status) {
      $scope.updatingStatus = false;
      if (err) {
        if (err === 'WALLET_NOT_REGISTERED') {
          $scope.walletNotRegistered = true;
        } else {
          $scope.updateStatusError = bwcError.msg(err, gettextCatalog.getString('Could not update wallet'));
        }
        $scope.status = null;
      } else {
        setPendingTxps(status.pendingTxps);
        $scope.status = status;
      }
      refreshAmountSection();
      $timeout(function() {
        $scope.$apply();
      });

      analyzeUtxos();

    });
  };

  $scope.openSearchModal = function() {
    $scope.color = $scope.wallet.color;
    $scope.isSearching = true;
    $scope.txHistorySearchResults = [];
    $scope.filteredTxHistory = [];

    $ionicModal.fromTemplateUrl('views/modals/search.html', {
      scope: $scope,
      focusFirstInput: true
    }).then(function(modal) {
      $scope.searchModal = modal;
      $scope.searchModal.show();
    });

    $scope.close = function() {
      $scope.isSearching = false;
      $scope.searchModal.hide();
    };

    $scope.openTx = function(tx) {
      $ionicHistory.nextViewOptions({
        disableAnimate: true
      });
      $scope.close();
      $scope.openTxModal(tx);
    };
  };

  $scope.openTxModal = function(btx) {
    $scope.btx = lodash.cloneDeep(btx);
    $scope.walletId = $scope.wallet.id;
    $state.transitionTo('tabs.wallet.tx-details', {
      txid: $scope.btx.txid,
      walletId: $scope.walletId
    });
  };

  $scope.openBalanceModal = function() {
    $ionicModal.fromTemplateUrl('views/modals/wallet-balance.html', {
      scope: $scope
    }).then(function(modal) {
      $scope.walletBalanceModal = modal;
      $scope.walletBalanceModal.show();
    });

    $scope.close = function() {
      $scope.walletBalanceModal.hide();
    };
  };

  $scope.recreate = function() {
    walletService.recreate($scope.wallet, function(err) {
      if (err) return;
      $timeout(function() {
        walletService.startScan($scope.wallet, function() {
          $scope.updateAll();
          $scope.$apply();
        });
      });
    });
  };

  var updateTxHistory = function(cb) {
    if (!cb) cb = function() {};
    $scope.updatingTxHistory = true;

    $scope.updateTxHistoryError = false;
    $scope.updatingTxHistoryProgress = 0;

    var progressFn = function(txs, newTxs) {
      if (newTxs > 5) $scope.txHistory = null;
      $scope.updatingTxHistoryProgress = newTxs;
      $timeout(function() {
        $scope.$apply();
      });
    };

    walletService.getTxHistory($scope.wallet, {
      progressFn: progressFn
    }, function(err, txHistory) {
      $scope.updatingTxHistory = false;
      if (err) {
        $scope.txHistory = null;
        $scope.updateTxHistoryError = true;
        return;
      }

      var hasTx = txHistory[0];
      if (hasTx) $scope.showNoTransactionsYetMsg = false;
      else $scope.showNoTransactionsYetMsg = true;

      $scope.completeTxHistory = txHistory;
      $scope.showHistory();
      $timeout(function() {
        $scope.$apply();
      });
      return cb();
    });
  };

  $scope.showHistory = function() {
    if ($scope.completeTxHistory) {
      $scope.txHistory = $scope.completeTxHistory.slice(0, (currentTxHistoryPage + 1) * HISTORY_SHOW_LIMIT);
      $scope.txHistoryShowMore = $scope.completeTxHistory.length > $scope.txHistory.length;
    }
  };

  $scope.getDate = function(txCreated) {
    var date = new Date(txCreated * 1000);
    return date;
  };

  $scope.isFirstInGroup = function(index) {
    if (index === 0) {
      return true;
    }
    var curTx = $scope.txHistory[index];
    var prevTx = $scope.txHistory[index - 1];
    return !$scope.createdDuringSameMonth(curTx, prevTx);
  };

  $scope.isLastInGroup = function(index) {
    if (index === $scope.txHistory.length - 1) {
      return true;
    }
    return $scope.isFirstInGroup(index + 1);
  };

  $scope.createdDuringSameMonth = function(curTx, prevTx) {
    return timeService.withinSameMonth(curTx.time * 1000, prevTx.time * 1000);
  };

  $scope.createdWithinPastDay = function(time) {
    return timeService.withinPastDay(time);
  };

  $scope.isDateInCurrentMonth = function(date) {
    return timeService.isDateInCurrentMonth(date);
  };

  $scope.isUnconfirmed = function(tx) {
    return !tx.confirmations || tx.confirmations === 0;
  };

  $scope.showMore = function() {
    $timeout(function() {
      currentTxHistoryPage++;
      $scope.showHistory();
      $scope.$broadcast('scroll.infiniteScrollComplete');
    }, 100);
  };

  $scope.onRefresh = function() {
    $timeout(function() {
      $scope.$broadcast('scroll.refreshComplete');
    }, 300);
    $scope.updateAll(true);
  };

  $scope.updateAll = function(force, cb)  {
    updateStatus(force);
    updateTxHistory(cb);
  };

  $scope.hideToggle = function() {
    profileService.toggleHideBalanceFlag($scope.wallet.credentials.walletId, function(err) {
      if (err) $log.error(err);
    });
  };

  var prevPos;

  function getScrollPosition() {
    var scrollPosition = $ionicScrollDelegate.getScrollPosition();
    if (!scrollPosition) {
      $window.requestAnimationFrame(function() {
        getScrollPosition();
      });
      return;
    }
    var pos = scrollPosition.top;
    if (pos === prevPos) {
      $window.requestAnimationFrame(function() {
        getScrollPosition();
      });
      return;
    }
    prevPos = pos;
    refreshAmountSection(pos);
  };

  function refreshAmountSection(scrollPos) {
    $scope.showBalanceButton = false;
    if ($scope.status) {
      $scope.showBalanceButton = ($scope.status.totalBalanceSat != $scope.status.spendableAmount);
    }
    if (!$scope.amountIsCollapsible) {
      var t = ($scope.showBalanceButton ? 15 : 45);
      $scope.amountScale = 'translateY(' + t + 'px)';
      return;
    }

    scrollPos = scrollPos || 0;
    var amountHeight = 210 - scrollPos;
    if (amountHeight < 80) {
      amountHeight = 80;
    }
    var contentMargin = amountHeight;
    if (contentMargin > 210) {
      contentMargin = 210;
    }

    var amountScale = (amountHeight / 210);
    if (amountScale < 0.5) {
      amountScale = 0.5;
    }
    if (amountScale > 1.1) {
      amountScale = 1.1;
    }

    var s = amountScale;

    // Make space for the balance button when it needs to display.
    var TOP_NO_BALANCE_BUTTON = 115;
    var TOP_BALANCE_BUTTON = 30;
    var top = TOP_NO_BALANCE_BUTTON;
    if ($scope.showBalanceButton) {
      top = TOP_BALANCE_BUTTON;
    }

    var amountTop = ((amountScale - 0.7) / 0.7) * top;
    if (amountTop < -10) {
      amountTop = -10;
    }
    if (amountTop > top) {
      amountTop = top;
    }

    var t = amountTop;

    $scope.altAmountOpacity = (amountHeight - 100) / 80;
    $window.requestAnimationFrame(function() {
      $scope.amountHeight = amountHeight + 'px';
      $scope.contentMargin = contentMargin + 'px';
      $scope.amountScale = 'scale3d(' + s + ',' + s + ',' + s + ') translateY(' + t + 'px)';
      $scope.$digest();
      getScrollPosition();
    });
  }

  var scrollWatcherInitialized;

  $scope.$on("$ionicView.enter", function(event, data) {
    if ($scope.isCordova && $scope.isAndroid) setAndroidStatusBarColor();
    if (scrollWatcherInitialized || !$scope.amountIsCollapsible) {
      return;
    }
    scrollWatcherInitialized = true;
  });

  $scope.$on("$ionicView.beforeEnter", function(event, data) {
    var clearCache = data.stateParams.clearCache;
    $scope.walletId = data.stateParams.walletId;
    $scope.wallet = profileService.getWallet($scope.walletId);
    if (!$scope.wallet) return;
    // Getting info from cache
    if (clearCache) {
      $scope.txHistory = null;
      $scope.status = null;
    } else {
      $scope.status = $scope.wallet.cachedStatus;
      if ($scope.wallet.completeHistory) {
        $scope.completeTxHistory = $scope.wallet.completeHistory;
        $scope.showHistory();
      }
    }

    $scope.requiresMultipleSignatures = $scope.wallet.credentials.m > 1;

    addressbookService.list(function(err, ab) {
      if (err) $log.error(err);
      $scope.addressbook = ab || {};
    });

    listeners = [
      $rootScope.$on('bwsEvent', function(e, walletId) {
        if (walletId == $scope.wallet.id && e.type != 'NewAddress')
          $scope.updateAll();
      }),
      $rootScope.$on('Local/TxAction', function(e, walletId) {
        if (walletId == $scope.wallet.id)
          $scope.updateAll();
      }),
    ];
  });

  $scope.$on("$ionicView.afterEnter", function(event, data) {
    $scope.updateAll();
    refreshAmountSection();
  });

  $scope.$on("$ionicView.afterLeave", function(event, data) {

    if ($window.StatusBar) {
      var statusBarColor = appConfigService.name == 'qyb' ? '#192c3a' : '#1e3186';
      $window.StatusBar.backgroundColorByHexString(statusBarColor);
    }
  });

  $scope.$on("$ionicView.leave", function(event, data) {
    lodash.each(listeners, function(x) {
      x();
    });
  });

  function setAndroidStatusBarColor() {
    var SUBTRACT_AMOUNT = 15;
    var walletColor;
    if (!$scope.wallet.color) walletColor = appConfigService.name == 'qyb' ? '#019477' : '#4a90e2';
    else walletColor = $scope.wallet.color;
    var rgb = hexToRgb(walletColor);
    var keys = Object.keys(rgb);
    keys.forEach(function(k) {
      if (rgb[k] - SUBTRACT_AMOUNT < 0) {
        rgb[k] = 0;
      } else {
        rgb[k] -= SUBTRACT_AMOUNT;
      }
    });
    var statusBarColorHexString = rgbToHex(rgb.r, rgb.g, rgb.b);
    if ($window.StatusBar)
      $window.StatusBar.backgroundColorByHexString(statusBarColorHexString);
  }

  function hexToRgb(hex) {
    // Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
    var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
    hex = hex.replace(shorthandRegex, function(m, r, g, b) {
      return r + r + g + g + b + b;
    });

    var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? {
      r: parseInt(result[1], 16),
      g: parseInt(result[2], 16),
      b: parseInt(result[3], 16)
    } : null;
  }

  function componentToHex(c) {
    var hex = c.toString(16);
    return hex.length == 1 ? "0" + hex : hex;
  }

  function rgbToHex(r, g, b) {
    return "#" + componentToHex(r) + componentToHex(g) + componentToHex(b);
  }
});

angular.module('copayApp').run(['gettextCatalog', function (gettextCatalog) {
/* jshint -W100 */
    gettextCatalog.setStrings('de', {"(Trusted)":"(Vertraut)","(possible double spend)":"(mögliche Doppelausgabe)","* A payment proposal can be deleted if 1) you are the creator, and no other copayer has signed, or 2) 24 hours have passed since the proposal was created.":"* Ein Zahlungsvorschlag kann gelöscht werden, wenn 1) Du diesen erzeugt hast und noch kein anderer Copayer unterschrieben hat, oder 2) 24 Stunden vergangen sind, seit der Vorschlag erstellt wurde.","- {{btx.feeRateStr}} of the transaction":"- {{btx.feeRateStr}}ของธุรกรรม","- {{tx.feeRateStr}} of the transaction":"{{tx.feeRateStr}} von die transaccion","5-star ratings help us get {{appName}} into more hands, and more users means more resources can be committed to the app!":"Eine 5-Sterne Bewertung hilft uns, {{appName}} unter die Leute zu bringen. Und mehr Nutzer bedeuten, dass uns mehr Ressourcen für die App-Entwicklung zur Verfügung stehen!","A member of the team will review your feedback as soon as possible.":"Ein Mitarbeiter wird Ihr Feedback so bald wie möglich überprüfen.","A total of {{amountAboveMaxSizeStr}} were excluded. The maximum size allowed for a transaction was exceeded.":"Insgesamt wurden {{amountAboveMaxSizeStr}} ausgeschlossen. Die maximale Größe für eine Transaktion wurde überschritten.","A total of {{amountBelowFeeStr}} were excluded. These funds come from UTXOs smaller than the network fee provided.":"Insgesamt wurden {{amountBelowFeeStr}} ausgeschlossen. Diese Gelder stammen aus UTXOs, die kleiner sind als die Netzwerkgebühr.","About":"Über","Accepted":"Akzeptiert","Account":"Benutzerkonto","Account Number":"Kontonummer","Accounts":"Konten","Activity":"Aktivität","Add Account":"Konto hinzufügen","Add BitPay Account?":"BitPay-Konto hinzufügen?","Add Contact":"Kontakt hinzufügen","Add Funds":"Guthaben aufladen","Add Memo":"Notiz hinzufügen","Add a password":"Passwort festlegen","Add account":"Konto hinzufügen","Add an optional password to secure the recovery phrase":"Ein optionales Passwort zur Sicherung der Wiederherstellungsphrase hinzufügen","Add description":"Beschreibung hinzufügen","Add wallet":"Wallet hinzufügen","Address":"Adresse","Address Book":"Addressbuch","Address Type":"Adresstyp","Addresses With Balance":"Adressen mit Guthaben","Advanced":"Erweitert","Advanced Settings":"Erweiterte Einstellungen","All":"Alle","All Addresses":"Alle Adressen","All of your bitcoin wallet balance may not be available for immediate spending.":"Möglicherweise kann nicht ihr gesamtes Qybcoin Guthaben sofort ausgegeben werden.","All signing devices must be added to this multisig wallet before bitcoin addresses can be created.":"Alle unterzeichnenden Geräte müssen zu dieser Multi-Signatur Wallet hinzugefügt werden, bevor Qybcoin-Adressen erstellt werden können.","Allow Camera Access":"Kamerazugriff erlauben","Allow notifications":"Benachrichtigungen erlauben","Almost done! Let's review.":"Fast fertig! Fassen wir zusammen.","Alternative Currency":"Alternative Währung","Amount":"Betrag","Amount below minimum allowed":"Betrag unter zulässigem Minimum","Amount too big":"Betrag zu hoch","An update to this app is available. For your security, please update to the latest version.":"Ein Aktualisierung für diese App ist verfügbar. Zu Ihrer Sicherheit bitte auf die neueste Version aktualisieren.","Anyone with your backup phrase can access or spend your bitcoin.":"Jeder mit Ihrer Wiederherstellungsphrase hat Zugriff auf ihre Bitcoins und kann diese ausgeben.","Are you being watched?":"Werden Sie beobachtet?","Are you being watched? Anyone with your recovery phrase can access or spend your bitcoin.":"Werden Sie beobachtet? Jeder der Ihre Wiederherstellungsphrase kennt, kann auf Ihre Qybcoin zugreifen und diese ausgeben.","Are you sure you want to cancel and delete this wallet?":"Wollen Sie wirklich abbrechen und dieses Wallet löschen?","Are you sure you want to delete this wallet?":"Soll das Wallet wirklich gelöscht werden?","Are you sure you want to reject this transaction?":"Wollen Sie wirklich diese Transaktion ablehnen?","Are you sure you want to remove this transaction?":"Wollen Sie wirklich diese Transaktion löschen?","Are you sure you want to skip it?":"Sind Sie sicher dass Sie es überspringen möchten?","Are you sure you would like to remove your BitPay Card ({{lastFourDigits}}) from this device?":"Sind Sie sicher, dass Sie Ihre BitPay-Karte ({{lastFourDigits}}) von diesem Gerät entfernen möchten?","Auditable":"Prüffähig","Available":"Verfügbar","Available Balance":"Verfügbarer Gesamtbetrag","Average confirmation time":"Durchschnittliche Bestätigungzeit","BIP32 path for address derivation":"BIP32 Pfad für die Adressen-Ableitung","Backup":"Sicherung","Backup Needed":"Backup wird benötigt","Backup all livenet wallets before using this function":"Sichern Sie alle Livenet Wallets, bevor Sie diese Funktion nutzen","Backup needed":"Backup benötigt","Backup now":"Jetzt sichern","Backup wallet":"Sicherung der Wallet","Backup your wallet before using this function":"Sichern Sie ihr Wallet, bevor Sie diese Funktion nutzen","Bad wallet invitation":"Ungültige Einladung","Balance By Address":"Guthaben nach Adresse","Be sure to store your recovery phrase in a secure place. If this app is deleted, your money cannot be recovered without it.":"Achten Sie darauf Ihre Wiederherstellungsphrase an einem sicheren Ort abzulegen. Ihr Geld kann nicht ohne dieser Phrase wiederhergestellt werden falls die App deinstalliert wird.","BitPay Visa® Cards":"BitPay Visa&reg; Karten","Qybcoin Address":"Qybcoin-Adresse","Qybcoin Network Fee Policy":"Qybcoin-Netzwerk Gebührenübersicht","Qybcoin is a currency.":"Qybcoin ist eine Währung.","Qybcoin is different – it cannot be safely held with a bank or web service.":"Bitcoins sind anders &ndash; sie können nicht sicher in einer Bank oder einem Onlinedienst aufbewahrt werden.","Qybcoin is secure,<br>digital money.":"Qybcoin ist sicheres,<br>digitales Geld.","Qybcoin transactions include a fee collected by miners on the network.":"Qybcoin Transaktionen enthalten eine Gebühr für die \"Miners\" im Netzwerk.","Broadcast Payment":"Zahlung übermitteln","Broadcasted":"Gesendet","Broadcasting transaction":"Übermittlung der Transaktion","Browser unsupported":"Browser wird nicht unterstützt","Buy &amp; Sell Qybcoin":"Kaufe &amp; Verkaufe Bitcoins","Buy Qybcoin":"Kaufe Bitcoins","Buying Qybcoin...":"Kaufe Bitcoins...","Calculating fee":"Mining-Fee Berechnung","Cancel":"Abbruch","Cannot Create Wallet":"Wallet kann nicht erstellt werden","Cannot join the same wallet more that once":"An einem Wallet kann nicht mehrfach teilgenommen werden","Cards":"Karten","Certified by":"Zertifiziert von","Check installation and retry.":"Installation überprüfen und wiederholen.","Choose a backup file from your computer":"Bitte eine Sicherungsdatei vom Computer wählen","Choose your destination wallet":"Wählen Sie Ihre Ziel-Wallet","Choose your source wallet":"Wählen Sie Ihre Quell-Wallet","Clear":"Leeren","Clear cache":"Cache leeren","Close":"Schließen","Color":"Farbe","Commit hash":"Hash übertragen","Complete the backup process to use this option":"Beenden Sie den Backupvorgang um diese Option zu nutzen","Confirm":"Bestätigen","Confirm &amp; Finish":"Bestätigen &amp; Beenden","Confirm your PIN":"PIN bestätigen","Confirm your new spending password":"Bestätigen Sie Ihr neues Passwort","Confirmations":"Bestätigungen","Confirming":"Bestätigen","Connect my BitPay Card":"Verbinde meine BitPay-Karte","Connecting to Coinbase...":"Verbinde mit Coinbase...","Connecting to Glidera...":"Verbinde mit Glidera...","Connection reset by peer":"Verbindung von Peer zurückgesetzt","Contacts":"Kontakte","Continue":"Weiter","Contribute Translations":"Übersetzungen beitragen","Copayer already in this wallet":"Copayer nimmt bereits teil","Copayer already voted on this spend proposal":"Copayer hat schon für diesen Zahlungsvorschlag angestimmt","Copayer data mismatch":"Copayer Datenkonflikt","Copayer joined":"Copayer beigetreten","Copayer {{$index}}":"Copayer {{$index}}","Copied to clipboard":"In die Zwischenablage kopiert","Copy this text as it is to a safe place (notepad or email)":"Diesen Text an einem sichern Ort einfügen (Notepad oder E-Mail)","Copy to clipboard":"In die Zwischenablage kopieren","Could not access the wallet at the server. Please check:":"Kein Zugriff auf Wallet des Servers. Überprüfen Sie bitte:","Could not access wallet":"Auf Wallet konnte nicht zugegriffen werden","Could not add message to imported wallet without shared encrypting key":"Nachricht kann nicht an die importierte Wallet hinzugefügt werden ohne einem gemeinsamen Verschlüsselungsschlüssel","Could not broadcast payment":"Zahlung konnte nicht gesendet werden","Could not build transaction":"Transaktion konnte nicht erstellt werden","Could not create address":"Adresse konnte nicht erstellt werden","Could not create using the specified extended private key":"Erzeugung mit erweiterten privaten Schlüssel nicht möglich","Could not create using the specified extended public key":"Erzeugung mit dem angegebenen erweiterten öffentlichen Schlüssel nicht möglich","Could not create: Invalid wallet recovery phrase":"Wallet-Wiederherstellungsphrase nicht gültig","Could not decrypt file, check your password":"Datei konnte nicht entschlüsselt werden, bitte das Passwort überprüfen","Could not delete payment proposal":"Zahlungsvorschlag konnte nicht gelöscht werden","Could not get dynamic fee":"Dynamische Gebühr konnten nicht abgerufen werden","Could not get dynamic fee for level: {{feeLevel}}":"Dynamische Gebühr für den Level konnte nicht abgerufen werden: {{feeLevel}}","Could not get transactions":"Transaktionen konnten nicht gefunden werden","Could not import":"Import nicht möglich","Could not import. Check input file and spending password":"Import nicht möglich. Bitte Datei und Berechtigungscode überprüfen","Could not join wallet":"Beteiligung am Wallet nicht möglich","Could not reject payment":"Zahlung konnte nicht abgelehnt werden","Could not remove account":"Konto konnte nicht entfernt werden","Could not remove card":"Karte konnte nicht gelöscht werden","Could not save preferences on the server":"Die Einstellungen konnten nicht am Server gespeichert werden","Could not send payment":"Zahlung kann nicht gesendet werden","Could not update transaction history":"Die Transaktionshistorie konnte nicht aktualisiert werden","Could not update wallet":"Wallet konnte nicht aktualisiert werden","Create Personal Wallet":"Erstelle eine persönliche Wallet","Create Shared Wallet":"Erstelle eine gemeinsame Wallet","Create bitcoin wallet":"Erstelle Qybcoin-Wallet","Create new wallet":"Neues Wallet erzeugen","Create shared wallet":"Erstelle gemeinsame Wallet","Create {{formData.requiredCopayers}}-of-{{formData.totalCopayers}} wallet":"Ein {{formData.requiredCopayers}}-von-{{formData.totalCopayers}} Wallet erzeugen","Created by":"Erstellt von","Creating Wallet...":"Wallet erstellen...","Creating transaction":"Transaktion erstellen","Current fee rate for this policy":"Aktuelle Gebühr für dieses Verfahren","Custom Amount":"Benutzerdefinierter Betrag","Date":"Datum","Delete":"Löschen","Delete Payment Proposal":"Zahlungsvorschlag löschen","Delete Wallet":"Wallet löschen","Delete it and create a new one":"Löschen und neues Wallet erzeugen","Deleting Wallet...":"Wallet wird gelöscht...","Deleting payment proposal":"Lösche Zahlungsvorschlag","Derivation Path":"Ableitungsstruktur","Derivation Strategy":"Ableitungstrategie","Disabled":"Deaktiviert","Do it later":"Später erledigen","Do not include private key":"Den privaten Schlüssel nicht einbeziehen","Don't see your language on Crowdin? Contact the Owner on Crowdin! We'd love to support your language.":"Wird deine Sprache auf Crowdin nicht angezeigt? Kontaktiere den Support von Crowdin, denn wir würden deine Sprache gerne hinzufügen.","Download":"Herunterladen","Each bitcoin wallet can generate billions of addresses from your 12-word backup. A new address is automatically generated and shown each time you receive a payment.":"Jede Qybcoin-Wallet kann Milliarden von Adressen aus Ihrem 12-Wort Backup erzeugen. Jedesmal wenn Sie eine Zahlung erhalten wird neue Adresse automatisch generiert und dargestellten.","Economy":"Wirtschaftlich","Email":"E-Mail","Email Address":"E-Mail Adresse","Empty addresses limit reached. New addresses cannot be generated.":"Obergrenze für leere Adressen erreicht. Neue Adressen können nicht generiert werden.","Enable camera access in your device settings to get started.":"Aktiviere den Kamerazugriff in Ihren Geräteeinstellungen.","Enable email notifications":"Aktiviere E-Mail Benachrichtigung","Enable push notifications":"Pushbenachrichtigungen aktivieren","Enable the camera to get started.":"Aktivieren Sie die Kamera um loszulegen.","Enter Spending Password":"Berechtigungscode eingeben","Enter Two Factor for your BitPay account":"Eingabe des Zwei-Faktor-Authentifizierungs-Codes für das BitPay Konto","Enter new spending password":"Neuen Berechtigungscode eingeben","Enter the recovery phrase (BIP39)":"Wiederherstellungsphrase eingeben (BIP39)","Enter your password":"Passwort eingeben","Error":"Fehler","Error at confirm":"Fehler beim bestätigen","Error creating wallet":"Fehler beim Erstellen des Wallets","Error scanning funds:":"Fehler beim Ermitteln des Guthaben:","Error sweeping wallet:":"Fehler beim Leeren der Wallet:","Error updating Debit Cards":"Fehler beim Aktualisieren der Debitkarten","Exceeded daily limit of $500 per user":"Tageslimit von $500 pro Benutzer überschritten","Expired":"Abgelaufen","Expires":"Gültig bis","Export Wallet":"Wallet exportieren","Export to file":"In eine Datei exportieren","Export wallet":"Wallet exportieren","Exporting via QR not supported for this wallet":"Für diese Wallet ist Export per QR nicht unterstützt","Extended Public Keys":"Erweiterte öffentliche Schlüssel","Failed to export":"Fehler beim Exportieren","Family vacation funds":"Familienurlaub","Fee":"Gebühr","Feedback could not be submitted. Please try again later.":"Feedback konnte nicht abgeschickt werden. Bitte versuchen Sie es später erneut.","Fetching BitPay Account...":"BitPay Konto abrufen...","File/Text":"Datei/Text","Finger Scan Failed":"Abtasten des Fingerabdrucks gescheitert","Finish":"Beenden","For audit purposes":"Zur Kontrolle","From":"Von","From BitPay account":"Von BitPay Konto","From the destination device, go to Add wallet &gt; Import wallet and scan this QR code":"Gehen Sie auf Wallet Hinzufügen &gt; Wallet Importieren von dem Zielgerät und scannen Sie diesen QR-Code","Funds are locked by pending spend proposals":"Beträge sind durch ausstehende Zahlungsvorschläge gesperrt","Funds found:":"Betrag gefunden:","Funds transferred":"Betrag übermittelt","Funds will be transferred to":"Beträge werden überwiesen an","Generating .csv file...":"CSV-Datei erzeugen...","Generating new address...":"Neue Adresse erzeugen...","Get local cash anywhere you go, from any Visa<sup>®</sup> compatible ATM. ATM bank fees may apply.":"Erhalten Sie Bargeld überall von einem Visa<sup>&reg;</sup> kompatiblen Bankomaten. Es fallen eventuell Bankomatgebühren an.","Get news and updates from BitPay":"Erhalten Sie Neuigkeiten und Aktualisierungen von BitPay","Get started":"Los geht’s","Get started by adding your first one.":"Starten Sie indem Sie ihr erstes hinzufügen.","Getting fee levels...":"Entgelt-Level werden abgerufen...","Go Back":"Zurück","Go back":"Zurück","Got it":"Habe verstanden","Hardware Wallet":"Hardware-Wallet","Hardware not connected.":"Hardware nicht verbunden.","Hardware wallet":"Hardware-Wallet","Help & Support":"Hilfe & Support","Help and support information is available at the website.":"Hilfe und Support-Informationen gibt es auf der Website.","Hide":"Verstecken","Hide Balance":"Guthaben Verstecken","Hide Next Steps Card":"Nächste Schritte der Karte ausblenden","Hide advanced options":"Erweiterte Optionen ausblenden","Home":"Start","How could we improve your experience?":"Wie können wir Ihre Zufriedenheit verbessern?","How do you like {{appName}}?":"Wie gefällt Ihnen {{appName}}?","I don't like it":"Das gefällt mir nicht","I have read, understood, and agree to the <a ng-click=\"openTerms()\" translate=\"\">Terms of Use</a>.":"Ich habe die <a ng-click=\"openTerms()\" translate=\"\">Nutzungsbedingungen</a> gelesen, verstanden und stimme ihnen zu.","I have read, understood, and agree with the Terms of use.":"Ich habe die Nutzungsbedingungen gelesen und stimme ihnen zu.","I have written it down":"Ich habe es aufgeschrieben","I like the app":"Mir gefällt die App","I think this app is terrible.":"Diese App ist furchtbar.","I understand":"Ich verstehe","I understand that if this app is moved to another device or deleted, my bitcoin can only be recovered with the backup phrase.":"Ich verstehe, dass wenn diese App auf ein anderes Gerät verschoben oder gelöscht wird, meine Bitcoins nur mit der Wiederherstellungsphrase wiederhergestellt werden können.","I understand that my funds are held securely on this device, not by a company.":"Ich verstehe, dass mein Geld auf diesem Gerät und nicht von einem Unternehmen gesichert wird.","I've written it down":"Ich habe es aufgeschrieben","If enabled, all sensitive information (private key and recovery phrase) and actions (spending and exporting) associated with this wallet will be protected.":"Wenn aktiviert, werden alle vertraulichen Informationen (private Schlüssel und Wiederherstellungs Satz) und die zugeordneten Aktionen (Ausgaben und Exporte) des Wallets geschützt.","If enabled, the Recent Transactions card - a list of transactions occuring across all wallets - will appear in the Home tab.":"Wenn aktiviert wird die \"Kürzlich Ausgeführte Transaktionen\" Karte - eine Liste von Transaktionen aller Wallets - in der Registerkarte \"Start\" erscheinen.","If enabled, wallets will also try to spend unconfirmed funds. This option may cause transaction delays.":"Wenn aktiviert werden Wallets auch versuchen unbestätigtes Vermögen auszugeben. Diese Option kann zu Transaktionsverzögerungen führen.","If this device is replaced or this app is deleted, neither you nor BitPay can recover your funds without a backup.":"Wenn dieses Gerät ersetzt oder diese App gelöscht wird, so können weder Sie noch BitPay Ihr Geld ohne eine Sicherung wiederherstellen.","If you have additional feedback, please let us know by tapping the \"Send feedback\" option in the Settings tab.":"Wenn Sie zusätzliches Feedback haben, so lassen Sie uns es wissen indem Sie auf die Option \"Feedback senden\" in der Registerkarte \"Einstellungen\" drücken.","If you take a screenshot, your backup may be viewed by other apps. You can make a safe backup with physical paper and a pen.":"Wenn Sie einen Screenshot erstellen, kann die Sicherung von anderen Apps angesehen werden. Sie können ein sicheres Backup mit Papier und Stift erstellen.","Import":"Import","Import Wallet":"Wallet importieren","Import backup":"Importiere Sicherung","Import wallet":"Wallet importieren","Importing Wallet...":"Wallet wird importiert...","In order to verify your wallet backup, please type your password.":"Um die Sicherung der Wallet zu überprüfen, geben Sie bitte Ihr Passwort ein.","Incomplete":"Unvollständig","Incomplete wallet":"Unvollständige Wallet","Incorrect PIN, try again.":"Falscher PIN, bitte erneut versuchen.","Incorrect code format":"QR code hat falsches Format","Insufficient funds":"Nicht ausreichendes Guthaben","Insufficient funds for fee":"Nicht ausreichendes Guthaben für die Gebühr","Invalid":"Ungültig","Invalid account number":"Ungültige Kontonummer","Invalid address":"Ungültige Adresse","Invalid data":"Ungültige Daten","Invalid derivation path":"Ungültige Ableitungsstruktur","Invitation to share a {{appName}} Wallet":"Einladung um eine {{appName}} Wallet zu teilen","Is there anything we could do better?":"Gibt es etwas, das wir besser machen können?","Is this correct?":"Ist das richtig?","Is this email address correct?":"Ist diese E-Mail Adresse korrekt?","It's a good idea to avoid reusing addresses - this both protects your privacy and keeps your bitcoins secure against hypothetical attacks by quantum computers.":"Es ist eine gute Idee Adressen nicht wiederzuverwenden - dies schützt Ihre Privatsphäre und hält Ihre Bitcoins vor hypothetischen Angriffen durch Quanten-Computern sicher.","It's important that you write your backup phrase down correctly. If something happens to your wallet, you'll need this backup to recover your money. Please review your backup and try again.":"Es ist wichtig dass Sie Ihre Wiederherstellungsphrase korrekt aufschreiben. Wenn etwas mit Ihrer Wallet passiert benötigen Sie diese Sicherung um Ihr Geld wiederherstellen zu können. Bitte überprüfen Sie Ihre Sicherung und versuchen Sie es erneut.","Join":"Teilnehmen","Join my {{appName}} Wallet. Here is the invitation code: {{secret}} You can download {{appName}} for your phone or desktop at {{appUrl}}":"Meiner {{appName}} Wallet beitreten. Hier ist der Einladungs-Code: {{secret}} Sie können {{appName}} für Ihr Telefon oder Desktop auf {{appUrl}} herunterladen","Join shared wallet":"Gemeinschaftliches Wallet","Joining Wallet...":"Teilnahme am Wallet einrichten...","Just scan the code to pay.":"Scannen Sie einfach den Code um zu zahlen.","Key already associated with an existing wallet":"Schlüssel ist bereits mit einem existierenden Wallet verbunden","Language":"Sprache","Last Month":"Letzter Monat","Let's verify your backup phrase.":"Überprüfen Sie Ihre Wiederherstellungsphrase.","Loading addresses...":"Lade Adressen...","Loading transaction info...":"Transaktionen werden geladen...","Lock App":"App sperren","Lock by Fingerprint":"Mit Fingerabdruck sperren","Lock by PIN":"Mit PIN sperren","Locked":"Gesperrt","Locktime in effect. Please wait to create a new spend proposal":"Zeitsperre aktiv. Bitte mit neuem Zahlungsvorschlag warten","Locktime in effect. Please wait to remove this spend proposal":"Zeitsperre aktiv. Bitte auf die Entfernung des Zahlungsvorschlags warten","Low fees":"Niedrige Gebühren","Makes sense":"Macht Sinn","Matches:":"Übereinstimmungen:","Me":"Ich","Meh - it's alright":"Meh - ist in Ordnung","Memo":"Notiz","Merchant Message":"Händlernachricht","Missing parameter":"Angabe fehlt","Missing private keys to sign":"Zum Signieren fehlen die privaten Schlüssel","More Options":"Weitere Optionen","Moved":"Verschoben","Moved Funds":"Guthaben verschoben","Multiple recipients":"Mehrere Empfänger","NOTE: To import a wallet from a 3rd party software, please go to Add Wallet &gt; Create Wallet, and specify the Recovery Phrase there.":"Hinweis: Um eine Brieftasche aus einer 3rd-Party-Software zu importieren, gehen Sie bitte auf Wallet Hinzufügen &gt; Wallet Importieren, und geben Sie die Wiederhestellungsphrase ein.","Name":"Name","Network error":"Netzwerkfehler","New Proposal":"Neuer Vorschlag","New address could not be generated. Please try again.":"Neue Adresse konnte nicht erstellt werden. Bitte versuche es erneut.","New personal wallet":"Neue persönliche Wallet","Next steps":"Nächste Schritte","No Wallet":"Keine Wallet","No backup, no bitcoin.":"Keine Sicherung, keine Bitcoins.","No contacts yet":"Noch keine Kontakte","No hardware information available.":"Keine Hardwareinformationen verfügbar.","No hardware wallets supported on this device":"Hardware-Wallets werden auf diesem Gerät nicht unterstützt","No pending proposals":"Keine ausstehenden Vorschläge","No recent transactions":"Keine aktuellen Transaktionen","No transactions yet":"Noch keine Transaktionen","No wallet found":"Kein Wallet gefunden","No wallet selected":"Kein Wallet ausgewählt","No wallets available to receive funds":"Keine Wallet verfügbar um Guthaben zu erhalten","Normal":"Normal","Not authorized":"Nicht berechtigt","Not enough funds for fee":"Das Guthaben reicht nicht für die Gebühr","Not even BitPay can access it.":"Nicht einmal BitPay kann darauf zugreifen.","Not funds found":"Kein Guthaben gefunden","Not now":"Nicht jetzt","Note":"Notiz","Notice: only 1-1 (single signature) wallets can be used for sell bitcoin":"Hinweis: nur 1-1 (Einzelunterschrift) Wallets können verwendet werden um Bitcoins zu verkaufen","Notifications":"Benachrichtigungen","Now is a good time to backup your wallet. If this device is lost, it is impossible to access your funds without a backup.":"Jetzt ist ein guter Zeitpunkt um Ihre Wallet zu sichern. Wenn das Gerät verloren geht ist es unmöglich ohne eine Sicherung auf Ihr Geld zuzugreifen.","Now is a perfect time to assess your surroundings. Nearby windows? Hidden cameras? Shoulder-spies?":"Jetzt ist die perfekte Zeit um Ihre Umgebung zu überprüfen. In der Nähe eines Fensters? Versteckte Kameras? Schulter-Spione?","OK":"OK","OKAY":"Okay","Official English Disclaimer":"Offizieller englischer Haftungsausschluss","Oh no!":"Oh nein!","On this screen you can see all your wallets, accounts, and assets.":"Auf diesem Bildschirm sehen Sie alle Ihre Wallets, Konten und Guthaben.","Open":"Öffnen","Open Crowdin":"Öffne Crowdin","Open GitHub":"Öffne GitHub","Open GitHub Project":"Öffne GitHub Projekt","Open Insight":"Öffne Insight","Open Settings":"Öffne Einstellungen","Open Translation Community":"Öffne Übersetzungs-Community","Open Website":"Öffne Website","Open wallet":"Öffne Wallet","Order the BitPay Card":"BitPay-Karte bestellen","Password":"Passwort","Password required. Make sure to enter your password in advanced options":"Passwort erforderlich. Geben Sie Ihr Passwort in den erweiterten Optionen ein","Paste invitation here":"Einladung hier einfügen","Paste the backup plain text code":"Den Klartext der Sicherung einfügen","Pay 0% fees to turn bitcoin into dollars.":"Zahle 0 % Gebühren um Bitcoins in Dollar zu wechseln.","Pay To":"Zahle an","Payment Accepted":"Zahlung angenommen","Payment Expires:":"Zahlung läuft ab:","Payment Proposal":"Zahlungsvorschlag","Payment Proposal Created":"Zahlungsvorschlag erstellt","Payment Proposals":"Zahlungsvorschläge","Payment Protocol Invalid":"Ungültiges Zahlungsprotokoll","Payment Protocol not supported on Chrome App":"Zahlungsprotokoll wird nicht von der Chrome App unterstützt","Payment Received":"Zahlung erhalten","Payment Rejected":"Zahlung abgelehnt","Payment Sent":"Zahlung gesendet","Payment accepted, but not yet broadcasted":"Zahlung akzeptiert, aber noch nicht übermittelt","Payment accepted. It will be broadcasted by Glidera. In case there is a problem, it can be deleted 6 hours after it was created.":"Zahlung akzeptiert. Sie wird durch Glidera übermittelt. Falls ein Problem auftritt, kann sie nach einer Wartezeit von 6 Stunden gelöscht werden.","Payment details":"Zahlungsdetails","Payment request":"Zahlungsanforderung","Pending Proposals":"Anstehende Vorschläge","Permanently delete this wallet.":"Wallet dauerhaft löschen.","Personal Wallet":"Persönliches Wallet","Please carefully write down this phrase.":"Notieren Sie bitte sorgfältig diese Phrase.","Please connect a camera to get started.":"Bitte verbinden Sie eine Kamera um loszulegen.","Please enter the recovery phrase":"Bitte geben Sie die Wiederherstellungsphrase ein","Please enter the wallet recovery phrase":"Bitte geben Sie die Wallet-Wiederherstellungsphrase ein","Please enter your PIN":"Bitte geben Sie Ihre PIN ein","Please tap each word in the correct order.":"Bitte tippen Sie jedes Wort in der richtigen Reihenfolge.","Please upgrade Qyb to perform this action":"Bitte Qyb aktualisieren, um diese Aktion auszuführen","Please, select your backup file":"Bitte die Sicherungsdatei wählen","Preferences":"Einstellungen","Preparing addresses...":"Adressen werden vorbereitet...","Preparing backup...":"Sicherung wird vorbereitet...","Press again to exit":"Zum Beenden erneut drücken","Priority":"höchste Priorität","Private key encrypted. Enter password":"Privater Schlüssel verschlüsselt. Passwort eingeben","Private key is encrypted, cannot sign":"Der private Schlüssel ist verschlüsselt, signieren ist nicht möglich","Proposal Accepted":"Vorschlag angenommen","Proposal Created":"Vorschlag erstellt","Proposal Deleted":"Vorschlag gelöscht","Proposal Rejected":"Vorschlag abgelehnt","Proposals":"Vorschläge","Push Notifications":"Push-Benachrichtigungen","Push notifications for {{appName}} are currently disabled. Enable them in the Settings app.":"Push-Benachrichtigungen für {{appName}} sind derzeit deaktiviert. Aktivieren Sie diese in den Einstellungen.","QR Code":"QR-Code","Quick review!":"Schnelle Überprüfung!","Random":"Per Zufall","Rate on the app store":"Im App Store bewerten","Read less":"Weniger anzeigen","Read more":"Mehr anzeigen","Receive":"Empfangen","Received":"Empfangen","Received Funds":"Erhaltener Betrag","Receiving":"Eingehend","Recent":"Kürzlich","Recent Transaction Card":"Kürzlich Ausgeführte Transaktionen Karte","Recent Transactions":"Kürzliche Transaktionen","Recipient":"Empfänger","Recipients":"Empfänger","Recovery phrase":"Wiederherstellungsphrase","Recreating Wallet...":"Wallet wiederherstellen...","Rejected":"Abgelehnt","Rejecting payment proposal":"Ablehnung des Zahlungsvorschlags","Release information":"Release-Informationen","Remove BitPay Account?":"BitPay-Konto entfernen?","Remove BitPay Card?":"BitPay Karte entfernen?","Removing your BitPay account will remove all associated BitPay account data from this device. Are you sure you would like to remove your BitPay Account ({{email}}) from this device?":"Das Entfernen des BitPay-Kontos löscht alle zugehörigen Daten von diesem Gerät. Soll wirklich das BityPay-Konto ({{email}}) von diesem Gerät entfernt werden?","Repeat password":"Passwort wiederholen","Repeat the password":"Passwort wiederholen","Request Fingerprint":"Fingerabdruck anfordern","Request Specific amount":"Einen bestimmten Betrag anfordern","Request Spending Password":"Berechtigungscode abfragen","Required number of signatures":"Erforderliche Anzahl von Signaturen","Restore from backup":"Von Sicherung wiederherstellen","Retrieving inputs information":"Eingänge werden abgerufen","Retry":"Nochmals versuchen","Retry Camera":"Kamera nochmals versuchen","Save":"Speichern","Scan":"Scannen","Scan QR Codes":"QR-Code scannen","Scan addresses for funds":"Adresse auf neue Beträge überprüfen","Scan your fingerprint please":"Scannen Sie bitte Ihren Fingerabdruck","Scanning Wallet funds...":"Prüfe Wallet auf neue Beträge...","Screenshots are not secure":"Screenshots sind nicht sicher","Search Transactions":"Transaktionen durchsuchen","Search or enter bitcoin address":"Qybcoin-Adresse suchen oder eingeben","Search transactions":"Transaktionen durchsuchen","Search your currency":"Suchen Sie Ihre Währung","Security":"Sicherheit","Select a backup file":"Eine Sicherungsdatei auswählen","Select a wallet":"Wallet wählen","Self-signed Certificate":"Selbstsigniertes Zertifikat","Selling Qybcoin...":"Verkauf von Bitcoins...","Send":"Senden","Send Feedback":"Feedback senden","Send Money":"Geld senden","Send addresses by email":"Adressen per e-Mail versenden","Send by email":"Per E-Mail versenden","Send from":"Senden von","Send max amount":"Sende max. Betrag","Send us feedback instead":"Senden Sie uns Feedback stattdessen","Sending":"Senden","Sending 2FA code...":"2FA Code senden...","Sending feedback...":"Feedback wird gesendet...","Sending maximum amount":"Sende maximalen Betrag","Sending transaction":"Sende Transaktion","Sending {{amountStr}} from your {{name}} wallet":"Sende {{amountStr}} aus Ihrer Wallet {{name}}","Sent":"Gesendet","Sent Funds":"Guthaben senden","Server response could not be verified":"Antwort des Servers konnte nicht verifiziert werden","Services":"Services","Session Log":"Sitzungsprotokoll","Session log":"Sitzungsprotokoll","Set up a password":"Passwort einrichten","Settings":"Einstellungen","Share the love by inviting your friends.":"Teilen Sie die Liebe indem Sie Ihre Freunde einladen.","Share this invitation with your copayers":"Einladung mit Copayern teilen","Share {{appName}}":"{{appName}} weiterleiten","Shared Wallet":"Wallet teilen","Show Recovery Phrase":"Wiederherstellungsphrase anzeigen","Show address":"Adresse anzeigen","Show advanced options":"Erweiterte Optionen anzeigen","Show bitcoin address":"Qybcoin-Adresse anzeigen","Show more":"Mehr anzeigen","Signatures rejected by server":"Signaturen wurden vom Server abgelehnt","Signing transaction":"Unterschreibe Transaktion","Since only you control your money, you’ll need to save your backup phrase in case this app is deleted.":"Da nur Sie Ihr Geld kontrollieren müssen Sie Ihre Wiederherstellungsphrase gut sichern, für den Fall dass die App gelöscht wird.","Single Address Wallet":"Wallet mit einer einzigen Adresse","Skip":"Überspringen","Specify Recovery Phrase...":"Wiederherstellungsphrase angeben...","Spend proposal is not accepted":"Zahlungsvorschlag wurde nicht akzeptiert","Spend proposal not found":"Zahlungsvorschlag wurde nicht gefunden","Spending Password needed":"Berechtigungscode erforderlich","Start sending bitcoin":"Starte mit dem Senden der Bitcoins","Startup Lock":"Sperre des Startups","Super Economy":"Niedrigste Priorität","Sweep":"Leeren","Sweep paper wallet":"Paperwallet löschen","Sweeping Wallet...":"Leere Wallet...","THIS ACTION CANNOT BE REVERSED":"DIESE AKTION KANN NICHT RÜCKGÄNGIG GEMACHT WERDEN","Take control of your money,<br>get started with bitcoin.":"Übernehmen Sie die Kontrolle über Ihr Geld, <br>Legen Sie los mit Bitcoins.","Tap and hold to show":"Anzeigen durch tippen und halten","Tap to retry":"Zum Wiederholen antippen","Terms Of Use":"Nutzungsbedingungen","Terms of Use":"Nutzungsbedingungen","Testnet":"Testnet","Thank you!":"Vielen Dank!","Thanks!":"Danke!","That's exciting to hear. We'd love to earn that fifth star from you – how could we improve your experience?":"Wir sind gespannt es zu erfahren. Wir würden uns freuen fünf Sterne von Ihnen zu erhalten - Wie können wir Ihre Erfahrung verbessern?","The Ledger Chrome application is not installed":"Die Chrome-Anwendung für Ledger ist nicht installiert","The amount of bitcoin immediately spendable from this wallet.":"Den Betrag an Bitcoins sofort aus dieser Wallet zahlen.","The amount of bitcoin stored in this wallet that is allocated as inputs to your pending transaction proposals. The amount is determined using unspent transaction outputs associated with this wallet and may be more than the actual amounts associated with your pending transaction proposals.":"Der Betrag an Bitcoins gespeichert in dieser Wallet ist zugewiesen als Einsatz für die ausstehende Transaktion. Dem Betrag wurde zugewiesen unverbrauchte Transaktions-Ausgänge zu verwenden, welche mit dieser Brieftasche verbunden sind, und entspricht möglicherweise mehr als die tatsächlichen Beträge welche im Zusammenhang mit Ihren ausstehenden Transaktions-Betrag stehen.","The amount of bitcoin stored in this wallet with less than 1 blockchain confirmation.":"Die Menge an Bitcoins sind in dieser Geldbörse mit weniger als 1 Blockchain Bestätigung gespeichert.","The derivation path":"Die Ableitungsstruktur","The exchange rate changes with the market.":"Der Wechselkurs ändert sich mit dem Markt.","The higher the fee, the greater the incentive a miner has to include that transaction in a block. Current fees are determined based on network load and the selected policy.":"Je höher die Gebühr, desto größer ist der Anreiz das ein \"Miner\" die Transaktion in einem \"Block\" inkludiert. Aktuelle Gebühren werden anhand der Netzauslastung und der ausgewählten Richtlinie bestimmt.","The maximum number of consecutive unused addresses (20) has been reached. When one of your unused addresses receives a payment, a new address will be generated and shown in your Receive tab.":"Die maximale Anzahl aufeinander folgender ungenutzter Adressen (20) wurde erreicht. Wenn eine Ihrer ungenutzten Adressen eine Zahlung erhält wird eine neue Adresse erzeugt und in der Registerkarte \"Empfangen\" gezeigt.","The official English Terms of Service are available on the BitPay website.":"Die offizielle englischen Nutzungsbedingungen sind auf der BitPay Website verfügbar.","The password of the recovery phrase (if set)":"Das Passwort der Wiederherstellungsphrase (wenn eingestellt)","The payment was created but could not be completed. Please try again from home screen":"Die Zahlung wurde erzeugt, kann aber nicht abgeschlossen werden. Bitte erneut über die Startseite versuchen","The payment was removed by creator":"Die Zahlung wurde vom Ersteller entfernt","The recovery phrase could require a password to be imported":"Um die Wiederherstellungsphrase zu importieren könnte ein Passwort nötig sein","The request could not be understood by the server":"Die Anforderung konnte nicht vom Server interpretiert werden","The restore process will stop when 20 addresses are generated in a row which contain no funds. To safely generate more addresses, make a payment to one of the unused addresses which has already been generated.":"Der Wiederherstellungsvorgang wird beendet wenn 20 hintereinander generierte Adressen keinen Betrag erhalten. Um sicher mehr Adressen generieren zu können führen Sie eine Zahlung zu einer der ungenutzten Adressen durch welche bereits erzeugt wurden.","The spend proposal is not pending":"Der Zahlungsvorschlag ist nicht ausstehend","The total amount of bitcoin stored in this wallet.":"Der Gesamtbetrag an Bitcoins vorrätig in dieser Wallet.","The transaction history and every new incoming transaction are cached in the app. This feature clean this up and synchronizes again from the server":"Die Transaktionshistorie und jede neue eingehende Transaktion werden in der App zwischengespeichert. Diese Funktion bereinigt dies und synchronisiert erneut vom Server","The wallet service URL":"Die URL des Wallet-Diensts","There is a new version of {{appName}} available":"Es steht eine neue Version von {{appName}} zur Verfügung","There is an error in the form":"Es ist ein Fehler im Formular aufgetreten","There's obviously something we're doing wrong.":"Hier ist offensichtlich etwas was wir falsch machen.","This app is fantastic!":"Diese App ist fantastisch!","This app stores your bitcoin with cutting-edge security.":"Diese App speichert Ihre Bitcoins mit modernster Sicherheit.","This bitcoin payment request has expired.":"Diese Qybcoin Zahlungsaufforderung ist abgelaufen.","This password cannot be recovered. If the password is lost, there is no way you could recover your funds.":"Dieses Passwort kann nicht wiederhergestellt werden. Wenn das Passwort verloren gegangen ist gibt es keine Möglichkeit mehr Ihr Geld zurück zu holen.","This recovery phrase was created with a password. To recover this wallet both the recovery phrase and password are needed.":"Diese Wiederherstellungsphrase entstand mit einem Passwort. Zur Wiederherstellung der Wallet sind die Wiederherstellungsphrase und das Passwort erforderlich.","This transaction could take a long time to confirm or could be dropped due to the low fees set by the sender":"Die Bestätigung dieser Transaktion kann sehr lange dauern oder verworfen werden, da vom Absender nur geringe Gebühren eingestellt wurden","This wallet is not registered at the given Bitcore Wallet Service (BWS). You can recreate it from the local information.":"Dieses Wallet ist nicht beim angegebenen Bitcore Wallet Service (BWS) registriert. Bitte aus den lokalen Informationen wiederherstellen","Timeline":"Zeitachse","To":"An","To get started, buy bitcoin or share your address. You can receive bitcoin from any wallet or service.":"Um loszulegen kaufe Bitcoins oder teilen Sie ihre Adresse. Sie können Bitcoins von jeder beliebigen Wallet oder von einem Dienstleister/Broker empfangen.","To get started, you'll need to create a bitcoin wallet and get some bitcoin.":"Um loszulegen müssen Sie eine Qybcoin-Wallet erstellen und einige Bitcoins erhalten.","Total":"Gesamt","Total Locked Balance":"Ingesamt gesperrter Gesamtsaldo","Total number of copayers":"Gesamtanzahl der Copayer","Touch ID Failed":"Touch-ID gescheitert","Transaction":"Transaktion","Transaction History":"Transaktionsverlauf","Transaction already broadcasted":"Transaktion wurde bereits übermittelt","Transaction not available at this time":"Transaktion ist zu diesem Zeitpunkt nicht verfügbar","Transaction not found":"Transaktion konnte nicht gefunden werden","Transfer to Wallet":"Übertragung zur Wallet","Try again in {{expires}}":"Versuchen Sie es erneut in {{expires}}","Turn bitcoin into dollars, swipe anywhere Visa<sup>®</sup> is accepted.":"Wechseln Sie Bitcoins in Dollar, wechseln Sie überall wo Visa<sup>&reg;</sup> akzeptiert wird.","Type the Recovery Phrase (usually 12 words)":"Wiederherstellungsphrase eingeben (in der Regel 12 Wörter)","Uh oh...":"Uh oh...","Unconfirmed":"Unbestätigt","Unsent transactions":"Nicht vesendete Transaktionen","Unused Addresses":"Nicht verwendete Adressen","Unused Addresses Limit":"Nicht genutzte Adressen Limit","Update Available":"Aktualisierung verfügbar","Updating pending proposals. Please stand by":"Aktualisiere anstehende Vorschläge. Bitte warten","Updating transaction history. Please stand by.":"Aktualisieren des Transaktionsverlaufs. Bitte warten.","Updating... Please stand by":"Aktualisiere... Bitte warten","Urgent":"Dringend","Use Unconfirmed Funds":"Unbestätigte Mittel einsetzen","Validating recovery phrase...":"Überprüfe Wiederherstellungsphrase...","Version":"Version","View":"Ansicht","View All Addresses":"Alle Adressen anzeigen","View Terms of Service":"Nutzungsbedingungen anzeigen","View Transaction on Insight":"Transaktionen auf Insight anzeigen","View Update":"Aktualisierungen anzeigen","View on blockchain":"Auf blockchain anzeigen","WARNING: Key derivation is not working on this device/wallet. Actions cannot be performed on this wallet.":"Warnung: Ableitung der Schlüssel funktioniert nicht auf diesem Gerät/Wallet. Aktionen können nicht mit dieser Wallet durchgeführt werden.","WARNING: Not including the private key allows to check the wallet balance, transaction history, and create spend proposals from the export. However, does not allow to approve (sign) proposals, so <b>funds will not be accessible from the export</b>.":"WARNUNG: Ohne das Hinzufügen des privaten Schlüssels, ist es möglich das Guthaben und die Transaktionshistorie einzusehen, sowie Zahlungsvorschläge zu erzeugen. Allerdings können Vorschläge nicht ausgeführt (unterschrieben) werden und es ist <b>kein Zugriff auf Guthaben möglich</b>.","WARNING: The private key of this wallet is not available. The export allows to check the wallet balance, transaction history, and create spend proposals from the export. However, does not allow to approve (sign) proposals, so <b>funds will not be accessible from the export</b>.":"WARNUNG: Der private Schlüssel ist nicht verfügbar. Dieser Export ermöglicht das Guthaben und die Transaktionshistorie zu prüfen, sowie Zahlungsvorschläge zu erzeugen. Allerdings können Vorschläge nicht ausgeführt (unterschrieben) werden und so ist <b>kein Zugriff auf Guthaben möglich</b>.","WARNING: UNTRUSTED CERTIFICATE":"WARNUNG: NICHT VERTRAUENSWÜRDIGES ZERTIFIKAT","Waiting for Ledger...":"Warte auf Ledger...","Waiting for Trezor...":"Warte auf Trezor...","Waiting for copayers":"Warte auf copayer","Waiting...":"Warte...","Wallet Addresses":"Wallet-Adressen","Wallet Color":"Wallet-Farbe","Wallet Configuration (m-n)":"Wallet-Konfiguration (m-n)","Wallet Created":"Wallet erstellt","Wallet Id":"Wallet-Id","Wallet Information":"Wallet-Informationen","Wallet Invitation":"Wallet Einladung","Wallet Key":"Wallet-Schlüssel","Wallet Name":"Wallet-Name","Wallet Name (at creation)":"Wallet-Name (bei der Erzeugung)","Wallet Network":"Wallet-Netzwerk","Wallet Recovery Phrase":"Wallet-Wiederherstellungsphrase","Wallet Recovery Phrase is invalid":"Wallet-Wiederherstellungsphrase ist ungültig","Wallet Service URL":"URL des Wallet-Diensts","Wallet Settings":"Wallet-Einstellungen","Wallet Type":"Wallet-Typ","Wallet already exists":"Wallet exstiert bereits","Wallet created":"Wallet erstellt","Wallet incomplete and broken":"Wallet unvollständig oder defekt","Wallet is full":"Maximale Teilnehmerzahl erreicht","Wallet is locked":"Wallet ist gesperrt","Wallet is not complete":"Wallet ist unvollständig","Wallet name":"Name des Wallets","Wallet needs backup":"Wallet braucht Sicherung","Wallet not backed up":"Wallet nicht gesichert","Wallet not found":"Wallet nicht gefunden","Wallet not registered":"Wallet nicht registriert","Wallet not registered at the wallet service. Recreate it from \"Create Wallet\" using \"Advanced Options\" to set your recovery phrase":"Wallet ist nicht beim Wallet-Service registiert. Neu erzeugen mit \"Neues Wallet erzeugen\" und \"Erweiterte Optionen\" um die Wiederherstellungsphrase anzugeben","Wallet service not found":"Wallet-Dienst nicht gefunden","Wallets":"Wallets","Warning!":"Warnung!","Warning: this transaction has unconfirmed inputs":"Warnung: Diese Transaktion hat unbestätigte Eingänge","Watch out!":"Aufgepasst!","We'd love to do better.":"Wir würden es gerne besser machen.","We'll confirm on the next screen.":"Wir werden es auf der nächsten Seite bestätigen.","We're always looking for ways to improve {{appName}}.":"Wir sind immer auf der Suche nach Möglichkeiten um {{appName}} zu verbessern.","We're always looking for ways to improve {{appName}}. How could we improve your experience?":"Wir sind immer auf der Suche nach Möglichkeiten um {{appName}} zu verbessern. Wie können wir Ihr Erlebnis verbessern?","We’re always looking for translation contributions! You can make corrections or help to make this app available in your native language by joining our community on Crowdin.":"Wir sind immer auf der Suche nach Übersetzungs-Beiträge! Sie können Korrekturen vornehmen oder helfen diese App in Ihrer Muttersprache zur Verfügung stellen, durch den Beitritt unserer Community bei Crowdin.","What do you call this wallet?":"Wie möchten Sie diese Wallet benennen?","When this wallet was created, it was called “{{walletName}}”. You can change the name displayed on this device below.":"Zu dem Zeitpunkt an dem diese Wallet erstellt wurde, wurde Sie &ldquo;{{walletName}}&rdquo; benannt. Sie können auf diesem Gerät den unten angezeigten Namen ändern.","Where would you like to receive email notifications about payments?":"Wo möchten Sie E-Mail Benachrichtigungen über Zahlungen erhalten?","Why?":"Warum?","Would you be willing to rate {{appName}} in the app store?":"Wären Sie bereit {{appName}} im App Store zu bewerten?","Would you like to receive push notifications about payments?":"Möchten Sie Push-Benachrichtigungen über Zahlungen erhalten?","Wrong number of recovery words:":"Falsche Anzahl von Wiederherstellungswörtern:","Wrong spending password":"Falscher Berechtigungscode","Yes":"Ja","Yes, skip":"Ja, überspringen","You can create a backup later from your wallet settings.":"Sie können später eine Sicherung über Ihren Wallet-Einstellungen erstellen.","You can make contributions by signing up on our Crowdin community translation website. We’re looking forward to hearing from you!":"Sie können Beiträge leisten indem Sie sich auf unserer Crowdin Community Übersetzungs-Website registrieren. Wir freuen uns darauf von Ihnen zu hören!","You can scan bitcoin addresses, payment requests, paper wallets, and more.":"Sie können Qybcoin-Adressen, Zahlungsaufforderungen, Papier-Wallets und mehr scannen.","You can see the latest developments and contribute to this open source app by visiting our project on GitHub.":"Sie können auf GitHub die neuesten Entwicklungen ansehen und zu dieser Open-Source App beitragen.","You can spend bitcoin at millions of websites and stores worldwide.":"Sie können Bitcoins auf Millionen von Webseiten und Shops weltweit ausgeben.","You can still export it from Advanced &gt; Export.":"Sie können es auch exportieren aus dem Erweiterten &gt; Export.","You can trade it for other currencies like US Dollars, Euros, or Pounds.":"Sie können auch mit andere Währungen wie US-Dollar, Euro oder Pfund handeln.","You control your bitcoin.":"Sie kontrollieren Ihre Bitcoins.","You'll receive email notifications about payments sent and received from your wallets.":"Sie erhalten E-Mail Benachrichtigungen über gesendete und empfangen Zahlungen aus Ihren Wallets.","Your bitcoin wallet is backed up!":"Ihre Qybcoin-Wallet wurde gesichert!","Your bitcoin wallet is ready!":"Ihre Qybcoin-Wallet ist fertig!","Your ideas, feedback, or comments":"Ihre Ideen, Feedback oder Kommentare","Your name":"Ihr Name","Your nickname":"Name des Teilnehmers","Your password":"Passwort","Your wallet is never saved to cloud storage or standard device backups.":"Ihre Wallet wird nie auf einem Cloud-Speicher oder einer Standard-Geräte-Backup gespeichert.","Your wallet key will be encrypted. The Spending Password cannot be recovered. Be sure to write it down.":"Ihre Wallet wird verschlüsselt. Der Berechtigungscode kann nicht wiederhergestellt werden. Achten Sie darauf ihn aufzuschreiben.","[Balance Hidden]":"[Guthaben versteckt]","add your BitPay Visa card(s)":"Ihre BitPay Visa Karte(n) hinzufügen","locked by pending payments":"durch ausstehende Zahlungen gesperrt","me":"Ich","name@example.com":"name@beispiel.com","preparing...":"in Arbeit...","{{appName}} depends on Bitcore Wallet Service (BWS) for blockchain information, networking and Copayer synchronization. The default configuration points to https://bws.bitpay.com (BitPay's public BWS instance).":"{{appName}} hängt von Bitcore Wallet Service (BWS) ab bezüglich Blockchain Informationen, Vernetzung und Copayer Synchronisation. Die Standard Konfiguration verweist auf https://bws.bitpay.com (BitPays öffentlicher BWS Instanz).","{{fee}} will be deducted for bitcoin networking fees.":"{{fee}} wird für Qybcoin-Netzwerkgebühren abgezogen werden.","{{updatingTxHistoryProgress}} transactions downloaded":"{{updatingTxHistoryProgress}} Transaktionen werden heruntergeladen","{{wallet.m}}-of-{{wallet.n}}":"{{wallet.m}}-von-{{wallet.n}}"});
    gettextCatalog.setStrings('es', {"(Trusted)":"(De confianza)","(possible double spend)":"(Posible doble gasto)","* A payment proposal can be deleted if 1) you are the creator, and no other copayer has signed, or 2) 24 hours have passed since the proposal was created.":"* Una propuesta de pago puede ser eliminada si 1) Tú eres el creador, y ningún otro copayer la haya firmado, o 2) hayan transcurrido 24 horas desde la creación de la propuesta.","- {{btx.feeRateStr}} of the transaction":"- {{btx.feeRateStr}} de la transacción","- {{tx.feeRateStr}} of the transaction":"- {{tx.feeRateStr}} de la transacción","5-star ratings help us get {{appName}} into more hands, and more users means more resources can be committed to the app!":"Una calificación de 5 estrellas nos ayuda a que {{appName}} sea más utilizado, mientras más usuarios más son las razones para seguir comprometidos con esta aplicación!","<b>Only</b> redeemable on Mercado Livre (Brazil)":"<b>Solo</b> canjeable en Mercado Livre (Brasil)","A member of the team will review your feedback as soon as possible.":"Un miembro del equipo revisará tus comentarios tan pronto como sea posible.","A total of {{amountAboveMaxSizeStr}} were excluded. The maximum size allowed for a transaction was exceeded.":"Se excluyeron un total de {{amountAboveMaxSizeStr}}. Fue excedido el tamaño máximo permitido para una transacción.","A total of {{amountBelowFeeStr}} were excluded. These funds come from UTXOs smaller than the network fee provided.":"Se excluyeron un total de {{amountBelowFeeStr}}. Estos fondos provienen del UTXOs más pequeños que la comisión de red provista.","About":"Acerca de","Accepted":"Aceptada","Account":"Cuenta","Account Number":"Número de cuenta","Accounts":"Cuentas","Activity":"Actividad","Add Account":"Agregar Cuenta","Add BitPay Account?":"¿Agregar cuenta de BitPay?","Add Contact":"Agregar contacto","Add Funds":"Añadir fondos","Add Memo":"Añadir nota","Add a password":"Agregar una contraseña","Add account":"Agregar cuenta","Add an optional password to secure the recovery phrase":"Agregar una contraseña opcional para asegurar la frase de recuperación","Add as a contact":"Agregar como Contacto","Add description":"Añadir descripción","Add funds":"Agregar fondos","Add this BitPay account ({{email}})?":"¿Agregar esta cuenta BitPay ({{email}})?","Add wallet":"Agregar billetera","Address":"Dirección","Address Book":"Agenda de contactos","Address Type":"Tipo de dirección","Addresses With Balance":"Direcciones con fondos","Advanced":"Avanzado","Advanced Settings":"Preferencias Avanzadas","All":"Todos","All Addresses":"Todas las direcciones","All of your bitcoin wallet balance may not be available for immediate spending.":"Todo el balance de tu billetera puede que no esté disponible para su uso inmediato.","All signing devices must be added to this multisig wallet before bitcoin addresses can be created.":"Todos los dispositivos de los firmantes deben ser agregados a esta billetera compartido antes de que se puedan crear direcciones bitcoin.","Allow Camera Access":"Permitir el acceso de la cámara","Allow notifications":"Permitir notificaciones","Almost done! Let's review.":"¡Casi listo! Vamos a revisar.","Alternative Currency":"Moneda Alternativa","Amazon.com is not available at this moment. Please try back later.":"Amazon.com no está disponible en este momento. Inténtalo de nuevo más tarde.","Amount":"Importe","Amount below minimum allowed":"Cantidad por debajo del mínimo permitido","Amount too big":"Monto demasiado grande","Amount too low to spend":"Monto insuficiente para enviar","An update to this app is available. For your security, please update to the latest version.":"Actualización disponible. Por seguridad, actualiza a la versión más reciente.","Anyone with your backup phrase can access or spend your bitcoin.":"Cualquier persona con tu copia de seguridad puede gastar tus bitcoins.","Approximate Qybcoin network fee to transfer wallet's balance (with normal priority)":"Comisión aproximada de la red Qybcoin para transferir el saldo de esta billetera (con prioridad normal)","Are you being watched?":"¿Estás siendo observado?","Are you being watched? Anyone with your recovery phrase can access or spend your bitcoin.":"¿Estás siendo observado? Cualquier persona con tu copia de seguridad puede gastar tus bitcoins.","Are you sure you want to cancel and delete this wallet?":"¿Estás seguro de cancelar y borrar esta billetera?","Are you sure you want to delete this contact?":"¿Está seguro de que desea eliminar este contacto?","Are you sure you want to delete this wallet?":"¿Estás seguro de borrar esta billetera?","Are you sure you want to reject this transaction?":"¿Estás seguro de rechazar esta transacción?","Are you sure you want to remove this transaction?":"¿Estás seguro de eliminar esta transacción?","Are you sure you want to skip it?":"¿Estás seguro de omitirla?","Are you sure you would like to log out of your BitPay Card account?":"¿Está seguro que desea cerrar la sesión de su cuenta BitPay Card?","Are you sure you would like to remove your BitPay Card ({{lastFourDigits}}) from this device?":"¿Estás seguro de quitar tu BitPay Card ({{lastFourDigits}}) de este dispositivo?","Auditable":"Auditables","Available":"Disponible","Available Balance":"Balance disponible","Average confirmation time":"Tiempo promedio de confirmación","BIP32 path for address derivation":"BIP32 para el camino de derivación de direcciones","QYB wallets":"Billeteras QYB","Backup":"Copia de seguridad","Backup Needed":"Se necesita copia de seguridad","Backup all livenet wallets before using this function":"Debes respaldar todas tus billeteras para utilizar esta función","Backup needed":"Necesita respaldar","Backup now":"Realizar copia de seguridad","Backup wallet":"Respaldar","Backup your wallet before using this function":"Respalda tu billetera para utilizar esta función","Bad wallet invitation":"Invitación incorrecta a la billetera","Balance By Address":"Balance por Dirección","Be sure to store your recovery phrase in a secure place. If this app is deleted, your money cannot be recovered without it.":"Asegúrate de guardar la frase de recuperación en un lugar seguro. Si se elimina esta aplicación, no se podrá recuperar el dinero.","BitPay Visa® Cards":"Tarjetas BitPay Visa&reg;","Qybcoin Address":"Dirección Qybcoin","Qybcoin Cash Wallets":"Billeteras Qybcoin Cash","Qybcoin Network Fee Policy":"Política de Comisión de la Red Qybcoin","Qybcoin Wallets":"Billeteras Qybcoin","Qybcoin cash Payment":"Pago en Qybcoin cash","Qybcoin is a currency.":"Qybcoin es una moneda.","Qybcoin is different – it cannot be safely held with a bank or web service.":"Qybcoin es diferente &ndash; no se puede resguardar con ningún servicio web o banco.","Qybcoin is secure,<br>digital money.":"Qybcoin es seguro,<br> dinero digital.","Qybcoin transactions include a fee collected by miners on the network.":"Las transacciones de bitcoins incluyen una comisión recogida por los mineros de la red.","Bought {{amountUnitStr}}":"Compró {{amountUnitStr}}","Broadcast Payment":"Enviar Pago","Broadcasted":"Enviado","Broadcasting transaction":"Finalizando transacción","Browser unsupported":"Navegador no soportado","Buy":"Comprar","Buy &amp; Sell Qybcoin":"Comprar &amp; Vender Qybcoin","Buy Qybcoin":"Comprar Qybcoin","Buy a Gift Card":"Comprar una Tarjeta de Regalo","Buy from":"Comprar desde","Buying Qybcoin...":"Comprando Bitcoins...","Calculating fee":"Calculando comisión","Cancel":"Cancelar","Cancel invitation":"Cancelar invitación","Cannot Create Wallet":"No se pudo crear la billetera","Cannot join the same wallet more that once":"No puede unirse a la misma billetera más de una vez","Cards":"Tarjetas","Certified by":"Certificado por","Check installation and retry.":"Comproba la instalación y reintenta.","Choose a backup file from your computer":"Selecciona el archivo de copia de seguridad de tu computadora","Choose your destination wallet":"Elegir billetera destino","Choose your source wallet":"Elegir billetera de origen","Clear":"Anular","Clear cache":"Limpiar cache","Click to accept":"Click para aceptar","Click to pay":"Click para pagar","Click to send":"Click para enviar","Close":"Cerrar","Coin":"Moneda","Color":"Color","Commit hash":"Commit hash","Complete the backup process to use this option":"Completar el proceso de respaldo para usar esta opción","Completed":"Terminadas","Confirm":"Confirmar","Confirm &amp; Finish":"Confirmar y terminar","Confirm purchase":"Confirmar compra","Confirm your PIN":"Confirma tu PIN","Confirm your new spending password":"Confirme su contraseña para enviar","Confirmations":"Confirmaciones","Confirming":"Confirmando","Connect my BitPay Card":"Conecte mi BitPay Card","Connecting to Coinbase...":"Conectando a Coinbase...","Connecting to Glidera...":"Conectando a Glidera...","Connection reset by peer":"Conexión re establecida","Contacts":"Contactos","Continue":"Continuar","Contribute Translations":"Contribuir","Qyb only supports Qybcoin Cash using new version numbers addresses":"Qyb sólo soporta Qybcoin Cash utilizando la nueva versión de direcciones","Copayer already in this wallet":"Ya se encuentra en esta billetera","Copayer already voted on this spend proposal":"Ya votaste en esta propuesta de gasto","Copayer data mismatch":"Discrepancia en los datos del Copayer","Copayer joined":"Copayer unido","Copayer {{$index}}":"Copayer {{$index}}","Copied to clipboard":"Copiado al portapapeles","Copy this text as it is to a safe place (notepad or email)":"Copiar el texto como está en un lugar seguro (bloc de notas o correo electrónico)","Copy to clipboard":"Copiar al portapapeles","Could not access Gift Card Service":"No se pudo acceder a Gift Card Service","Could not access the wallet at the server. Please check:":"No se pudo acceder a la billetera desde el servidor. Por favor verificar:","Could not access to Amazon.com":"No se pudo acceder a Amazon.com","Could not access wallet":"No se pudo acceder a la billetera","Could not add message to imported wallet without shared encrypting key":"No se puede agregar mensajes a una billetera importada sin la clave cifrada compartida","Could not broadcast payment":"No se pudo enviar el pago","Could not build transaction":"No se pudo construir la transacción","Could not create address":"No se pudo crear la dirección","Could not create the invoice":"No se pudo crear la factura","Could not create transaction":"No se pudo crear la transacción","Could not create using the specified extended private key":"No se pudo crear la billetera usando la clave privada ingresada","Could not create using the specified extended public key":"No se pudo crear con la clave pública extendida especificada","Could not create: Invalid wallet recovery phrase":"No se pudo crear: frase de recuperación inválida","Could not decrypt file, check your password":"No se pudo descifrar el archivo, verifique su contraseña","Could not delete payment proposal":"No se pudo eliminar la propuesta de pago","Could not duplicate":"No se pudo duplicar","Could not get dynamic fee":"No se pudo obtener comisión dinámica","Could not get dynamic fee for level: {{feeLevel}}":"No se pudo obtener comisión dinámica: {{feeLevel}}","Could not get fee levels":"No se pudieron obtener los niveles de comisión","Could not get the invoice":"No se pudo obtener la factura","Could not get transactions":"No se pudo obtener las transacciones","Could not import":"No se pudo importar","Could not import. Check input file and spending password":"No se pudo importar. Verifique el archivo y la contraseña para pagos","Could not join wallet":"No se pudo unir a la billetera","Could not reject payment":"No se pudo rechazar el pago","Could not remove account":"No se pudo eliminar la cuenta","Could not remove card":"No se pudo quitar tarjeta","Could not save preferences on the server":"No se pueden guardar las preferencias en el servidor","Could not send payment":"No se pudo enviar el pago","Could not send transaction":"No se pudo enviar la transacción","Could not update transaction history":"No se pudo actualizar el historial de transacciones","Could not update wallet":"No se pudo actualizar la billetera","Create Personal Wallet":"Crear billetera Personal","Create Shared Wallet":"Crear billetera compartida","Create bitcoin wallet":"Crear billetera","Create new wallet":"Crear billetera nueva","Create shared wallet":"Crear billetera compartida","Create {{formData.requiredCopayers}}-of-{{formData.totalCopayers}} wallet":"Crear billetera {{formData.requiredCopayers}}-de-{{formData.totalCopayers}}","Created by":"Creado por","Creating Wallet...":"Creando billetera...","Creating transaction":"Creando transacción","Current fee rate for this policy":"Tarifa actual de esta política","Custom":"Personalizado","Custom Amount":"Importe Específico","Custom Fee":"Comisión personalizada","Date":"Fecha","Delete":"Eliminar","Delete Payment Proposal":"Eliminar Propuesta de Pago","Delete Wallet":"Eliminar billetera","Delete it and create a new one":"Borrar y crear uno nuevo","Deleting Wallet...":"Eliminando billetera...","Deleting payment proposal":"Eliminando la propuesta de pago","Derivation Path":"Camino de derivación","Derivation Strategy":"Estrategia de derivación","Details":"Detalles","Disabled":"Deshabilitado","Do it later":"Luego","Do not include private key":"No incluir la clave privada","Don't see your language on Crowdin? Contact the Owner on Crowdin! We'd love to support your language.":"¿No ves tu idioma en Crowdin? Contacta con el encargado del proyecto! Nos encantaría soportar tu idioma.","Download":"Descargar","Duplicate for dmb":"Duplicar a dmb","Duplicating wallet...":"Duplicando billetera...","Each bitcoin wallet can generate billions of addresses from your 12-word backup. A new address is automatically generated and shown each time you receive a payment.":"Cada billetera puede generar billones de direcciones desde sus 12 palabras. Se genera una nueva dirección automáticamente cada vez que se recibe un pago.","Economy":"Económico","Edit":"Editar","Email":"Correo electrónico","Email Address":"Dirección de correo electrónico","Empty addresses limit reached. New addresses cannot be generated.":"Se ha alcanzado el límite de direcciones vacías. No se pueden generar nuevas direcciones.","Enable camera access in your device settings to get started.":"Habilitar el acceso de la cámara en su configuración de dispositivo para empezar.","Enable email notifications":"Activar notificaciones de correo electrónico","Enable push notifications":"Activar notificaciones push","Enable the camera to get started.":"Activar la cámara empezar.","Enter Spending Password":"Ingrese contraseña para pagos","Enter Two Factor for your BitPay account":"Ingrese Autenticación de Dos Pasos para su cuenta de BitPay","Enter amount":"Ingrese el monto","Enter custom fee":"Ingrese comisión","Enter new spending password":"Ingrese una nueva contraseña para pagos","Enter the recovery phrase (BIP39)":"Introduce la frase de recuperación (BIP39)","Enter your email":"Ingresa tu correo electrónico","Enter your password":"Ingrese su contraseña","Error":"Error","Error at confirm":"Error al confirmar","Error creating gift card":"Error al crear tarjeta de regalo","Error creating the invoice":"Error al crear la factura","Error creating wallet":"Error al crear billetera","Error getting SendMax information":"Error al obtener información de SendMax","Error in Payment Protocol":"Error en el Protocolo de Pago","Error pairing BitPay Account":"Error de sincronización con la cuenta de BitPay","Error scanning funds:":"Error al escanear fondos:","Error sweeping wallet:":"Error al buscar fondos:","Error updating Debit Cards":"Error al actualizar las tarjetas de débito","Exceeded daily limit of $500 per user":"Se excedió el limite de $500 por usuario","Expired":"Expirada","Expires":"Expira","Export Wallet":"Exportar billetera","Export to file":"Exportar a archivo","Export wallet":"Exportar billetera","Exporting via QR not supported for this wallet":"Exportar vía código QR no es compatible para esta billetera","Extended Private Key":"Clave Privada Extendida","Extended Public Keys":"Claves Públicas Extendidas","Extracting Wallet information...":"Obteniendo Información de la billetera...","Failed to export":"Error al exportar","Family vacation funds":"Fondos para vacaciones en familia","Fee":"Comisión","Fee level":"Nivel de comisión","Fee level is not defined":"El nivel de comisión no esta definido","Fee:":"Comisión:","Feedback could not be submitted. Please try again later.":"No se pudo enviar el comentario. Por favor intente nuevamente.","Fetching BitPay Account...":"Buscando Cuenta de BitPay...","Fetching payment information":"Obteniendo información del pago","File/Text":"Archivo/Texto","Filter setting":"Ajuste de filtro","Finger Scan Failed":"Fallo en la verificación de la huella","Finish":"Finalizar","For audit purposes":"Para propósitos de auditoría","From":"Desde","From BitPay account":"De la cuenta de BitPay","From Hardware Wallet":"Billetera Física","From the destination device, go to Add wallet &gt; Import wallet and scan this QR code":"Desde el dispositivo de destino, ir a Agregar billetera &gt; Importar y escanear este código QR","Funds are locked by pending spend proposals":"Los fondos están bloqueados por propuestas de gastos pendientes","Funds found:":"Fondos encontrados:","Funds to be added":"Fondos a agregar","Funds transferred":"Fondos transferidos","Funds were added to debit card":"Los fondos se agregaron a la tarjeta de débito","Funds will be transferred to":"Los fondos serán transferidos a","Generate new address":"Generar nueva dirección","Generating .csv file...":"Generando archivo .csv...","Generating new address...":"Generando una nueva dirección...","Get local cash anywhere you go, from any Visa<sup>®</sup> compatible ATM. ATM bank fees may apply.":"Consigue efectivo local dondequiera que vayas, desde cualquier ATM Visa<sup>&reg;</sup> compatible. Comisión de parte del ATM pueden ser aplicadas.","Get news and updates from BitPay":"Recibir noticias y actualizaciones de BitPay","Get started":{"$$noContext":"Empezar","button":"Comenzar"},"Get started by adding your first one.":"Comienza agregando el primero.","Getting fee levels...":"Obteniendo niveles de comisión...","Gift Card":"Tarjeta de Regalo","Gift Card is not available to use anymore":"La Tarjeta de Regalo ya no esta disponible para usar","Gift card expired":"La tarjeta de regalo expiró","Gift card generated and ready to use.":"Tarjeta de regalo generada y lista para usar.","Go Back":"Volver","Go back":"Volver","Got it":"Entiendo","Hardware Wallet":"Billetera Física","Hardware not connected.":"Equipo no conectado.","Hardware wallet":"Billetera física","Hardware wallets are not yet supported with Qybcoin Cash":"Billeteras en hardware no son compatibles con Qybcoin Cash todavía","Help & Support":"Ayuda & Soporte","Help and support information is available at the website.":"La ayuda está disponible en el sitio web.","Hide":"Ocultar","Hide Balance":"Balance Oculto","Hide Next Steps Card":"Ocultar Tarjeta de Próximo Pasos","Hide advanced options":"Ocultar opciones avanzadas","Home":"Inicio","How could we improve your experience?":"¿Cómo podríamos mejorar tu experiencia?","How do you like {{appName}}?":"¿Te gusta {{appName}}?","I don't like it":"No me gusta","I have read, understood, and agree to the <a ng-click=\"openTerms()\" translate=\"\">Terms of Use</a>.":"He leído, entendido y acepto los <a ng-click=\"openTerms()\" translate=\"\">Términos de Uso</a>.","I have read, understood, and agree with the Terms of use.":"He leído, entendido y acepto los Términos de uso.","I have written it down":"Ya he anotado","I like the app":"Me gusta la aplicación","I think this app is terrible.":"Creo que esta aplicación es terrible.","I understand":"Entiendo","I understand that if this app is moved to another device or deleted, my bitcoin can only be recovered with the backup phrase.":"Entiendo que si esta aplicación es borrada, mis fondos pueden recuperarse únicamente con la copia de seguridad.","I understand that my funds are held securely on this device, not by a company.":"Entiendo que mis fondos están protegidos por el dispositivo y no por una empresa.","I've written it down":"Ya he anotado","If enabled, all sensitive information (private key and recovery phrase) and actions (spending and exporting) associated with this wallet will be protected.":"Si está habilitado, se protegerá toda información sensible (clave privada y frase recuperación) y acciones (gastar y exportar) asociadas con esta billetera.","If enabled, the Recent Transactions card - a list of transactions occuring across all wallets - will appear in the Home tab.":"Si se habilita, aparecerá una lista de las transacciones recientes de las billeteras en el inicio.","If enabled, wallets will also try to spend unconfirmed funds. This option may cause transaction delays.":"Si se habilita, las billeteras podrán gastar los fondos sin confirmar. Esta opción puede causar demoras en la transacción.","If this device is replaced or this app is deleted, neither you nor BitPay can recover your funds without a backup.":"Si pierdes este dispositivo o esta aplicación es eliminada, ni tú ni BitPay podrán recuperar el dinero.","If you have additional feedback, please let us know by tapping the \"Send feedback\" option in the Settings tab.":"Si tienes comentarios adicionales, por favor envíalos pulsando la opción \"Enviar comentarios\" en la pestaña de preferencias.","If you take a screenshot, your backup may be viewed by other apps. You can make a safe backup with physical paper and a pen.":"Si tomas una captura de pantalla, otras aplicaciones podrían ver tu copia de seguridad. La forma más acertada es resguardarla con tinta y papel.","Import":"Importar","Import Wallet":"Importar billetera","Import backup":"Importar copia de seguridad","Import wallet":"Importar billetera","Importing Wallet...":"Importando billetera...","In order to verify your wallet backup, please type your password.":"Para verificar la copia de seguridad de la billetera, por favor escriba la contraseña.","Inactive":"Inactivo","Incomplete":"Incompleta","Incomplete wallet":"Billetera Incompleta","Incorrect PIN, try again.":"PIN Incorrecto. Inténtelo de nuevo.","Incorrect code format":"Formato de código incorrecto","Incorrect network address":"Dirección de red incorrecta","Insufficient funds":"Fondos insuficientes","Insufficient funds for fee":"Fondos insuficientes para el pago de la comisión","Integrations":"Integraciones","Invalid":"Inválido","Invalid URL":"URL incorrecta","Invalid account number":"Número de cuenta inválido","Invalid address":"Dirección inválida","Invalid data":"Datos no válidos","Invalid derivation path":"Camino de derivación no válido","Invitation to share a {{appName}} Wallet":"Invitación para unirse a la billetera {{appName}} compartida","Invoice expired":"Factura vencida","Is there anything we could do better?":"¿Hay algo que podríamos mejorar?","Is this correct?":"¿Es correcto?","Is this email address correct?":"¿Es correcta esta dirección de correo electrónico?","It's a good idea to avoid reusing addresses - this both protects your privacy and keeps your bitcoins secure against hypothetical attacks by quantum computers.":"Es una buena idea evitar el reuso de las direcciones. Esto protege tu privacidad y mantiene tus fondos seguros contra hipotéticos ataques de ordenadores cuánticos.","It's important that you write your backup phrase down correctly. If something happens to your wallet, you'll need this backup to recover your money. Please review your backup and try again.":"Es importante que escribas correctamente la frase de seguridad. Si algo le pasa a tu billetera, necesitarás de ésta para recuperar el dinero. Revísala y vuelve a intentarlo.","Join":"Unirse","Join my {{appName}} Wallet. Here is the invitation code: {{secret}} You can download {{appName}} for your phone or desktop at {{appUrl}}":"Únete a mi billetera {{appName}}. Aquí está el código de invitación: {{secret}} puede descargar {{appName}} para su teléfono o escritorio en {{appUrl}}","Join shared wallet":"Unirse a una billetera compartida","Joining Wallet...":"Uniéndose a la billetera...","Just scan the code to pay.":"Sólo escanea y paga.","Key already associated with an existing wallet":"La clave ya esta asociada a un monedero existente","Language":"Idioma","Last Month":"Mes pasado","Learn more":"Más información","Let's verify your backup phrase.":"Verifiquemos la copia de seguridad.","Loading addresses...":"Cargando direcciones...","Loading transaction info...":"Cargando información de transacción...","Lock App":"Bloquear la aplicación","Lock by Fingerprint":"Bloquear por huella digital","Lock by PIN":"Bloquear por PIN","Locked":"Bloqueado","Locktime in effect. Please wait to create a new spend proposal":"Bloqueo temporal. Por favor espera para crear una nueva propuesta de gasto","Locktime in effect. Please wait to remove this spend proposal":"Bloqueo temporal. Por favor espera para eliminar esta propuesta de gasto","Log options":"Opciones de registro","Log out":"Cerrar Sesión","Low amount inputs":"Entradas de monto bajo","Low fees":"Comisión baja","Makes sense":"Entiendo","Matches:":"Coincidencias:","Me":"Yo","Meh - it's alright":"Buu - está bien","Memo":"Nota","Mercado Livre Brazil Gift Cards":"Tarjetas de Regalo Mercado Livre Brasil","Mercadolibre Gift Card Service is not available at this moment. Please try back later.":"Mercadolibre Gift Card Service no esta disponible en este momento. Por favor, inténtelo más tarde.","Merchant Message":"Mensaje del comerciante","Miner Fee":"Comisión de minado","Missing parameter":"Faltan parámetros","Missing private keys to sign":"Faltan las claves privadas para firmar","More Options":"Más opciones","Moved":"Movido","Moved Funds":"Fondos movidos","Multiple recipients":"Varios destinatarios","NOTE: To import a wallet from a 3rd party software, please go to Add Wallet &gt; Create Wallet, and specify the Recovery Phrase there.":"Nota: Para importar una billetera de un software de tercero debes ir a Añadir billetera &gt; Crear billetera, y especificar la frase de recuperación.","Name":"Nombre","Network Cost":"Costo de la red","Network error":"Error de red","New Proposal":"Nueva propuesta de pago","New address could not be generated. Please try again.":"No se pudo generar la nueva dirección. Por favor inténtalo de nuevo.","New personal wallet":"Nueva billetera personal","Next steps":"Próximos pasos","No Wallet":"Sin billetera","No access key defined":"No se ha definido la llave de acceso","No backup, no bitcoin.":"Sin copia de seguridad, no hay bitcoins.","No contacts yet":"Aun no hay contactos","No entries for this log level":"No hay entradas para este nivel de registro","No hardware information available.":"No hay información disponible sobre el equipo.","No hardware wallets supported on this device":"No hay billeteras físicas compatibles con este dispositivo","No pending proposals":"No propuestas de pago pendientes","No recent transactions":"No hay transacciones recientes","No signing proposal: No private key":"Propuesta sin firmar: No existe la clave privada","No transactions yet":"Aun no hay transacciones","No wallet found":"Se se encontró la billetera","No wallet selected":"No se seleccionó una billetera","No wallets available":"No hay billeteras disponibles","No wallets available to receive funds":"No hay billeteras disponibles para recibir fondos","No wallets eligible for Qybcoin Cash support":"No hay billeteras elegibles para soporte a Qybcoin Cash","Non BIP44 wallet":"Billetera no BIP44","Non eligible QYB wallets":"Billeteras QYB no elegibles","Normal":"Normal","Not authorized":"No autorizado","Not enough funds for fee":"No hay suficientes fondos para la comisión","Not even BitPay can access it.":"Ni siquiera BitPay puede acceder a ellos.","Not funds found":"No se encontraron fondos","Not now":"Ahora no","Note":"Nota","Note: if this dmb wallet was duplicated from a QYB wallet, they share the same recovery phrase.":"Nota: Si esta billetera dmb fue duplicada desde una billetera QYB, entonces comparten la misma frase de recuperación.","Notice: only 1-1 (single signature) wallets can be used for sell bitcoin":"Aviso: solo billeteras 1-1 (única firma) pueden ser utilizadas para vender bitcoin","Notifications":"Notificaciones","Notifications by email":"Notificaciones por correo electrónico","Notify me if confirmed":"Notificarme si se confirma","Notify me when transactions are confirmed":"Notificarme cuando se confirmen las transacciones","Now is a good time to backup your wallet. If this device is lost, it is impossible to access your funds without a backup.":"Es un buen momento para realizar una copia de seguridad de la billetera. Si este dispositivo se pierde, será imposible acceder a los fondos.","Now is a perfect time to assess your surroundings. Nearby windows? Hidden cameras? Shoulder-spies?":"Es el momento perfecto para mirar a tu alrededor. ¿ventanas? ¿cámaras? ¿gente curiosa?","OK":"OK","OKAY":"LISTO","Official English Disclaimer":"Renuncia oficial en inglés","Oh no!":"¡Oh no!","Ok":"Correcto","On this screen you can see all your wallets, accounts, and assets.":"En esta pantalla puedes ver tus billeteras, cuentas y activos.","Open":"Abrir","Open Crowdin":"Abrir Crowdin","Open GitHub":"Abrir GitHub","Open GitHub Project":"Abrir Proyecto en GitHub","Open Insight":"Abrir Insight","Open Settings":"Abrir Opciones","Open Translation Community":"Abrir Comunidad de Traducciones","Open Website":"Abrir Sitio Web","Open the recovery tool.":"Abrir herramienta de recuperación.","Open wallet":"Abrir billetera","Open website":"Abrir página web","Order the BitPay Card":"Solicitar BitPay Card","Password":"Contraseña","Password required. Make sure to enter your password in advanced options":"Se requiere contraseña. Asegúrate de introducirla en opciones avanzadas","Paste invitation here":"Pegar invitación aquí","Paste the backup plain text code":"Pegar copia de seguridad en texto plano","Pay 0% fees to turn bitcoin into dollars.":"Paga 0% de comisión para transformar tus bitcoin en dólares.","Pay To":"Pagar A","Payment Accepted":"Pago Aceptado","Payment Expires:":"Pago expira:","Payment Proposal":"Propuesta de Pago","Payment Proposal Created":"Propuesta de Pago Creada","Payment Proposals":"Propuestas de Pago","Payment Protocol Invalid":"Protocolo de Pago Inválido","Payment Protocol not supported on Chrome App":"El protocolo de pago no está soportado en Chrome","Payment Received":"Pago recibido","Payment Rejected":"Pago Rechazado","Payment Sent":"Pago Enviado","Payment accepted, but not yet broadcasted":"Pago aceptado, pero aún no fue enviado","Payment accepted. It will be broadcasted by Glidera. In case there is a problem, it can be deleted 6 hours after it was created.":"Pago aceptado. Se transmitirá por Glidera. En caso de que haya un problema, puedes eliminar la transacción 6 horas después de fue creada.","Payment address was translated to new Qybcoin Cash address format:":"La dirección de pago fue traducida al nuevo formato de Qybcoin Cash:","Payment details":"Detalles del pago","Payment request":"Solicitud de pago","Pending":"Pendiente","Pending Proposals":"Propuestas de pago pendientes","Permanently delete this wallet.":"Eliminar esta billetera de forma permanente.","Personal Wallet":"Billetera Personal","Please carefully write down this phrase.":"Por favor, anota cuidadosamente esta frase.","Please connect a camera to get started.":"Por favor, conecta una cámara para empezar.","Please enter the recovery phrase":"Por favor ingresa la frase de recuperación","Please enter the wallet recovery phrase":"Por favor ingresa la frase de recuperación de la billetera","Please enter your PIN":"Ingresá tu PIN","Please tap each word in the correct order.":"Escoje las palabras en el orden correcto.","Please upgrade Qyb to perform this action":"Por favor actualiza Qyb para realizar esta acción","Please wait":"Por favor espere","Please, select your backup file":"Por favor, selecciona el archivo de copia de seguridad","Pre-Auth Holds":"Pre-Auth Holds","Preferences":"Preferencias","Preparing addresses...":"Preparando direcciones...","Preparing backup...":"Preparando copia de seguridad...","Press again to exit":"Presione nuevamente para salir","Priority":"Prioritario","Private Key":"Clave privada","Private key encrypted. Enter password":"La clave privada está encriptada. Escriba la contraseña","Private key is encrypted, cannot sign":"La clave privada está encriptada, no puedes firmar","Proposal Accepted":"Propuesta Aceptada","Proposal Created":"Propuesta Creada","Proposal Deleted":"Propuesta Eliminada","Proposal Rejected":"Propuesta Rechazada","Proposals":"Propuestas","Purchase Amount is limited to {{limitPerDay}} {{currency}} per day":"El monto de la compra esta limitada a {{limitPerDay}} {{currency}} por día","Purchase amount must be a value between 50 and 2000":"El monto de la compra debe ser un valor entre 50 y 2000","Push Notifications":"Notificaciones Push","Push notifications for {{appName}} are currently disabled. Enable them in the Settings app.":"Notificaciones push para {{appName}} están deshabilitadas. Habilitarla en la configuración de la aplicación.","QR Code":"Código QR","Quick review!":"¡Revisión rápida!","Random":"Al azar","Rate on the app store":"Califica en la app store","Read less":"Mostrar menos","Read more":"Leer más","Read more in our Wiki":"Lee más en nuestra Wiki","Read only wallet":"Billetera solo lectura","Receive":"Recibir","Receive in":"Recibir en","Received":"Recibido","Received Funds":"Fondos recibidos","Receiving":"Recibiendo","Recent":"Recientes","Recent Transaction Card":"Tarjeta con transacciones recientes","Recent Transactions":"Transacciones Recientes","Recipient":"Destinatario","Recipients":"Destinatarios","Recovery phrase":"Frase de Recuperación","Recreating Wallet...":"Recreando billetera...","Redeem now":"Canjear ahora","Rejected":"Rechazado","Rejecting payment proposal":"Rechazando propuesta de pago","Release information":"Información de la versión","Remove":"Remover","Remove BitPay Account?":"¿Eliminar Cuenta de BitPay?","Remove BitPay Card?":"¿Eliminar BitPay Card?","Removing your BitPay account will remove all associated BitPay account data from this device. Are you sure you would like to remove your BitPay Account ({{email}}) from this device?":"Al eliminar una cuenta de BitPay se eliminarán todos los datos asociados de este dispositivo. ¿Desea realmente eliminar la cuenta de BitPay ({{email}}) del dispositivo?","Repeat password":"Escribe nuevamente la contraseña","Repeat the password":"Repetir la contraseña","Request Fingerprint":"Solicitar Huella Digital","Request Specific amount":"Solicitar importe Especifico","Request Spending Password":"Solicitar contraseña para pagos","Required number of signatures":"Número requerido de firmas","Restore from backup":"Restaurar desde copia de seguridad","Retrieving inputs information":"Recuperando información de las entradas","Retry":"Vuelva a intentarlo","Retry Camera":"Reintentar","Save":"Guardar","Scan":"Escanear","Scan QR Codes":"Escanear Código QR","Scan addresses for funds":"Busca direcciones con fondos","Scan again":"Escanear de nuevo","Scan your fingerprint please":"Por favor ingrese su huella digital","Scanning Wallet funds...":"Buscando fondos en la billetera...","Scanning funds...":"Buscando fondos...","Screenshots are not secure":"Las capturas de pantallas no son seguras","Search Transactions":"Buscar transacciones","Search or enter bitcoin address":"Buscar o introducir dirección bitcoin","Search transactions":"Buscar transacciones","Search your currency":"Busca tu moneda","Security":"Seguridad","See invoice":"Ver factura","Select a backup file":"Seleccionar el archivo de copia de seguridad","Select a wallet":"Seleccionar una billetera","Self-signed Certificate":"Certificado autofirmado","Selling Qybcoin...":"Vendiendo Bitcoins...","Send":"Enviar","Send Feedback":"Enviar Sugerencia","Send Money":"Enviar dinero","Send addresses by email":"Enviar las direcciones por email","Send by email":"Enviar por correo electrónico","Send from":"Enviar desde","Send max amount":"Enviar la máxima cantidad","Send payment to this address":"Enviar pago a esta dirección","Send us feedback instead":"En su lugar, enviar comentario","Sending":"Enviando","Sending 2FA code...":"Enviando código 2FA...","Sending feedback...":"Enviando comentario...","Sending maximum amount":"Enviando cantidad máxima","Sending transaction":"Enviando transacción","Sending {{amountStr}} from your {{name}} wallet":"Enviando {{amountStr}} desde tu billetera {{name}}","Sent":"Enviado","Sent Funds":"Fondos enviados","Server response could not be verified":"La respuesta del servidor no se ha podido verificar","Service not available":"Servicio no disponible","Services":"Servicios","Session Log":"Registro de sesión","Session log":"Registro de sesión","Set up a password":"Configurar una contraseña","Set your own fee in satoshis/byte":"Establecer su propia comisión en satoshis/byte","Settings":"Configuración","Share the love by inviting your friends.":"Comparte la pasión invitando a tus amigos.","Share this invitation with your copayers":"Compartir esta invitación con sus copayers","Share {{appName}}":"Compartir {{appName}}","Shared Wallet":"Billetera Compartida","Show Recovery Phrase":"Mostrar frase de recuperación del monedero","Show address":"Mostrar dirección","Show advanced options":"Mostrar opciones avanzadas","Show bitcoin address":"Mostrar dirección bitcoin","Show more":"Ver más","Signatures rejected by server":"Firmas rechazadas por el servidor","Signing transaction":"Firmando transacción","Since only you control your money, you’ll need to save your backup phrase in case this app is deleted.":"Ya que sólo tu controlas tu dinero, deberás guardar la copia de seguridad en caso de que esta aplicación sea eliminada.","Single Address Wallet":"Billetera de una sola dirección","Skip":"Omitir","Slide to accept":"Deslizar para aceptar","Slide to buy":"Deslizar para comprar","Slide to pay":"Deslizar para pagar","Slide to send":"Deslizar para enviar","Some of your wallets are not eligible for Qybcoin Cash support. You can try to access dmb funds from these wallets using the":"Algunas de sus billeteras no pueden ser seleccionadas para darle soporte Qybcoin Cash. Pruebe acceder a sus fondos dmb utilizando la","Specify Recovery Phrase...":"Especificar la frase de recuperación...","Spend proposal is not accepted":"La propuesta de gasto no se ha aceptado","Spend proposal not found":"La propuesta de gasto no se ha encontrado","Spending Password needed":"Se necesita la contraseña para pagos","Spending this balance will need significant Qybcoin network fees":"Gastar este balance requiere de significativas comisiones","Start sending bitcoin":"Empezar a enviar bitcoin","Startup Lock":"Bloqueo inicial","Still pending":"Aún pendiente","Success":"Listo","Super Economy":"Súper Económico","Sweep":"Importar","Sweep paper wallet":"Importar billetera en papel","Sweeping Wallet...":"Leyendo la Billetera...","THIS ACTION CANNOT BE REVERSED":"ESTA ACCIÓN NO SE PUEDE REVERTIR","Take control of your money,<br>get started with bitcoin.":"Toma control de tu dinero,<br>comienza a utilizar bitcoin.","Tap and hold to show":"Tocar y mantener para mostrar","Tap to recreate":"Toca para recrear","Tap to retry":"Toque para reintentar","Terms Of Use":"Términos de uso","Terms of Use":"Términos de Uso","Testnet":"Testnet","Text":"Texto","Thank you!":"¡Gracias!","Thanks!":"¡Gracias!","That's exciting to hear. We'd love to earn that fifth star from you – how could we improve your experience?":"Es emocionante escucharlo. Nos encantaría ganar esa quinta estrella – ¿cómo podemos mejorar tu experiencia?","The Ledger Chrome application is not installed":"La aplicación Ledger de Chrome no esta instalada","The amount of bitcoin immediately spendable from this wallet.":"Total de bitcoins disponibles en esta billetera para su uso inmediato.","The amount of bitcoin stored in this wallet that is allocated as inputs to your pending transaction proposals. The amount is determined using unspent transaction outputs associated with this wallet and may be more than the actual amounts associated with your pending transaction proposals.":"La cantidad de bitcoins almacenados en esta billetera que se utilizan como \"inputs\" en la transacción pendiente. Esa cantidad se determina en base a los \"unspent transaction outputs\" asociados con la billetera, estos pueden que sean mayor al monto enviado en la transacción en cuestión.","The amount of bitcoin stored in this wallet with less than 1 blockchain confirmation.":"La cantidad de bitcoins almacenados en esta billetera que poseen menos de 1 confirmación en \"Blockchain\".","The derivation path":"La ruta de derivación","The exchange rate changes with the market.":"La cotización varía según el mercado.","The higher the fee, the greater the incentive a miner has to include that transaction in a block. Current fees are determined based on network load and the selected policy.":"Mientras más grande la comisión, mayor incentivo tiene el minero para agregar tu transacción a un bloque. Las comisiones están determinadas en base al tráfico y política de la red elegida.","The maximum number of consecutive unused addresses (20) has been reached. When one of your unused addresses receives a payment, a new address will be generated and shown in your Receive tab.":"Se ha alcanzado el número máximo de direcciones consecutivas sin utilizar (20). Cuando una de sus direcciones reciba un pago, una nueva dirección se generará y se mostrará en la pestaña 'Recibir'.","The official English Terms of Service are available on the BitPay website.":"Los términos y condiciones oficiales en inglés se encuentran disponibles en la web de BitPay.","The password of the recovery phrase (if set)":"La contraseña de la frase de recuperación (si existe)","The payment was created but could not be completed. Please try again from home screen":"El pago fue creado pero no se pudo completar. Por favor intenta nuevamente desde la pantalla de inicio","The payment was removed by creator":"El pago fue eliminado por el creador","The recovery phrase could require a password to be imported":"La frase de recuperación podría requerir una contraseña para ser importada","The request could not be understood by the server":"La solicitud no pudo ser comprendida por el servidor","The restore process will stop when 20 addresses are generated in a row which contain no funds. To safely generate more addresses, make a payment to one of the unused addresses which has already been generated.":"El proceso generación de nuevas direcciones se detendrá cuando se generen 20 direcciones de manera consecutiva. Luego deberás recibir un pago en una de las direcciones sin uso para obtener una nueva.","The spend proposal is not pending":"La propuesta de gasto no esta pendiente","The total amount of bitcoin stored in this wallet.":"El total de bitcoins almacenados en esta billetera.","The transaction history and every new incoming transaction are cached in the app. This feature clean this up and synchronizes again from the server":"El historial de transacciones y cada nueva transacción entrantes se almacenan en caché en la aplicación. Esta característica limpia y sincroniza otra vez desde el servidor","The wallet service URL":"URL de Wallet Service","There is a new version of {{appName}} available":"Hay una nueva versión de {{appName}} disponible","There is an error in the form":"Hay un error en el formulario","There's obviously something we're doing wrong.":"Obviamente hay algo que estamos haciendo mal.","This app is fantastic!":"¡Esta aplicación es fantástica!","This app stores your bitcoin with cutting-edge security.":"Esta aplicación almacena tus bitcoins con seguridad avanzada.","This bitcoin payment request has expired.":"Esta solicitud de pago ha caducado.","This password cannot be recovered. If the password is lost, there is no way you could recover your funds.":"Esta contraseña no se puede recuperar. Si la pierdes, no hay manera de que puedas recuperar los fondos.","This recovery phrase was created with a password. To recover this wallet both the recovery phrase and password are needed.":"Esta frase de recuperación fue creada con una contraseña. Para recuperar esta billetera, la frase de recuperación y la contraseña son necesarios.","This transaction amount is too small compared to current Qybcoin network fees. Spending these funds will need a Qybcoin network fee cost comparable to the funds itself.":"Este monto en la transacción es demasiado bajo comparado con las comisiones de la red Qybcoin. Para gastar estos fondos se requiere disponer de un monto superior a la comisión requerida por la red Qybcoin.","This transaction could take a long time to confirm or could be dropped due to the low fees set by the sender":"Esta transacción podría tardar mucho tiempo en confirmar o podría caer debido a la baja comisión establecida por el remitente","This wallet is not registered at the given Bitcore Wallet Service (BWS). You can recreate it from the local information.":"Esta billetera no está registrada en el servidor de Bitcore Wallet Service (BWS). Debes re-crearla con la información local disponible.","Timeline":"Línea de tiempo","To":"Para","To get started, buy bitcoin or share your address. You can receive bitcoin from any wallet or service.":"Para empezar, compra bitcoin o comparte tu dirección. Puedes recibir bitcoin desde cualquier billetera o servicio.","To get started, you'll need to create a bitcoin wallet and get some bitcoin.":"Para empezar, necesitarás crear una billetera y obtener bitcoins.","To {{reason}} you must first add your BitPay account - {{email}}":"Para {{reason}} primero debes agregar tu cuenta de BitPay - {{email}}","Top up in progress...":"Recarda en progreso...","Top up {{amountStr}} to debit card ({{cardLastNumber}})":"Recargar {{amountStr}} a la tarjeta de débito ({{cardLastNumber}})","Total":"Total","Total Locked Balance":"Balance Total Bloqueado","Total number of copayers":"Número total de copayers","Total wallet inputs":"Total de entradas de la billetera","Touch ID Failed":"Falló Touch ID","Transaction":"Transacción","Transaction Created":"Transacción creada","Transaction History":"Historial de Transacciones","Transaction already broadcasted":"La transacción ya fue enviada","Transaction has not been created":"La transacción no ha sido creada","Transaction initiated":"Transacción iniciada","Transaction not available at this time":"La transacción no esta disponible en este momento","Transaction not found":"Transacción no encontrada","Transactions without fee are not supported.":"Las transacciones sin comisión no están soportadas.","Transfer to":"Transferir a","Transfer to Wallet":"Transferir a billetera","Try again in {{expires}}":"Intenta de nuevo en {{expires}}","Turn bitcoin into dollars, swipe anywhere Visa<sup>®</sup> is accepted.":"Convierta Bitcoins en Dólares, use Visa<sup>&reg;</sup>.","Type the Recovery Phrase (usually 12 words)":"Escribe la frase de recuperación (normalmente 12 palabras)","Uh oh...":"Ouch...","Unconfirmed":"Sin confirmar","Unsent transactions":"Transacciones no enviadas","Unused Addresses":"Direcciones no utilizadas","Unused Addresses Limit":"Limite de direcciones sin uso","Update Available":"Actualización Disponible","Updating pending proposals. Please stand by":"Actualizando propuestas de pago pendientes. Por favor, espera","Updating transaction history. Please stand by.":"Actualizando el historial de transacciones. Por favor aguarda un momento.","Updating... Please stand by":"Actualizando... Por favor, espera","Urgent":"Urgente","Use Unconfirmed Funds":"Utilizar los fondos sin confirmar","Validating recovery phrase...":"Validando la frase de recuperación...","Verify your identity":"Verificar tu identidad","Version":"Versión","View":"Ver","View All Addresses":"Ver todas las direcciones","View Terms of Service":"Ver Términos de Uso","View Transaction on Insight":"Ver Transacción en Insight","View Update":"Ver Actualización","View on blockchain":"Ver en blockchain","Visit mercadolivre.com.br &rarr;":"Ir a Mercadolivre.com.br &rarr;","WARNING: Key derivation is not working on this device/wallet. Actions cannot be performed on this wallet.":"ADVERTENCIA: Derivación de la clave no funciona en este dispositivo/billetera. Acciones no pueden realizarse en esta billetera.","WARNING: Not including the private key allows to check the wallet balance, transaction history, and create spend proposals from the export. However, does not allow to approve (sign) proposals, so <b>funds will not be accessible from the export</b>.":"ADVERTENCIA: No incluir la clave privada permite verificar el saldo de la billetera, historial de transacciones y crear propuestas de gastos. Sin embargo, no permite aprobar propuestas (firmar), así que <b>los fondos no serán accesibles al exportar</b>.","WARNING: The private key of this wallet is not available. The export allows to check the wallet balance, transaction history, and create spend proposals from the export. However, does not allow to approve (sign) proposals, so <b>funds will not be accessible from the export</b>.":"ADVERTENCIA: La clave privada de esta billetera no está disponible. La exportación permite verificar el saldo de la billetera, historial de transacciones y crear propuestas de gastos. Sin embargo, no permite aprobar propuestas (firmar), así que <b>los fondos no serán accesibles al exportar</b>.","WARNING: UNTRUSTED CERTIFICATE":"ADVERTENCIA: EL CERTIFICADO NO ES DE CONFIANZA","WARNING: Your extended private keys are all that is needed to access your bitcoin funds. Be sure to protect your private keys and store them only on secure devices. BitPay does not have access to your private keys, so you alone are responsible for your keys. If you share key access with external services, you take responsibility for the risk of theft or breach. Only advanced users should handle extended private keys directly.":"ADVERTENCIA: Sus claves privadas extendidas son todo lo que se necesita para acceder a sus fondos de bitcoin. No olvide proteger sus claves privadas y almacenarlas en dispositivos seguros. BitPay no tiene acceso a sus claves privadas, por lo que solo usted es responsable de sus claves. Si comparte la clave acceso con servicios externos, usted asume la responsabilidad por el riesgo de robo o violación. Sólo los usuarios avanzados deberían manipular las claves privadas extendidas directamente.","Waiting for Ledger...":"Esperando a Ledger...","Waiting for Trezor...":"Esperando a Trezor...","Waiting for copayers":"Esperando a los demás copayers","Waiting...":"Esperando...","Wallet Addresses":"Direcciones de la billetera","Wallet Color":"Color de la billetera","Wallet Configuration (m-n)":"Configuración de la billetera (m-n)","Wallet Created":"Billetera Creada","Wallet Id":"Id de la Billetera","Wallet Information":"Información de la Billetera","Wallet Inputs":"Entradas de la billetera","Wallet Invitation":"Invitación para unirse a la billetera","Wallet Key":"Llave de la billetera","Wallet Name":"Nombre de la billetera","Wallet Name (at creation)":"Nombre de la billetera (al crear)","Wallet Network":"Red de la billetera","Wallet Recovery Phrase":"Frase de recuperación de la billetera","Wallet Recovery Phrase is invalid":"La frase de recuperación no es válida","Wallet Service URL":"Wallet Service URL","Wallet Settings":"Preferencias de la billetera","Wallet Type":"Tipo de billetera","Wallet already exists":"La billetera ya existe","Wallet already in {{appName}}":"El monedero ya existe en {{appName}}","Wallet created":"Billetera Creada","Wallet incomplete and broken":"Billetera incompleta y rota","Wallet is full":"La billetera está completa","Wallet is locked":"Billetera bloqueada","Wallet is not complete":"La billetera no esta completa","Wallet name":"Nombre de la billetera","Wallet needs backup":"La billetera requiere copia de seguridad","Wallet not backed up":"Billetera sin copia de seguridad","Wallet not found":"Billetera no encontrada","Wallet not registered":"Billetera no registrada","Wallet not registered at the wallet service. Recreate it from \"Create Wallet\" using \"Advanced Options\" to set your recovery phrase":"La billetera no esta registrado en Wallet Service. Para volver a crear, utilice \"Crear billetera\", \"Opciones avanzadas\" e ingrese la frase de recuperación","Wallet recovery phrase not available":"Frase de recuperación de la billetera no disponible","Wallet service not found":"Wallet Service no encontrado","Wallets":"Billeteras","Warning!":"¡Advertencia!","Warning: this transaction has unconfirmed inputs":"Advertencia: esta operación tiene entradas sin confirmar","Watch out!":"¡Cuidado!","We'd love to do better.":"Nos encantaría hacerlo mejor.","We'll confirm on the next screen.":"Se confirmará en la siguiente pantalla.","We're always looking for ways to improve {{appName}}.":"Siempre estamos buscando maneras de mejorar {{appName}}.","We're always looking for ways to improve {{appName}}. How could we improve your experience?":"Siempre estamos buscando maneras de mejorar {{appName}}. ¿Cómo podríamos mejorar tu experiencia?","Website":"Página web","We’re always looking for translation contributions! You can make corrections or help to make this app available in your native language by joining our community on Crowdin.":"¡Siempre estamos buscando aportes de traducción! Puedes ayudar a que esta aplicación esté disponible en tu idioma nativo uniéndote a nuestra comunidad en Crowdin.","What do you call this wallet?":"¿Como desea llamar a esta billetera?","When this wallet was created, it was called “{{walletName}}”. You can change the name displayed on this device below.":"Cuando fue creada esta billetera, se llamaba &ldquo;{{walletName}}&rdquo;. Aquí puede cambiar el nombre que se mostrara en este dispositivo.","Where would you like to receive email notifications about payments?":"¿A donde le gustaría recibir notificaciones por email sobre sus transacciones?","Why?":"¿Por qué?","Would you be willing to rate {{appName}} in the app store?":"¿Estaría usted dispuesto a opinar sobre {{appName}} en la app store?","Would you like to receive push notifications about payments?":"¿Quieres recibir notificaciones push sobre sus transacciones?","Wrong number of recovery words:":"Número incorrecto de palabras:","Wrong spending password":"Contraseña para pagos incorrecta","Yes":"Si","Yes, skip":"Si, omitir","You can create a backup later from your wallet settings.":"Puedes hacerlo luego desde las preferencias de la billetera.","You can make contributions by signing up on our Crowdin community translation website. We’re looking forward to hearing from you!":"Se pueden hacer contribuciones al registrarse en nuestro proyecto de traducciones en Crowdin. ¡Esperamos tener noticias tuyas!","You can scan bitcoin addresses, payment requests, paper wallets, and more.":"Puedes escanear direcciones bitcoin, solicitudes de pago, billeteras de papel y más.","You can see the latest developments and contribute to this open source app by visiting our project on GitHub.":"Puede ver las últimas novedades y contribuir a nuestra aplicación de código abierto visitando nuestro proyecto en GitHub.","You can spend bitcoin at millions of websites and stores worldwide.":"Puedes utilizar bitcoin en millones de páginas web y tiendas en todo el mundo.","You can still export it from Advanced &gt; Export.":"Todavía puede exportar en Avanzados &gt; Exportar.","You can trade it for other currencies like US Dollars, Euros, or Pounds.":"Puedes cambiarlo por otras monedas como Dólares, Euros o Libras.","You control your bitcoin.":"Controlas tus bitcoins.","You should not set a fee higher than {{maxFeeRecommended}} satoshis/byte.":"No debería elegir una comisión superior a {{maxFeeRecommended}} satoshis/byte.","You will need to log back for fill in your BitPay Card.":"Tendrá que iniciar sesión para completar su BitPay Card.","You'll receive email notifications about payments sent and received from your wallets.":"Recibirás notificaciones por correo electrónico acerca de pagos enviados y recibidos de tus billeteras.","Your BitPay Card is ready. Add funds to your card to start using it at stores and ATMs worldwide.":"Tu Tarjeta BitPay ya esta lista. Agrega fondos para comenzar a utilizarla en negocios y cajeros automáticos de todo el mundo.","Your Gift Cards":"Tus Tarjetas de Regalo","Your bitcoin wallet is backed up!":"¡Su billetera bitcoin está resguardada!","Your bitcoin wallet is ready!":"¡Su billetera bitcoin está lista!","Your fee is lower than recommended.":"Tu comisión es inferior a la recomendada.","Your ideas, feedback, or comments":"Ideas, sugerencias o comentarios","Your name":"Nombre","Your nickname":"Sobrenombre","Your password":"Contraseña","Your purchase could not be completed":"No se pudo completar la compra","Your purchase was added to the list of pending":"Tu compra fue agregada a la lista de pendientes","Your wallet is never saved to cloud storage or standard device backups.":"Tu billetera nunca se sube a la nube ni se resguarda automáticamente en el dispositivo.","Your wallet key will be encrypted. The Spending Password cannot be recovered. Be sure to write it down.":"La clave de la billetera será cifrada. La contraseña para pagos no puede ser recuperada. Asegúrate de anotarla.","[Balance Hidden]":"[Balance Oculto]","[Scanning Funds]":"[Buscando Fondos]","add your BitPay Visa card(s)":"agregar sus tarjetas BitPay Visa","locked by pending payments":"bloqueado por pagos pendientes","me":"yo","name@example.com":"nombre@ejemplo.com","preparing...":"preparando...","recovery tool.":"herramienta de recuperación.","{{amountStr}} for Amazon.com Gift Card":"{{amountStr}} en tarjeta de regalo de Amazon.com","{{amountStr}} for Mercado Livre Brazil Gift Card":"{{amountStr}} en Tarjeta de Regalo Mercado Livre Brasil","{{appName}} depends on Bitcore Wallet Service (BWS) for blockchain information, networking and Copayer synchronization. The default configuration points to https://bws.bitpay.com (BitPay's public BWS instance).":"{{appName}} depende de Bitcore Wallet Service (BWS) para obtener información sobre blockchain y sincronización del Copayer. La configuración por defecto apunta a https://bws.bitpay.com (instancia pública de BitPay).","{{fee}} will be deducted for bitcoin networking fees.":"{{fee}} se descontará por comisión de la red bitcoin.","{{tx.txp[wallet.id].feeRatePerStr}}  of the sending amount":"{{tx.txp[wallet.id].feeRatePerStr}} de la cantidad a enviar","{{updatingTxHistoryProgress}} transactions downloaded":"{{updatingTxHistoryProgress}} transacciones descargadas","{{wallet.m}}-of-{{wallet.n}}":"{{wallet.m}}-de-{{wallet.n}}"});
    gettextCatalog.setStrings('fr', {"(Trusted)":"(Fiable)","(possible double spend)":"(double dépense possible)","* A payment proposal can be deleted if 1) you are the creator, and no other copayer has signed, or 2) 24 hours have passed since the proposal was created.":"* Une proposition de paiement peut être supprimée si vous en êtes le créateur et qu'aucun des autres copayers n'a signé, ou si 24 heures sont passées depuis la création de la proposition.","- {{btx.feeRateStr}} of the transaction":"- {{btx.feeRateStr}} de la transaction","- {{tx.feeRateStr}} of the transaction":"- {{tx.feeRateStr}} de la transaction","5-star ratings help us get {{appName}} into more hands, and more users means more resources can be committed to the app!":"Une note de 5 étoiles permet à {{appName}} de gagner en popularité, et plus d'utilisateurs signifie davantage de ressources allouées à l'appli !","<b>Only</b> redeemable on Mercado Livre (Brazil)":"<b>Seulement</b> utilisable sur Mercado Livre (Brazil)","A member of the team will review your feedback as soon as possible.":"Un membre de l’équipe passera en revue votre avis dès que possible.","A total of {{amountAboveMaxSizeStr}} were excluded. The maximum size allowed for a transaction was exceeded.":"Un total de {{amountAboveMaxSizeStr}} a été exclu. La taille maximale autorisée pour une transaction a été dépassée.","A total of {{amountBelowFeeStr}} were excluded. These funds come from UTXOs smaller than the network fee provided.":"Un total de {{amountBelowFeeStr}} a été exclu. Ces fonds proviennent d'UTXOs plus petites que les frais de réseau prévus.","About":"À propos","Accepted":"Acceptée","Account":"Compte","Account Number":"Numéro de compte","Accounts":"Comptes","Activity":"Activité","Add Account":"Ajouter un compte","Add BitPay Account?":"Ajouter un compte BitPay ?","Add Contact":"Ajouter un contact","Add Funds":"Ajouter des fonds","Add Memo":"Ajouter une note","Add a password":"Ajouter un mot de passe","Add account":"Ajouter un compte","Add an optional password to secure the recovery phrase":"Ajouter un mot de passe optionnel pour sécuriser la phrase de récupération","Add as a contact":"Ajouter comme contact","Add description":"Ajouter une description","Add funds":"Ajouter des fonds","Add this BitPay account ({{email}})?":"Voulez-vous ajouter ce compte BitPay ({{email}}) ?","Add wallet":"Ajouter un portefeuille","Address":"Adresse","Address Book":"Répertoire","Address Type":"Type d'adresse","Addresses With Balance":"Adresses avec un solde","Advanced":"Paramètres avancés","Advanced Settings":"Paramètres avancés","All":"Toutes","All Addresses":"Toutes les adresses","All of your bitcoin wallet balance may not be available for immediate spending.":"L'intégralité du solde de votre portefeuille bitcoin peut ne pas être disponible pour des dépenses immédiates.","All signing devices must be added to this multisig wallet before bitcoin addresses can be created.":"Tous les appareils de signature doivent être ajoutés à ce portefeuille multisig avant que les adresses bitcoin ne puissent être créées.","Allow Camera Access":"Autoriser l'accès à la caméra","Allow notifications":"Autoriser les notifications","Almost done! Let's review.":"C'est presque terminé ! Vérifions.","Alternative Currency":"Devise alternative","Amazon.com is not available at this moment. Please try back later.":"Amazon.com n’est pas disponible pour le moment. Veuillez réessayer plus tard.","Amount":"Montant","Amount below minimum allowed":"Montant en dessous du minimum autorisé","Amount too big":"Le montant est trop élevé","Amount too low to spend":"Le montant est trop faible pour être dépensé","An update to this app is available. For your security, please update to the latest version.":"Une mise à jour de cette appli est disponible. Pour votre sécurité, veuillez mettre à jour vers la dernière version.","Anyone with your backup phrase can access or spend your bitcoin.":"Quelqu'un disposant de votre phrase de sauvegarde peut dépenser vos bitcoins.","Approximate Qybcoin network fee to transfer wallet's balance (with normal priority)":"Frais de réseau Qybcoin approximatifs pour transférer le solde du portefeuille (avec des frais normaux)","Are you being watched?":"Êtes-vous surveillé(e) ?","Are you being watched? Anyone with your recovery phrase can access or spend your bitcoin.":"Êtes-vous surveillé(e) ? N’importe qui peut dépenser vos bitcoins grâce à votre phrase de récupération.","Are you sure you want to cancel and delete this wallet?":"Êtes-vous certain(e) de vouloir annuler et supprimer ce portefeuille ?","Are you sure you want to delete this contact?":"Souhaitez-vous réellement supprimer ce contact ?","Are you sure you want to delete this wallet?":"Êtes-vous certain(e) de vouloir supprimer ce portefeuille ?","Are you sure you want to reject this transaction?":"Êtes-vous certain(e) de vouloir rejeter cette transaction ?","Are you sure you want to remove this transaction?":"Êtes-vous certain(e) de vouloir supprimer cette transaction ?","Are you sure you want to skip it?":"Êtes-vous sûr(e) de vouloir ignorer la sauvegarde ?","Are you sure you would like to log out of your BitPay Card account?":"Souhaitez-vous réellement vous déconnecter de votre compte BitPay Card ?","Are you sure you would like to remove your BitPay Card ({{lastFourDigits}}) from this device?":"Êtes-vous sûr(e) de vouloir supprimer votre BitPay Card ({{lastFourDigits}}) de cet appareil ?","Auditable":"Vérifiable","Available":"Disponible","Available Balance":"Solde disponible","Average confirmation time":"Temps de confirmation moyen ","BIP32 path for address derivation":"Chemin BIP32 pour la dérivation de l'adresse","QYB wallets":"Portefeuilles QYB","Backup":"Sauvegarder","Backup Needed":"Sauvegarde requise","Backup all livenet wallets before using this function":"Sauvegardez tous les portefeuilles (livenet) avant d'utiliser cette fonction","Backup needed":"Sauvegarde requise","Backup now":"Sauvegarder maintenant","Backup wallet":"Sauvegarder le portefeuille","Backup your wallet before using this function":"Sauvegardez votre portefeuille avant d'utiliser cette fonction","Bad wallet invitation":"Mauvaise invitation de portefeuille","Balance By Address":"Solde par adresse","Be sure to store your recovery phrase in a secure place. If this app is deleted, your money cannot be recovered without it.":"N’oubliez pas de conserver votre phrase de récupération dans un endroit sûr. Si cette application est supprimée, votre argent ne peut pas être récupéré sans elle.","BitPay Visa® Cards":"BitPay Visa&reg; Cards","Qybcoin Address":"Adresse bitcoin","Qybcoin Cash Wallets":"Portefeuilles Qybcoin Cash","Qybcoin Network Fee Policy":"Frais de réseau","Qybcoin Wallets":"Portefeuilles Qybcoin","Qybcoin cash Payment":"Paiement Qybcoin Cash","Qybcoin is a currency.":"Qybcoin est une monnaie.","Qybcoin is different – it cannot be safely held with a bank or web service.":"Les bitcoins sont particuliers &ndash; ils ne peuvent pas être stockés en toute sécurité sur un service internet ou bancaire.","Qybcoin is secure,<br>digital money.":"Qybcoin est de l'argent<br>numérique sécurisé.","Qybcoin transactions include a fee collected by miners on the network.":"Les transactions Qybcoin incluent des frais collectés par les mineurs du réseau.","Bought {{amountUnitStr}}":"{{amountUnitStr}} achetés","Broadcast Payment":"Diffuser le paiement","Broadcasted":"Diffusée","Broadcasting transaction":"Diffusion de la transaction","Browser unsupported":"Navigateur non supporté","Buy":"Acheter","Buy &amp; Sell Qybcoin":"Acheter &amp; vendre des bitcoins","Buy Qybcoin":"Acheter des bitcoins","Buy a Gift Card":"Acheter une carte-cadeau","Buy from":"Acheter depuis","Buying Qybcoin...":"Achat de bitcoins...","Calculating fee":"Calcul des frais","Cancel":"Annuler","Cancel invitation":"Annuler l'invitation","Cannot Create Wallet":"Impossible de créer le portefeuille","Cannot join the same wallet more that once":"Impossible de rejoindre le même portefeuille plus d'une fois","Cards":"Cartes","Certified by":"Certifié par","Check installation and retry.":"Vérifiez l’installation et réessayez.","Choose a backup file from your computer":"Choisissez un fichier de sauvegarde depuis votre ordinateur","Choose your destination wallet":"Choisissez votre portefeuille de destination","Choose your source wallet":"Choisissez votre portefeuille source","Clear":"Effacer","Clear cache":"Vider le cache","Click to accept":"Cliquez pour accepter","Click to pay":"Cliquez pour payer","Click to send":"Cliquez pour envoyer","Close":"Fermer","Coin":"Crypto-monnaie","Color":"Couleur","Commit hash":"Commit hash","Complete the backup process to use this option":"Terminez le processus de sauvegarde pour utiliser cette option","Completed":"Terminé","Confirm":"Confirmer","Confirm &amp; Finish":"Confirmer &amp; Terminer","Confirm purchase":"Confirmer l'achat","Confirm your PIN":"Confirmez votre PIN","Confirm your new spending password":"Confirmez votre nouveau code de dépenses","Confirmations":"Confirmations","Confirming":"Confirmation","Connect my BitPay Card":"Connecter ma BitPay Card","Connecting to Coinbase...":"Connexion à Coinbase...","Connecting to Glidera...":"Connexion à Glidera...","Connection reset by peer":"Connexion réinitialisée par un pair","Contacts":"Contacts","Continue":"Continuer","Contribute Translations":"Contribuer aux traductions","Qyb only supports Qybcoin Cash using new version numbers addresses":"Qyb prend uniquement en charge le nouveau type d'adresse de Qybcoin Cash","Copayer already in this wallet":"Copayer déjà dans ce portefeuille","Copayer already voted on this spend proposal":"Le Copayer a déjà voté pour cette proposition de dépense","Copayer data mismatch":"Les données Copayer ne correspondent pas","Copayer joined":"Un Copayer à rejoint","Copayer {{$index}}":"Copayer {{$index}}","Copied to clipboard":"Copié(e) dans le presse-papier","Copy this text as it is to a safe place (notepad or email)":"Copiez ce texte présenté tel quel vers un endroit sûr (bloc-notes ou e-mail)","Copy to clipboard":"Copier dans le presse-papier","Could not access Gift Card Service":"Impossible d'accéder au service de carte-cadeau","Could not access the wallet at the server. Please check:":"Impossible d'accéder au portefeuille via le serveur. Veuillez vérifier :","Could not access to Amazon.com":"Impossible d'accéder à Amazon.com","Could not access wallet":"Impossible d’accéder au portefeuille","Could not add message to imported wallet without shared encrypting key":"Could not add message to imported wallet without shared encrypting key","Could not broadcast payment":"Impossible de diffuser le paiement","Could not build transaction":"Impossible de créer la transaction","Could not create address":"Impossible de créer l'adresse","Could not create the invoice":"Impossible de créer la facture","Could not create transaction":"Impossible de créer la transaction","Could not create using the specified extended private key":"Impossible de créer en utilisant la clé privée étendue spécifiée","Could not create using the specified extended public key":"Impossible de créer en utilisant la clé publique étendue spécifiée","Could not create: Invalid wallet recovery phrase":"Impossible de créer : Phrase de récupération du portefeuille invalide","Could not decrypt file, check your password":"Impossible de déchiffrer le fichier, vérifiez votre mot de passe","Could not delete payment proposal":"Impossible de supprimer la proposition de paiement","Could not duplicate":"Impossible de dupliquer","Could not get dynamic fee":"Impossible d'obtenir les frais dynamiques","Could not get dynamic fee for level: {{feeLevel}}":"Impossible d'obtenir les frais dynamiques pour : {{feeLevel}}","Could not get fee levels":"Impossible d'obtenir les niveaux de frais","Could not get the invoice":"Impossible d'obtenir la facture","Could not get transactions":"Impossible de récupérer les transactions","Could not import":"Impossible d'importer","Could not import. Check input file and spending password":"Impossible d'importer. Vérifiez le fichier d'entrée et le code de dépenses","Could not join wallet":"Impossible de rejoindre le portefeuille","Could not reject payment":"Impossible de rejeter le paiement","Could not remove account":"Impossible de supprimer le compte","Could not remove card":"Impossible de supprimer la carte","Could not save preferences on the server":"Impossible d'enregistrer les préférences sur le serveur","Could not send payment":"Impossible d'envoyer le paiement","Could not send transaction":"Impossible d'envoyer la transaction","Could not update transaction history":"Impossible de mettre à jour l'historique des transactions","Could not update wallet":"Impossible de mettre à jour le portefeuille","Create Personal Wallet":"Créer un portefeuille personnel","Create Shared Wallet":"Créer un portefeuille partagé","Create bitcoin wallet":"Créer un portefeuille bitcoin","Create new wallet":"Créer","Create shared wallet":"Créer un portefeuille partagé","Create {{formData.requiredCopayers}}-of-{{formData.totalCopayers}} wallet":"Créer un portefeuille {{formData.requiredCopayers}}-sur-{{formData.totalCopayers}}","Created by":"Créée par","Creating Wallet...":"Création du portefeuille...","Creating transaction":"Création de la transaction","Current fee rate for this policy":"Frais actuels pour ce choix ","Custom":"Personnalisés","Custom Amount":"Montant personnalisé","Custom Fee":"Frais personnalisés","Date":"Date","Delete":"Supprimer","Delete Payment Proposal":"Supprimer la proposition de paiement","Delete Wallet":"Supprimer le portefeuille","Delete it and create a new one":"Le supprimer et en créer un nouveau","Deleting Wallet...":"Suppression du portefeuille...","Deleting payment proposal":"Suppression de la proposition de paiement","Derivation Path":"Chemin de dérivation","Derivation Strategy":"Stratégie de dérivation","Details":"Détails","Disabled":"Désactivé","Do it later":"La faire plus tard","Do not include private key":"Ne pas inclure la clé privée","Don't see your language on Crowdin? Contact the Owner on Crowdin! We'd love to support your language.":"Vous ne voyez pas votre langue sur Crowdin ? Contactez le propriétaire sur Crowdin ! Nous serions ravis de prendre en charge votre langue.","Download":"Télécharger","Duplicate for dmb":"Dupliquer pour dmb","Duplicating wallet...":"Duplication du portefeuille...","Each bitcoin wallet can generate billions of addresses from your 12-word backup. A new address is automatically generated and shown each time you receive a payment.":"Chaque portefeuille bitcoin peut générer des milliards d’adresses depuis votre sauvegarde de 12 mots. Une nouvelle adresse est automatiquement générée et affichée à chaque fois que vous recevez un paiement.","Economy":"Faibles","Edit":"Modifier","Email":"E-mail","Email Address":"Adresse e-mail","Empty addresses limit reached. New addresses cannot be generated.":"La limite d'adresses vides a été atteinte. Les nouvelles adresses ne peuvent plus être générées.","Enable camera access in your device settings to get started.":"Autorisez l’accès à la caméra dans les réglages de votre appareil pour commencer.","Enable email notifications":"Activer les notifications e-mail","Enable push notifications":"Autoriser les notifications","Enable the camera to get started.":"Autorisez la caméra pour commencer.","Enter Spending Password":"Saisissez le code de dépenses","Enter Two Factor for your BitPay account":"Saisissez le code à deux facteurs pour votre compte BitPay","Enter amount":"Saisissez un montant","Enter custom fee":"Saisissez des frais personnalisés","Enter new spending password":"Saisissez un nouveau code de dépenses","Enter the recovery phrase (BIP39)":"Saisissez la phrase de récupération (BIP39)","Enter your email":"Saisissez votre e-mail","Enter your password":"Écrivez votre mot de passe","Error":"Erreur","Error at confirm":"Erreur à la confirmation","Error creating gift card":"Erreur de création de la carte-cadeau","Error creating the invoice":"Erreur de création de la facture","Error creating wallet":"Erreur de création du portefeuille","Error getting SendMax information":"Erreur d’obtention de l'information SendMax","Error in Payment Protocol":"Erreur dans le protocole de paiement","Error pairing BitPay Account":"Erreur d'appariement du compte BitPay","Error scanning funds:":"Erreur de numérisation des fonds :","Error sweeping wallet:":"Erreur de balayage de portefeuille :","Error updating Debit Cards":"Erreur de mise à jour des cartes de débit","Exceeded daily limit of $500 per user":"La limite quotidienne de 500$ par utilisateur a été dépassée","Expired":"Expiré","Expires":"Expire dans","Export Wallet":"Exporter le portefeuille","Export to file":"Exporter vers un fichier","Export wallet":"Exporter le portefeuille","Exporting via QR not supported for this wallet":"L'exportation via QR n'est pas supportée pour ce portefeuille","Extended Private Key":"Clé privée étendue","Extended Public Keys":"Clés publiques étendues","Extracting Wallet information...":"Extraction des informations du portefeuille...","Failed to export":"Impossible d'exporter","Family vacation funds":"Fonds pour les vacances familiales","Fee":"Frais","Fee level":"Frais","Fee level is not defined":"Le niveau de frais n'est pas défini","Fee:":"Frais :","Feedback could not be submitted. Please try again later.":"Vos commentaires n'ont pas pu être envoyés. Veuillez réessayer plus tard.","Fetching BitPay Account...":"Récupération du compte BitPay...","Fetching payment information":"Récupération des informations de paiement","File/Text":"Fichier / Texte","Filter setting":"Paramètres de filtre","Finger Scan Failed":"La numérisation digitale a échoué","Finish":"Terminer","For audit purposes":"À des fins de vérification","From":"De","From BitPay account":"Depuis un compte BitPay","From Hardware Wallet":"Depuis un portefeuille matériel","From the destination device, go to Add wallet &gt; Import wallet and scan this QR code":"Depuis l'appareil de destination, allez sur « Ajouter un portefeuille » &gt; « Importer » et numérisez ce code QR","Funds are locked by pending spend proposals":"Les fonds sont verrouillés par des propositions de dépenses en attente","Funds found:":"Fonds trouvés :","Funds to be added":"Fonds à ajouter","Funds transferred":"Fonds transférés","Funds were added to debit card":"Les fonds ont été ajoutés à la carte de débit","Funds will be transferred to":"Les fonds seront transférés à ","Generate new address":"Générer une nouvelle adresse","Generating .csv file...":"Génération du fichier .csv...","Generating new address...":"Génération d'une nouvelle adresse...","Get local cash anywhere you go, from any Visa<sup>®</sup> compatible ATM. ATM bank fees may apply.":"Retirez de l'argent partout où vous allez, depuis n'importe quel distributeur compatible Visa<sup>&reg;</sup>. Des frais bancaires de distributeur peuvent s'appliquer.","Get news and updates from BitPay":"Obtenir les actualités et mises à jour de BitPay","Get started":{"$$noContext":"Commencez","button":"Commencer"},"Get started by adding your first one.":"Commencez par ajouter votre premier contact.","Getting fee levels...":"Obtention des niveaux de frais...","Gift Card":"Carte-cadeau","Gift Card is not available to use anymore":"La carte-cadeau n'est plus utilisable","Gift card expired":"Carte-cadeau expirée","Gift card generated and ready to use.":"Carte-cadeau générée et prête à l’emploi.","Go Back":"Retour","Go back":"Retour","Got it":"J'ai compris","Hardware Wallet":"Portefeuille matériel","Hardware not connected.":"Matériel non connecté.","Hardware wallet":"Portefeuille matériel","Hardware wallets are not yet supported with Qybcoin Cash":"Les portefeuilles matériels ne sont pas encore pris en charge avec Qybcoin Cash","Help & Support":"Aide & Support","Help and support information is available at the website.":"De l'aide peut être trouvée sur le site internet (en anglais pour le moment).","Hide":"Masquer","Hide Balance":"Masquer le solde","Hide Next Steps Card":"Masquer la carte « Prochaines étapes »","Hide advanced options":"Masquer les options avancées","Home":"Accueil","How could we improve your experience?":"Comment pourrions-nous améliorer votre expérience ?","How do you like {{appName}}?":"Comment trouvez-vous {{appName}} ?","I don't like it":"Je ne l'aime pas","I have read, understood, and agree to the <a ng-click=\"openTerms()\" translate=\"\">Terms of Use</a>.":"J’ai lu, compris et suis d'accord avec les <a ng-click=\"openTerms()\" translate=\"\">Conditions d'utilisation</a>.","I have read, understood, and agree with the Terms of use.":"J'ai lu, compris et suis d'accord avec les conditions d'utilisation.","I have written it down":"Je l'ai bien écrit","I like the app":"J'aime l'appli","I think this app is terrible.":"Je déteste cette appli","I understand":"Je comprends","I understand that if this app is moved to another device or deleted, my bitcoin can only be recovered with the backup phrase.":"Je comprends que si cette application est déplacée vers un autre appareil ou supprimée, mes bitcoins ne peuvent être récupérés qu'avec la phrase de sauvegarde.","I understand that my funds are held securely on this device, not by a company.":"Je comprends que mes fonds sont en toute sécurité sur cet appareil et non détenus par une entreprise.","I've written it down":"Je l'ai bien écrite","If enabled, all sensitive information (private key and recovery phrase) and actions (spending and exporting) associated with this wallet will be protected.":"Si l'option est activée, toutes les informations sensibles (clé privée et phrase de récupération) ainsi que les opérations (dépenses et exportations) associées à ce portefeuille seront protégées.","If enabled, the Recent Transactions card - a list of transactions occuring across all wallets - will appear in the Home tab.":"Si l'option est activée, la carte des transactions récentes - une liste des transactions qui se produisent dans l’ensemble des portefeuilles - s’affichera dans l’onglet « Accueil ».","If enabled, wallets will also try to spend unconfirmed funds. This option may cause transaction delays.":"Si l'option est activée, les portefeuilles vont essayer de dépenser des fonds non confirmés. Cette option peut entraîner des retards de transaction.","If this device is replaced or this app is deleted, neither you nor BitPay can recover your funds without a backup.":"Si cet appareil est remplacé ou si cette appli est supprimée, ni vous ni BitPay ne pouvez récupérer vos fonds sans une sauvegarde.","If you have additional feedback, please let us know by tapping the \"Send feedback\" option in the Settings tab.":"Si vous avez d'autres commentaires, veuillez nous en informer en appuyant sur l'option « Envoyer un avis » dans l'onglet Paramètres.","If you take a screenshot, your backup may be viewed by other apps. You can make a safe backup with physical paper and a pen.":"Si vous prenez une capture d’écran, votre sauvegarde peut être vue par d’autres applications. Vous pouvez faire une sauvegarde physique sécurisée avec du papier et un stylo.","Import":"Importer","Import Wallet":"Importer un portefeuille","Import backup":"Importer la sauvegarde","Import wallet":"Importer un portefeuille","Importing Wallet...":"Importation du portefeuille...","In order to verify your wallet backup, please type your password.":"Afin de vérifier la sauvegarde de votre portefeuille, veuillez saisir votre mot de passe.","Inactive":"Inactive","Incomplete":"Non terminé","Incomplete wallet":"Portefeuille non terminé","Incorrect PIN, try again.":"PIN incorrect, veuillez réessayer.","Incorrect code format":"Format du code incorrect","Incorrect network address":"Adresse réseau invalide","Insufficient funds":"Fonds insuffisants","Insufficient funds for fee":"Fonds insuffisants pour les frais","Integrations":"Intégrations","Invalid":"Invalide","Invalid URL":"URL invalide","Invalid account number":"Numéro de compte invalide","Invalid address":"Adresse invalide","Invalid data":"Données invalides","Invalid derivation path":"Chemin de dérivation invalide","Invitation to share a {{appName}} Wallet":"Invitation pour partager un portefeuille {{appName}}","Invoice expired":"La facture a expiré","Is there anything we could do better?":"Y a-t-il quelque chose que nous pourrions améliorer ?","Is this correct?":"Est-ce correct ?","Is this email address correct?":"Cette adresse e-mail est-elle correcte ?","It's a good idea to avoid reusing addresses - this both protects your privacy and keeps your bitcoins secure against hypothetical attacks by quantum computers.":"C’est une bonne idée d'éviter la réutilisation des adresses. Cela fois protège votre anonymat et garde vos bitcoins en sécurité contre les attaques hypothétiques des ordinateurs quantiques.","It's important that you write your backup phrase down correctly. If something happens to your wallet, you'll need this backup to recover your money. Please review your backup and try again.":"Il est important d’écrire correctement votre phrase de sauvegarde. Si quelque chose arrive à votre portefeuille, vous aurez besoin de cette sauvegarde afin de récupérer votre argent. Vérifiez votre sauvegarde et réessayez.","Join":"Rejoindre","Join my {{appName}} Wallet. Here is the invitation code: {{secret}} You can download {{appName}} for your phone or desktop at {{appUrl}}":"Rejoins mon portefeuille {{appName}}. Voici le code d'invitation : {{secret}} Tu peux télécharger {{appName}} pour ton téléphone ou pour ton ordinateur sur {{appUrl}}","Join shared wallet":"Rejoindre un portefeuille partagé","Joining Wallet...":"Connexion au portefeuille...","Just scan the code to pay.":"Numérisez juste le code pour payer.","Key already associated with an existing wallet":"La clé est déjà associée avec un portefeuille existant","Language":"Langue","Last Month":"Le mois dernier","Learn more":"En savoir plus","Let's verify your backup phrase.":"Vérifions votre phrase de sauvegarde.","Loading addresses...":"Chargement des adresses...","Loading transaction info...":"Chargement des infos de transaction...","Lock App":"Verrouillage de l'application","Lock by Fingerprint":"Verrouiller par empreinte digitale","Lock by PIN":"Verrouiller par un code PIN","Locked":"Verrouillé","Locktime in effect. Please wait to create a new spend proposal":"Locktime effectif. Veuillez patienter pour créer une nouvelle proposition de dépense","Locktime in effect. Please wait to remove this spend proposal":"Locktime effectif. Veuillez patienter pour supprimer cette proposition de dépense","Log options":"Options de log","Log out":"Se déconnecter","Low amount inputs":"Entrées de faible montant","Low fees":"Frais faibles","Makes sense":"C'est logique","Matches:":"Correspondances :","Me":"Moi","Meh - it's alright":"Ça peut aller","Memo":"Note","Mercado Livre Brazil Gift Cards":"Cartes-cadeaux Mercado Livre Brazil","Mercadolibre Gift Card Service is not available at this moment. Please try back later.":"Le service de carte-cadeau Mercadolibre n'est pas disponible en ce moment. Veuillez réessayer plus tard.","Merchant Message":"Message marchand","Miner Fee":"Frais de minage","Missing parameter":"Paramètre manquant","Missing private keys to sign":"Clés privées manquantes pour signer","More Options":"Plus d'options","Moved":"Déplacés","Moved Funds":"Fonds déplacés","Multiple recipients":"Plusieurs destinataires","NOTE: To import a wallet from a 3rd party software, please go to Add Wallet &gt; Create Wallet, and specify the Recovery Phrase there.":"Remarque : Pour importer un portefeuille d’un autre logiciel que Qyb, veuillez aller dans « Ajouter portefeuille » &gt; « Créer » et spécifier la phrase de récupération.","Name":"Nom","Network Cost":"Coût de réseau","Network error":"Erreur réseau","New Proposal":"Nouvelle proposition","New address could not be generated. Please try again.":"La nouvelle adresse n'a pas pu être générée. Veuillez réessayer.","New personal wallet":"Nouveau portefeuille personnel","Next steps":"Prochaines étapes","No Wallet":"Aucun portefeuille","No access key defined":"Aucune clé d’accès définie","No backup, no bitcoin.":"Pas de sauvegarde, pas de bitcoin.","No contacts yet":"Aucun contact","No entries for this log level":"Aucune entrée pour ce niveau de log","No hardware information available.":"Aucune information matérielle disponible.","No hardware wallets supported on this device":"Aucun portefeuille matériel pris en charge sur cet appareil","No pending proposals":"Aucune proposition en attente","No recent transactions":"Aucune transaction récente","No signing proposal: No private key":"Aucune proposition de signature : aucune clé privée","No transactions yet":"Aucune transaction","No wallet found":"Aucun portefeuille trouvé","No wallet selected":"Aucun portefeuille sélectionné","No wallets available":"Aucun portefeuille disponible","No wallets available to receive funds":"Aucun portefeuille disponible pour recevoir des fonds","No wallets eligible for Qybcoin Cash support":"Aucun portefeuille n'est éligible pour Qybcoin Cash","Non BIP44 wallet":"Portefeuille non BIP44","Non eligible QYB wallets":"Portefeuilles QYB non éligibles","Normal":"Normaux","Not authorized":"Non autorisé","Not enough funds for fee":"Pas assez de fonds pour les frais","Not even BitPay can access it.":"Même BitPay ne peut y accéder.","Not funds found":"Aucun fonds trouvé","Not now":"Pas maintenant","Note":"Note","Note: if this dmb wallet was duplicated from a QYB wallet, they share the same recovery phrase.":"Remarque : si ce portefeuille dmb a été dupliqué à partir d'un portefeuille QYB, ils partagent la même phrase de récupération.","Notice: only 1-1 (single signature) wallets can be used for sell bitcoin":"Note : seuls les portefeuilles 1-1 (signature unique) peuvent être utilisés pour vendre des bitcoins","Notifications":"Notifications","Notifications by email":"Notifications par e-mail","Notify me if confirmed":"Me notifier si la transaction se confirme","Notify me when transactions are confirmed":"Me notifier quand les transactions se confirment","Now is a good time to backup your wallet. If this device is lost, it is impossible to access your funds without a backup.":"C'est un bon moment pour sauvegarder votre portefeuille. Si cet appareil est perdu, vos fonds seront irrécupérables sans une sauvegarde.","Now is a perfect time to assess your surroundings. Nearby windows? Hidden cameras? Shoulder-spies?":"C'est le moment d'observer autour de vous ! Personne aux fenêtres ? Derrière vous ? Aucune caméra cachée ?","OK":"Ok","OKAY":"OK","Official English Disclaimer":"Clause de non-responsabilité anglaise officielle","Oh no!":"Oh non !","Ok":"Ok","On this screen you can see all your wallets, accounts, and assets.":"Vous pouvez visualiser tous vos portefeuilles, comptes et actifs sur cet écran.","Open":"Ouvrir","Open Crowdin":"Ouvrir Crowdin","Open GitHub":"Ouvrir GitHub","Open GitHub Project":"Ouvrir le projet GitHub","Open Insight":"Ouvrir Insight","Open Settings":"Ouvrir les paramètres","Open Translation Community":"Ouvrir la communauté de traduction","Open Website":"Ouvrir le site internet","Open the recovery tool.":"Ouvrir l'outil de récupération.","Open wallet":"Ouvrir le portefeuille","Open website":"Ouvrir le site internet","Order the BitPay Card":"Commander la BitPay Card","Password":"Mot de passe","Password required. Make sure to enter your password in advanced options":"Mot de passe requis. Veuillez saisir votre mot de passe dans les options avancées","Paste invitation here":"Collez l'invitation ici","Paste the backup plain text code":"Collez le code texte de sauvegarde","Pay 0% fees to turn bitcoin into dollars.":"Aucun frais pour échanger des bitcoins en dollars.","Pay To":"Payer à","Payment Accepted":"Paiement accepté","Payment Expires:":"Le paiement expirera dans :","Payment Proposal":"Proposition de paiement","Payment Proposal Created":"Proposition de paiement créée","Payment Proposals":"Propositions de paiement","Payment Protocol Invalid":"Protocole de paiement invalide","Payment Protocol not supported on Chrome App":"Le protocole de paiement n'est pas supporté sur l'application Chrome","Payment Received":"Paiement reçu","Payment Rejected":"Paiement rejeté","Payment Sent":"Paiement envoyé","Payment accepted, but not yet broadcasted":"Paiement accepté, mais pas encore diffusé","Payment accepted. It will be broadcasted by Glidera. In case there is a problem, it can be deleted 6 hours after it was created.":"Paiement accepté. Il sera diffusé par Glidera. Dans le cas où il y a un problème, il peut être supprimé 6 heures après avoir été créé.","Payment address was translated to new Qybcoin Cash address format:":"L'adresse de paiement a été convertie au nouveau format d'adresse Qybcoin Cash :","Payment details":"Détails du paiement","Payment request":"Demande de paiement","Pending":"En attente","Pending Proposals":"Propositions en attente","Permanently delete this wallet.":"Supprimer définitivement ce portefeuille.","Personal Wallet":"Portefeuille personnel","Please carefully write down this phrase.":"Veuillez écrire soigneusement cette phrase.","Please connect a camera to get started.":"Veuillez connecter une caméra pour commencer.","Please enter the recovery phrase":"Veuillez saisir la phrase de récupération","Please enter the wallet recovery phrase":"Veuillez saisir la phrase de récupération du portefeuille","Please enter your PIN":"Veuillez saisir votre PIN","Please tap each word in the correct order.":"Veuillez sélectionner chaque mot dans le bon ordre.","Please upgrade Qyb to perform this action":"Veuillez mettre à jour Qyb pour effectuer cette action","Please wait":"Veuillez patienter","Please, select your backup file":"Veuillez sélectionner votre fichier de sauvegarde","Pre-Auth Holds":"Blocages pré-autorisés","Preferences":"Préférences","Preparing addresses...":"Préparation des adresses...","Preparing backup...":"Préparation de la sauvegarde...","Press again to exit":"Appuyez de nouveau pour quitter","Priority":"Élevés","Private Key":"Clé privée","Private key encrypted. Enter password":"Clé privée chiffrée. Saisissez le mot de passe","Private key is encrypted, cannot sign":"La clé privée est chiffrée, impossible de signer","Proposal Accepted":"Proposition acceptée","Proposal Created":"Proposition créée","Proposal Deleted":"Proposition supprimée","Proposal Rejected":"Proposition rejetée","Proposals":"Propositions","Purchase Amount is limited to {{limitPerDay}} {{currency}} per day":"Le montant d'achat est limité à {{limitPerDay}} {{currency}} par jour","Purchase amount must be a value between 50 and 2000":"Le montant d'achat doit être une valeur comprise entre 50 et 2000","Push Notifications":"Notifications","Push notifications for {{appName}} are currently disabled. Enable them in the Settings app.":"Les notifications pour {{appName}} sont actuellement désactivées. Activez-les dans les paramètres de l'appli.","QR Code":"Code QR","Quick review!":"Récapitulatif !","Random":"Aléatoire","Rate on the app store":"Évaluer dans la boutique","Read less":"En savoir moins","Read more":"En savoir plus","Read more in our Wiki":"Lisez notre Wiki pour en savoir plus","Read only wallet":"Portefeuille en lecture seule","Receive":"Recevoir","Receive in":"Recevoir dans","Received":"Reçus","Received Funds":"Fonds reçus","Receiving":"Réception","Recent":"Transactions récentes","Recent Transaction Card":"Carte des transactions récentes","Recent Transactions":"Transactions récentes","Recipient":"Destinataire","Recipients":"Destinataire(s)","Recovery phrase":"Phrase de récupération","Recreating Wallet...":"Recréation du portefeuille...","Redeem now":"Utiliser maintenant","Rejected":"Rejetée","Rejecting payment proposal":"Rejet de la proposition de paiement","Release information":"Informations de version","Remove":"Supprimer","Remove BitPay Account?":"Supprimer le compte BitPay ?","Remove BitPay Card?":"Supprimer la BitPay Card ?","Removing your BitPay account will remove all associated BitPay account data from this device. Are you sure you would like to remove your BitPay Account ({{email}}) from this device?":"La suppression de votre compte BitPay supprimera tous les données de compte BitPay associées à cet appareil. Êtes-vous sûr(e) de vouloir supprimer votre compte BitPay {{email}} de cet appareil ?","Repeat password":"Confirmez le mot de passe","Repeat the password":"Confirmez le mot de passe","Request Fingerprint":"Demander l'empreinte digitale","Request Specific amount":"Demander un montant précis","Request Spending Password":"Demander un code de dépenses","Required number of signatures":"Nombre requis de signatures","Restore from backup":"Restaurer à partir d'une sauvegarde","Retrieving inputs information":"Récupération des informations d'entrée","Retry":"Rééssayer","Retry Camera":"Réessayer la caméra","Save":"Valider","Scan":"Numériser","Scan QR Codes":"Numérisez des codes QR","Scan addresses for funds":"Analyser les adresses pour des fonds","Scan again":"Réanalyser","Scan your fingerprint please":"Veuillez scanner votre empreinte digitale","Scanning Wallet funds...":"Analyse des fonds du portefeuille...","Scanning funds...":"Analyse des fonds...","Screenshots are not secure":"Les captures d’écran ne sont pas sécurisées","Search Transactions":"Rechercher des transactions","Search or enter bitcoin address":"Recherchez ou saisissez une adresse bitcoin","Search transactions":"Rechercher des transactions","Search your currency":"Rechercher votre monnaie","Security":"Sécurité ","See invoice":"Voir la facture","Select a backup file":"Sélectionner un fichier de sauvegarde","Select a wallet":"Sélectionner un portefeuille","Self-signed Certificate":"Certificat auto-signé","Selling Qybcoin...":"Vente de bitcoins...","Send":"Envoyer","Send Feedback":"Envoyer un avis","Send Money":"Envoyer de l'argent","Send addresses by email":"Envoyer les adresses par e-mail","Send by email":"Envoyer par e-mail","Send from":"Envoyer à partir de","Send max amount":"Envoyer le montant maximal","Send payment to this address":"Envoyer le paiement à cette adresse","Send us feedback instead":"Nous envoyer un avis à la place","Sending":"Envoi","Sending 2FA code...":"Envoi du code 2FA...","Sending feedback...":"Envoi de votre avis...","Sending maximum amount":"Envoi du montant maximal","Sending transaction":"Envoi de la transaction","Sending {{amountStr}} from your {{name}} wallet":"Envoi de {{amountStr}} depuis votre portefeuille {{name}}","Sent":"Envoyés","Sent Funds":"Fonds envoyés","Server response could not be verified":"La réponse du serveur n'a pas pu être vérifiée","Service not available":"Service non disponible","Services":"Services","Session Log":"Journal de session","Session log":"Journal de session","Set up a password":"Spécifiez un mot de passe","Set your own fee in satoshis/byte":"Définissez vos propres frais en satoshis/byte","Settings":"Paramètres","Share the love by inviting your friends.":"Partagez l’amour en invitant vos amis.","Share this invitation with your copayers":"Partagez cette invitation avec vos copayers","Share {{appName}}":"Partager {{appName}}","Shared Wallet":"Portefeuille partagé","Show Recovery Phrase":"Afficher la phrase de récupération","Show address":"Afficher l'adresse","Show advanced options":"Afficher les options avancées","Show bitcoin address":"Afficher vos adresses bitcoin","Show more":"En afficher plus","Signatures rejected by server":"Signatures rejetées par le serveur","Signing transaction":"Signature de la transaction","Since only you control your money, you’ll need to save your backup phrase in case this app is deleted.":"Puisque vous seul contrôlez votre argent, vous devrez enregistrer votre phrase de sauvegarde au cas où cette appli est supprimée.","Single Address Wallet":"Portefeuille d'adresse unique","Skip":"Ignorer","Slide to accept":"Faites glisser pour accepter","Slide to buy":"Faites glisser pour acheter","Slide to pay":"Faites glisser pour payer","Slide to send":"Faites glisser pour envoyer","Some of your wallets are not eligible for Qybcoin Cash support. You can try to access dmb funds from these wallets using the":"Certains de vos portefeuilles ne sont pas éligibles à Qybcoin Cash. Vous pouvez essayer d’avoir accès aux fonds dmb de ces portefeuilles à l’aide de","Specify Recovery Phrase...":"Spécifier la phrase de récupération...","Spend proposal is not accepted":"La proposition de dépense n'est pas acceptée","Spend proposal not found":"Propostion de dépense introuvable","Spending Password needed":"Code de dépenses requis","Spending this balance will need significant Qybcoin network fees":"La dépense de ce solde demandera d'importants frais de réseau Qybcoin","Start sending bitcoin":"Commencez à envoyer des bitcoins","Startup Lock":"Verrou au démarrage de l'appli","Still pending":"En attente","Success":"Succès","Super Economy":"Infimes","Sweep":"Balayer","Sweep paper wallet":"Balayer un portefeuille de papier","Sweeping Wallet...":"Balayage du portefeuille...","THIS ACTION CANNOT BE REVERSED":"CETTE ACTION NE PEUT PAS ÊTRE ANNULÉE","Take control of your money,<br>get started with bitcoin.":"Prenez le contrôle de votre argent,<br>commencez avec bitcoin.","Tap and hold to show":"Appuyez et maintenez pour afficher","Tap to recreate":"Appuyez pour recréer","Tap to retry":"Tapotez pour réessayer","Terms Of Use":"Conditions d'utilisation","Terms of Use":"Conditions d'utilisation","Testnet":"Testnet","Text":"Texte","Thank you!":"Merci !","Thanks!":"Merci !","That's exciting to hear. We'd love to earn that fifth star from you – how could we improve your experience?":"Votre avis nous intéresse ! Nous aimerions obtenir une note de 5 étoiles de votre part – comment pourrions-nous améliorer votre expérience ?","The Ledger Chrome application is not installed":"L'application Ledger pour Chrome n'est pas installée","The amount of bitcoin immediately spendable from this wallet.":"Le montant des bitcoins immédiatement disponibles depuis ce portefeuille.","The amount of bitcoin stored in this wallet that is allocated as inputs to your pending transaction proposals. The amount is determined using unspent transaction outputs associated with this wallet and may be more than the actual amounts associated with your pending transaction proposals.":"Le montant des bitcoins stockés dans ce portefeuille qui est alloué en tant qu'entrées à vos propositions de transaction en attente. Le montant est déterminé en utilisant les sorties de transaction non dépensées associées à ce portefeuille et peut être plus important que les montants réels associés à vos propositions de transaction en attente.","The amount of bitcoin stored in this wallet with less than 1 blockchain confirmation.":"Le montant des bitcoins stockés dans ce portefeuille avec moins d'une confirmation blockchain.","The derivation path":"Le chemin de dérivation","The exchange rate changes with the market.":"Le taux de change varie avec le marché.","The higher the fee, the greater the incentive a miner has to include that transaction in a block. Current fees are determined based on network load and the selected policy.":"Plus les frais sont importants, plus les mineurs sont incités à inclure votre transaction dans un bloc. Les frais actuels sont déterminés en fonction de la charge du réseau et du choix sélectionné.","The maximum number of consecutive unused addresses (20) has been reached. When one of your unused addresses receives a payment, a new address will be generated and shown in your Receive tab.":"Le nombre maximal d’adresses inutilisées consécutives (20) a été atteint. Lorsqu'une de vos adresses inutilisées reçoit un paiement, une nouvelle adresse sera générée et affichée dans votre onglet Recevoir.","The official English Terms of Service are available on the BitPay website.":"Les conditions d'utilisation officielles en anglais sont disponibles sur le site internet de BitPay.","The password of the recovery phrase (if set)":"Le mot de passe de la phrase de récupération (si configuré)","The payment was created but could not be completed. Please try again from home screen":"Le paiement a été créé mais n'a pas pu être achevé. Veuillez réessayer depuis l'écran d'accueil","The payment was removed by creator":"Le paiement a été supprimé par le créateur","The recovery phrase could require a password to be imported":"La phrase de récupération pourrait demander un mot de passe pour être importée","The request could not be understood by the server":"La demande n'a pas été comprise par le serveur","The restore process will stop when 20 addresses are generated in a row which contain no funds. To safely generate more addresses, make a payment to one of the unused addresses which has already been generated.":"Le processus de restauration s’arrête lorsque 20 adresses sont générées consécutivement sans qu'elles ne contiennent de fonds. Pour générer plus d'adresses en toute sécurité, effectuez un paiement à l’une des adresses inutilisées qui a déjà été générée.","The spend proposal is not pending":"La proposition de dépense n'est pas en attente","The total amount of bitcoin stored in this wallet.":"Le montant total des bitcoins stockés dans ce portefeuille.","The transaction history and every new incoming transaction are cached in the app. This feature clean this up and synchronizes again from the server":"L’historique des transactions et chaque nouvelle transaction entrante sont mis en cache dans l’application. Cette fonctionnalité efface cela et synchronise à nouveau à partir du serveur","The wallet service URL":"L’URL du service de portefeuille","There is a new version of {{appName}} available":"Une nouvelle version de {{appName}} est disponible","There is an error in the form":"Il y a une erreur dans la forme","There's obviously something we're doing wrong.":"Il y a visiblement quelque chose que nous faisons mal.","This app is fantastic!":"Cette appli est fantastique !","This app stores your bitcoin with cutting-edge security.":"Cette appli conserve vos bitcoins avec une sécurité de pointe.","This bitcoin payment request has expired.":"Cette demande de paiement bitcoin a expiré.","This password cannot be recovered. If the password is lost, there is no way you could recover your funds.":"Ce mot de passe ne peut pas être récupéré. Si le mot de passe est perdu, il n’y a aucun moyen pour vous de récupérer vos fonds.","This recovery phrase was created with a password. To recover this wallet both the recovery phrase and password are needed.":"Cette phrase de récupération a été créée avec un mot de passe. Pour récupérer ce portefeuille, la phrase de récupération et le mot de passe sont requis.","This transaction amount is too small compared to current Qybcoin network fees. Spending these funds will need a Qybcoin network fee cost comparable to the funds itself.":"Ce montant de transaction est trop faible par rapport aux actuels frais de réseau Qybcoin. La dépense de ces fonds demandera des frais de réseau Qybcoin comparables aux fonds eux-mêmes.","This transaction could take a long time to confirm or could be dropped due to the low fees set by the sender":"Cette transaction pourrait prendre beaucoup de temps pour être confirmée ou pourrait être abandonnée à cause du faible niveau de frais fixé par l'expéditeur","This wallet is not registered at the given Bitcore Wallet Service (BWS). You can recreate it from the local information.":"Ce portefeuille n'est pas enregistré dans le Bitcore Wallet Service (BWS) donné. Vous pouvez le recréer depuis l'information locale.","Timeline":"Chronologie","To":"À","To get started, buy bitcoin or share your address. You can receive bitcoin from any wallet or service.":"Pour commencer, achetez des bitcoins ou partagez votre adresse. Vous pouvez recevoir des bitcoins de n'importe quel portefeuille ou service.","To get started, you'll need to create a bitcoin wallet and get some bitcoin.":"Pour commencer, vous aurez besoin de créer un portefeuille bitcoin et d'obtenir quelques bitcoins.","To {{reason}} you must first add your BitPay account - {{email}}":"Pour {{reason}} vous devez d'abord ajouter votre compte BitPay - {{email}}","Top up in progress...":"Rechargement en cours...","Top up {{amountStr}} to debit card ({{cardLastNumber}})":"Rechargement de {{amountStr}} vers la carte de débit ({{cardLastNumber}})","Total":"Total","Total Locked Balance":"Solde verrouillé total","Total number of copayers":"Nombre total de copayers","Total wallet inputs":"Entrées de portefeuille totales","Touch ID Failed":"Touch ID a échoué","Transaction":"Transaction","Transaction Created":"Transaction créée","Transaction History":"Historique des transactions","Transaction already broadcasted":"Transaction déjà diffusée","Transaction has not been created":"La transaction n'a pas été créée","Transaction initiated":"Transaction initiée","Transaction not available at this time":"La transaction n'est pas disponible pour l'instant","Transaction not found":"Transaction introuvable","Transactions without fee are not supported.":"Les transactions sans frais ne sont pas supportées.","Transfer to":"Transférer à","Transfer to Wallet":"Transférer vers un portefeuille","Try again in {{expires}}":"Réessayez dans {{expires}}","Turn bitcoin into dollars, swipe anywhere Visa<sup>®</sup> is accepted.":"Convertissez des bitcoins en dollars et dépensez partout où Visa<sup>&reg;</sup> est accepté.","Type the Recovery Phrase (usually 12 words)":"Saisissez la phrase de récupération (généralement 12 mots)","Uh oh...":"Oh là là...","Unconfirmed":"Non confirmée","Unsent transactions":"Transactions non envoyées","Unused Addresses":"Adresses inutilisées","Unused Addresses Limit":"Limite des adresses inutilisées","Update Available":"Mise à jour disponible","Updating pending proposals. Please stand by":"Mise à jour des propositions en attente. Veuillez patienter","Updating transaction history. Please stand by.":"Mise à jour de l'historique des transactions. Veuillez patienter.","Updating... Please stand by":"Mise à jour... veuillez patienter","Urgent":"Très élevés","Use Unconfirmed Funds":"Utiliser les fonds non confirmés","Validating recovery phrase...":"Validation de la phrase de récupération...","Verify your identity":"Vérification de votre identité","Version":"Version","View":"Voir","View All Addresses":"Voir toutes les adresses","View Terms of Service":"Voir les conditions d'utilisation","View Transaction on Insight":"Voir la transaction sur Insight","View Update":"Voir la mise à jour","View on blockchain":"Voir sur la blockchain","Visit mercadolivre.com.br &rarr;":"Visiter mercadolivre.com.br &rarr;","WARNING: Key derivation is not working on this device/wallet. Actions cannot be performed on this wallet.":"ATTENTION : La dérivation de la clé ne fonctionne pas sur cet appareil / portefeuille. Impossible d’effectuer des actions sur ce portefeuille.","WARNING: Not including the private key allows to check the wallet balance, transaction history, and create spend proposals from the export. However, does not allow to approve (sign) proposals, so <b>funds will not be accessible from the export</b>.":"ATTENTION : Ne pas inclure la clé privée permet de vérifier le solde du portefeuille, l'historique des transactions, et de créer des demandes de dépenses depuis le fichier exporté. Cependant, cela ne permet pas d'approuver (signer) les propositions <b>et les fonds ne seront pas accessibles depuis le fichier exporté</b>.","WARNING: The private key of this wallet is not available. The export allows to check the wallet balance, transaction history, and create spend proposals from the export. However, does not allow to approve (sign) proposals, so <b>funds will not be accessible from the export</b>.":"ATTENTION : La clé privée de ce portefeuille n'est pas disponible. L'exportation permet de vérifier le solde du portefeuille, l'historique des transactions, et de créer des propositions de dépenses depuis le fichier exporté. Cependant, cela ne permet pas d'approuver (signer) les propositions <b>et les fonds ne seront pas accessibles depuis le fichier exporté</b>.","WARNING: UNTRUSTED CERTIFICATE":"ATTENTION : CERTIFICAT NON APPROUVÉ","WARNING: Your extended private keys are all that is needed to access your bitcoin funds. Be sure to protect your private keys and store them only on secure devices. BitPay does not have access to your private keys, so you alone are responsible for your keys. If you share key access with external services, you take responsibility for the risk of theft or breach. Only advanced users should handle extended private keys directly.":"Attention : vos clés privées étendues permettent un accès direct et intégral à vos fonds bitcoin. Veillez à protéger vos clés privées et à ne les stocker que sur des appareils sécurisés. BitPay n'a pas accès à vos clés privées et vous êtes seul responsable de vos clés. Si vous partagez l'accès à une clé avec des services externes, vous assumez la responsabilité du risque de vol ou de violation. Seuls les utilisateurs avertis doivent gérer les clés privées étendues.","Waiting for Ledger...":"En attente de Ledger...","Waiting for Trezor...":"En attente de Trezor...","Waiting for copayers":"Attente des copayers","Waiting...":"Attente...","Wallet Addresses":"Adresses du portefeuille","Wallet Color":"Couleur du portefeuille","Wallet Configuration (m-n)":"Configuration du portefeuille (m-n)","Wallet Created":"Portefeuille créé","Wallet Id":"Id du portefeuille","Wallet Information":"Informations du portefeuille","Wallet Inputs":"Entrées de portefeuille","Wallet Invitation":"Invitation de portefeuille","Wallet Key":"Clé du portefeuille","Wallet Name":"Nom du portefeuille","Wallet Name (at creation)":"Nom du portefeuille (à la création)","Wallet Network":"Réseau du portefeuille","Wallet Recovery Phrase":"Phrase de récupération","Wallet Recovery Phrase is invalid":"La phrase de récupération du portefeuille est invalide","Wallet Service URL":"Wallet Service URL","Wallet Settings":"Paramètres du portefeuille","Wallet Type":"Type de portefeuille","Wallet already exists":"Le portefeuille existe déjà","Wallet already in {{appName}}":"Le portefeuille existe déjà dans {{appName}}","Wallet created":"Portefeuille créé","Wallet incomplete and broken":"Portefeuille incomplet et cassé ","Wallet is full":"Le portefeuille est plein","Wallet is locked":"Le portefeuille est verrouillé","Wallet is not complete":"Le portefeuille n'est pas complet","Wallet name":"Nom du portefeuille","Wallet needs backup":"Le portefeuille a besoin d'une sauvegarde","Wallet not backed up":"Le portefeuille n'est pas sauvegardé","Wallet not found":"Portefeuille introuvable","Wallet not registered":"Portefeuille non enregistré","Wallet not registered at the wallet service. Recreate it from \"Create Wallet\" using \"Advanced Options\" to set your recovery phrase":"Le portefeuille n'est pas enregistré au Wallet Service. Vous pouvez le recréer depuis « Créer » en utilisant les « Options avancées » pour configurer votre phrase de récupération","Wallet recovery phrase not available":"La phrase de récupération du portefeuille n'est pas disponible","Wallet service not found":"Wallet Service introuvable","Wallets":"Portefeuilles","Warning!":"Attention !","Warning: this transaction has unconfirmed inputs":"ATTENTION : Cette transaction a des entrées non confirmées","Watch out!":"Méfiez-vous !","We'd love to do better.":"Nous serions ravis de faire mieux.","We'll confirm on the next screen.":"Nous allons la confirmer sur l’écran suivant.","We're always looking for ways to improve {{appName}}.":"Nous recherchons constamment des moyens afin d'améliorer {{appName}}.","We're always looking for ways to improve {{appName}}. How could we improve your experience?":"Nous recherchons constamment des moyens afin d'améliorer {{appName}}. Comment pourrions-nous améliorer votre expérience ?","Website":"Site internet","We’re always looking for translation contributions! You can make corrections or help to make this app available in your native language by joining our community on Crowdin.":"Nous recherchons toujours des contributions de traduction ! Vous pouvez apporter des corrections ou aider à rendre cette application disponible dans votre langue maternelle en rejoignant notre communauté sur Crowdin.","What do you call this wallet?":"Comment voulez-vous appeler ce portefeuille ?","When this wallet was created, it was called “{{walletName}}”. You can change the name displayed on this device below.":"Lorsque ce portefeuille a été créé, il se nommait &ldquo;{{walletName}}&rdquo;. Vous pouvez modifier ci-dessous le nom affiché sur cet appareil.","Where would you like to receive email notifications about payments?":"Souhaitez-vous recevoir des notifications par e-mail à propos des paiements ?","Why?":"Pourquoi ?","Would you be willing to rate {{appName}} in the app store?":"Seriez-vous prêt à évaluer {{appName}} dans la boutique d'application ?","Would you like to receive push notifications about payments?":"Souhaitez-vous recevoir des notifications relatives aux paiements ?","Wrong number of recovery words:":"Nombre incorrect de mots de récupération :","Wrong spending password":"Code de dépenses incorrect","Yes":"Oui","Yes, skip":"Oui, ignorer","You can create a backup later from your wallet settings.":"Vous pouvez créer une sauvegarde plus tard à partir des paramètres de votre portefeuille.","You can make contributions by signing up on our Crowdin community translation website. We’re looking forward to hearing from you!":"Vous pouvez apporter des contributions en vous inscrivant sur notre site internet de traduction communautaire Crowdin. Nous sommes impatients de vous y voir !","You can scan bitcoin addresses, payment requests, paper wallets, and more.":"Vous pouvez numériser des adresses bitcoin, des demandes de paiement, des portefeuilles de papier et plus.","You can see the latest developments and contribute to this open source app by visiting our project on GitHub.":"Vous pouvez voir les derniers développements et contribuer à cette application open source en visitant notre projet sur GitHub.","You can spend bitcoin at millions of websites and stores worldwide.":"Vous pouvez dépenser des bitcoins dans des millions de sites internet et de boutiques à travers le monde.","You can still export it from Advanced &gt; Export.":"Vous pouvez l’exporter depuis le menu « Avancé » &gt; « Exporter ».","You can trade it for other currencies like US Dollars, Euros, or Pounds.":"Vous pouvez l’échanger contre d'autres monnaies comme le dollar américain, l'euro ou la livre.","You control your bitcoin.":"Vous contrôlez vos bitcoins.","You should not set a fee higher than {{maxFeeRecommended}} satoshis/byte.":"Vous ne devriez pas définir des frais plus élevés que {{maxFeeRecommended}} satoshis/byte.","You will need to log back for fill in your BitPay Card.":"Vous devrez vous reconnecter pour approvisionner votre BitPay Card.","You'll receive email notifications about payments sent and received from your wallets.":"Vous recevrez des notifications par e-mail concernant les paiements envoyés et reçus depuis vos portefeuilles.","Your BitPay Card is ready. Add funds to your card to start using it at stores and ATMs worldwide.":"Votre BitPay Card est prête. Ajoutez des fonds sur votre carte pour commencer à l'utiliser dans des magasins et distributeurs automatiques à travers le monde entier.","Your Gift Cards":"Vos cartes-cadeaux","Your bitcoin wallet is backed up!":"Votre portefeuille bitcoin est sauvegardé !","Your bitcoin wallet is ready!":"Votre portefeuille bitcoin est prêt !","Your fee is lower than recommended.":"Vos frais sont inférieurs au niveau recommandé.","Your ideas, feedback, or comments":"Vos idées, vos commentaires ou observations","Your name":"Votre nom","Your nickname":"Votre surnom","Your password":"Votre mot de passe","Your purchase could not be completed":"Votre achat n'a pas pu aboutir","Your purchase was added to the list of pending":"Votre achat a été ajouté à la liste d’attente","Your wallet is never saved to cloud storage or standard device backups.":"Votre portefeuille n’est jamais enregistré en dehors de votre appareil ou dans des sauvegardes qui lui sont propres.","Your wallet key will be encrypted. The Spending Password cannot be recovered. Be sure to write it down.":"La clé de votre portefeuille sera chiffrée. Le code de dépenses ne peut pas être récupéré. N'oubliez pas de l'écrire.","[Balance Hidden]":"[Solde masqué]","[Scanning Funds]":"[Analyse des fonds]","add your BitPay Visa card(s)":"ajouter vos cartes BitPay Visa","locked by pending payments":"verrouillés par les paiements en attente","me":"moi","name@example.com":"nom@exemple.com","preparing...":"préparation...","recovery tool.":"l'outil de récupération.","{{amountStr}} for Amazon.com Gift Card":"{{amountStr}} pour la carte-cadeau Amazon.com","{{amountStr}} for Mercado Livre Brazil Gift Card":"{{amountStr}} pour la carte-cadeau Mercado Livre Brazil","{{appName}} depends on Bitcore Wallet Service (BWS) for blockchain information, networking and Copayer synchronization. The default configuration points to https://bws.bitpay.com (BitPay's public BWS instance).":"{{appName}} repose sur Bitcore Wallet Service (BWS) pour les informations de blockchain, le réseau et la synchronisation des Copayers. La configuration par défaut est orientée vers https://bws.bitpay.com (instance BWS publique de BitPay).","{{fee}} will be deducted for bitcoin networking fees.":"{{fee}} seront déduits pour les frais de réseau Qybcoin.","{{tx.txp[wallet.id].feeRatePerStr}}  of the sending amount":"{{tx.txp[wallet.id].feeRatePerStr}} du montant d'envoi","{{updatingTxHistoryProgress}} transactions downloaded":"{{updatingTxHistoryProgress}} transactions téléchargées","{{wallet.m}}-of-{{wallet.n}}":"{{wallet.m}}-sur-{{wallet.n}}"});
    gettextCatalog.setStrings('it', {"(Trusted)":"(Fidato)","(possible double spend)":"(possibile doppia spesa)","* A payment proposal can be deleted if 1) you are the creator, and no other copayer has signed, or 2) 24 hours have passed since the proposal was created.":"* Una proposta di pagamento può essere eliminata se 1) Tu sei il creatore e nessun altro copayer ha firmato, oppure 2) Sono passate 24 ore da quando la proposta e' stata creata.","- {{btx.feeRateStr}} of the transaction":"- {{btx.feeRateStr}} della transazione","- {{tx.feeRateStr}} of the transaction":"- {{tx.feeRateStr}} della transazione","5-star ratings help us get {{appName}} into more hands, and more users means more resources can be committed to the app!":"Darci un voto a 5 stelle ci aiuta a portare {{appName}} a più mani, e più utenti significa più risorse possono essere impegnate sull'app!","<b>Only</b> redeemable on Mercado Livre (Brazil)":"<b>Solo</b> rimborsabili su Mercado Livre (Brasile)","A member of the team will review your feedback as soon as possible.":"Un membro del team esaminerà il tuo feedback appena possibile.","A total of {{amountAboveMaxSizeStr}} were excluded. The maximum size allowed for a transaction was exceeded.":"Un totale di{{amountAboveMaxSizeStr}} sono state escluse. La dimensione massima consentita per una transazione è stata superata.","A total of {{amountBelowFeeStr}} were excluded. These funds come from UTXOs smaller than the network fee provided.":"Un totale di {{amountBelowFeeStr}} è stato escluso. Questi fondi provengono da UTXO più piccole rispetto alla commissione di rete fornita.","About":"Informazioni","Accepted":"Accettata","Account":"Conto","Account Number":"Numero del Conto","Accounts":"Account","Activity":"Attività","Add Account":"Aggiungere Account","Add BitPay Account?":"Aggiungere il conto BitPay?","Add Contact":"Aggiungi Contatto","Add Funds":"Aggiungere fondi","Add Memo":"Aggiungi Memo","Add a password":"Aggiungi una password","Add account":"Aggiungere account","Add an optional password to secure the recovery phrase":"Aggiungere una password facoltativa per proteggere la frase di recupero","Add as a contact":"Aggiungi come contatto","Add description":"Aggiungi descrizione","Add funds":"Aggiungi fondi","Add this BitPay account ({{email}})?":"Aggiungere questo account BitPay ({{email}})?","Add wallet":"Aggiungi un portafoglio","Address":"Indirizzo","Address Book":"Rubrica Indirizzi","Address Type":"Tipo di indirizzo","Addresses With Balance":"Indirizzi con saldo","Advanced":"Avanzato","Advanced Settings":"Impostazioni avanzate","All":"Tutto","All Addresses":"Tutti gli indirizzi","All of your bitcoin wallet balance may not be available for immediate spending.":"Tutto il bilancio del tuo portafoglio potrebbe non essere disponibile ad essere speso nell'immediato.","All signing devices must be added to this multisig wallet before bitcoin addresses can be created.":"Tutti i dispositivi firmanti devono essere aggiunti a questo portafoglio multisig prima che si possano creare indirizzi bitcoin.","Allow Camera Access":"Abilita accesso macchina fotografica","Allow notifications":"Consenti notifiche","Almost done! Let's review.":"Quasi finito! Ripassiamo.","Alternative Currency":"Valuta alternativa","Amazon.com is not available at this moment. Please try back later.":"Ia tabella dei guadagni di Amazon.com non è disponibile al momento. Per favore riprova piu tardi.","Amount":"Ammontare","Amount below minimum allowed":"Importo inferiore al minimo consentito","Amount too big":"Quantità troppo grande","Amount too low to spend":"Quantità troppo bassa per essere spesa","An update to this app is available. For your security, please update to the latest version.":"Un aggiornamento dell'app è disponibile. Per la tua sicurezza è consigliato aggiornare all'ultima versione.","Anyone with your backup phrase can access or spend your bitcoin.":"Qualcuno con la tua frase di recupero potrebbe avere accesso o spendere i tuoi bitcoin.","Approximate Qybcoin network fee to transfer wallet's balance (with normal priority)":"La tariffa approssimativa della rete Qybcoin per il trasferimento del saldo del portafoglio ( con priorità normale)","Are you being watched?":"Sei osservato?","Are you being watched? Anyone with your recovery phrase can access or spend your bitcoin.":"Siete osservati? Chiunque con la vostra frase di recupero può accedere o spendere i vostri bitcoin.","Are you sure you want to cancel and delete this wallet?":"Sei sicuro di voler eliminare questo portafoglio?","Are you sure you want to delete this contact?":"Sei sicuro di voler cancellare questo contatto?","Are you sure you want to delete this wallet?":"Sei sicuro di voler eliminare questo portafoglio?","Are you sure you want to reject this transaction?":"Sei sicuro di voler rifiutare questa transazione?","Are you sure you want to remove this transaction?":"Sei sicuro di voler rimuovere questa transazione?","Are you sure you want to skip it?":"Sei sicuro di voler saltare?","Are you sure you would like to log out of your BitPay Card account?":"Sei sicuro che vuoi uscire dal tuo account BitPay Card?","Are you sure you would like to remove your BitPay Card ({{lastFourDigits}}) from this device?":"Sei certo di volere rimuovere la tua BitPay Card ({{lastFourDigits}}) da questo dispositivo?","Auditable":"Controllabile","Available":"Disponibile","Available Balance":"Saldo disponibile","Average confirmation time":"Tempo previsto per la conferma","BIP32 path for address derivation":"Percorso BIP32 per generare l'indirizzo","QYB wallets":"Portafogli QYB","Backup":"Backup","Backup Needed":"Backup necessario","Backup all livenet wallets before using this function":"Fai un backup di tutti i portafogli sulla livenet prima di utilizzare questa funzione","Backup needed":"Backup necessario","Backup now":"Esegui backup ora","Backup wallet":"Backup portafoglio","Backup your wallet before using this function":"Eseguire il backup del tuo portafoglio prima di utilizzare questa funzione","Bad wallet invitation":"Invito al wallet non corretto","Balance By Address":"Bilancio per indirizzo","Be sure to store your recovery phrase in a secure place. If this app is deleted, your money cannot be recovered without it.":"Assicurati di salvare la frase di recupero in un luogo sicuro. Senza di essa, se rimuovi questa applicazione il tuo denaro non potrà essere recuperato.","BitPay Visa® Cards":"Carte di BitPay Visa®","Qybcoin Address":"Indirizzo Qybcoin","Qybcoin Cash Wallets":"Portafogli Qybcoin Cash","Qybcoin Network Fee Policy":"Criterio delle Commissioni del Qybcoin Network","Qybcoin Wallets":"Portafogli Qybcoin","Qybcoin cash Payment":"Pagamento Qybcoin Cash","Qybcoin is a currency.":"Qybcoin è una moneta.","Qybcoin is different – it cannot be safely held with a bank or web service.":"Qybcoin è differente e non può essere custodito in una banca o con un servizio web.","Qybcoin is secure,<br>digital money.":"Qybcoin è sicuro,<br>moneta digitale.","Qybcoin transactions include a fee collected by miners on the network.":"Le transazioni Qybcoin comprendono un supplemento che viene raccolto dai mines nella rete.","Bought {{amountUnitStr}}":"Comprato {{amountUnitStr}}","Broadcast Payment":"Diffusione del Pagamento","Broadcasted":"Trasmesso","Broadcasting transaction":"Diffondendo la transazione","Browser unsupported":"Browser non supportato","Buy":"Acquista","Buy &amp; Sell Qybcoin":"Comprare &amp; Vendere Qybcoin","Buy Qybcoin":"Acquista Qybcoin","Buy a Gift Card":"Acquista una carta regalo","Buy from":"Acquista da","Buying Qybcoin...":"Comprare Qybcoin...","Calculating fee":"Calcolo commissione","Cancel":"Annulla","Cancel invitation":"Annulla invito","Cannot Create Wallet":"Impossibile creare portafoglio","Cannot join the same wallet more that once":"Non è possibile aggiungere un portafoglio più di una volta","Cards":"Carte","Certified by":"Certificato da","Check installation and retry.":"Verifica installazione e riprovare.","Choose a backup file from your computer":"Seleziona un file di backup dal tuo computer","Choose your destination wallet":"Scegli il tuo portafoglio di destinazione","Choose your source wallet":"Scegli il tuo portafoglio di origine","Clear":"Elimina","Clear cache":"Svuota la cache","Click to accept":"Fare clic per accettare","Click to pay":"Fai clic per pagare","Click to send":"Clicca per inviare","Close":"Chiudi","Coin":"Moneta","Color":"Colore","Commit hash":"Commit hash","Complete the backup process to use this option":"Completare il processo di backup per utilizzare questa opzione","Completed":"Completato","Confirm":"Conferma","Confirm &amp; Finish":"Confirm &amp; concludi","Confirm purchase":"Conferma acquisto","Confirm your PIN":"Conferma il tuo PIN","Confirm your new spending password":"Conferma la tua nuova password di spesa","Confirmations":"Conferme","Confirming":"Confermando","Connect my BitPay Card":"Collegare la mia Carta BitPay","Connecting to Coinbase...":"Connessione a Coinbase...","Connecting to Glidera...":"Connessione a Glidera...","Connection reset by peer":"Connessione ripristinata dall'utente","Contacts":"Contatti","Continue":"Continua","Contribute Translations":"Contribuisci alle traduzioni","Qyb only supports Qybcoin Cash using new version numbers addresses":"Qyb supporta Qybcoin Cash soltanto utilizzando la nuova versione di indirizzi","Copayer already in this wallet":"Copayer già in questo portafoglio","Copayer already voted on this spend proposal":"Copayer già votato su questa proposta","Copayer data mismatch":"Mancata corrispondenza dei dati del copayer","Copayer joined":"Copayer iscritto","Copayer {{$index}}":"Copayer {{$index}}","Copied to clipboard":"Copiato negli appunti","Copy this text as it is to a safe place (notepad or email)":"Copia questo testo cosí com'è in un posto sicuro (blocco note o email)","Copy to clipboard":"Copia negli appunti","Could not access Gift Card Service":"Impossibile accedere Servizio Carta Regalo","Could not access the wallet at the server. Please check:":"Non può accedere al portafoglio sul server. Si prega di controllare:","Could not access to Amazon.com":"Impossibile accedere ad Amazon.com","Could not access wallet":"Impossibile accedere al portafoglio","Could not add message to imported wallet without shared encrypting key":"Non puoi aggiungere un messaggio da importare nel portafoglio senza condividere la chiave criptata","Could not broadcast payment":"Impossibile trasmettere il pagamento","Could not build transaction":"Non è possibile generare la transazione","Could not create address":"Impossibile creare un indirizzo","Could not create the invoice":"Non è stato creata la fattura","Could not create transaction":"Non è possibile creare la transazione","Could not create using the specified extended private key":"Non posso crearlo utilizzando la chiave privata estesa specificata","Could not create using the specified extended public key":"Non è possibile creare usando questa chiave estesa pubblica","Could not create: Invalid wallet recovery phrase":"Impossibile creare: Frase di recupero portafoglio non valida","Could not decrypt file, check your password":"Impossibile decifrare il file, controlla la tua password","Could not delete payment proposal":"Impossibile eliminare la proposta di pagamento","Could not duplicate":"Duplicazione non riuscita","Could not get dynamic fee":"Impossibile avere commissioni dinamiche","Could not get dynamic fee for level: {{feeLevel}}":"Impossibile avere la commissione per il livello: {{feeLevel}}","Could not get fee levels":"Livelli commissione non disponibile","Could not get the invoice":"La fattura non puo essere creata","Could not get transactions":"Non è possibile ottenere le transazioni","Could not import":"Impossibile importare","Could not import. Check input file and spending password":"Impossibile importare. Controlla il file da importare e la password di spesa","Could not join wallet":"Impossibile partecipare al portafoglio","Could not reject payment":"Impossibile rifiutare il pagamento","Could not remove account":"Rimozione account non riuscita","Could not remove card":"Impossibile rimuovere la carta","Could not save preferences on the server":"Impossibile salvare le preferenze nel server","Could not send payment":"Impossibile inviare il pagamento","Could not send transaction":"Non è possibile inviare la transazione","Could not update transaction history":"Impossibile aggiornare la cronologia delle transazioni","Could not update wallet":"Impossibile aggiornare il portafoglio","Create Personal Wallet":"Creare il portafoglio personale","Create Shared Wallet":"Creare portafoglio condiviso","Create bitcoin wallet":"Creare portafoglio bitcoin","Create new wallet":"Crea nuovo portafoglio","Create shared wallet":"Creare portafoglio condiviso","Create {{formData.requiredCopayers}}-of-{{formData.totalCopayers}} wallet":"Creare il portafoglio di {{formData.requiredCopayers}}-di-{{formData.totalCopayers}}","Created by":"Creato da","Creating Wallet...":"Creazione Portafoglio...","Creating transaction":"Creazione transazione","Current fee rate for this policy":"Attuale commissione con questa politica","Custom":"Personalizzata","Custom Amount":"Importo personalizzato","Custom Fee":"Commissione personalizzata","Date":"Data","Delete":"Elimina","Delete Payment Proposal":"Elimina Proposta di Pagamento","Delete Wallet":"Elimina Portafoglio","Delete it and create a new one":"Eliminalo e creane uno nuovo","Deleting Wallet...":"Eliminazione del portafoglio...","Deleting payment proposal":"Cancello la richiesta di pagamento","Derivation Path":"Percorso derivato","Derivation Strategy":"Strategia di derivazione","Details":"Dettagli","Disabled":"Disabilitato","Do it later":"Farlo in seguito","Do not include private key":"Non includere la chiave privata","Don't see your language on Crowdin? Contact the Owner on Crowdin! We'd love to support your language.":"Non vedi la tua lingua su Crowdin? Contatta il proprietario su Crowdin! Ci piacerebbe supportare la lingua.","Download":"Download","Duplicate for dmb":"Duplicato per dmb","Duplicating wallet...":"Duplicazione di portafoglio...","Each bitcoin wallet can generate billions of addresses from your 12-word backup. A new address is automatically generated and shown each time you receive a payment.":"Ogni portafoglio bitcoin è in grado di generare miliardi di indirizzi dal tuo backup di 12 parole. Un nuovo indirizzo verrà automaticamente generato e mostrato ogni volta che riceverai un pagamento.","Economy":"Economia","Edit":"Modifica","Email":"Email","Email Address":"Indirizzo Email","Empty addresses limit reached. New addresses cannot be generated.":"Raggiunto il limite degli indirizzi vuoti. Non possono essere generati nuovi indirizzi.","Enable camera access in your device settings to get started.":"Abilita l'accesso alla fotocamera dalle impostazioni del tuo dispositivo per iniziare.","Enable email notifications":"Attiva Notifiche Email","Enable push notifications":"Abilitare le notifiche push","Enable the camera to get started.":"Abilita la fotocamera per iniziare.","Enter Spending Password":"Inserisci Password di spesa","Enter Two Factor for your BitPay account":"Inserisci Due Fattori per il tuo account BitPay","Enter amount":"Inserisci importo","Enter custom fee":"Inserisci commissione personalizzata","Enter new spending password":"Inserisci la nuova password di spesa","Enter the recovery phrase (BIP39)":"Inserire la frase di recupero (BIP39)","Enter your email":"Inserisci la tua e-mail","Enter your password":"Inserisci la tua password","Error":"Errore","Error at confirm":"Errore di conferma","Error creating gift card":"Errore nella creazione della Gift card","Error creating the invoice":"Errore nella creazione della fattura","Error creating wallet":"Errore creazione portafoglio","Error getting SendMax information":"Errore nel recupero di informazione SendMax","Error in Payment Protocol":"Errore nel protocollo di pagamento","Error pairing BitPay Account":"Errore di accoppiamento BitPay Account","Error scanning funds:":"Errore di scansione dei fondi:","Error sweeping wallet:":"Errore nello spazzolamento del portafoglio:","Error updating Debit Cards":"Errore durante l'aggiornamento delle carte di debito","Exceeded daily limit of $500 per user":"Superato il limite giornaliero di $500 per utente","Expired":"Scaduta","Expires":"Scadenza","Export Wallet":"Esporta portafoglio","Export to file":"Esporta in un file","Export wallet":"Esporta portafoglio","Exporting via QR not supported for this wallet":"Per questo portafoglio non è supportata l'esportazione tramite QR","Extended Private Key":"Chiave Privata Estesa","Extended Public Keys":"Chiave pubblica estesa","Extracting Wallet information...":"Recupero informazioni del portafoglio...","Failed to export":"Esportazione non riuscita","Family vacation funds":"Fondi vacanza di famiglia","Fee":"Tassa","Fee level":"Livello della commissione","Fee level is not defined":"Livello commissione non definito","Fee:":"Commissione:","Feedback could not be submitted. Please try again later.":"Il feedback non può essere sottoscritto. Riprova più tardi.","Fetching BitPay Account...":"Recupero Account BitPay...","Fetching payment information":"Recupero informazione del pagamento","File/Text":"File/Testo","Filter setting":"Impostazione del filtro","Finger Scan Failed":"Scansione dito fallita","Finish":"Fine","For audit purposes":"Per finalità di controllo","From":"Da","From BitPay account":"Dal conto BitPay","From Hardware Wallet":"Dal portafoglio Hardware","From the destination device, go to Add wallet &gt; Import wallet and scan this QR code":"Dal dispositivo di destinazione, andare in Aggiungi portafoglio &gt; Importare portafoglio e scansionare questo codice QR","Funds are locked by pending spend proposals":"I fondi sono bloccati in attesa della proposta di pagamento","Funds found:":"Fondi trovati:","Funds to be added":"Fondi da aggiungere","Funds transferred":"Fondi trasferiti","Funds were added to debit card":"I fondi sono stati aggiunti alla carta di debito","Funds will be transferred to":"I fondi saranno trasferiti a","Generate new address":"Genera un nuovo indirizzo","Generating .csv file...":"Genera un file .csv...","Generating new address...":"Generando un nuovo indirizzo...","Get local cash anywhere you go, from any Visa<sup>®</sup> compatible ATM. ATM bank fees may apply.":"Ottieni contante locale ovunque tu vada, da qualsiasi ATM bancomat compatibile con Visa<sup>&reg;</sup>. Possibili commissioni bancarie da ATM.","Get news and updates from BitPay":"Ricevi notizie e aggiornamenti da BitPay","Get started":{"$$noContext":"Inizia","button":"Per iniziare"},"Get started by adding your first one.":"Inizia aggiungendo il tuo primo.","Getting fee levels...":"Ottenendo i livelli di commissione...","Gift Card":"Carta Regalo","Gift Card is not available to use anymore":"Gift Card non è più disponibile per l'uso","Gift card expired":"Carta regalo scaduta","Gift card generated and ready to use.":"Carta regalo generata e pronta all'uso.","Go Back":"Indietro","Go back":"Indietro","Got it":"Ok","Hardware Wallet":"Portafoglio Hardware","Hardware not connected.":"Hardware non collegato.","Hardware wallet":"Portafoglio hardware","Hardware wallets are not yet supported with Qybcoin Cash":"I portafogli hardware non sono ancora supportati con Qybcoin Cash","Help & Support":"Aiuto e Assistenza","Help and support information is available at the website.":"Guida e informazioni di supporto tecnico sono disponibili sul sito web.","Hide":"Nascondere","Hide Balance":"Nascondere saldo","Hide Next Steps Card":"Nascondere le successive procedure per la carta","Hide advanced options":"Nascondi opzioni avanzate","Home":"Home","How could we improve your experience?":"Come potremmo migliorare la tua esperienza?","How do you like {{appName}}?":"Come ti piace {{appName}}?","I don't like it":"Non mi piace","I have read, understood, and agree to the <a ng-click=\"openTerms()\" translate=\"\">Terms of Use</a>.":"Ho letto, compreso, e sono d'accordo con <a ng-click=\"openTerms()\" translate=\"\"> Condizioni d'uso</a>.","I have read, understood, and agree with the Terms of use.":"Ho letto, compreso, e sono d'accordo con le Condizioni d'uso.","I have written it down":"L'ho scritto","I like the app":"Mi piace l'app","I think this app is terrible.":"Penso che questa app sia terribile.","I understand":"Ho capito","I understand that if this app is moved to another device or deleted, my bitcoin can only be recovered with the backup phrase.":"Ho compreso che se questa app sarà trasferita ad un altro dispositivo o cancellata, i miei bitcoin potranno essere recuperati solo tramite la tua frase di recupero.","I understand that my funds are held securely on this device, not by a company.":"Ho capito che i miei fondi sono custoditi in sicurezza in questa dispositivo, non da un'azienda.","I've written it down":"L'ho scritto","If enabled, all sensitive information (private key and recovery phrase) and actions (spending and exporting) associated with this wallet will be protected.":"Se attivata, tutte le informazioni sensibili (chiavi private e la frase di recupero) e azioni (spesa ed esportazione) associate a questo portafoglio saranno protette.","If enabled, the Recent Transactions card - a list of transactions occuring across all wallets - will appear in the Home tab.":"Se abilitata, la scheda delle Transazioni Recenti - una lista di transazioni che avvengono attraverso tutti i portafogli - apparirà nella scheda Home.","If enabled, wallets will also try to spend unconfirmed funds. This option may cause transaction delays.":"Se abilitata, i portafogli cercheranno di spendere anche fondi non ancora confermati. Questa opzione può causare ritardi delle transazioni.","If this device is replaced or this app is deleted, neither you nor BitPay can recover your funds without a backup.":"Se questo dispositivo viene sostituito o eliminato questa app, né tu né BitPay può recuperare i fondi senza una copia di backup.","If you have additional feedback, please let us know by tapping the \"Send feedback\" option in the Settings tab.":"Se si dispone di ulteriori feedback, fatecelo sapere toccando l'opzione \"Invia feedback\" nella scheda Impostazioni.","If you take a screenshot, your backup may be viewed by other apps. You can make a safe backup with physical paper and a pen.":"Se esegui uno screenshot, il backup può essere visualizzato da altre applicazioni. Si può fare un backup sicuro con la carta fisica e una penna.","Import":"Importa","Import Wallet":"Importa Portafoglio","Import backup":"Importa backup","Import wallet":"Importa un portafoglio","Importing Wallet...":"Importazione del Portafoglio...","In order to verify your wallet backup, please type your password.":"Per verificare il backup del tuo portafoglio, inserire la password.","Inactive":"Inattivo","Incomplete":"Incompleto","Incomplete wallet":"Portafoglio incompleto","Incorrect PIN, try again.":"PIN errato, riprovare.","Incorrect code format":"Formato qrcode non corretto","Incorrect network address":"Indirizzo di rete non corretto","Insufficient funds":"Fondi insufficienti","Insufficient funds for fee":"Fondi insufficienti per la commissione","Integrations":"Integrazioni","Invalid":"Invalido","Invalid URL":"URL non valido","Invalid account number":"Numero di conto non valido","Invalid address":"Indirizzo non valido","Invalid data":"Dati non validi","Invalid derivation path":"Percorso di derivazione non valido","Invitation to share a {{appName}} Wallet":"Invito a condividere un {{appName}} portafoglio","Invoice expired":"Fattura scaduta","Is there anything we could do better?":"C'è qualcosa che potevamo fare meglio?","Is this correct?":"È corretto?","Is this email address correct?":"Questo indirizzo email è corretto?","It's a good idea to avoid reusing addresses - this both protects your privacy and keeps your bitcoins secure against hypothetical attacks by quantum computers.":"È una buona idea evitare di riutilizzare gli indirizzi - questo protegge la tua privacy e mantiene i Qybcoin al sicuro da ipotetici attacchi di computer quantistici.","It's important that you write your backup phrase down correctly. If something happens to your wallet, you'll need this backup to recover your money. Please review your backup and try again.":"È importante annotare la frase di recupero correttamente. Se succede qualcosa al tuo portafoglio, allora avrai bisogno di questo backup per ripristinare il tuo denaro. Si prega di rivedere il backup e riprovare.","Join":"Unisciti","Join my {{appName}} Wallet. Here is the invitation code: {{secret}} You can download {{appName}} for your phone or desktop at {{appUrl}}":"Iscriviti a mio {{appName}} portafoglio. Ecco il codice di invito: {{secret}} è possibile scaricare {{appName}} per il vostro telefono o desktop su {{appUrl}}","Join shared wallet":"Unisciti al portafoglio condiviso","Joining Wallet...":"Unendo al portafoglio...","Just scan the code to pay.":"Scansiona giusto il codice per pagare.","Key already associated with an existing wallet":"Chiave già associata ad un portafoglio esistente","Language":"Lingua","Last Month":"Scorso Mese","Learn more":"Ulteriori informazioni","Let's verify your backup phrase.":"Verifichiamo la tua frase di backup.","Loading addresses...":"Caricamento indirizzi...","Loading transaction info...":"Caricamento info della transazione...","Lock App":"Blocca app","Lock by Fingerprint":"Blocco con impronte digitali","Lock by PIN":"Blocca tramite PIN","Locked":"Bloccato","Locktime in effect. Please wait to create a new spend proposal":"Locktime in effetto. Si prega di attendere per creare una nuova proposta di pagamento","Locktime in effect. Please wait to remove this spend proposal":"Locktime in effetto. Si prega di attendere per rimuovere questa proposta di pagamento","Log options":"Opzioni di log","Log out":"Esci","Low amount inputs":"Ingressi di quantità bassa","Low fees":"Commissioni basse","Makes sense":"Ho capito","Matches:":"Corrispondenze:","Me":"Io","Meh - it's alright":"Beh - è tutto ok","Memo":"Nota","Mercado Livre Brazil Gift Cards":"Carte regalo di Mercado Livre Brasile","Mercadolibre Gift Card Service is not available at this moment. Please try back later.":"Il Servizio MercadoLibre Gift Card non è disponibile in questo momento. Si prega di provare più tardi.","Merchant Message":"Messaggio dal commerciante","Miner Fee":"Commissione per miner","Missing parameter":"Parametro mancante","Missing private keys to sign":"Chiavi private per la firma mancanti","More Options":"Altre Opzioni","Moved":"Spostato","Moved Funds":"Fondi trasferiti","Multiple recipients":"Più destinatari","NOTE: To import a wallet from a 3rd party software, please go to Add Wallet &gt; Create Wallet, and specify the Recovery Phrase there.":"Nota: Per importare un portafoglio da un software di terze parti, si prega di andare in Aggiungi portafoglio &gt; Crea portafoglio, e specificare la frase di recupero.","Name":"Nome","Network Cost":"Costo della rete","Network error":"Errore di rete","New Proposal":"Nuova proposta","New address could not be generated. Please try again.":"Il nuovo indirizzo non può essere generato. Si prega di riprovare.","New personal wallet":"Nuovo portafoglio personale","Next steps":"Prossimi passi","No Wallet":"Nessun Portafoglio","No access key defined":"Nessuna chiave di accesso definita","No backup, no bitcoin.":"Nessun backup, nessun bitcoin.","No contacts yet":"Ancora nessun contatto","No entries for this log level":"Nessuna voce per questo livello di log","No hardware information available.":"Nessuna informazione del'hardware disponibile.","No hardware wallets supported on this device":"Nessun portafoglio hardware supportato da questo dispositivo","No pending proposals":"Nessuna proposta in attesa","No recent transactions":"Nessuna transazione recente","No signing proposal: No private key":"Nessuna proposta di firma: nessuna chiave privata","No transactions yet":"Ancora nessuna transazione","No wallet found":"Nessun portafoglio trovato","No wallet selected":"Nessun portafoglio selezionato","No wallets available":"Nessun portafoglio disponibile","No wallets available to receive funds":"Nessun portafoglo disponibile per ricevere i fondi","No wallets eligible for Qybcoin Cash support":"Nessun portafogli idoneo al supporto di Qybcoin Cash","Non BIP44 wallet":"Portafoglio non BIP44","Non eligible QYB wallets":"Portafogli QYB non ammissibili","Normal":"Normale","Not authorized":"Non autorizzato","Not enough funds for fee":"Non ci sono abbastanza fondi per la commissione","Not even BitPay can access it.":"Nemmeno BitPay può accedervi.","Not funds found":"Fondi non trovati","Not now":"Non ora","Note":"Nota","Note: if this dmb wallet was duplicated from a QYB wallet, they share the same recovery phrase.":"Nota: se questo portafoglio dmb è stato duplicato da un portafoglio QYB, condividono la stessa frase di recupero.","Notice: only 1-1 (single signature) wallets can be used for sell bitcoin":"Avviso: solo i portafogli 1-1 (con singola firma) possono essere utilizzati per vendere bitcoin","Notifications":"Notifiche","Notifications by email":"Notifiche via email","Notify me if confirmed":"Notificami se confermato","Notify me when transactions are confirmed":"Avvisami quando le transazioni sono confermate","Now is a good time to backup your wallet. If this device is lost, it is impossible to access your funds without a backup.":"Ora è un buon momento per effettuare un backup del tuo portafoglio. Se questo dispositivo andasse perso, sarebbe impossibile accedere ai tuoi fondi senza una copia di backup.","Now is a perfect time to assess your surroundings. Nearby windows? Hidden cameras? Shoulder-spies?":"È il momento perfetto per valutare l'ambiente circostante. Finestre nelle vicinanze? Telecamere nascoste? Spie alle spalle?","OK":"Ok","OKAY":"VA BENE","Official English Disclaimer":"Dichiarazione di esclusione di responsabilità ufficiale in inglese","Oh no!":"Oh no!","Ok":"Ok","On this screen you can see all your wallets, accounts, and assets.":"In questa schermata puoi vedere tutti i portafogli, gli account e i beni.","Open":"Apri","Open Crowdin":"Aprire Crowdin","Open GitHub":"Aprire Github","Open GitHub Project":"Aprire il progetto GitHub","Open Insight":"Aprire Insight","Open Settings":"Apri Impostazioni","Open Translation Community":"Aprire comunità traduttori","Open Website":"Apri sito","Open the recovery tool.":"Aprire lo strumento di recupero.","Open wallet":"Apri Portafoglio","Open website":"Apri il sito","Order the BitPay Card":"Ordinare la carta BitPay","Password":"Password","Password required. Make sure to enter your password in advanced options":"Password necessaria. Assicurarsi di immettere la password nelle impostazioni avanzate","Paste invitation here":"Incolla qui l'invito","Paste the backup plain text code":"Incolla qui il codice di backup","Pay 0% fees to turn bitcoin into dollars.":"Pagare 0% di tasse per trasformare bitcoin in dollari.","Pay To":"Paga A","Payment Accepted":"Pagamento Accettato","Payment Expires:":"Scadenza del pagamento:","Payment Proposal":"Proposta di Pagamento","Payment Proposal Created":"Proposta di Pagamento Creata","Payment Proposals":"Proposte di Pagamento","Payment Protocol Invalid":"Protocollo di pagamento non valido","Payment Protocol not supported on Chrome App":"Proposta di Pagamento non supportata dall'applicazione Chrome","Payment Received":"Pagamento ricevuto","Payment Rejected":"Pagamento Rifiutato","Payment Sent":"Pagamento Inviato","Payment accepted, but not yet broadcasted":"Pagamento accettato, ma non ancora inviata alla rete","Payment accepted. It will be broadcasted by Glidera. In case there is a problem, it can be deleted 6 hours after it was created.":"Pagamento accettato. Esso sarà trasmesso attraverso la rete Glidera. Nel caso in cui ci fosse un problema, si potrà eliminarlo 6 ore dopo che è stato creato.","Payment address was translated to new Qybcoin Cash address format:":"Indirizzo per il pagamento è stato tradotto al nuovo formato di indirizzo Qybcoin Cash:","Payment details":"Dettagli pagamento","Payment request":"Richiesta di pagamento","Pending":"In sospeso","Pending Proposals":"Proposte in attesa","Permanently delete this wallet.":"Eliminare definitivamente questo portafoglio.","Personal Wallet":"Portafoglio Personale","Please carefully write down this phrase.":"Si prega di annotare accuratamente questa frase.","Please connect a camera to get started.":"Si prega di collegare una telecamera per iniziare.","Please enter the recovery phrase":"Si prega di inserire la frase di recupero","Please enter the wallet recovery phrase":"Si prega di inserire la frase di recupero del portafoglio","Please enter your PIN":"Inserisci il tuo PIN","Please tap each word in the correct order.":"Si prega di toccare ogni parola nell'ordine corretto.","Please upgrade Qyb to perform this action":"Si prega di aggiornare Qyb per eseguire questa azione","Please wait":"Attendere prego","Please, select your backup file":"Per favore, selezione il tuo file di backup","Pre-Auth Holds":"Detenzione pre-autorizzata","Preferences":"Preferenze","Preparing addresses...":"Preparazione indirizzi...","Preparing backup...":"Preparando il backup...","Press again to exit":"Premi ancora per uscire","Priority":"Priorità","Private Key":"Chiave Privata","Private key encrypted. Enter password":"Chiave privata crittografata. Inserisci la password","Private key is encrypted, cannot sign":"La chiave privata è crittografata, non è possibile accedere","Proposal Accepted":"Proposta accettata","Proposal Created":"Proposta creata","Proposal Deleted":"Proposta eliminata","Proposal Rejected":"Proposta respinta","Proposals":"Proposte","Purchase Amount is limited to {{limitPerDay}} {{currency}} per day":"Importo di acquisto è limitato a {{limitPerDay}} di {{currency}} al giorno","Purchase amount must be a value between 50 and 2000":"Importo di acquisto deve essere un valore compreso tra 50 e 2000","Push Notifications":"Notifiche push","Push notifications for {{appName}} are currently disabled. Enable them in the Settings app.":"Le notifiche push per {{appName}} sono attualmente disabilitate. Abilitale nelle impostazioni app.","QR Code":"Codice QR","Quick review!":"Breve recensione!","Random":"Casuale","Rate on the app store":"Valuta su App Store","Read less":"Riduci","Read more":"Ulteriori informazioni","Read more in our Wiki":"Per saperne di più sul nostro Wiki","Read only wallet":"Portafoglio in solo lettura","Receive":"Ricevi","Receive in":"Ricevere in","Received":"Ricevuti","Received Funds":"Fondi ricevuti","Receiving":"Ricezione","Recent":"Recente","Recent Transaction Card":"Transazione recente della carta","Recent Transactions":"Transazioni recenti","Recipient":"Destinatario","Recipients":"Destinatari","Recovery phrase":"Frase di Recupero","Recreating Wallet...":"Ricreando Portafoglio...","Redeem now":"Riscattare ora","Rejected":"Respinto","Rejecting payment proposal":"Respingendo proposta di pagamento","Release information":"Informazioni sul rilascio","Remove":"Rimuovere","Remove BitPay Account?":"Rimuovere il conto BitPay?","Remove BitPay Card?":"Rimuovere la Carta BitPay?","Removing your BitPay account will remove all associated BitPay account data from this device. Are you sure you would like to remove your BitPay Account ({{email}}) from this device?":"La rimozione dell'account BitPay eliminerà tutti i dati del conto BitPay associati da questo dispositivo. Sei sicuro che vuoi rimuovere il tuo conto BitPay ({{email}}) da questo dispositivo?","Repeat password":"Ripeti password","Repeat the password":"Ripeti la password","Request Fingerprint":"Richiesta delle impronte digitali","Request Specific amount":"Richiedi un importo specifico","Request Spending Password":"Richiedere Password di spesa","Required number of signatures":"Selezionare il numero necessario di firme","Restore from backup":"Ripristinare da backup","Retrieving inputs information":"Recupero delle informazioni iniziali","Retry":"Riprova","Retry Camera":"Riprova con fotocamera","Save":"Salva","Scan":"Scansione","Scan QR Codes":"Scansiona il codici QR","Scan addresses for funds":"Scansione degli indirizzi per fondi","Scan again":"Ripetere la scansione","Scan your fingerprint please":"Per cortesia procedere alla scansione dell'impronta digitale","Scanning Wallet funds...":"Scansione fondi Portafoglio...","Scanning funds...":"Scansione dei fondi...","Screenshots are not secure":"Gli screenshot non sono sicuri","Search Transactions":"Cerca Transazioni","Search or enter bitcoin address":"Cerca o inserisci indirizzo bitcoin","Search transactions":"Ricerca transazioni","Search your currency":"Cerca la tua valuta","Security":"Sicurezza","See invoice":"Vedere la fattura","Select a backup file":"Seleziona un file di backup","Select a wallet":"Selezionare un portafoglio","Self-signed Certificate":"Certificato autofirmato","Selling Qybcoin...":"Vendere Qybcoin...","Send":"Invia","Send Feedback":"Invia Feedback","Send Money":"Invia denaro","Send addresses by email":"Invia indirizzi via Email","Send by email":"Invia via email","Send from":"Inviata Da","Send max amount":"Inviare l'importo massimo","Send payment to this address":"Inviare il pagamento a questo indirizzo","Send us feedback instead":"Inviaci invece i tuoi pareri","Sending":"Invio in corso","Sending 2FA code...":"Invio codice 2FA...","Sending feedback...":"Invio feedback...","Sending maximum amount":"Invio dell'importo massimo","Sending transaction":"Invio transazione","Sending {{amountStr}} from your {{name}} wallet":"L'invio di {{amountStr}} dal tuo portafoglio {{name}}","Sent":"Inviato","Sent Funds":"Inviare Fondi","Server response could not be verified":"La risposta del server non può essere verificata","Service not available":"Servizio non disponibile","Services":"Servizi","Session Log":"Registro di sessione","Session log":"Registro sessione","Set up a password":"Imposta una password","Set your own fee in satoshis/byte":"Impostare la propria commissione in satoshi/byte","Settings":"Impostazioni","Share the love by inviting your friends.":"Condividi il piacere invitando i tuoi amici.","Share this invitation with your copayers":"Condividi questo invito con i tuoi copayers","Share {{appName}}":"Condividi {{appName}}","Shared Wallet":"Portafoglio Condiviso","Show Recovery Phrase":"Visualizza Frase di Recupero","Show address":"Visualizza indirizzo","Show advanced options":"Mostra opzioni avanzate","Show bitcoin address":"Visualizza indirizzo bitcoin","Show more":"Mostra di più","Signatures rejected by server":"Firme rifiutate dal server","Signing transaction":"Firmando transazione","Since only you control your money, you’ll need to save your backup phrase in case this app is deleted.":"Dal momento che solo tu controlli il tuo denaro, avrai allora bisogno di salvare la tua frase di recupero nel caso in cui questa applicazione venga eliminata.","Single Address Wallet":"Singolo indirizzo di portafoglio","Skip":"Salta","Slide to accept":"Trascina per accettare","Slide to buy":"Trascina per acquistare","Slide to pay":"Trascina per pagare","Slide to send":"Trascina per inviare","Some of your wallets are not eligible for Qybcoin Cash support. You can try to access dmb funds from these wallets using the":"Alcuni dei vostri portafogli non sono ammissibili al supporto di Qybcoin Cash. È possibile tentare di accedere ai fondi dmb da questi portafogli utilizzando il","Specify Recovery Phrase...":"Specificare la frase di recupero...","Spend proposal is not accepted":"La proposta di pagamento non è accettata","Spend proposal not found":"Proposta di pagamento non trovata","Spending Password needed":"Necessaria password di spesa","Spending this balance will need significant Qybcoin network fees":"Per spendere questa quantità saranno necessarie significative commissioni di rete Qybcoin","Start sending bitcoin":"Iniziare a inviare bitcoin","Startup Lock":"Blocco all'avvio","Still pending":"Ancora in sospeso","Success":"Completato","Super Economy":"Super Economica","Sweep":"Spazzola","Sweep paper wallet":"Spazzare il portafoglio di carta","Sweeping Wallet...":"Spazzolamento Portafoglio...","THIS ACTION CANNOT BE REVERSED":"QUESTA AZIONE NON PUÒ ESSERE INVERTITA","Take control of your money,<br>get started with bitcoin.":"Prendi il controllo del tuo denaro, <br>inizia con bitcoin.","Tap and hold to show":"Toccare e tenere premuto per mostrare","Tap to recreate":"Toccare per ricreare","Tap to retry":"Tocca per riprovare","Terms Of Use":"Termini di utilizzo","Terms of Use":"Termini di Utilizzo","Testnet":"Testnet","Text":"Testo","Thank you!":"Grazie!","Thanks!":"Grazie!","That's exciting to hear. We'd love to earn that fifth star from you – how could we improve your experience?":"Questo è eccitante da sentire. Ci piacerebbe guadagnare quella quinta stella da te - come potremmo migliorare la tua esperienza?","The Ledger Chrome application is not installed":"Non è installata l'applicazione di contabilità Chrome","The amount of bitcoin immediately spendable from this wallet.":"La quantità di bitcoin immediatamente spendibile da questo portafoglio.","The amount of bitcoin stored in this wallet that is allocated as inputs to your pending transaction proposals. The amount is determined using unspent transaction outputs associated with this wallet and may be more than the actual amounts associated with your pending transaction proposals.":"La quantità di bitcoin memorizzati in questo portafoglio è allocata come input per le sue proposte di transazione in sospeso. L'importo è determinato usando le transazioni in uscita non spese associate a questo portafoglio e potrebbero essere superiori agli importi effettivi associati con le vostre proposte di transazione in sospeso.","The amount of bitcoin stored in this wallet with less than 1 blockchain confirmation.":"La quantità di bitcoin memorizzati in questo portafoglio con meno di una conferma su blockchain.","The derivation path":"Il percorso di derivazione","The exchange rate changes with the market.":"Le variazioni dei tassi di cambio con il mercato.","The higher the fee, the greater the incentive a miner has to include that transaction in a block. Current fees are determined based on network load and the selected policy.":"Più alta la commissione, maggiore sarà l'incentivo di un minatore ad includere tale transazione in un blocco. Le attuali commissioni sono determinate basandosi sul carico di rete e il criterio selezionato.","The maximum number of consecutive unused addresses (20) has been reached. When one of your unused addresses receives a payment, a new address will be generated and shown in your Receive tab.":"È stato raggiunto il numero massimo di indirizzi consecutivi inutilizzati (20). Quando uno dei tuoi indirizzi inutilizzati riceve un pagamento, verrà generato un nuovo indirizzo e mostrato nella tua scheda di ricezione.","The official English Terms of Service are available on the BitPay website.":"I termini di servizio ufficiali in inglese sono disponibili sul sito web di BitPay.","The password of the recovery phrase (if set)":"La password della frase recupero (se impostata)","The payment was created but could not be completed. Please try again from home screen":"Il pagamento è stato creato ma è stato impossibile completarlo. Per favore prova di nuovo dalla schermata iniziale","The payment was removed by creator":"Il pagamento è stato rimosso dal creatore","The recovery phrase could require a password to be imported":"La frase di recupero potrebbe richiedere una password per essere importata","The request could not be understood by the server":"La richiesta potrebbe non essere compresa dal server","The restore process will stop when 20 addresses are generated in a row which contain no funds. To safely generate more addresses, make a payment to one of the unused addresses which has already been generated.":"Il processo di ripristino verrà interrotto quando 20 indirizzi di fila verranno generati senza che contengano fondi. Per generare in modo sicuro più indirizzi, è necessario effettuare un pagamento ad uno degli indirizzi non utilizzati che è già stato generato.","The spend proposal is not pending":"La proposta di pagamento non è in sospeso","The total amount of bitcoin stored in this wallet.":"La quantità totale di bitcoin depositati su questo portafoglio.","The transaction history and every new incoming transaction are cached in the app. This feature clean this up and synchronizes again from the server":"La cronologia delle transazioni e ogni nuova transazione in entrata vengono memorizzate nella cache nell'app. Questa funzionalità la ripulisce e sincronizza nuovamente dal server","The wallet service URL":"L'URL del servizio di portafoglio","There is a new version of {{appName}} available":"C'è una nuova versione di {{appName}} disponibile","There is an error in the form":"C'è un errore nel form","There's obviously something we're doing wrong.":"C'è evidentemente qualcosa che stiamo sbagliando.","This app is fantastic!":"Questa applicazione è fantastica!","This app stores your bitcoin with cutting-edge security.":"Questa app memorizza i tuoi bitcoin con sicurezza all'avanguardia.","This bitcoin payment request has expired.":"Questa richiesta di pagamento in bitcoin è scaduta.","This password cannot be recovered. If the password is lost, there is no way you could recover your funds.":"Questa password non può essere recuperata. Se si dimentica la password, non c'è alcun modo possibile per recuperare i fondi.","This recovery phrase was created with a password. To recover this wallet both the recovery phrase and password are needed.":"Questa frase di recupero è stata creata con una password. Per recuperare questo portafoglio sono necessari sia la frase di recupero e che la password.","This transaction amount is too small compared to current Qybcoin network fees. Spending these funds will need a Qybcoin network fee cost comparable to the funds itself.":"Questo importo della transazione è troppo piccolo rispetto alle attuali commissioni della rete Qybcoin. Per spendere questi fondi sarà necessaria una commissione Qybcoin paragonabile ai fondi stessi.","This transaction could take a long time to confirm or could be dropped due to the low fees set by the sender":"Questa operazione potrebbe richiedere molto tempo per essere confermata o potrebbe essere abbandonata a causa delle commissioni basse impostate dal mittente","This wallet is not registered at the given Bitcore Wallet Service (BWS). You can recreate it from the local information.":"Questo portafoglio non è registrato al Bitcore Wallet Service (BWS). Puoi ricrearlo dalle informazioni locali.","Timeline":"Cronologia","To":"A","To get started, buy bitcoin or share your address. You can receive bitcoin from any wallet or service.":"Per iniziare, acquista bitcoin o condividi il tuo indirizzo. È possibile ricevere bitcoin da qualsiasi servizio o portafoglio.","To get started, you'll need to create a bitcoin wallet and get some bitcoin.":"Per iniziare, è necessario che tu crei un portafoglio bitcoin e ottenerne qualcuno.","To {{reason}} you must first add your BitPay account - {{email}}":"Per {{reason}} è necessario innanzitutto aggiungere il tuo account BitPay - {{email}}","Top up in progress...":"Ricarica in corso...","Top up {{amountStr}} to debit card ({{cardLastNumber}})":"Ricaricare di {{amountStr}} sulla carta di debito ({{cardLastNumber}})","Total":"Totale","Total Locked Balance":"Totale Importo Bloccato","Total number of copayers":"Numero totale di copayer","Total wallet inputs":"Totale ingressi nel portafoglio","Touch ID Failed":"Touch ID Fallito","Transaction":"Transazione","Transaction Created":"Transazione creata","Transaction History":"Cronologia delle transazioni","Transaction already broadcasted":"Transazione già trasmessa","Transaction has not been created":"La transazione non è stata creata","Transaction initiated":"Transazione avviata","Transaction not available at this time":"Transazione non disponibile in questo momento","Transaction not found":"Transazione non trovata","Transactions without fee are not supported.":"Non sono supportate transazioni senza commissione.","Transfer to":"Trasferisci a","Transfer to Wallet":"Trasferire su portafoglio","Try again in {{expires}}":"Provare di nuovo in {{expires}}","Turn bitcoin into dollars, swipe anywhere Visa<sup>®</sup> is accepted.":"Trasformare i bitcoin in dollari, fai scorrere la Visa<sup>&reg;</sup> ovunque sia accettata.","Type the Recovery Phrase (usually 12 words)":"Digitare la Frase di Recupero (tipicamente 12 parole)","Uh oh...":"Oh oh...","Unconfirmed":"Non confermato","Unsent transactions":"Transazioni non inviate","Unused Addresses":"Indirizzi non utilizzati","Unused Addresses Limit":"Limite di indirizzi non utilizzati","Update Available":"Aggiornamento Disponibile","Updating pending proposals. Please stand by":"Aggiornamento in attesa di proposte. Si prega di attendere","Updating transaction history. Please stand by.":"Aggiornamento cronologia delle transazioni. Siete pregati di attendere.","Updating... Please stand by":"In aggiornamento... Attendere","Urgent":"Urgente","Use Unconfirmed Funds":"Usa i fondi non confermati","Validating recovery phrase...":"Validazione della frase di recupero...","Verify your identity":"Verifica della tua identità","Version":"Versione","View":"Visualizza","View All Addresses":"Mostra tutti gli indirizzi","View Terms of Service":"Visualizza i termini di servizio","View Transaction on Insight":"Visualizzazione della transazione su Insight","View Update":"Visualizza aggiornamenti","View on blockchain":"Mostra su blockchain","Visit mercadolivre.com.br &rarr;":"Visita mercadolivre.com.br &rarr;","WARNING: Key derivation is not working on this device/wallet. Actions cannot be performed on this wallet.":"ATTENZIONE: La derivazione della chiave non funziona su questo dispositivo/portafoglio. Le operazioni non possono essere eseguite su questo portafoglio.","WARNING: Not including the private key allows to check the wallet balance, transaction history, and create spend proposals from the export. However, does not allow to approve (sign) proposals, so <b>funds will not be accessible from the export</b>.":"AVVISO: L'esclusione della chiave privata permette di controllare il bilancio del portafoglio, la cronologia delle transazioni e creare proposte di spesa dall'esportazione. Tuttavia, non consente di approvare le proposte (firma), così <b>fondi non saranno accessibili dall'esportazione</b>.","WARNING: The private key of this wallet is not available. The export allows to check the wallet balance, transaction history, and create spend proposals from the export. However, does not allow to approve (sign) proposals, so <b>funds will not be accessible from the export</b>.":"AVVISO: La chiave privata di questo portafoglio non è disponibile. L'esportazione permette di controllare il bilancio del portafoglio, la cronologia delle transazioni e creare proposte di spesa dall'esportazione. Tuttavia, non consente di approvare le proposte (firma), così <b>fondi non saranno accessibili dall'esportazione</b>.","WARNING: UNTRUSTED CERTIFICATE":"ATTENZIONE: CERTIFICATO NON ATTENDIBILE","WARNING: Your extended private keys are all that is needed to access your bitcoin funds. Be sure to protect your private keys and store them only on secure devices. BitPay does not have access to your private keys, so you alone are responsible for your keys. If you share key access with external services, you take responsibility for the risk of theft or breach. Only advanced users should handle extended private keys directly.":"ATTENZIONE: Le chiavi private estese sono tutto ciò che è necessario per accedere ai tuoi fondi bitcoin. Assicuratevi di proteggere le chiavi private e memorizzarle solo su dispositivi sicuri. BitPay non ha accesso alla vostre chiavi private, quindi sei l'unico responsabile per le tue chiavi. Se si condivide la tua chiave di accesso con servizi esterni, ti assumi la responsabilità per il rischio di furto o di violazione. Solo gli utenti esperti dovrebbero gestire direttamente le chiavi estese private.","Waiting for Ledger...":"In attesa del Ledger...","Waiting for Trezor...":"In attesa del Trezor...","Waiting for copayers":"In attesa di copayers","Waiting...":"In attesa...","Wallet Addresses":"Indirizzi del portafoglio","Wallet Color":"Colore portafoglio","Wallet Configuration (m-n)":"Configurazione di portafoglio (m-n)","Wallet Created":"Portafoglio creato","Wallet Id":"Id portafoglio","Wallet Information":"Informazioni sul portafoglio","Wallet Inputs":"Ingressi nel portafoglio","Wallet Invitation":"Invito Portafoglio","Wallet Key":"Chiave del portafoglio","Wallet Name":"Nome Portafoglio","Wallet Name (at creation)":"Nome portafoglio (al momento della creazione)","Wallet Network":"Portafoglio di rete","Wallet Recovery Phrase":"Frase di recupero del portafoglio","Wallet Recovery Phrase is invalid":"Frase di recupero del portafoglio non è valida","Wallet Service URL":"URL del servizio di portafoglio","Wallet Settings":"Impostazioni del portafoglio","Wallet Type":"Tipo di portafoglio","Wallet already exists":"Il portafoglio esiste già","Wallet already in {{appName}}":"Portafoglio è già in {{appName}}","Wallet created":"Portafoglio creato","Wallet incomplete and broken":"Portafoglio incompleto e danneggiato","Wallet is full":"Portafoglio è pieno","Wallet is locked":"Il portafoglio è bloccato","Wallet is not complete":"Portafoglio non è completo","Wallet name":"Nome Portafoglio","Wallet needs backup":"Il portafoglio richiede password","Wallet not backed up":"Portafoglio senza backup","Wallet not found":"Portafoglio non trovato","Wallet not registered":"Portafoglio non registrato","Wallet not registered at the wallet service. Recreate it from \"Create Wallet\" using \"Advanced Options\" to set your recovery phrase":"Portafoglio non registrato presso il servizio di portafoglio. Ricrearlo da \"Creare portafoglio\" tramite \"Opzioni avanzate\" per impostare la tua frase di recupero","Wallet recovery phrase not available":"Frase di recupero portafoglio non disponibile","Wallet service not found":"Wallet service non trovato","Wallets":"Portafogli","Warning!":"Attenzione!","Warning: this transaction has unconfirmed inputs":"Attenzione: questa transazione ha inputs non confermati","Watch out!":"Attento!","We'd love to do better.":"Ci piacerebbe fare di più.","We'll confirm on the next screen.":"Confermeremo la schermata successiva.","We're always looking for ways to improve {{appName}}.":"Siamo sempre alla ricerca di modi per migliorare {{appName}}.","We're always looking for ways to improve {{appName}}. How could we improve your experience?":"Siamo sempre alla ricerca di modi per migliorare {{appName}}. Come potremmo migliorare la tua esperienza?","Website":"Sito Web","We’re always looking for translation contributions! You can make corrections or help to make this app available in your native language by joining our community on Crowdin.":"Stiamo sempre cercando contributi alla traduzione! Si possono apportare correzioni o contribuire a rendere questa app disponibile nella tua lingua nativa unendo le nostre comunità su Crowdin.","What do you call this wallet?":"Come chiameresti questo portafoglio?","When this wallet was created, it was called “{{walletName}}”. You can change the name displayed on this device below.":"Quando è stato creato questo portafoglio, è stato chiamato &ldquo;{{walletName}}&rdquo;. È possibile modificare qui sotto il nome visualizzato su questo dispositivo.","Where would you like to receive email notifications about payments?":"Dove ti piacerebbe ricevere le notifiche sui pagamenti via email?","Why?":"Perche?","Would you be willing to rate {{appName}} in the app store?":"Sareste disposti a votare {{appName}} sull'app store?","Would you like to receive push notifications about payments?":"Vorresti ricevere le notifiche push sui pagamenti?","Wrong number of recovery words:":"Numero errato delle parole di recupero:","Wrong spending password":"Password per spesa errata","Yes":"Sì","Yes, skip":"Sì, saltare","You can create a backup later from your wallet settings.":"È possibile creare più tardi una copia di backup dalle impostazioni del tuo portafoglio.","You can make contributions by signing up on our Crowdin community translation website. We’re looking forward to hearing from you!":"È possibile contribuire registrandovi sulla comunità di traduzione Crowdin. Non vediamo l'ora di sentirvi!","You can scan bitcoin addresses, payment requests, paper wallets, and more.":"È possibile scansionare indirizzi bitcoin, richieste di pagamento, portafogli di carta e altro ancora.","You can see the latest developments and contribute to this open source app by visiting our project on GitHub.":"Potete vedere gli ultimi sviluppi e contribuire a questa applicazione open source andando al nostro progetto su GitHub.","You can spend bitcoin at millions of websites and stores worldwide.":"Si può spendere bitcoin in milioni di siti web e negozi in tutto il mondo.","You can still export it from Advanced &gt; Export.":"È comunque possibile esportare da Avanzate &gt; Esporta.","You can trade it for other currencies like US Dollars, Euros, or Pounds.":"È possibile scambiarlo con altre valute come i dollari USA, Euro o Sterline.","You control your bitcoin.":"Controlli i tuoi bitcoin.","You should not set a fee higher than {{maxFeeRecommended}} satoshis/byte.":"Non è necessario impostare una commissione maggiore di {{maxFeeRecommended}} satoshis/byte.","You will need to log back for fill in your BitPay Card.":"Sarà necessario accedere nuovamente per riempire la vostra carta BitPay.","You'll receive email notifications about payments sent and received from your wallets.":"Riceverai notifiche e-mail per i pagamenti inviati e ricevuti dai tuoi portafogli.","Your BitPay Card is ready. Add funds to your card to start using it at stores and ATMs worldwide.":"La carta BitPay è pronta. Aggiungi fondi alla tua carta per iniziare ad usarla presso i negozi e gli sportelli automatici in tutto il mondo.","Your Gift Cards":"Le tue carte regalo","Your bitcoin wallet is backed up!":"Il tuo portafoglio bitcoin ha eseguito il backup!","Your bitcoin wallet is ready!":"Il tuo portafoglio bitcoin è pronto!","Your fee is lower than recommended.":"La tua commissione è inferiore a quella consigliata.","Your ideas, feedback, or comments":"Vostre idee, feedback o commenti","Your name":"Il tuo nome","Your nickname":"Il tuo nickname","Your password":"La tua password","Your purchase could not be completed":"Impossibile completare il tuo acquisto","Your purchase was added to the list of pending":"Il tuo acquisto è stato aggiunto alla lista d'attesa","Your wallet is never saved to cloud storage or standard device backups.":"Il tuo portafoglio non viene mai salvato in archiviazione cloud o nel normale backup del dispositivo.","Your wallet key will be encrypted. The Spending Password cannot be recovered. Be sure to write it down.":"La chiave del tuo portafoglio verrà cifrata. La Password Per Spendere non può essere recuperata. Assicurati di scrivertela.","[Balance Hidden]":"[Fondi Nascosti]","[Scanning Funds]":"[Scansione fondi]","add your BitPay Visa card(s)":"aggiungi la tua carta(e) BitPay Visa","locked by pending payments":"bloccati da pagamenti in sospeso","me":"io","name@example.com":"nome@esempio.com","preparing...":"preparazione...","recovery tool.":"strumento di recupero.","{{amountStr}} for Amazon.com Gift Card":"{{amountStr}} per una carta regalo Amazon.com","{{amountStr}} for Mercado Livre Brazil Gift Card":"{{amountStr}} per Mercado Livre Brasile Gift Card","{{appName}} depends on Bitcore Wallet Service (BWS) for blockchain information, networking and Copayer synchronization. The default configuration points to https://bws.bitpay.com (BitPay's public BWS instance).":"{{appName}} dipende dal servizio portafoglio di Bitcore (BWS) per informazioni blockchain, networking e sincronizzazione di Copayer. La configurazione predefinita fa riferimento a https://bws.bitpay.com (istanza di BitPay BWS pubblica).","{{fee}} will be deducted for bitcoin networking fees.":"{{fee}} verranno detratti come commissione per il network.","{{tx.txp[wallet.id].feeRatePerStr}}  of the sending amount":"{{tx.txp[wallet.id].feeRatePerStr}} dell'importo d'invio","{{updatingTxHistoryProgress}} transactions downloaded":"{{updatingTxHistoryProgress}} transazioni scaricate","{{wallet.m}}-of-{{wallet.n}}":"{{wallet.m}}-di-{{wallet.n}}"});
    gettextCatalog.setStrings('ja', {"(Trusted)":"(信頼済み)","(possible double spend)":"(二重払い可能性あり)","* A payment proposal can be deleted if 1) you are the creator, and no other copayer has signed, or 2) 24 hours have passed since the proposal was created.":"* 送金の提案の取下げは①他のウォレット参加者に署名されていなかった場合、提案者に提案を取り下げることができます。②提案の起案から24時間が経っても解決しなかった場合、全員に取り下げることができます。","- {{btx.feeRateStr}} of the transaction":"- {{btx.feeRateStr}}のレート","- {{tx.feeRateStr}} of the transaction":"- {{tx.feeRateStr}}のレート","5-star ratings help us get {{appName}} into more hands, and more users means more resources can be committed to the app!":"5つ星の評価をいただけると、もっとたくさんの人にこのアプリを届けることができます。そして、ユーザーが増えればこのアプリの改善に当てられる人員やリソースも増えます。","<b>Only</b> redeemable on Mercado Livre (Brazil)":"Mercado Livre (ブラジル)<b>のみ</b>で引き換え可能","A member of the team will review your feedback as soon as possible.":"ただちに開発メンバーでいただいた評価を拝読し参考にさせていただきます。","A total of {{amountAboveMaxSizeStr}} were excluded. The maximum size allowed for a transaction was exceeded.":"注意：合計{{amountAboveMaxSizeStr}} を除外しました。取引に許可される最大サイズを超えました","A total of {{amountBelowFeeStr}} were excluded. These funds come from UTXOs smaller than the network fee provided.":"注意：合計 {{amountBelowFeeStr}} を除外しました。これらのビットコインは手数料よりも低い額となるため除外しました。","About":"このアプリについて","Accepted":"承諾済","Account":"ポケット","Account Number":"ポケット番号","Accounts":"アカウント一覧","Activity":"履歴","Add Account":"アカウントを追加","Add BitPay Account?":"BitPay アカウントを追加しますか？","Add Contact":"連絡先を追加","Add Funds":"資金を追加","Add Memo":"メモを追加","Add a password":"復元フレーズ用パスワードを追加","Add account":"アカウントを追加","Add an optional password to secure the recovery phrase":"フレーズを守るために任意のパスワードをかけて下さい","Add as a contact":"連絡先に追加","Add description":"詳細を追加","Add funds":"資金を追加","Add this BitPay account ({{email}})?":"このBitPayアカウント ({{email}}) を追加しますか？","Add wallet":"ウォレットを追加","Address":"アドレス","Address Book":"アドレス帳","Address Type":"アドレスの種類","Addresses With Balance":"残高のあるアドレス","Advanced":"上級者向け","Advanced Settings":"詳細の設定","All":"すべて","All Addresses":"全アドレス","All of your bitcoin wallet balance may not be available for immediate spending.":"ビットコインのウォレットの残高の内、即座に送れないビットコインが含まれている可能性があります。","All signing devices must be added to this multisig wallet before bitcoin addresses can be created.":"この共有ウォレットの必要参加者の人数が集まるまではビットコインアドレスを発行することができません。","Allow Camera Access":"カメラへのアクセスを許可","Allow notifications":"通知を許可する","Almost done! Let's review.":"ほぼ完了!確認してみましょう。","Alternative Currency":"表示通貨","Amazon.com is not available at this moment. Please try back later.":"Amazon.com は現在ご利用できません、また後でお試しください","Amount":"金額","Amount below minimum allowed":"送金可能最少額を下回っています","Amount too big":"金額が大きすぎます","Amount too low to spend":"小さすぎて送れない額","An update to this app is available. For your security, please update to the latest version.":"このアプリのアップデートがあります。セキュリティーを保持するために最新版にアップデートして下さい。","Anyone with your backup phrase can access or spend your bitcoin.":"復元フレーズを知る者はあなたのビットコインが勝手に送れてしまいます。","Approximate Qybcoin network fee to transfer wallet's balance (with normal priority)":"ウォレットの残高を送るために推測される必要なビットコインネットワーク手数料(優先度：普通)","Are you being watched?":"見られていませんか？","Are you being watched? Anyone with your recovery phrase can access or spend your bitcoin.":"見られていますか？ 復元フレーズを知る者はあなたのビットコインが勝手に送れてしまいます。","Are you sure you want to cancel and delete this wallet?":"本当にこのウォレットをキャンセルし、削除しても\n宜しいですか？","Are you sure you want to delete this contact?":"本当にこの連絡先を削除しますか？","Are you sure you want to delete this wallet?":"本当にこのウォレットを削除しても\n宜しいですか？","Are you sure you want to reject this transaction?":"この取引を却下してもよろしいですか?","Are you sure you want to remove this transaction?":"この取引を破棄してもよろしいですか?","Are you sure you want to skip it?":"本当にバックアップの手順を飛ばしても良いですか？","Are you sure you would like to log out of your BitPay Card account?":"BitPayカードアカウントからログアウトしてもよろしいですか?","Are you sure you would like to remove your BitPay Card ({{lastFourDigits}}) from this device?":"この端末から BitPay カード ({{lastFourDigits}}) を本当に削除してもよろしいですか？","Auditable":"監査用","Available":"即座送金可能","Available Balance":"送金可能残高","Average confirmation time":"平均承認時間","BIP32 path for address derivation":"階級アドレス派生のパス","QYB wallets":"ビットコインウォレット","Backup":"バックアップ","Backup Needed":"要バックアップ","Backup all livenet wallets before using this function":"この機能を使う前に必ず全てのウォレットの復元フレーズのバックアップを取って下さい！","Backup needed":"要バックアップ","Backup now":"今すぐバックアップ","Backup wallet":"ウォレットをバックアップ","Backup your wallet before using this function":"この機能を使う前に必ず復元フレーズのバックアップを取って下さい！","Bad wallet invitation":"不正なウォレット招待コード","Balance By Address":"アドレスごとの残高","Be sure to store your recovery phrase in a secure place. If this app is deleted, your money cannot be recovered without it.":"書き留めた復元フレーズは金庫など、安全な場所にて保管して下さい。このアプリが削除されたら、復元フレーズが必須になってきます。","BitPay Visa® Cards":"BitPayのVISA&reg; カード","Qybcoin Address":"ビットコインアドレス","Qybcoin Cash Wallets":"ビットコインキャッシュウォレット","Qybcoin Network Fee Policy":"ビットコインネットワークの手数料設定","Qybcoin Wallets":"ビットコインウォレット","Qybcoin cash Payment":"ビットコインキャッシュペイメント","Qybcoin is a currency.":"ビットコインは通貨の一つ","Qybcoin is different – it cannot be safely held with a bank or web service.":"ビットコインは違う &ndash; 銀行やウェブのサービスに安全に預けることはできません。","Qybcoin is secure,<br>digital money.":"ビットコインは世界で<br>最も安全な仮想通貨。","Qybcoin transactions include a fee collected by miners on the network.":"ビットコインの取引はネットワークの安全を守る「採掘者」と呼ばれる者達に送る手数料が含まれます。","Bought {{amountUnitStr}}":"{{amountUnitStr}} 購入済み","Broadcast Payment":"取引送信","Broadcasted":"送信済み","Broadcasting transaction":"取引送信中","Browser unsupported":"ブラウザ未対応","Buy":"購入","Buy &amp; Sell Qybcoin":"ビットコインの購入&amp;売却","Buy Qybcoin":"ビットコインを購入","Buy a Gift Card":"ギフトカードの購入","Buy from":"今すぐ購入","Buying Qybcoin...":"ビットコインを購入中...","Calculating fee":"手数料計算中...","Cancel":"キャンセル","Cancel invitation":"招待状のキャンセル","Cannot Create Wallet":"ウォレットを作成できません。","Cannot join the same wallet more that once":"同じ端末で同じウォレットに複数回参加することができません。","Cards":"カード","Certified by":"証明元：","Check installation and retry.":"正しくインストールされたか確認してから再度お試し下さい。","Choose a backup file from your computer":"パソコンからバックアップファイルを選択して下さい。","Choose your destination wallet":"宛先ウォレットの選択","Choose your source wallet":"送金元のウォレットを選択して下さい","Clear":"やり直し","Clear cache":"キャッシュを消去","Click to accept":"クリックして承諾","Click to pay":"クリックして支払う","Click to send":"クリックして送る","Close":"閉じる","Coin":"別通貨切り替え","Color":"色","Commit hash":"コミットのハッシュ値","Complete the backup process to use this option":"この機能をご利用いただくにはバックアップを行う必要があります","Completed":"完了","Confirm":"確認","Confirm &amp; Finish":"承諾して終了する","Confirm purchase":"購入の確認","Confirm your PIN":"確認のためPINを再入力してください","Confirm your new spending password":"新しい送金時パスワードを確認してください","Confirmations":"承認回数","Confirming":"承認中","Connect my BitPay Card":"BitPay カードを接続","Connecting to Coinbase...":"Coinbase に接続中…","Connecting to Glidera...":"Glidera に接続中…","Connection reset by peer":"接続がピアによってリセットされました","Contacts":"連絡先","Continue":"続ける","Contribute Translations":"翻訳に協力","Qyb only supports Qybcoin Cash using new version numbers addresses":"Qyb のビットコインキャッシュはビットコインと完全に異なる別通貨なので、アドレスの頭文字が異なります。","Copayer already in this wallet":"ウォレット参加者が既に存在しています。","Copayer already voted on this spend proposal":"ウォレット参加者が既に送金の提案の意思表明をしています。","Copayer data mismatch":"ウォレット参加者のデータ不整合","Copayer joined":"ウォレット参加者が加わりました","Copayer {{$index}}":"ウォレット参加者 {{$index}}","Copied to clipboard":"クリップボードにコピーしました","Copy this text as it is to a safe place (notepad or email)":"このテキストを安全な場所に貼り付けて保管して下さい (メモ帳やメールの下書きなど)","Copy to clipboard":"クリップボードへコピー","Could not access Gift Card Service":"ギフトカードサービスにアクセスできません","Could not access the wallet at the server. Please check:":"サーバーにてウォレットの確認ができませんでした。こちらをご確認下さい:","Could not access to Amazon.com":"Amazon.comにアクセスできませんでした。","Could not access wallet":"ウォレットにアクセスできませんでした。","Could not add message to imported wallet without shared encrypting key":"共有キー無しでインポートされたウォレットへのメッセージの追加ができません","Could not broadcast payment":"送金を配信できませんでした。","Could not build transaction":"取引を作成できませんでした。","Could not create address":"アドレスを生成できませんでした。","Could not create the invoice":"請求を作成できませんでした","Could not create transaction":"取引を作成できませんでした。","Could not create using the specified extended private key":"指定された拡張秘密鍵で作成できませんでした。","Could not create using the specified extended public key":"指定された拡張公開鍵で作成できませんでした。","Could not create: Invalid wallet recovery phrase":"作成できません：ウォレットの復元フレーズが不正です。","Could not decrypt file, check your password":"複合化できませんでした。パスワードが正しいかご確認下さい。","Could not delete payment proposal":"送金の提案を削除できませんでした","Could not duplicate":"複製できませんでした。","Could not get dynamic fee":"手数料の金額を取得できませんでした。","Could not get dynamic fee for level: {{feeLevel}}":"次の手数料レートを取得できませんでした: {{feeLevel}}","Could not get fee levels":"手数料のレベルを取得できませんでした。","Could not get the invoice":"請求の取得ができませんでした","Could not get transactions":"取引を取得できませんでした。","Could not import":"インポートできませんでした。","Could not import. Check input file and spending password":"インポートできませんでした。入力ファイルとパスワードが正しいかご確認下さい。","Could not join wallet":"ウォレットに参加できませんでした。","Could not reject payment":"送金を却下できませんでした。","Could not remove account":"アカウントを削除できませんでした。","Could not remove card":"カードを削除できませんでした。","Could not save preferences on the server":"設定をサーバーと同期できませんでした。","Could not send payment":"送金できませんでした。","Could not send transaction":"取引が送れませんでした","Could not update transaction history":"取引履歴を更新できませんでした。","Could not update wallet":"ウォレットが更新できませんでした。","Create Personal Wallet":"個人用ウォレットを作成","Create Shared Wallet":"共有ウォレットを作成","Create bitcoin wallet":"ビットコインウォレット作成","Create new wallet":"新規ウォレット作成","Create shared wallet":"共有ウォレットを作成","Create {{formData.requiredCopayers}}-of-{{formData.totalCopayers}} wallet":"{{formData.requiredCopayers}}-of-{{formData.totalCopayers}} ウォレットを作成","Created by":"作成者","Creating Wallet...":"ウォレット作成中…","Creating transaction":"取引作成中…","Current fee rate for this policy":"この設定の現在の手数料レート","Custom":"カスタム設定","Custom Amount":"金額を入力","Custom Fee":"カスタム手数料","Date":"日付","Delete":"削除する","Delete Payment Proposal":"送金の提案を削除","Delete Wallet":"ウォレットを削除","Delete it and create a new one":"削除して新規作成","Deleting Wallet...":"ウォレット削除中…","Deleting payment proposal":"送金の提案を削除","Derivation Path":"派生パス","Derivation Strategy":"派生パス","Details":"詳細","Disabled":"無効","Do it later":"後で行う","Do not include private key":"秘密鍵を含めない","Don't see your language on Crowdin? Contact the Owner on Crowdin! We'd love to support your language.":"ご自分の言語はCrowdinで見当たりませんか？Crowdinの管理者に連絡とってみてください。是非とも対応したく思っております。","Download":"ダウンロード","Duplicate for dmb":"ビットコインキャッシュウォレットを複製","Duplicating wallet...":"ウォレットを複製しています...","Each bitcoin wallet can generate billions of addresses from your 12-word backup. A new address is automatically generated and shown each time you receive a payment.":"12個の単語から無限大のアドレスを生成することができ、それをビットコインウォレットと呼びます。送金を受け取る度に新しいアドレスを生成して受取画面でお見せします。","Economy":"節約","Edit":"編集","Email":"電子メール","Email Address":"メールアドレス","Empty addresses limit reached. New addresses cannot be generated.":"未使用アドレスを生成しすぎたため、これ以上アドレスを生成することができません。","Enable camera access in your device settings to get started.":"端末の設定でカメラの使用許可をしないとスキャンができません。","Enable email notifications":"メール通知を有効化","Enable push notifications":"プッシュ通知を有効化","Enable the camera to get started.":"始めるためにカメラを有効にして下さい。","Enter Spending Password":"送金時のパスワード入力して下さい。","Enter Two Factor for your BitPay account":"BitPay アカウントの2段階認証コードを入力して下さい","Enter amount":"金額を入力","Enter custom fee":"カスタム手数料を入力","Enter new spending password":"新しい送金時パスワードを入力してください","Enter the recovery phrase (BIP39)":"復元フレーズの単語をご入力下さい。","Enter your email":"メールアドレスを入力してください","Enter your password":"パスワードを入力して下さい。","Error":"エラー","Error at confirm":"確認のエラー","Error creating gift card":"ギフトカード作成時にエラー","Error creating the invoice":"請求の作成中にエラー","Error creating wallet":"ウォレット作成時にエラー","Error getting SendMax information":"全額送金データ取得時にエラー","Error in Payment Protocol":"支払い検証のエラー","Error pairing BitPay Account":"Bitpayアカウントを接続中にエラー","Error scanning funds:":"残高確認に失敗しました","Error sweeping wallet:":"ペーパーウォレット出金時にエラー","Error updating Debit Cards":"デビットカードの更新エラー","Exceeded daily limit of $500 per user":"ユーザーの1日当たりの制限 500 米ドルを超えました","Expired":"期限切れ","Expires":"有効期限：","Export Wallet":"ウォレットをエクスポート","Export to file":"ファイルへのエクスポート","Export wallet":"ウォレットをエクスポート","Exporting via QR not supported for this wallet":"このウォレットはQRによるエクスポートに対応していません","Extended Private Key":"拡張秘密鍵","Extended Public Keys":"拡張公開鍵","Extracting Wallet information...":"ウォレット情報を抽出中…","Failed to export":"エクスポートに失敗しました。","Family vacation funds":"家族旅行貯金","Fee":"手数料","Fee level":"手数料レベル","Fee level is not defined":"手数料レベルが定義されていません","Fee:":"手数料:","Feedback could not be submitted. Please try again later.":"フォームを送信する事ができませんでした。時間をおいて再試行ください。","Fetching BitPay Account...":"BitPay アカウントを取得...","Fetching payment information":"支払い情報要求しています…","File/Text":"ファイル/テキスト","Filter setting":"フィルタ設定","Finger Scan Failed":"指紋認証に失敗しました","Finish":"完了","For audit purposes":"監査用機能","From":"送信者","From BitPay account":" BitPayアカウントから","From Hardware Wallet":"ハードウェアウォレットから","From the destination device, go to Add wallet &gt; Import wallet and scan this QR code":"移行先の端末では、ウォレットを追加から、ウォレットをインポートの画面でQRをスキャンして下さい。","Funds are locked by pending spend proposals":"協議中の送金の提案により、資金がロックされています。","Funds found:":"残高がありました:","Funds to be added":"追加する資金","Funds transferred":"入金されました","Funds were added to debit card":"デビットカードへ入金されました","Funds will be transferred to":"送金先","Generate new address":"新規アドレスを生成","Generating .csv file...":"CSVファイル作成中…","Generating new address...":"新規アドレスを生成中...","Get local cash anywhere you go, from any Visa<sup>®</sup> compatible ATM. ATM bank fees may apply.":"Visa<sup>&reg;</sup>カード対応ATMから現地通貨をいつでも引き出せます。ATMの手数料はATMによって異なります。","Get news and updates from BitPay":"BitPay からのニュースや更新情報を受け取ります。","Get started":{"$$noContext":"始めよう","button":"始めよう"},"Get started by adding your first one.":"初めての連絡先を追加しましょう。","Getting fee levels...":"手数料レベルを取得しています…","Gift Card":"ギフトカード","Gift Card is not available to use anymore":"ギフトカードがもう使用できません。","Gift card expired":"期限切れのギフトカード","Gift card generated and ready to use.":"ギフトカードが利用可能になりました。","Go Back":"戻る","Go back":"戻る","Got it":"分かりました","Hardware Wallet":"ハードウェアウォレット","Hardware not connected.":"ハードウェアは接続されていません。","Hardware wallet":"ハードウェアウォレット","Hardware wallets are not yet supported with Qybcoin Cash":"ビットコインキャッシュはまだハードウェアウォレットに対応しておりません。","Help & Support":"ヘルプ＆サポート","Help and support information is available at the website.":"サポートに関する情報はウェブサイトに掲載しております。","Hide":"非表示","Hide Balance":"残高を非表示","Hide Next Steps Card":"次のステップカードを非表示","Hide advanced options":"詳細設定を非表示","Home":"ホーム","How could we improve your experience?":"このアプリを改善するためにご意見下さい。","How do you like {{appName}}?":"このアプリを使用してみて、どのようにお感じですか?","I don't like it":"好きではない","I have read, understood, and agree to the <a ng-click=\"openTerms()\" translate=\"\">Terms of Use</a>.":"<a ng-click=\"openTerms()\" translate>利用規約</a>をよく読み、理解し、同意します。","I have read, understood, and agree with the Terms of use.":"利用規約をよく読み、理解し、同意します。","I have written it down":"紙に書き留めました","I like the app":"このアプリが好き","I think this app is terrible.":"このアプリは最悪です!","I understand":"承知しました","I understand that if this app is moved to another device or deleted, my bitcoin can only be recovered with the backup phrase.":"このアプリが別の端末に移動されたり、削除されたりした場合に、含まれたビットコインが復元フレーズからのみ復元ができることを理解しています。","I understand that my funds are held securely on this device, not by a company.":"自分のビットコインがこの端末に入っていて、外部のサーバー等に保管は一切されていないことを理解しています。","I've written it down":"紙に書き留めました","If enabled, all sensitive information (private key and recovery phrase) and actions (spending and exporting) associated with this wallet will be protected.":"有効にした場合は、このウォレットに関連する全ての秘密情報(秘密鍵と復元フレーズ)と履歴情報(送金やエクスポート)は守られます。","If enabled, the Recent Transactions card - a list of transactions occuring across all wallets - will appear in the Home tab.":"有効にした場合、「最近の取引」カードがホームのメニューに表示されます。アプリに含まれる全ウォレットの取引が一覧できるカードです。","If enabled, wallets will also try to spend unconfirmed funds. This option may cause transaction delays.":"有効にした場合、ウォレットは未承認ビットコインも送金時の候補に含めます。これを有効にした場合、承認に時間がかかることがあります。","If this device is replaced or this app is deleted, neither you nor BitPay can recover your funds without a backup.":"この端末の機種変更をしたり、アプリを削除したりした場合、端末のバックアップを取っていてもビットコインは復元されません。BitPayは復元フレーズを知らないため、お金を失ったことになります。なので、絶対に復元フレーズを書き留めて安全な場所に保管して下さい。","If you have additional feedback, please let us know by tapping the \"Send feedback\" option in the Settings tab.":"他にご意見などありましたら、設定画面の「フィードバックの送信」をタップして下さい。","If you take a screenshot, your backup may be viewed by other apps. You can make a safe backup with physical paper and a pen.":"画面写真を撮ってしまうと、その時点で他のアプリに見られるようになりますので、そのアプリの運営者が安易にビットコインを全て盗めます。安全にバックアップを取るには、紙とボールペンで書き留めましょう。","Import":"インポート","Import Wallet":"ウォレットをインポート","Import backup":"バックアップをインポート","Import wallet":"ウォレットをインポート","Importing Wallet...":"ウォレットインポート中…","In order to verify your wallet backup, please type your password.":"ウォレットのバックアップを確認するためには、復元フレーズ用のパスワードをご入力下さい。","Inactive":"非アクティブ","Incomplete":"未完成","Incomplete wallet":"未完成のウォレット","Incorrect PIN, try again.":"PINが間違っています。もう一度やり直して下さい。","Incorrect code format":"コードの形式が異なります","Incorrect network address":"サーバーのアドレスが不正です","Insufficient funds":"残高不足","Insufficient funds for fee":"手数料付けるには残高が足りません","Integrations":"連携","Invalid":"無効","Invalid URL":"無効なURL","Invalid account number":"無効なポケット番号です。","Invalid address":"不正アドレス","Invalid data":"無効のデータ","Invalid derivation path":"無効な派生パス","Invitation to share a {{appName}} Wallet":"{{appName}} 共有ウォレットへの招待","Invoice expired":"請求有効期限切れ","Is there anything we could do better?":"もっと頑張って欲しいところはありますか？","Is this correct?":"正しいですか？","Is this email address correct?":"このメールアドレスで宜しいですか？","It's a good idea to avoid reusing addresses - this both protects your privacy and keeps your bitcoins secure against hypothetical attacks by quantum computers.":"アドレスの再利用は避けましょう。これはプライバシーを守ることももちろんのこと、将来的にあり得るかもしれない量子コンピューターからの、ある攻撃からビットコインを守ることもできます。","It's important that you write your backup phrase down correctly. If something happens to your wallet, you'll need this backup to recover your money. Please review your backup and try again.":"正確に復元フレーズを書き留めることが大変重要です。このアプリやこの端末に問題が発生したりデータが破損したりすると、ビットコインの残高を元に戻すためには復元フレーズが必須になってきます。バックアップを再確認して、もう一度お試し下さい。","Join":"参加","Join my {{appName}} Wallet. Here is the invitation code: {{secret}} You can download {{appName}} for your phone or desktop at {{appUrl}}":"{{appName}}の共有ウォレット作りました： {{secret}} この招待コードを入力して、ウォレットに参加して下さい。アプリのダウンロードは {{appUrl}} にてどうぞ！","Join shared wallet":"共有ウォレットに参加","Joining Wallet...":"ウォレット参加中…","Just scan the code to pay.":"コードを読み取って送金できます","Key already associated with an existing wallet":"この鍵は既存のウォレットにて登録されています","Language":"言語設定","Last Month":"先月","Learn more":"詳細情報","Let's verify your backup phrase.":"復元フレーズを確認しましょう。","Loading addresses...":"アドレスを読み込んでいます...","Loading transaction info...":"取引情報の読み込み中...","Lock App":"アプリをロックする","Lock by Fingerprint":"指紋認証でロック","Lock by PIN":"PINでロック","Locked":"ロック済み","Locktime in effect. Please wait to create a new spend proposal":"Locktime待ち中です。新しい送金の提案が作成できるまであとしばらくお待ち下さい。","Locktime in effect. Please wait to remove this spend proposal":"Locktime待ち中です。この送金の提案が削除できるまであとしばらくお待ち下さい。","Log options":"ログの設定","Log out":"ログアウト","Low amount inputs":"少額の入力","Low fees":"低手数料","Makes sense":"わかりました","Matches:":"結果:","Me":"自分","Meh - it's alright":"まあまあです","Memo":"メモ","Mercado Livre Brazil Gift Cards":"Mercado Livre Brazil ギフトカード","Mercadolibre Gift Card Service is not available at this moment. Please try back later.":"Mercadolibre Gift Card Service は現在ご利用できません、また後でお試しください","Merchant Message":"お店からのメッセージ：","Miner Fee":"ネットワーク手数料","Missing parameter":"不足しているパラメータ","Missing private keys to sign":"署名するための秘密鍵がありません。","More Options":"その他オプション","Moved":"移動済","Moved Funds":"資金を移動済み","Multiple recipients":"複数送金先","NOTE: To import a wallet from a 3rd party software, please go to Add Wallet &gt; Create Wallet, and specify the Recovery Phrase there.":"注意：他アプリのウォレットをインポートする場合、ウォレットを追加 &gt; 新規ウォレット作成にて復元フレーズを指定するオプションを詳細設定にて有効にして下さい。","Name":"名前","Network Cost":"ネットワーク手数料","Network error":"ネットワークにエラーが発生した","New Proposal":"新しい提案","New address could not be generated. Please try again.":"アドレスを生成できませんでした。もう一度やり直してください。","New personal wallet":"個人用ウォレットを作成","Next steps":"次のステップ","No Wallet":"ウォレットが無いよ…(´・ω・`)","No access key defined":"アクセスキーが定義されていません","No backup, no bitcoin.":"バックアップは非常に重要です！","No contacts yet":"連絡先が無い","No entries for this log level":"このレベルのログのエントリーがありません。","No hardware information available.":"ハードウェア情報はありません","No hardware wallets supported on this device":"この端末ではハードウェアウォレットがサポートされていません","No pending proposals":"保留中の提案はありません","No recent transactions":"最近の取引がありません","No signing proposal: No private key":"提案に署名できない：秘密鍵がありません","No transactions yet":"取引がありません","No wallet found":"ウォレットが見つかりません","No wallet selected":"ウォレットが選択されていません","No wallets available":"利用可能なウォレットがありません","No wallets available to receive funds":"ペーパーウォレットの出金を受け取るためのウォレットが入っていません。","No wallets eligible for Qybcoin Cash support":"ビットコインキャッシュ対応できるウォレットがありません。","Non BIP44 wallet":"非 BIP44 ウォレット","Non eligible QYB wallets":"非対応ビットコインウォレット","Normal":"通常","Not authorized":"権限がありません。","Not enough funds for fee":"手数料含めたら残高が不足しています。","Not even BitPay can access it.":"BitPayは管理できない。","Not funds found":"残高がありませんでした","Not now":"今はしない","Note":"メモ","Note: if this dmb wallet was duplicated from a QYB wallet, they share the same recovery phrase.":"注意: このビットコインキャッシュウォレットがビットコインウォレットからの複製の場合、復元フレーズは一緒です。","Notice: only 1-1 (single signature) wallets can be used for sell bitcoin":"注意： ビットコインの売却は 1-of-1 (単一署名) のウォレットからしか行えません。","Notifications":"通知設定","Notifications by email":"メール通知","Notify me if confirmed":"取引承認時に通知","Notify me when transactions are confirmed":"取引が承認されたら通知する。","Now is a good time to backup your wallet. If this device is lost, it is impossible to access your funds without a backup.":"お金を受け取る前に、このウォレットのバックアップを取っておくことを強くオススメします。一ウォレットごとにバックアップは一回です。バックアップを取らないまま、この端末が紛失・故障されてしまったら全残高が消失されてしまいます。","Now is a perfect time to assess your surroundings. Nearby windows? Hidden cameras? Shoulder-spies?":"今一度周りの環境をよく見てみましょう。隠しカメラ、窓、覗いてくる人などありませんか？","OK":"OK","OKAY":"OK","Official English Disclaimer":"公式免責事項 (英語)","Oh no!":"おっと!","Ok":"OK","On this screen you can see all your wallets, accounts, and assets.":"この画面では、全てのウォレット、アカウント、資産が閲覧できます。","Open":"開く","Open Crowdin":"Crowdinを開く","Open GitHub":"GitHubを開く","Open GitHub Project":"GitHub のプロジェクトを開く","Open Insight":"Insightを開く","Open Settings":"設定を開く","Open Translation Community":"翻訳ページを開く","Open Website":"サイトを開く","Open the recovery tool.":"復元ツールを開く","Open wallet":"ウォレットを開く","Open website":"サイトを開く","Order the BitPay Card":"BitPay カードを申し込み","Password":"パスワード","Password required. Make sure to enter your password in advanced options":"パスワードが必要です。上級者向け設定にてパスワードを入力してください。","Paste invitation here":"招待コードをこちらへ貼り付けて下さい","Paste the backup plain text code":"バックアップの文字をここに貼り付けて下さい","Pay 0% fees to turn bitcoin into dollars.":"0% 手数料でビットコインを米ドルに替える","Pay To":"支払い先","Payment Accepted":"支払いが完了しました","Payment Expires:":"支払い請求の有効期限:","Payment Proposal":"送金の提案","Payment Proposal Created":"送金の提案が作成されました","Payment Proposals":"送金の提案","Payment Protocol Invalid":"ペイメントプロトコルが不正です。","Payment Protocol not supported on Chrome App":"クロームのアプリではペイメントプロトコールがサポートされていません。","Payment Received":"送金が受領されました","Payment Rejected":"送金が却下されました","Payment Sent":"送金が完了しました","Payment accepted, but not yet broadcasted":"取引が承認されましたが、まだ送信していません。","Payment accepted. It will be broadcasted by Glidera. In case there is a problem, it can be deleted 6 hours after it was created.":"取引が承認されました。Glideraより送信されます。問題があった場合、送金命令を出す６時間以内に取り消すことができます。","Payment address was translated to new Qybcoin Cash address format:":"支払先アドレスはビットコインキャッシュの新フォーマットに変更された:","Payment details":"支払いの詳細","Payment request":"支払い請求","Pending":"未決","Pending Proposals":"保留中の提案","Permanently delete this wallet.":"ウォレットを完全に削除する","Personal Wallet":"個人用ウォレット","Please carefully write down this phrase.":"丁寧に復元フレーズを紙に書き留めて下さい","Please connect a camera to get started.":"始めるためにカメラを接続して下さい。","Please enter the recovery phrase":"復元フレーズをご入力下さい","Please enter the wallet recovery phrase":"復元フレーズをご入力下さい","Please enter your PIN":"PIN コードを入力してください。","Please tap each word in the correct order.":"正しい順序で各単語をタップしてください。","Please upgrade Qyb to perform this action":"この操作を実行するにはCopayを最新バージョンに更新してください","Please wait":"お待ちください","Please, select your backup file":"バックアップファイルを選択","Pre-Auth Holds":"承認前の保留","Preferences":"設定","Preparing addresses...":"アドレスを処理中…","Preparing backup...":"バックアップを準備中...","Press again to exit":"もう一度押して終了","Priority":"優先","Private Key":"秘密鍵","Private key encrypted. Enter password":"秘密鍵は暗号化されています。復号化パスワードを入力して下さい。","Private key is encrypted, cannot sign":"秘密鍵が暗号化されており署名できません。","Proposal Accepted":"提案が承諾されました","Proposal Created":"提案が作成されました","Proposal Deleted":"提案が削除されました","Proposal Rejected":"提案が却下されました","Proposals":"提案","Purchase Amount is limited to {{limitPerDay}} {{currency}} per day":"購入額が一日最大 {{limitPerDay}} {{currency}} になります。","Purchase amount must be a value between 50 and 2000":"購入金額は 50〜2000 の間の値でなければなりません","Push Notifications":"プッシュ通知","Push notifications for {{appName}} are currently disabled. Enable them in the Settings app.":"{{appName}}のプッシュ通知は現在無効です。アプリ設定で有効にします。","QR Code":"QRコード","Quick review!":"おさらい！","Random":"乱数","Rate on the app store":"App Storeで評価","Read less":"非表示にする","Read more":"もっと読む","Read more in our Wiki":"詳しくはwikiでお読みください","Read only wallet":"閲覧専用ウォレット","Receive":"受取","Receive in":"通貨","Received":"受取済み","Received Funds":"受領した資金","Receiving":"受け取り中","Recent":"履歴","Recent Transaction Card":"最近の取引カード","Recent Transactions":"最近の取引","Recipient":"受取人","Recipients":"受取人","Recovery phrase":"復元フレーズ","Recreating Wallet...":"ウォレットを再作成中…","Redeem now":"今すぐ引き換えをする","Rejected":"却下済み","Rejecting payment proposal":"送金の提案却下中","Release information":"リリース情報","Remove":"削除","Remove BitPay Account?":"BitPay アカウントの接続を解除しますか？","Remove BitPay Card?":"BitPay カードを削除しますか？","Removing your BitPay account will remove all associated BitPay account data from this device. Are you sure you would like to remove your BitPay Account ({{email}}) from this device?":"BitPay アカウントを削除すると、このデバイスからすべての関連付けられている BitPay のアカウントデータが削除されます。本当にこのデバイスから BitPay アカウント ({{email}}) を削除してもよろしいですか。","Repeat password":"パスワードを再入力","Repeat the password":"パスワードの再入力","Request Fingerprint":"指紋を要求","Request Specific amount":"指定金額を要求","Request Spending Password":"送金時のパスワード入力","Required number of signatures":"必要な署名の数を選択","Restore from backup":"バックアップから復元","Retrieving inputs information":"入力情報の取得中","Retry":"やり直し","Retry Camera":"カメラを再試行","Save":"保存","Scan":"スキャン","Scan QR Codes":"QRコードを読み取る","Scan addresses for funds":"アドレスの残高照会","Scan again":"もう一度スキャンし直してください。","Scan your fingerprint please":"指紋をスキャンしてください","Scanning Wallet funds...":"ウォレット残高照会中…","Scanning funds...":"確認中…","Screenshots are not secure":"画面写真を撮ってしまうと危険です！","Search Transactions":"取引を検索","Search or enter bitcoin address":"連絡先検索かビットコインアドレスを指定","Search transactions":"取引を検索","Search your currency":"通貨を検索","Security":"セキュリティ","See invoice":"請求書を表示","Select a backup file":"バックアップファイルを選択","Select a wallet":"ウォレットを選択","Self-signed Certificate":"自己署名証明書","Selling Qybcoin...":"ビットコインを売却中...","Send":"送信","Send Feedback":"フィードバックの送信","Send Money":"送金する","Send addresses by email":"ビットコインアドレスをメールにて共有","Send by email":"メールで送信","Send from":"ここから送金","Send max amount":"全残高を送金","Send payment to this address":"このアドレスへ送信して下さい","Send us feedback instead":"代わりにフィードバックを送信","Sending":"送信中","Sending 2FA code...":"2段階認証コードを送信中…","Sending feedback...":"フィードバックを送信中...","Sending maximum amount":"全残高を送金","Sending transaction":"取引送信中","Sending {{amountStr}} from your {{name}} wallet":"ウォレット {{name}} から {{amountStr}} の送金を行います。","Sent":"送金済み","Sent Funds":"資金を送金済み","Server response could not be verified":"サーバーからの返答を検証できませんでした","Service not available":"このサービスは利用できません","Services":"サービス","Session Log":"セッションのログ","Session log":"セッションのログ","Set up a password":"パスワードを設定","Set your own fee in satoshis/byte":"カスタム手数料は satoshis/byte で指定","Settings":"設定","Share the love by inviting your friends.":"是非友達と共有して下さい","Share this invitation with your copayers":"ウォレット参加者に\nこの招待コードを\n送って下さい。","Share {{appName}}":"{{appName}}を共有","Shared Wallet":"共有ウォレットに参加","Show Recovery Phrase":"復元フレーズを表示","Show address":"アドレスを表示","Show advanced options":"詳細設定を表示","Show bitcoin address":"ビットコインアドレスを表示","Show more":"すべて表示","Signatures rejected by server":"サーバーより署名が却下されました。","Signing transaction":"取引署名中","Since only you control your money, you’ll need to save your backup phrase in case this app is deleted.":"ビットコインの管理は全てご自身でしていただくため、端末やアプリの不具合や削除に備えるために復元フレーズを書き留めていただきます。","Single Address Wallet":"単一アドレスウォレット","Skip":"スキップ","Slide to accept":"スライドして承諾","Slide to buy":"スライドして購入","Slide to pay":"スライドして支払う","Slide to send":"スライドして送る","Some of your wallets are not eligible for Qybcoin Cash support. You can try to access dmb funds from these wallets using the":"いくつかのウォレットがビットコインキャッシュに対応できません。ビットコインキャッシュの取り戻しは復元ツールで試すとうまくいくかもしれません。","Specify Recovery Phrase...":"復元フレーズを指定…","Spend proposal is not accepted":"送金の提案が受諾されませんでした。","Spend proposal not found":"送金の提案が見つかりませんでした。","Spending Password needed":"パスワードが必要","Spending this balance will need significant Qybcoin network fees":"この入力の組み合わせを送金するために膨大なビットコインネットワーク手数料を必要とします","Start sending bitcoin":"ビットコインの送金を始めましょう","Startup Lock":"起動ロック","Still pending":"まだ未決","Success":"成功","Super Economy":"超節約","Sweep":"全残高インポート","Sweep paper wallet":"ペーパーウォレットの全残高インポート","Sweeping Wallet...":"ビットコイン回収中…","THIS ACTION CANNOT BE REVERSED":"＊＊＊注意＊＊＊ このアクションを元に戻すことはできません！！！","Take control of your money,<br>get started with bitcoin.":"お金のコントロールを取り戻そう、<br>ビットコインをはじめよう","Tap and hold to show":"長押しで表示","Tap to recreate":"タップして再構築","Tap to retry":"タップしてやり直し","Terms Of Use":"利用規約","Terms of Use":"利用規約","Testnet":"テスト用ネットワーク","Text":"テキスト","Thank you!":"ありがとうございます!","Thanks!":"ありがとうございます。","That's exciting to hear. We'd love to earn that fifth star from you – how could we improve your experience?":"嬉しい限りです！是非5つ星のアプリを目指したいため、このアプリの改善するにはどうしたら良いと思いますか？","The Ledger Chrome application is not installed":"Ledgerのクロームアプリがインストールされていません。","The amount of bitcoin immediately spendable from this wallet.":"このウォレットからすぐに送金できる額","The amount of bitcoin stored in this wallet that is allocated as inputs to your pending transaction proposals. The amount is determined using unspent transaction outputs associated with this wallet and may be more than the actual amounts associated with your pending transaction proposals.":"現在協議中の送金の提案によってロックされてしまっている金額です。この金額は未使用出力の割り当てられた合計額になりますので、必ずしも送金提案の送金額だけがロックされるというものではありません。","The amount of bitcoin stored in this wallet with less than 1 blockchain confirmation.":"このウォレットの1承認未満の残高。","The derivation path":"派生パス","The exchange rate changes with the market.":"為替レートは市場と共に変動する","The higher the fee, the greater the incentive a miner has to include that transaction in a block. Current fees are determined based on network load and the selected policy.":"円滑な送金をしていただくために、ビットコインの送金には少量の手数料を付けることが義務付けられております。この手数料はビットコインのネットワークを運用する人たちに寄付され、より高い手数料であればより優先的にブロックに含まれ、承認されます。選択された手数料基準やネットワークの混雑状況により、その時点で払われるべき手数料が変動することがあります。","The maximum number of consecutive unused addresses (20) has been reached. When one of your unused addresses receives a payment, a new address will be generated and shown in your Receive tab.":"連続未使用アドレスの上限(20)に達しました。どれかにアドレスにビットコインが少量でも入れば再び受取画面にて新しいアドレスを生成することができるようになります。","The official English Terms of Service are available on the BitPay website.":"英語公式の規約は BitPay のウェブサイトにてご覧いただけます。","The password of the recovery phrase (if set)":"復元フレーズ用のパスワード(設定してある場合のみ)","The payment was created but could not be completed. Please try again from home screen":"送金の提案は作成されましたが完了できませんでした。ホーム画面からやり直して下さい。","The payment was removed by creator":"送金の提案が作成者により削除されました","The recovery phrase could require a password to be imported":"復元フレーズにパスワードをかけることが\nできるのでかけてある場合は\nインポート時に必要です。","The request could not be understood by the server":"サーバーが要求を処理できませんでした。","The restore process will stop when 20 addresses are generated in a row which contain no funds. To safely generate more addresses, make a payment to one of the unused addresses which has already been generated.":"復元のプロセスは残高の無いアドレスを20個連続で生成した場合に中止します。更にアドレスを生成したい場合は既存の20個のアドレスのどれかにビットコインを少量でも入金しますと、新しいアドレスが生成できます。","The spend proposal is not pending":"送金の提案が協議中ではありません。","The total amount of bitcoin stored in this wallet.":"このウォレットのビットコインの総残高","The transaction history and every new incoming transaction are cached in the app. This feature clean this up and synchronizes again from the server":"取引履歴は新規の取引が現れる度に端末にキャッシュとして保存されます。この機能はそのキャッシュを削除し、全ての取引履歴を初期の状態からサーバーに問い合わせ直します。","The wallet service URL":"ウォレットサービスのURL","There is a new version of {{appName}} available":"{{appName}} の新しいバージョンがあります。","There is an error in the form":"フォームにエラーがありました","There's obviously something we're doing wrong.":"このアプリで何か間違ったことをやっているようです。","This app is fantastic!":"このアプリは素晴らしいです!","This app stores your bitcoin with cutting-edge security.":"このアプリは、最先端のセキュリティであなたのビットコインをお守りします。","This bitcoin payment request has expired.":"ビットコインペイメントの請求期限が切れています。","This password cannot be recovered. If the password is lost, there is no way you could recover your funds.":"このパスワードは復元できません。リセットすることができません。弊社のサーバーで管理するものではありません。復元フレーズとセットで必ず書き留めておいて下さい。復元フレーズとこのパスワードのどれかを忘れてしまうと、ビットコインを復元することができません。ご注意下さい。","This recovery phrase was created with a password. To recover this wallet both the recovery phrase and password are needed.":"この復元フレーズにパスワードがかかっています。このウォレットを復元するためには、復元フレーズに加え、パスワードも必要です。","This transaction amount is too small compared to current Qybcoin network fees. Spending these funds will need a Qybcoin network fee cost comparable to the funds itself.":"この取引の金額はビットコインネットワーク手数料より低いです。送金額より大きい手数料を払ってしまうことになります。","This transaction could take a long time to confirm or could be dropped due to the low fees set by the sender":"この取引は承認されるまで非常に時間のかかる可能性があります。承認されずにネットワークに捨てられてしまう危険性もありますので、承認されるまでお待ちいただくことを強くおすすめします。","This wallet is not registered at the given Bitcore Wallet Service (BWS). You can recreate it from the local information.":"現在設定中のBitcore Wallet Service (BWS) サーバーにて、このウォレットの登録がありません。再登録を行うこともできます。","Timeline":"履歴","To":"宛先","To get started, buy bitcoin or share your address. You can receive bitcoin from any wallet or service.":"はじめるには、ビットコインを購入したり、アドレスを他の人に共有したりしましょう。どのビットコインウォレットやサービスから受け取れます。","To get started, you'll need to create a bitcoin wallet and get some bitcoin.":"はじめに、ビットコインウォレットを作成し、ビットコインを入手する必要があります。","To {{reason}} you must first add your BitPay account - {{email}}":"{{reason}}：その前にBitPayアカウントを追加する必要があります - {{email}}","Top up in progress...":"残高補充処理中...","Top up {{amountStr}} to debit card ({{cardLastNumber}})":"デビットカード ({{cardLastNumber}}) に {{amountStr}} の入金を行う","Total":"合計","Total Locked Balance":"ロック中の残高","Total number of copayers":"参加人数を選択して下さい。","Total wallet inputs":"合計ウォレット入力","Touch ID Failed":"Touch ID が失敗しました。","Transaction":"取引","Transaction Created":"取引情報を作成しました","Transaction History":"取引履歴","Transaction already broadcasted":"取引は既に配信されました。","Transaction has not been created":"取引が未作成です","Transaction initiated":"取引が開始されました","Transaction not available at this time":"現在この取引はご覧いただけません。","Transaction not found":"取引は見つかりません","Transactions without fee are not supported.":"手数料なしの取引はサポートされていません。","Transfer to":"移動先","Transfer to Wallet":"ウォレットに移動","Try again in {{expires}}":"{{expires}} 経過後にもう一度試してください。","Turn bitcoin into dollars, swipe anywhere Visa<sup>®</sup> is accepted.":"瞬時にビットコインを米ドルに変換！Visa<sup>&reg;</sup>カード利用可能店舗ならどこでも！","Type the Recovery Phrase (usually 12 words)":"復元フレーズの単語 (通常 12 個) を入力して下さい。","Uh oh...":"あら…","Unconfirmed":"未承認","Unsent transactions":"未送信取引","Unused Addresses":"未使用アドレス","Unused Addresses Limit":"未使用アドレス生成上限","Update Available":"利用可能なアップデートあり","Updating pending proposals. Please stand by":"協議中の送金提案を更新します。しばらくお待ちください。","Updating transaction history. Please stand by.":"取引履歴を更新します。しばらくお待ちください。","Updating... Please stand by":"更新中... お待ち下さい","Urgent":"緊急","Use Unconfirmed Funds":"未承認ビットコインを使用","Validating recovery phrase...":"復元フレーズを検証中…","Verify your identity":"認証を行って下さい","Version":"バージョン","View":"表示","View All Addresses":"全アドレスを表示","View Terms of Service":"サービス利用規約を表示","View Transaction on Insight":"Insightにて取引を表示","View Update":"更新情報を表示","View on blockchain":"ブロックチェーンで詳細を閲覧","Visit mercadolivre.com.br &rarr;":"mercadolivre.com.br を訪れる &rarr;","WARNING: Key derivation is not working on this device/wallet. Actions cannot be performed on this wallet.":"注意：このデバイスでは鍵の派生がちゃんと動いておりません。このウォレットは正常に動作しません。","WARNING: Not including the private key allows to check the wallet balance, transaction history, and create spend proposals from the export. However, does not allow to approve (sign) proposals, so <b>funds will not be accessible from the export</b>.":"注意：このウォレットは秘密鍵がありません。残高の確認、取引履歴の確認、送金の提案ができます。しかし、<b>送金の提案を承諾 (署名) できません</b>。","WARNING: The private key of this wallet is not available. The export allows to check the wallet balance, transaction history, and create spend proposals from the export. However, does not allow to approve (sign) proposals, so <b>funds will not be accessible from the export</b>.":"注意：このウォレットは秘密鍵がありません。残高の確認、取引履歴の確認、送金の提案ができます。しかし、<b>送金の提案を承諾 (署名) できません</b>。","WARNING: UNTRUSTED CERTIFICATE":"警告: 信頼されていない証明書","WARNING: Your extended private keys are all that is needed to access your bitcoin funds. Be sure to protect your private keys and store them only on secure devices. BitPay does not have access to your private keys, so you alone are responsible for your keys. If you share key access with external services, you take responsibility for the risk of theft or breach. Only advanced users should handle extended private keys directly.":"注意： 拡張秘密鍵だけでビットコインをすべて送金できてしまいます。秘密鍵を守り、安全な端末のみにて管理して下さい。BitPayは秘密鍵へのアクセスができないので、管理する責任は全て自己責任になります。外部のサービスにこの鍵を共有する場合、窃盗などのリスクを全て受け入れた上で宜しくお願いします。拡張秘密鍵を直接扱うのは上級者のユーザーのみです。","Waiting for Ledger...":"Ledger を待っています...","Waiting for Trezor...":"Trezor を待っています...","Waiting for copayers":"ウォレット参加者を待っています","Waiting...":"少々お待ち下さい…","Wallet Addresses":"ウォレットのアドレス","Wallet Color":"ウォレットの色","Wallet Configuration (m-n)":"ウォレット構成 (m-of-n)","Wallet Created":"ウォレットが作成されました","Wallet Id":"ウォレットID","Wallet Information":"ウォレット詳細","Wallet Inputs":"ウォレットの入力","Wallet Invitation":"ウォレット招待","Wallet Key":"ウォレットの鍵","Wallet Name":"ウォレット名","Wallet Name (at creation)":"ウォレット名 (作成時)","Wallet Network":"ウォレットのネットワーク","Wallet Recovery Phrase":"復元フレーズ","Wallet Recovery Phrase is invalid":"ウォレットシードが不正です。","Wallet Service URL":"ウォレットサービスのURL","Wallet Settings":"ウォレットの設定","Wallet Type":"ウォレットタイプ","Wallet already exists":"既存のウォレットです","Wallet already in {{appName}}":"{{appName}}内の既存のウォレットです","Wallet created":"ウォレットが作成されました","Wallet incomplete and broken":"ウォレットが未完成で破損しています","Wallet is full":"ウォレットがいっぱいです。","Wallet is locked":"ウォレットがロックされています。","Wallet is not complete":"ウォレットが未完成です。","Wallet name":"ウォレット名","Wallet needs backup":"ウォレットバックアップが必要","Wallet not backed up":"ウォレットがバックアップされていません","Wallet not found":"ウォレットが見つかりません。","Wallet not registered":"ウォレットが未登録","Wallet not registered at the wallet service. Recreate it from \"Create Wallet\" using \"Advanced Options\" to set your recovery phrase":"このウォレットは Wallet Service にて登録されていません。再び「新規作成」メニューから詳細設定を選び、復元フレーズをご入力下さい。","Wallet recovery phrase not available":"ウォレットの復元フレーズが削除されているため表示できません","Wallet service not found":"Wallet serviceが見つかりません。","Wallets":"ウォレット","Warning!":"注意！","Warning: this transaction has unconfirmed inputs":"注意: この取引は未承認資金が含まれており、承認されるまで商品等をお渡しするのを待つことをお勧めします。","Watch out!":"注意して下さい！","We'd love to do better.":"サービスを改善していきます","We'll confirm on the next screen.":"次の画面で確認作業を行います。","We're always looking for ways to improve {{appName}}.":"弊社では、{{appName}} を改善する方法を常に探しています。","We're always looking for ways to improve {{appName}}. How could we improve your experience?":"常に{{appName}}を改善したく思っております。どのようにしたら改善できると思いますか？","Website":"ウェブサイト","We’re always looking for translation contributions! You can make corrections or help to make this app available in your native language by joining our community on Crowdin.":"常にボランティア翻訳者募集中です！Crowdinにてご自分の母国語の翻訳をしてこのアプリをより良いものにしてみませんか？","What do you call this wallet?":"このウォレットの名前は何ですか？","When this wallet was created, it was called “{{walletName}}”. You can change the name displayed on this device below.":"このウォレットが作成された当時は「{{walletName}}」と名付けられましたが、この端末での表示名を下記にて変更することができます。","Where would you like to receive email notifications about payments?":"送金発生時のメール通知はどのメールアドレスで受け取りますか?","Why?":"なぜ？","Would you be willing to rate {{appName}} in the app store?":"アプリケーションストアにレビューを書いてみませんか？","Would you like to receive push notifications about payments?":"送金発生時にプッシュ通知を受け取りますか?","Wrong number of recovery words:":"単語の数が間違っています：","Wrong spending password":"不正なパスワード","Yes":"はい","Yes, skip":"飛ばす","You can create a backup later from your wallet settings.":"ウォレットの設定から、後でバックアップを作成できます。","You can make contributions by signing up on our Crowdin community translation website. We’re looking forward to hearing from you!":"Crowdinのサイトにて翻訳者登録をして、今すぐに投稿をいただけます。お待ちしております。","You can scan bitcoin addresses, payment requests, paper wallets, and more.":"ビットコインアドレス、支払い請求、ペーパーウォレットなどをスキャンできます。","You can see the latest developments and contribute to this open source app by visiting our project on GitHub.":"GitHubのページにて最近の開発動向を見たり、改善案のソースコードの貢献したりすることができます。","You can spend bitcoin at millions of websites and stores worldwide.":"世界中のECサイトや店舗でビットコインを使って支払いができます。","You can still export it from Advanced &gt; Export.":"バックアップファイルの作成は「上級者向け」⇒「エクスポート」からアクセスできます。","You can trade it for other currencies like US Dollars, Euros, or Pounds.":"米ドル、ユーロ、ポンドなど他の通貨との取引ができます。","You control your bitcoin.":"ビットコインの自己管理","You should not set a fee higher than {{maxFeeRecommended}} satoshis/byte.":"{{maxFeeRecommended}} satoshis/byte より高い手数料を設定しない方が良いです。","You will need to log back for fill in your BitPay Card.":"BitPayカードに入金するためにログインする必要があります。","You'll receive email notifications about payments sent and received from your wallets.":"メールアドレスにウォレットへの入金や出金に関する通知が送られます。","Your BitPay Card is ready. Add funds to your card to start using it at stores and ATMs worldwide.":"BitPayカードの準備が整いました。入金して全世界のお店やATMでご利用下さい。","Your Gift Cards":"ギフトカード","Your bitcoin wallet is backed up!":"ビットコインウォレットがバックアップされました!","Your bitcoin wallet is ready!":"ビットコインウォレットが完成しました!","Your fee is lower than recommended.":"手数料設定が推奨値より低くなっております。","Your ideas, feedback, or comments":"提案、評価、コメントなど","Your name":"自分の名前","Your nickname":"自分のハンドルネーム","Your password":"パスワード","Your purchase could not be completed":"購入が完了されませんでした。","Your purchase was added to the list of pending":"ご購入の品物が保留中のリストに追加されました。","Your wallet is never saved to cloud storage or standard device backups.":"ウォレットは一度もクラウドへ保存されたりすることはありませんし、携帯電話などに付いている標準バックアップ機能ではバックアップされません！！！！","Your wallet key will be encrypted. The Spending Password cannot be recovered. Be sure to write it down.":"ウォレットの鍵が暗号化されます。Copayでは送金時のパスワードをリセットしてくれる機能がありませんので、パスワードを忘れないよう、控えておいて下さい。","[Balance Hidden]":"[残高非表示中]","[Scanning Funds]":"[確認中]","add your BitPay Visa card(s)":"BitPay VISAカードを追加します","locked by pending payments":"未対応送金の提案によりロック中","me":"自分","name@example.com":"name@example.com","preparing...":"準備中...","recovery tool.":"復元ツールはこちら","{{amountStr}} for Amazon.com Gift Card":"{{amountStr}} を Amazon.com ギフトカードに","{{amountStr}} for Mercado Livre Brazil Gift Card":"{{amountStr}} を Mercado Livre Brazil ギフトカードに","{{appName}} depends on Bitcore Wallet Service (BWS) for blockchain information, networking and Copayer synchronization. The default configuration points to https://bws.bitpay.com (BitPay's public BWS instance).":"{{appName}}はブロックチェーンの情報を取得したり参加者を同期させたりするためにBitcore Wallet Service (BWS)に依存します。初期値としてBitPay社が提供する https://bws.bitpay.com (BitPay公式のBWSサーバー)を設定していますが、独自で運用してウォレットをそちらに接続しても構いません。","{{fee}} will be deducted for bitcoin networking fees.":"{{fee}} のビットコインネットワーク手数料が差し引かれます。","{{tx.txp[wallet.id].feeRatePerStr}}  of the sending amount":"送金額に対する {{tx.txp[wallet.id].feeRatePerStr}}","{{updatingTxHistoryProgress}} transactions downloaded":"{{updatingTxHistoryProgress}} 個の取引ダウンロード済み","{{wallet.m}}-of-{{wallet.n}}":"{{wallet.m}}-of-{{wallet.n}}"});
    gettextCatalog.setStrings('nl', {"(Trusted)":"(Vertrouwd)","(possible double spend)":"(mogelijk dubbel besteed)","* A payment proposal can be deleted if 1) you are the creator, and no other copayer has signed, or 2) 24 hours have passed since the proposal was created.":"* Een bestedingsvoorstel kan worden verwijderd als 1) u de aanmaker bent, en geen andere copayer deze heeft ondertekend, of 2) 24 uur zijn verstreken sinds het voorstel werd aangemaakt.","- {{btx.feeRateStr}} of the transaction":"- {{btx.feeRateStr}} van de transactie","- {{tx.feeRateStr}} of the transaction":"- {{tx.feeRateStr}} van de transactie","5-star ratings help us get {{appName}} into more hands, and more users means more resources can be committed to the app!":"Beoordelingen van 5 sterren helpen ons het gebruik van {{appName}} te laten groeien, en meer gebruikers betekent dat wij meer middelen aan de app kunnen wijden!","<b>Only</b> redeemable on Mercado Livre (Brazil)":"<b>Alleen</b> inwisselbaar op Mercado Livre (Brazilië)","A member of the team will review your feedback as soon as possible.":"Een lid van het team zal zo spoedig mogelijk uw feedback bekijken.","A total of {{amountAboveMaxSizeStr}} were excluded. The maximum size allowed for a transaction was exceeded.":"Een totaal van {{amountAboveMaxSizeStr}} is uitgesloten. De maximum toegestane grootte voor een transactie is overschreden.","A total of {{amountBelowFeeStr}} were excluded. These funds come from UTXOs smaller than the network fee provided.":"Een totaal van {{amountBelowFeeStr}} is uitgesloten. Dit saldo is afkomstig uit ontvangsten kleiner dan de transactiekosten.","About":"Over","Accepted":"Geaccepteerd","Account":"Account","Account Number":"Account Nummer","Accounts":"Accounts","Activity":"Activiteit","Add Account":"Account Toevoegen","Add BitPay Account?":"BitPay Account Toevoegen?","Add Contact":"Contactpersoon Toevoegen","Add Funds":"Saldo Toevoegen","Add Memo":"Notitie Toevoegen","Add a password":"Een wachtwoord toevoegen","Add account":"Account toevoegen","Add an optional password to secure the recovery phrase":"Een optioneel wachtwoord toevoegen voor het beveiligen van de herstel zin","Add as a contact":"Toevoegen als contactpersoon","Add description":"Beschrijving toevoegen","Add funds":"Saldo toevoegen","Add this BitPay account ({{email}})?":"Deze BitPay account ({{email}}) toevoegen?","Add wallet":"Portemonnee toevoegen","Address":"Adres","Address Book":"Adresboek","Address Type":"Adres Type","Addresses With Balance":"Adressen Met Saldo","Advanced":"Geavanceerd","Advanced Settings":"Geavanceerde Instellingen","All":"Alle","All Addresses":"Alle Adressen","All of your bitcoin wallet balance may not be available for immediate spending.":"Mogelijk is niet het volledige saldo van uw bitcoin portemonnee direct beschikbaar voor uitgaven.","All signing devices must be added to this multisig wallet before bitcoin addresses can be created.":"Alle ondertekenende apparaten moeten worden toegevoegd aan deze meervoudige-ondertekening portemonnee voordat bitcoin adressen kunnen worden aangemaakt.","Allow Camera Access":"Camera Toegang Toestaan","Allow notifications":"Meldingen toestaan","Almost done! Let's review.":"Bijna klaar! Nog eens nakijken.","Alternative Currency":"Alternatieve Valuta","Amazon.com is not available at this moment. Please try back later.":"Amazon.com is niet beschikbaar op dit moment. Probeer het later nog eens.","Amount":"Bedrag","Amount below minimum allowed":"Bedrag lager dan minimum toegestaan","Amount too big":"Bedrag te groot","Amount too low to spend":"Bedrag te laag om te besteden","An update to this app is available. For your security, please update to the latest version.":"Er is een update voor deze app beschikbaar. Update a.u.b. naar de nieuwste versie voor uw veiligheid.","Anyone with your backup phrase can access or spend your bitcoin.":"Iemand die uw herstel zin weet heeft toegang tot uw bitcoin en kan deze uitgeven.","Approximate Qybcoin network fee to transfer wallet's balance (with normal priority)":"Geschatte Qybcoin netwerk transactiekosten voor overdracht van volledige saldo van portemonnee (met normale prioriteit)","Are you being watched?":"Kijkt er iemand mee?","Are you being watched? Anyone with your recovery phrase can access or spend your bitcoin.":"Kijkt er iemand mee? Iedereen die uw herstel zin weet heeft toegang tot uw bitcoin en kan het uitgeven.","Are you sure you want to cancel and delete this wallet?":"Weet u zeker dat u wilt annuleren en deze portemonnee verwijderen?","Are you sure you want to delete this contact?":"Weet u zeker dat u deze contactpersoon wilt verwijderen?","Are you sure you want to delete this wallet?":"Weet u zeker dat u deze portemonnee wilt verwijderen?","Are you sure you want to reject this transaction?":"Weet u zeker dat u deze transactie wilt afwijzen?","Are you sure you want to remove this transaction?":"Weet u zeker dat u deze transactie wilt verwijderen?","Are you sure you want to skip it?":"Weet u zeker dat u dit wilt overslaan?","Are you sure you would like to log out of your BitPay Card account?":"Weet u zeker dat u wilt uitloggen uit uw BitPay Kaart account?","Are you sure you would like to remove your BitPay Card ({{lastFourDigits}}) from this device?":"Weet u zeker dat u de BitPay Kaart ({{lastFourDigits}}) van dit apparaat wilt verwijderen?","Auditable":"Auditeerbaar","Available":"Beschikbaar","Available Balance":"Beschikbaar Saldo","Average confirmation time":"Gemiddelde bevestigingstijd","BIP32 path for address derivation":"BIP32 pad voor adres derivatie","QYB wallets":"QYB portemonnees","Backup":"Backup","Backup Needed":"Backup Nodig","Backup all livenet wallets before using this function":"Maak een backup van alle livenet portemonnees voordat u deze functie gebruikt","Backup needed":"Backup nodig","Backup now":"Backup maken","Backup wallet":"Backup van portemonnee maken","Backup your wallet before using this function":"Maak een backup van uw portemonnee voordat u deze functie gebruikt","Bad wallet invitation":"Foutieve portemonnee-uitnodiging","Balance By Address":"Saldo Per Adres","Be sure to store your recovery phrase in a secure place. If this app is deleted, your money cannot be recovered without it.":"Zorg dat u de herstel zin op een veilige plek bewaard. Als deze app verwijderd is, kan uw saldo niet meer worden hersteld zonder de herstel zin.","BitPay Visa® Cards":"BitPay Visa&reg; Kaarten","Qybcoin Address":"Qybcoin Adres","Qybcoin Cash Wallets":"Qybcoin Cash Portemonnees","Qybcoin Network Fee Policy":"Transactiekostenbeleid Qybcoin-netwerk","Qybcoin Wallets":"Qybcoin Portemonnees","Qybcoin cash Payment":"Qybcoin cash Betaling","Qybcoin is a currency.":"Qybcoin is een valuta.","Qybcoin is different – it cannot be safely held with a bank or web service.":"Qybcoin is anders &ndash; het kan niet veilig worden bewaard bij een bank of online dienst.","Qybcoin is secure,<br>digital money.":"Qybcoin is veilig,<br>digitaal geld.","Qybcoin transactions include a fee collected by miners on the network.":"Qybcoin transacties bevatten transactiekosten betaald aan de miners in het netwerk.","Bought {{amountUnitStr}}":"Gekocht {{amountUnitStr}}","Broadcast Payment":"Betaling Verzenden","Broadcasted":"Verzonden","Broadcasting transaction":"Transactie verzenden","Browser unsupported":"Browser niet ondersteund","Buy":"Kopen","Buy &amp; Sell Qybcoin":"Koop &amp; Verkoop Qybcoin","Buy Qybcoin":"Qybcoin kopen","Buy a Gift Card":"Een Cadeaubon kopen","Buy from":"Kopen van","Buying Qybcoin...":"Qybcoin kopen...","Calculating fee":"Transactiekosten berekenen","Cancel":"Annuleren","Cancel invitation":"Uitnodiging annuleren","Cannot Create Wallet":"Kan Portemonnee Niet Aanmaken","Cannot join the same wallet more that once":"Kan niet meerdere keren tegelijk deelnemen aan een portemonnee","Cards":"Kaarten","Certified by":"Gecertificeerd door","Check installation and retry.":"Controleer de installatie en probeer het opnieuw.","Choose a backup file from your computer":"Kies een backup bestand op uw computer","Choose your destination wallet":"Kies uw doel portemonnee","Choose your source wallet":"Kies uw bron portemonnee","Clear":"Leegmaken","Clear cache":"Cache legen","Click to accept":"Klik om te accepteren","Click to pay":"Klik om te betalen","Click to send":"Klik om te verzenden","Close":"Sluiten","Coin":"Valuta","Color":"Kleur","Commit hash":"Commit hash","Complete the backup process to use this option":"Voltooi het backup proces voordat u deze optie gebruikt","Completed":"Voltooid","Confirm":"Bevestigen","Confirm &amp; Finish":"Bevestigen &amp; Voltooien","Confirm purchase":"Bevestig aankoop","Confirm your PIN":"Bevestig uw PIN","Confirm your new spending password":"Bevestig uw nieuwe bestedingswachtwoord","Confirmations":"Bevestigingen","Confirming":"Bevestigen","Connect my BitPay Card":"Koppelen met mijn BitPay Kaart","Connecting to Coinbase...":"Verbinding maken met Coinbase...","Connecting to Glidera...":"Verbinding maken met Glidera...","Connection reset by peer":"Verbinding is gereset door peer","Contacts":"Contactpersonen","Continue":"Ga verder","Contribute Translations":"Bijdragen aan Vertalingen","Qyb only supports Qybcoin Cash using new version numbers addresses":"Qyb ondersteunt Qybcoin Cash alleen met gebruik van nieuwe versienummer adressen","Copayer already in this wallet":"Copayer reeds in deze portemonnee","Copayer already voted on this spend proposal":"Copayer heeft al gestemd op dit bestedingsvoorstel","Copayer data mismatch":"Copayer gegevens komen niet overeen","Copayer joined":"Copayer toegetreden","Copayer {{$index}}":"Copayer {{$index}}","Copied to clipboard":"Gekopieerd naar klembord","Copy this text as it is to a safe place (notepad or email)":"Kopieer deze tekst zonder te wijzigen naar een veilige plek (kladblok of email)","Copy to clipboard":"Naar klembord kopiëren","Could not access Gift Card Service":"Kon geen verbinding maken met de Cadeaubon Service","Could not access the wallet at the server. Please check:":"Kon geen toegang krijgen tot de portemonnee op de server. Graag dit checken:","Could not access to Amazon.com":"Kon geen verbinding maken met Amazon.com","Could not access wallet":"Kon geen toegang krijgen tot portemonnee","Could not add message to imported wallet without shared encrypting key":"Kon geen bericht toegevoegd worden aan geïmporteerde portemonnee zonder gedeelde sleutel","Could not broadcast payment":"Kon betaling niet verzenden","Could not build transaction":"Kon transactie niet opzetten","Could not create address":"Kon adres niet aanmaken","Could not create the invoice":"Kon factuur niet aanmaken","Could not create transaction":"Kon transactie niet aanmaken","Could not create using the specified extended private key":"Kon niet aanmaken met de gebruikte verlengde privé sleutel","Could not create using the specified extended public key":"Kon niet aanmaken met de opgegeven verlengde publieke sleutel","Could not create: Invalid wallet recovery phrase":"Kon niet worden gemaakt: Ongeldige portemonnee herstel zin","Could not decrypt file, check your password":"Kon bestand niet ontsleutelen, check uw wachtwoord","Could not delete payment proposal":"Kon betalingsvoorstel niet verwijderen","Could not duplicate":"Kon niet dupliceren","Could not get dynamic fee":"Kon dynamische transactiekosten niet bepalen","Could not get dynamic fee for level: {{feeLevel}}":"Kon dynamische transactiekosten niet bepalen voor niveau: {{feeLevel}}","Could not get fee levels":"Kon niveaus transactiekosten niet opvragen","Could not get the invoice":"Kon factuur niet opvragen","Could not get transactions":"Kon transacties niet opvragen","Could not import":"Kon niet importeren","Could not import. Check input file and spending password":"Kon niet importeren. Controleer bestand en bestedingswachtwoord","Could not join wallet":"Kon niet toetreden tot portemonnee","Could not reject payment":"Kon betaling niet weigeren","Could not remove account":"Kon account niet verwijderen","Could not remove card":"Kon kaart niet verwijderen","Could not save preferences on the server":"Kon voorkeuren niet opslaan op de server","Could not send payment":"Kon betaling niet versturen","Could not send transaction":"Kon transactie niet versturen","Could not update transaction history":"Kon transactiehistorie niet bijwerken","Could not update wallet":"Kon portemonnee niet bijwerken","Create Personal Wallet":"Persoonlijke Portemonnee Aanmaken","Create Shared Wallet":"Gedeelde Portemonnee Aanmaken","Create bitcoin wallet":"Qybcoin portemonnee aanmaken","Create new wallet":"Nieuwe portemonnee aanmaken","Create shared wallet":"Gedeelde portemonnee aanmaken","Create {{formData.requiredCopayers}}-of-{{formData.totalCopayers}} wallet":"{{formData.requiredCopayers}}-van-{{formData.totalCopayers}} portemonnee aanmaken","Created by":"Aangemaakt door","Creating Wallet...":"Portemonnee Aanmaken...","Creating transaction":"Transactie aanmaken","Current fee rate for this policy":"Huidige transactiekosten voor dit beleid","Custom":"Aangepast","Custom Amount":"Aangepast Bedrag","Custom Fee":"Aangepaste Transactiekosten","Date":"Datum","Delete":"Verwijderen","Delete Payment Proposal":"Verwijder Bestedingsvoorstel","Delete Wallet":"Portemonnee verwijderen","Delete it and create a new one":"Verwijderen en een nieuwe maken","Deleting Wallet...":"Portemonnee Verwijderen...","Deleting payment proposal":"Betalingsvoorstel verwijderen","Derivation Path":"Derivatie Pad","Derivation Strategy":"Derivatiestrategie","Details":"Details","Disabled":"Uitgeschakeld","Do it later":"Doe het later","Do not include private key":"Privé sleutel niet bijvoegen","Don't see your language on Crowdin? Contact the Owner on Crowdin! We'd love to support your language.":"Ziet u uw taal niet op Crowdin? Neem contact op met de Eigenaar op Crowdin! We willen graag uw taal ondersteunen.","Download":"Download","Duplicate for dmb":"Dupliceren voor dmb","Duplicating wallet...":"Portemonnee dupliceren...","Each bitcoin wallet can generate billions of addresses from your 12-word backup. A new address is automatically generated and shown each time you receive a payment.":"Elke bitcoin portemonnee kan miljarden adressen genereren vanuit uw backup bestaand uit 12 woorden. Elke keer dat u een betaling ontvangt wordt automatisch een nieuw adres gegenereerd en getoond.","Economy":"Zuinig","Edit":"Bewerken","Email":"Email","Email Address":"Emailadres","Empty addresses limit reached. New addresses cannot be generated.":"Limiet lege adressen bereikt. Nieuwe adressen kunnen niet worden gegenereerd.","Enable camera access in your device settings to get started.":"Schakel camera toegang in vanuit uw apparaat instellingen om aan de slag te gaan.","Enable email notifications":"Email meldingen inschakelen","Enable push notifications":"Push meldingen inschakelen","Enable the camera to get started.":"Schakel de camera in om aan de slag te gaan.","Enter Spending Password":"Voer Bestedingswachtwoord in","Enter Two Factor for your BitPay account":"Voer Two Factor in voor uw BitPay account","Enter amount":"Vul bedrag in","Enter custom fee":"Vul aangepaste transactiekosten in","Enter new spending password":"Voer nieuw bestedingswachtwoord in","Enter the recovery phrase (BIP39)":"Vul de herstel zin in (BIP39)","Enter your email":"Vul uw email in","Enter your password":"Voer uw wachtwoord in","Error":"Fout","Error at confirm":"Fout bij bevestigen","Error creating gift card":"Fout tijdens maken cadeaubon","Error creating the invoice":"Fout tijdens maken van de factuur","Error creating wallet":"Fout tijdens maken portemonnee","Error getting SendMax information":"Fout tijdens opvragen VerstuurMaximum informatie","Error in Payment Protocol":"Fout in Betalings Protocol","Error pairing BitPay Account":"Fout tijdens koppelen BitPay Account","Error scanning funds:":"Fout tijdens scannen saldo:","Error sweeping wallet:":"Fout tijdens opnemen saldo portemonnee:","Error updating Debit Cards":"Fout tijdens bijwerken Debet Kaarten","Exceeded daily limit of $500 per user":"Dagelijkse limiet van $500 per gebruiker overschreden","Expired":"Verlopen","Expires":"Verloopt","Export Wallet":"Portemonnee exporteren","Export to file":"Exporteren naar bestand","Export wallet":"Exporteer portemonnee","Exporting via QR not supported for this wallet":"Exporteren via QR niet ondersteund voor deze portemonnee","Extended Private Key":"Verlengde Privé Sleutel","Extended Public Keys":"Verlengde Publieke Sleutels","Extracting Wallet information...":"Portemonnee informatie ophalen...","Failed to export":"Exporteren mislukt","Family vacation funds":"Familie vakantie fonds","Fee":"Transactiekosten","Fee level":"Niveau transactiekosten","Fee level is not defined":"Niveau transactiekosten is niet ingesteld","Fee:":"Transactiekosten:","Feedback could not be submitted. Please try again later.":"Feedback kon niet worden ingediend. Probeer het later nog eens.","Fetching BitPay Account...":"Ophalen BitPay Account...","Fetching payment information":"Ophalen van betalingsgegevens","File/Text":"Bestand/Tekst","Filter setting":"Filter instellingen","Finger Scan Failed":"Vingerscan Mislukt","Finish":"Voltooien","For audit purposes":"Voor audit doeleinden","From":"Van","From BitPay account":"Van BitPay account","From Hardware Wallet":"Vanuit Hardware Portemonnee","From the destination device, go to Add wallet &gt; Import wallet and scan this QR code":"Ga op het ontvangende apparaat naar Portemonnee toevoegen &gt; Importeer portemonnee, en scan deze QR code","Funds are locked by pending spend proposals":"Saldo is vergrendeld in afwachting van bestedingsvoorstellen","Funds found:":"Gevonden saldo:","Funds to be added":"Saldo toe te voegen","Funds transferred":"Overgemaakt saldo","Funds were added to debit card":"Saldo is toegevoegd aan debetkaart","Funds will be transferred to":"Saldo zal worden overgemaakt naar","Generate new address":"Genereer nieuw adres","Generating .csv file...":".csv bestand genereren...","Generating new address...":"Nieuw adres genereren...","Get local cash anywhere you go, from any Visa<sup>®</sup> compatible ATM. ATM bank fees may apply.":"Verkrijg lokaal contant geld waar je ook gaat, van elke Visa<sup>&reg;</sup> ondersteunende pinautomaat. Kosten voor gebruik van de pinautomaat kunnen in rekening gebracht worden.","Get news and updates from BitPay":"Ontvang nieuws en updates van BitPay","Get started":{"$$noContext":"Aan de slag","button":"Aan de slag"},"Get started by adding your first one.":"Ga aan de slag door uw eerste toe te voegen.","Getting fee levels...":"Hoogte transactiekosten opvragen...","Gift Card":"Cadeaubon","Gift Card is not available to use anymore":"Cadeaukaart is niet meer beschikbaar voor gebruik","Gift card expired":"Cadeaubon verlopen","Gift card generated and ready to use.":"Cadeaubon aangemaakt en klaar voor gebruik.","Go Back":"Terug","Go back":"Terug","Got it":"Ik begrijp het","Hardware Wallet":"Hardware Portemonnee","Hardware not connected.":"Hardware niet aangesloten.","Hardware wallet":"Hardware portemonnee","Hardware wallets are not yet supported with Qybcoin Cash":"Hardware portemonnees worden nog niet ondersteund bij Qybcoin Cash","Help & Support":"Hulp & Ondersteuning","Help and support information is available at the website.":"Hulp en ondersteuning is beschikbaar op de website.","Hide":"Verberg","Hide Balance":"Verberg Saldo","Hide Next Steps Card":"Verberg Volgende Stappen Kaart","Hide advanced options":"Verberg geavanceerde opties","Home":"Start","How could we improve your experience?":"Hoe zouden wij uw ervaring kunnen verbeteren?","How do you like {{appName}}?":"Hoe bevalt {{appName}}?","I don't like it":"Ik vind hem niet goed","I have read, understood, and agree to the <a ng-click=\"openTerms()\" translate=\"\">Terms of Use</a>.":"Ik heb gelezen, begrepen, en ga akkoord met de <a ng-click=\"openTerms()\" translate=\"\">Gebruiksvoorwaarden</a>.","I have read, understood, and agree with the Terms of use.":"Ik heb gelezen, begrepen, en ga akkoord met de Gebruiksvoorwaarden.","I have written it down":"Ik heb het opgeschreven","I like the app":"De app bevalt mij goed","I think this app is terrible.":"Ik vind de app verschrikkelijk.","I understand":"Ik begrijp het","I understand that if this app is moved to another device or deleted, my bitcoin can only be recovered with the backup phrase.":"Ik begrijp dat als deze app wordt verwijderd of verplaatst naar een ander apparaat, ik mijn bitcoin alleen kan herstellen met de herstel zin.","I understand that my funds are held securely on this device, not by a company.":"Ik begrijp dat mijn saldo veilig op dit apparaat bewaard wordt, en niet in handen is van een bedrijf.","I've written it down":"Ik heb het opgeschreven","If enabled, all sensitive information (private key and recovery phrase) and actions (spending and exporting) associated with this wallet will be protected.":"Indien ingeschakeld, zullen alle gevoelige informatie (privé sleutel en herstel zin) en acties (uitgeven en exporteren) geassocieerd met deze portemonnee worden beschermd.","If enabled, the Recent Transactions card - a list of transactions occuring across all wallets - will appear in the Home tab.":"Indien ingeschakeld, zal de Recente Transacties kaart - een lijst van transacties van alle portemonnees - worden weergegeven in het tabblad Start.","If enabled, wallets will also try to spend unconfirmed funds. This option may cause transaction delays.":"Indien ingeschakeld, zullen portemonnees ook onbevestigd saldo proberen te besteden. Deze optie kan transactie vertragingen veroorzaken.","If this device is replaced or this app is deleted, neither you nor BitPay can recover your funds without a backup.":"Als dit apparaat wordt vervangen of deze app wordt verwijderd, kunnen u noch BitPay uw saldo herstellen zonder backup.","If you have additional feedback, please let us know by tapping the \"Send feedback\" option in the Settings tab.":"Als u meer feedback heeft, laat het ons dan weten via de \"Geef feedback\" optie in het tabblad Instellingen.","If you take a screenshot, your backup may be viewed by other apps. You can make a safe backup with physical paper and a pen.":"Als u een screenshot neemt kunnen andere apps uw backup zien. U kunt een veilige backup maken met fysieke pen en papier.","Import":"Importeren","Import Wallet":"Portemonnee importeren","Import backup":"Backup importeren","Import wallet":"Importeer portemonnee","Importing Wallet...":"Portemonnee importeren...","In order to verify your wallet backup, please type your password.":"Vul uw wachtwoord in om de backup van uw portemonnee te verifiëren.","Inactive":"Inactief","Incomplete":"Onvolledig","Incomplete wallet":"Onvolledige portemonnee","Incorrect PIN, try again.":"Onjuiste PIN, probeer het opnieuw.","Incorrect code format":"Onjuist code format","Incorrect network address":"Onjuist netwerk adres","Insufficient funds":"Onvoldoende saldo","Insufficient funds for fee":"Onvoldoende saldo voor transactiekosten","Integrations":"Integraties","Invalid":"Ongeldig","Invalid URL":"Ongeldige URL","Invalid account number":"Ongeldig account nummer","Invalid address":"Ongeldig adres","Invalid data":"Ongeldige gegevens","Invalid derivation path":"Ongeldig derivatie pad","Invitation to share a {{appName}} Wallet":"Uitnodiging om {{appName}} Portemonnee te delen","Invoice expired":"Factuur verlopen","Is there anything we could do better?":"Is er iets dat we beter kunnen doen?","Is this correct?":"Klopt dit?","Is this email address correct?":"Is dit emailadres juist?","It's a good idea to avoid reusing addresses - this both protects your privacy and keeps your bitcoins secure against hypothetical attacks by quantum computers.":"Het is aan te raden adressen niet te hergebruiken - dit beschermt uw privacy en beveiligd uw bitcoins tegen een hypothetische aanval door quantum computers.","It's important that you write your backup phrase down correctly. If something happens to your wallet, you'll need this backup to recover your money. Please review your backup and try again.":"Het is van belang uw backup zin correct op te schrijven. Als er iets gebeurt met uw portemonnee, heeft u deze backup nodig om toegang tot uw geld te herstellen. Controleer uw backup en probeer het nogmaals.","Join":"Deelnemen","Join my {{appName}} Wallet. Here is the invitation code: {{secret}} You can download {{appName}} for your phone or desktop at {{appUrl}}":"Neem deel aan mijn {{appName}} Portemonnee. Hier is de uitnodigingscode: {{secret}} U kunt {{appName}} voor uw telefoon of desktop hier downloaden {{appUrl}}","Join shared wallet":"Deelnemen aan gedeelde portemonnee","Joining Wallet...":"Deelnemen aan Portemonnee...","Just scan the code to pay.":"Scan de code om te betalen.","Key already associated with an existing wallet":"Sleutel is reeds geassocieerd met een bestaande portemonnee","Language":"Taal","Last Month":"Vorige Maand","Learn more":"Meer informatie","Let's verify your backup phrase.":"Laten we de backup zin verifiëren.","Loading addresses...":"Adressen laden...","Loading transaction info...":"Transactie info laden...","Lock App":"Vergrendel App","Lock by Fingerprint":"Vergrendelen met Vingerafdruk","Lock by PIN":"Vergrendelen met PIN","Locked":"Vergrendeld","Locktime in effect. Please wait to create a new spend proposal":"Tijdslot van kracht. Wacht a.u.b. met het maken van een nieuw bestedingsvoorstel","Locktime in effect. Please wait to remove this spend proposal":"Tijdslot van kracht. Wacht a.u.b. met het verwijderen van dit bestedingsvoorstel","Log options":"Log opties","Log out":"Uitloggen","Low amount inputs":"Kleine ontvangsten","Low fees":"Lage transactiekosten","Makes sense":"Klinkt logisch","Matches:":"Overeenkomsten:","Me":"Ik","Meh - it's alright":"Meh - het is OK","Memo":"Notitie","Mercado Livre Brazil Gift Cards":"Mercado Livre Brazil Cadeaubonnen","Mercadolibre Gift Card Service is not available at this moment. Please try back later.":"Mercadolibre Cadeaubon Service is niet beschikbaar op dit moment. Probeer het later nog eens.","Merchant Message":"Bericht Verkoper","Miner Fee":"Transactiekosten Miner","Missing parameter":"Ontbrekende parameter","Missing private keys to sign":"Privé sleutels om te ondertekenen ontbreken","More Options":"Meer Opties","Moved":"Verplaatst","Moved Funds":"Saldo Verplaatst","Multiple recipients":"Meerdere ontvangers","NOTE: To import a wallet from a 3rd party software, please go to Add Wallet &gt; Create Wallet, and specify the Recovery Phrase there.":"OPMERKING: Om een portemonnee te importeren vanuit software van een 3e partij, ga naar Portemonnee Toevoegen &gt; Portemonnee Aanmaken, en vul daar de herstel zin in.","Name":"Naam","Network Cost":"Transactiekosten","Network error":"Netwerk fout","New Proposal":"Nieuw Voorstel","New address could not be generated. Please try again.":"Nieuw adres kon niet worden gegenereerd. Probeer het opnieuw.","New personal wallet":"Nieuwe persoonlijke portemonnee","Next steps":"Volgende stappen","No Wallet":"Geen Portemonnee","No access key defined":"Geen toegangsknop ingesteld","No backup, no bitcoin.":"Geen backup, geen bitcoin.","No contacts yet":"Nog geen contactpersonen","No entries for this log level":"Geen items voor dit logboek niveau","No hardware information available.":"Geen hardware informatie beschikbaar.","No hardware wallets supported on this device":"Er worden geen hardware portemonnees ondersteund op dit apparaat","No pending proposals":"Geen voorstellen in behandeling","No recent transactions":"Geen recente transacties","No signing proposal: No private key":"Geen voorstel voor ondertekenen: Geen privé sleutel","No transactions yet":"Nog geen transacties","No wallet found":"Geen portemonnee gevonden","No wallet selected":"Geen portemonnee geselecteerd","No wallets available":"Geen portemonnees beschikbaar","No wallets available to receive funds":"Geen portemonnees beschikbaar om saldo te ontvangen","No wallets eligible for Qybcoin Cash support":"Geen geschikte portemonnees voor Qybcoin Cash ondersteuning","Non BIP44 wallet":"Niet-BIP44 portemonnee","Non eligible QYB wallets":"Geen geschikte QYB-portemonnees","Normal":"Normaal","Not authorized":"Niet geautoriseerd","Not enough funds for fee":"Onvoldoende saldo voor transactiekosten","Not even BitPay can access it.":"Zelfs BitPay heeft geen toegang.","Not funds found":"Geen saldo gevonden","Not now":"Niet nu","Note":"Notitie","Note: if this dmb wallet was duplicated from a QYB wallet, they share the same recovery phrase.":"Let op: als deze dmb portemonnee is gedupliceerd van een QYB portemonnee, dan delen zij de zelfde herstel zin.","Notice: only 1-1 (single signature) wallets can be used for sell bitcoin":"Let op: alleen 1-1 (enkele ondertekening) portemonnees kunnen gebruikt worden voor het verkopen van bitcoin","Notifications":"Meldingen","Notifications by email":"Meldingen per email","Notify me if confirmed":"Geef mij een melding wanneer bevestigd","Notify me when transactions are confirmed":"Geef mij een melding wanneer transacties zijn bevestigd","Now is a good time to backup your wallet. If this device is lost, it is impossible to access your funds without a backup.":"Dit is een goed moment om een backup van de portemonnee te maken. Als dit apparaat kwijt raakt is het onmogelijk om toegang tot uw saldo te krijgen zonder een backup.","Now is a perfect time to assess your surroundings. Nearby windows? Hidden cameras? Shoulder-spies?":"Dit is het juiste moment om uw omgeving te bekijken. Ramen in de buurt? Verborgen camera's? Kijkt er iemand mee over uw schouder?","OK":"OK","OKAY":"OK","Official English Disclaimer":"Officiële Engelse Voorwaardelijkheidsverklaring","Oh no!":"Oh nee!","Ok":"OK","On this screen you can see all your wallets, accounts, and assets.":"Op dit scherm ziet u al uw portemonnees, accounts en eigendommen.","Open":"Openen","Open Crowdin":"Crowdin openen","Open GitHub":"GitHub openen","Open GitHub Project":"GitHub Project openen","Open Insight":"Insight openen","Open Settings":"Instellingen openen","Open Translation Community":"Vertalings Gemeenschap openen","Open Website":"Website Openen","Open the recovery tool.":"Open de herstel tool.","Open wallet":"Portemonnee openen","Open website":"Website openen","Order the BitPay Card":"Bestel de BitPay Kaart","Password":"Wachtwoord","Password required. Make sure to enter your password in advanced options":"Wachtwoord vereist. Vul uw wachtwoord in bij de geavanceerde opties","Paste invitation here":"Plak hier de uitnodiging","Paste the backup plain text code":"Plak de platte tekst backup","Pay 0% fees to turn bitcoin into dollars.":"Betaal 0% transactiekosten om bitcoin om te zetten naar dollars.","Pay To":"Betalen Aan","Payment Accepted":"Betaling Geaccepteerd","Payment Expires:":"Betaling Verloopt:","Payment Proposal":"Betalingsvoorstel","Payment Proposal Created":"Betalingsvoorstel Aangemaakt","Payment Proposals":"Betalingsvoorstellen","Payment Protocol Invalid":"Betaling Protocol Ongeldig","Payment Protocol not supported on Chrome App":"Betalingsvoorstel niet ondersteund door Chrome App","Payment Received":"Betaling Ontvangen","Payment Rejected":"Betaling Afgewezen","Payment Sent":"Betaling Verzonden","Payment accepted, but not yet broadcasted":"Betaling geaccepteerd, maar nog niet verzonden","Payment accepted. It will be broadcasted by Glidera. In case there is a problem, it can be deleted 6 hours after it was created.":"Betaling geaccepteerd. Deze zal worden verzonden door Glidera. In geval van problemen kan de betaling worden verwijderd 6 uur na aanmaken.","Payment address was translated to new Qybcoin Cash address format:":"Betalingsadres is vertaald naar nieuw adresformat voor Qybcoin Cash:","Payment details":"Details Betaling","Payment request":"Betalingsverzoek","Pending":"In behandeling","Pending Proposals":"Voorstellen in behandeling","Permanently delete this wallet.":"Deze portemonnee definitief verwijderen.","Personal Wallet":"Persoonlijke Portemonnee","Please carefully write down this phrase.":"Schrijf zorgvuldig deze zin op.","Please connect a camera to get started.":"Sluit een camera aan om aan de slag te gaan.","Please enter the recovery phrase":"Vul de herstel zin in","Please enter the wallet recovery phrase":"Vul de herstel zin van de portemonnee in","Please enter your PIN":"Vul uw PIN in","Please tap each word in the correct order.":"Druk a.u.b. op elk woord in de juiste volgorde.","Please upgrade Qyb to perform this action":"Upgrade Qyb om deze actie uit te voeren","Please wait":"Een moment geduld a.u.b.","Please, select your backup file":"Selecteer uw backup bestand","Pre-Auth Holds":"Pre-Authorisatie Inhoudingen","Preferences":"Voorkeuren","Preparing addresses...":"Adressen voorbereiden...","Preparing backup...":"Backup voorbereiden...","Press again to exit":"Druk nogmaals om te sluiten","Priority":"Dringend","Private Key":"Privé Sleutel","Private key encrypted. Enter password":"Privé sleutel versleuteld. Voer wachtwoord in","Private key is encrypted, cannot sign":"Privé sleutel is versleuteld, kan niet ondertekenen","Proposal Accepted":"Voorstel Geaccepteerd","Proposal Created":"Voorstel Aangemaakt","Proposal Deleted":"Voorstel Verwijderd","Proposal Rejected":"Voorstel Afgewezen","Proposals":"Voorstellen","Purchase Amount is limited to {{limitPerDay}} {{currency}} per day":"Aankoop Bedrag is beperkt tot {{limitPerDay}} {{currency}} per dag","Purchase amount must be a value between 50 and 2000":"Aankoop bedrag moet een getal zijn tussen de 50 en 2000","Push Notifications":"Push Meldingen","Push notifications for {{appName}} are currently disabled. Enable them in the Settings app.":"Push meldingen voor {{appName}} zijn op dit moment uitgeschakeld. Schakel deze in vanuit de Instellingen app.","QR Code":"QR Code","Quick review!":"Kort samenvatten!","Random":"Willekeurig","Rate on the app store":"Beoordelen in de app store","Read less":"Lees minder","Read more":"Lees meer","Read more in our Wiki":"Lees meer in onze Wiki","Read only wallet":"Alleen-lezen portemonnee","Receive":"Ontvangen","Receive in":"Ontvangen in","Received":"Ontvangen","Received Funds":"Ontvangen Saldo","Receiving":"Ontvangen","Recent":"Recent","Recent Transaction Card":"Recente Transacties Kaart","Recent Transactions":"Recente Transacties","Recipient":"Ontvanger","Recipients":"Ontvangers","Recovery phrase":"Herstel zin","Recreating Wallet...":"Portemonnee herstellen...","Redeem now":"Nu inwisselen","Rejected":"Afgewezen","Rejecting payment proposal":"Betalingsvoorstel afwijzen","Release information":"Release informatie","Remove":"Verwijderen","Remove BitPay Account?":"BitPay Account verwijderen?","Remove BitPay Card?":"BitPay Kaart verwijderen?","Removing your BitPay account will remove all associated BitPay account data from this device. Are you sure you would like to remove your BitPay Account ({{email}}) from this device?":"Het verwijderen van uw BitPay account zal alle geassocieerde BitPay accountgegevens van dit apparaat verwijderen. Weet u zeker dat u de BitPay Account ({{email}}) van dit apparaat wilt verwijderen?","Repeat password":"Herhaal wachtwoord","Repeat the password":"Herhaal het wachtwoord","Request Fingerprint":"Vereis Vingerafdruk","Request Specific amount":"Vraag Specifiek bedrag","Request Spending Password":"Vereis Bestedingswachtwoord","Required number of signatures":"Vereiste aantal ondertekeningen","Restore from backup":"Herstellen vanuit backup","Retrieving inputs information":"Opvragen informatie ontvangsten","Retry":"Probeer opnieuw","Retry Camera":"Camera opnieuw proberen","Save":"Opslaan","Scan":"Scannen","Scan QR Codes":"Scan QR Codes","Scan addresses for funds":"Scan adressen voor saldo","Scan again":"Scan nogmaals","Scan your fingerprint please":"Scan uw vingerafdruk","Scanning Wallet funds...":"Saldo Portemonnee scannen...","Scanning funds...":"Saldo scannen...","Screenshots are not secure":"Screenshots zijn niet veilig","Search Transactions":"Doorzoek Transacties","Search or enter bitcoin address":"Zoeken of bitcoin adres invullen","Search transactions":"Doorzoek transacties","Search your currency":"Zoek uw valuta","Security":"Beveiliging","See invoice":"Bekijk factuur","Select a backup file":"Selecteer een backup bestand","Select a wallet":"Selecteer een portemonnee","Self-signed Certificate":"Zelf-gesigneerd Certificaat","Selling Qybcoin...":"Qybcoin verkopen...","Send":"Verzenden","Send Feedback":"Feedback Sturen","Send Money":"Stuur Geld","Send addresses by email":"Verstuur adressen per email","Send by email":"Verstuur via email","Send from":"Verzenden vanuit","Send max amount":"Verzend maximale hoeveelheid","Send payment to this address":"Verstuur betaling naar dit adres","Send us feedback instead":"Stuur in plaats daarvan feedback","Sending":"Verzenden","Sending 2FA code...":"2FA code verzenden...","Sending feedback...":"Feedback verzenden...","Sending maximum amount":"Maximale hoeveelheid verzenden","Sending transaction":"Transactie verzenden","Sending {{amountStr}} from your {{name}} wallet":"Verzenden van {{amountStr}} vanuit uw {{name}} portemonnee","Sent":"Verzonden","Sent Funds":"Verzonden Bedrag","Server response could not be verified":"Server reactie kon niet geverifieerd worden","Service not available":"Service niet beschikbaar","Services":"Diensten","Session Log":"Sessie Log","Session log":"Sessie log","Set up a password":"Stel wachtwoord in","Set your own fee in satoshis/byte":"Kies uw eigen transactiekosten in satoshi/byte","Settings":"Instellingen","Share the love by inviting your friends.":"Deel het plezier door uw vrienden uit te nodigen.","Share this invitation with your copayers":"Deel deze uitnodiging met uw copayers","Share {{appName}}":"Deel {{appName}}","Shared Wallet":"Gedeelde Portemonnee","Show Recovery Phrase":"Toon Herstel Zin","Show address":"Toon adres","Show advanced options":"Geavanceerde opties weergeven","Show bitcoin address":"Toon bitcoin adres","Show more":"Meer weergeven","Signatures rejected by server":"Ondertekeningen geweigerd door server","Signing transaction":"Transactie ondertekenen","Since only you control your money, you’ll need to save your backup phrase in case this app is deleted.":"Omdat u de enige bent die uw geld beheert, zult u de herstel zin moeten bewaren indien deze app verwijderd wordt.","Single Address Wallet":"Portemonnee met 1 Adres","Skip":"Overslaan","Slide to accept":"Schuiven om te accepteren","Slide to buy":"Schuif om te kopen","Slide to pay":"Schuiven om te betalen","Slide to send":"Schuiven om te verzenden","Some of your wallets are not eligible for Qybcoin Cash support. You can try to access dmb funds from these wallets using the":"Sommige van uw portemonnees komen niet in aanmerking voor Qybcoin Cash ondersteuning. U kunt proberen toegang te krijgen tot het dmb saldo van deze portemonnees met gebruik van de","Specify Recovery Phrase...":"Voer Herstel Zin in...","Spend proposal is not accepted":"Bestedingsvoorstel is niet geaccepteerd","Spend proposal not found":"Bestedingsvoorstel niet gevonden","Spending Password needed":"Bestedingswachtwoord vereist","Spending this balance will need significant Qybcoin network fees":"Dit bedrag uitgeven vereist aanzienlijke transactiekosten","Start sending bitcoin":"Begin met het sturen van bitcoin","Startup Lock":"Opstart Slot","Still pending":"Nog in behandeling","Success":"Geslaagd","Super Economy":"Super Zuinig","Sweep":"Saldo opnemen","Sweep paper wallet":"Saldo papieren portemonnee opnemen","Sweeping Wallet...":"Saldo Portemonnee opnemen...","THIS ACTION CANNOT BE REVERSED":"DEZE ACTIE IS ONOMKEERBAAR","Take control of your money,<br>get started with bitcoin.":"Neem controle over uw geld,<br>aan de slag met bitcoin.","Tap and hold to show":"Tik en houd vast om te tonen","Tap to recreate":"Tik om opnieuw aan te maken","Tap to retry":"Tik om opnieuw te proberen","Terms Of Use":"Gebruiksvoorwaarden","Terms of Use":"Gebruikersvoorwaarden","Testnet":"Testnet","Text":"Tekst","Thank you!":"Dank u!","Thanks!":"Bedankt!","That's exciting to hear. We'd love to earn that fifth star from you – how could we improve your experience?":"Dat is goed om te horen. Wij zouden graag die vijfde ster verdienen - hoe kunnen wij uw ervaring verbeteren?","The Ledger Chrome application is not installed":"De Ledger Chrome applicatie is niet geïnstalleerd","The amount of bitcoin immediately spendable from this wallet.":"De hoeveelheid bitcoin die direct te besteden is vanuit deze portemonnee.","The amount of bitcoin stored in this wallet that is allocated as inputs to your pending transaction proposals. The amount is determined using unspent transaction outputs associated with this wallet and may be more than the actual amounts associated with your pending transaction proposals.":"De hoeveelheid bitcoin opgeslagen in deze portemonnee die is toegewezen als invoer voor uw wachtende betalingsvoorstellen. De hoeveelheid is bepaald door te kijken naar ongebruikte transactie uitvoer geassocieerd met deze portemonnee en kan meer zijn dan de daadwerkelijke hoeveelheid geassocieerd met de wachtende betalingsvoorstellen.","The amount of bitcoin stored in this wallet with less than 1 blockchain confirmation.":"De hoeveelheid bitcoin opgeslagen in deze portemonnee met minder dan 1 blockchain bevestiging.","The derivation path":"Het derivatie pad","The exchange rate changes with the market.":"De wisselkoers wijzigt aan de hand van de markt.","The higher the fee, the greater the incentive a miner has to include that transaction in a block. Current fees are determined based on network load and the selected policy.":"Des te hoger de betaalde transactiekosten, des te meer reden een miner heeft om de transactie in een blok op te nemen. De huidige transactiekosten worden bepaald aan de hand van de drukte op het netwerk en het gekozen beleid.","The maximum number of consecutive unused addresses (20) has been reached. When one of your unused addresses receives a payment, a new address will be generated and shown in your Receive tab.":"Het maximum aantal opeenvolgende ongebruikte adressen (20) is bereikt. Wanneer een van uw ongebruikte adressen een betaling ontvangt zal een nieuw adres worden gegenereerd en worden getoond in het tabblad Ontvangen.","The official English Terms of Service are available on the BitPay website.":"De officiële Engelse Gebruiksvoorwaarden zijn beschikbaar op de BitPay website.","The password of the recovery phrase (if set)":"Het wachtwoord van de herstel zin (indien ingesteld)","The payment was created but could not be completed. Please try again from home screen":"De betaling is aangemaakt maar kon niet worden voltooid. Probeer het nogmaals vanuit het start scherm","The payment was removed by creator":"De betaling is verwijderd door de aanmaker","The recovery phrase could require a password to be imported":"Voor het importeren van de herstel zin zou een wachtwoord nodig kunnen zijn","The request could not be understood by the server":"Het verzoek kon niet worden begrepen door de server","The restore process will stop when 20 addresses are generated in a row which contain no funds. To safely generate more addresses, make a payment to one of the unused addresses which has already been generated.":"Het herstel proces zal stoppen wanneer er 20 adressen achter elkaar zijn gegenereerd die geen saldo bevatten. Om veilig meer adressen te genereren kan een betaling gedaan worden naar een van de reeds gegenereerde adressen.","The spend proposal is not pending":"Het bestedingsvoorstel is niet meer in behandeling","The total amount of bitcoin stored in this wallet.":"De totale hoeveelheid bitcoin opgeslagen in deze portemonnee.","The transaction history and every new incoming transaction are cached in the app. This feature clean this up and synchronizes again from the server":"De transactiegeschiedenis en elke ontvangen transactie worden gecached in de app. Deze optie schoont de cache op en synchroniseert opnieuw met de server","The wallet service URL":"De portemonnee service URL","There is a new version of {{appName}} available":"Er is een nieuwe versie van {{appName}} beschikbaar","There is an error in the form":"Het formulier bevat een fout","There's obviously something we're doing wrong.":"Er is duidelijk iets dat we verkeerd doen.","This app is fantastic!":"Deze app is fantastisch!","This app stores your bitcoin with cutting-edge security.":"Deze app bewaart uw bitcoin met de nieuwste beveiliging.","This bitcoin payment request has expired.":"Dit bitcoin betalingsverzoek is verlopen.","This password cannot be recovered. If the password is lost, there is no way you could recover your funds.":"Dit wachtwoord kan niet worden achterhaald. Als het wachtwoord verloren gaat is er geen mogelijkheid om toegang tot uw saldo te herstellen.","This recovery phrase was created with a password. To recover this wallet both the recovery phrase and password are needed.":"Deze herstel zin is aangemaakt met een wachtwoord. Om deze portemonnee te herstellen heeft u de herstel zin en het wachtwoord nodig.","This transaction amount is too small compared to current Qybcoin network fees. Spending these funds will need a Qybcoin network fee cost comparable to the funds itself.":"Het bedrag van deze transactie is te klein vergeleken met huidige Qybcoin netwerk transactiekosten. Bij dit bedrag betaald u transactiekosten vergelijkbaar met het bedrag zelf.","This transaction could take a long time to confirm or could be dropped due to the low fees set by the sender":"Deze transactie zou lang kunnen wachten op een bevestiging of kan worden geschrapt vanwege de lage transactiekosten die de verzender heeft gekozen","This wallet is not registered at the given Bitcore Wallet Service (BWS). You can recreate it from the local information.":"Deze portemonnee is niet geregistreerd bij de opgegeven Bitcore Wallet Service (BWS). U kunt deze opnieuw aanmaken vanuit de lokale informatie.","Timeline":"Tijdlijn","To":"Naar","To get started, buy bitcoin or share your address. You can receive bitcoin from any wallet or service.":"Om aan de slag te gaan, koop bitcoin of deel uw adres. U kunt bitcoin ontvangen van elke portemonnee of dienst.","To get started, you'll need to create a bitcoin wallet and get some bitcoin.":"Om aan de slag te gaan zult u een bitcoin portemonnee moeten aanmaken en wat bitcoin moeten verkrijgen.","To {{reason}} you must first add your BitPay account - {{email}}":"Om {{reason}} zult u eerst uw BitPay account moeten toevoegen - {{email}}","Top up in progress...":"Bezig met opladen...","Top up {{amountStr}} to debit card ({{cardLastNumber}})":"Vul debet kaart ({{cardLastNumber}}) aan met {{amountStr}}","Total":"Totaal","Total Locked Balance":"Totaal Vergrendeld Saldo","Total number of copayers":"Totaal aantal copayers","Total wallet inputs":"Totaal portemonnee ontvangsten","Touch ID Failed":"Touch ID Mislukt","Transaction":"Transactie","Transaction Created":"Transactie Aangemaakt","Transaction History":"Transactiehistorie","Transaction already broadcasted":"Transactie reeds verzonden","Transaction has not been created":"Transactie is niet aangemaakt","Transaction initiated":"Transactie gestart","Transaction not available at this time":"Transactie momenteel niet beschikbaar","Transaction not found":"Transactie niet gevonden","Transactions without fee are not supported.":"Transacties zonder transactiekosten worden niet ondersteund.","Transfer to":"Overmaken naar","Transfer to Wallet":"Overmaken naar Portemonnee","Try again in {{expires}}":"Probeer het nogmaals over {{expires}}","Turn bitcoin into dollars, swipe anywhere Visa<sup>®</sup> is accepted.":"Zet bitcoin om in dollars, betaal overal waar Visa<sup>&reg;</sup> wordt geaccepteerd.","Type the Recovery Phrase (usually 12 words)":"Vul de Herstel Zin in (meestal 12 woorden)","Uh oh...":"Oh oh...","Unconfirmed":"Onbevestigd","Unsent transactions":"Niet-verzonden transacties","Unused Addresses":"Ongebruikte Adressen","Unused Addresses Limit":"Ongebruikte Adressen Limiet","Update Available":"Update Beschikbaar","Updating pending proposals. Please stand by":"Bestedingsvoorstellen in behandeling bijwerken. Een moment geduld","Updating transaction history. Please stand by.":"Transactie historie bijwerken. Een moment geduld.","Updating... Please stand by":"Bijwerken... Een moment geduld","Urgent":"Spoed","Use Unconfirmed Funds":"Onbevestigd Saldo Gebruiken","Validating recovery phrase...":"Herstel zin valideren...","Verify your identity":"Verifieer uw identiteit","Version":"Versie","View":"Weergeven","View All Addresses":"Toon Alle Adressen","View Terms of Service":"Toon Algemene Voorwaarden","View Transaction on Insight":"Bekijk Transactie op Insight","View Update":"Update Bekijken","View on blockchain":"Bekijk op blockchain","Visit mercadolivre.com.br &rarr;":"Bezoek mercadolivre.com.br &rarr;","WARNING: Key derivation is not working on this device/wallet. Actions cannot be performed on this wallet.":"WAARSCHUWING: Sleutel derivatie werkt op dit moment niet op dit apparaat/deze portemonnee. Er kunnen geen acties worden uitgevoerd met deze portemonnee.","WARNING: Not including the private key allows to check the wallet balance, transaction history, and create spend proposals from the export. However, does not allow to approve (sign) proposals, so <b>funds will not be accessible from the export</b>.":"WAARSCHUWING: De privé sleutel niet toevoegen maakt het wel mogelijk om het saldo en de transactiehistorie in te zien, en bestedingsvoorstellen aan te maken vanuit de export. Dit maakt het echter niet mogelijk om bestedingsvoorstellen goed te keuren (ondertekeken), dus <b>saldo is niet toegankelijk vanuit de export</b>.","WARNING: The private key of this wallet is not available. The export allows to check the wallet balance, transaction history, and create spend proposals from the export. However, does not allow to approve (sign) proposals, so <b>funds will not be accessible from the export</b>.":"WAARSCHUWING: De privé sleutel van deze portemonnee is niet beschikbaar. De export maakt het wel mogelijk om het saldo en de transactiehistorie in te zien, en bestedingsvoorstellen aan te maken. De export maakt het echter niet mogelijk om bestedingsvoorstellen goed te keuren (ondertekeken), dus <b>het saldo is niet toegankelijk vanuit de export</b>.","WARNING: UNTRUSTED CERTIFICATE":"WAARSCHUWING: NIET-VERTROUWD CERTIFICAAT","WARNING: Your extended private keys are all that is needed to access your bitcoin funds. Be sure to protect your private keys and store them only on secure devices. BitPay does not have access to your private keys, so you alone are responsible for your keys. If you share key access with external services, you take responsibility for the risk of theft or breach. Only advanced users should handle extended private keys directly.":"WAARSCHUWING: Uw verlengde privé sleutels zijn het enige dat nodig is om toegang tot uw bitcoin te verkrijgen. Bescherm uw privé sleutels goed en bewaar deze alleen op beveiligde apparaten. BitPay heeft geen toegang tot uw privé sleutels, u bent zelf als enige verantwoordelijk voor het bewaren van uw sleutels. Als u toegang tot de sleutels deelt met externe diensten neemt u zelf de verantwoordelijkheid voor het risico op diefstal of inbraak. Het direct hanteren van verlengde privé sleutels is enkel voor gevorderde gebruikers.","Waiting for Ledger...":"Wachten op Ledger...","Waiting for Trezor...":"Wachten op Trezor...","Waiting for copayers":"Wachten op copayers","Waiting...":"Wachten...","Wallet Addresses":"Adressen Portemonnee","Wallet Color":"Kleur Portemonnee","Wallet Configuration (m-n)":"Configuratie Portemonnee (m-n)","Wallet Created":"Portemonnee Aangemaakt","Wallet Id":"Portemonnee Id","Wallet Information":"Portemonnee Informatie","Wallet Inputs":"Ontvangsten Portemonnee","Wallet Invitation":"Portemonnee Uitnodiging","Wallet Key":"Sleutel Portemonnee","Wallet Name":"Naam Portemonnee","Wallet Name (at creation)":"Naam Portemonnee (ten tijde van aanmaken)","Wallet Network":"Portemonnee Netwerk","Wallet Recovery Phrase":"Portemonnee Herstel Zin","Wallet Recovery Phrase is invalid":"Portemonnee Herstel Zin is ongeldig","Wallet Service URL":"Portemonnee Service URL","Wallet Settings":"Portemonnee Instellingen","Wallet Type":"Portemonnee Type","Wallet already exists":"Portemonnee bestaat al","Wallet already in {{appName}}":"Portemonnee reeds in {{appName}}","Wallet created":"Portemonnee aangemaakt","Wallet incomplete and broken":"Portemonnee onvolledig en onwerkzaam","Wallet is full":"Portemonnee is vol","Wallet is locked":"Portemonnee is vergrendeld","Wallet is not complete":"Portemonnee is niet volledig","Wallet name":"Naam portemonnee","Wallet needs backup":"Portemonnee vereist backup","Wallet not backed up":"Nog geen backup van de portemonnee gemaakt","Wallet not found":"Portemonnee niet gevonden","Wallet not registered":"Portemonnee niet geregistreerd","Wallet not registered at the wallet service. Recreate it from \"Create Wallet\" using \"Advanced Options\" to set your recovery phrase":"Portemonnee niet geregistreerd bij de wallet service. Maak deze opnieuw aan vanuit \"Portemonnee Aanmaken\" en maak gebruik van \"Geavanceerde Opties\" om uw herstel zin in te voeren","Wallet recovery phrase not available":"Portemonnee herstel zin niet beschikbaar","Wallet service not found":"Wallet service niet gevonden","Wallets":"Portemonnees","Warning!":"Waarschuwing!","Warning: this transaction has unconfirmed inputs":"Waarschuwing: deze transactie heeft onbevestigde ontvangsten","Watch out!":"Pas op!","We'd love to do better.":"Wij doen het graag nog beter.","We'll confirm on the next screen.":"We bevestigen dit op het volgende scherm.","We're always looking for ways to improve {{appName}}.":"Wij zoeken altijd naar manieren om {{appName}} te verbeteren.","We're always looking for ways to improve {{appName}}. How could we improve your experience?":"Wij zoeken altijd naar manieren om {{appName}} te verbeteren. Hoe kunnen wij uw ervaring verbeteren?","Website":"Website","We’re always looking for translation contributions! You can make corrections or help to make this app available in your native language by joining our community on Crowdin.":"Wij zijn altijd op zoek naar hulp met vertalingen! U kunt correcties aanbrengen of helpen deze app beschikbaar te maken in uw eigen taal door deel te nemen aan onze gemeenschap op Crowdin.","What do you call this wallet?":"Hoe noemt u deze portemonnee?","When this wallet was created, it was called “{{walletName}}”. You can change the name displayed on this device below.":"Ten tijde van aanmaken kreeg deze portemonnee de naam &ldquo;{{walletName}}&rdquo;. U kunt de naam wijzigen die op dit apparaat weergegeven wordt.","Where would you like to receive email notifications about payments?":"Waar wilt u email meldingen ontvangen over betalingen?","Why?":"Waarom?","Would you be willing to rate {{appName}} in the app store?":"Zou u bereid zijn om {{appName}} te beoordelen in de app store?","Would you like to receive push notifications about payments?":"Wilt u push meldingen ontvangen over betalingen?","Wrong number of recovery words:":"Onjuist aantal herstel woorden:","Wrong spending password":"Onjuist bestedingswachtwoord","Yes":"Ja","Yes, skip":"Ja, overslaan","You can create a backup later from your wallet settings.":"U kunt later een backup maken vanuit uw portemonnee instellingen.","You can make contributions by signing up on our Crowdin community translation website. We’re looking forward to hearing from you!":"U kunt een bijdrage leveren door u aan te melden bij onze Crowdin gemeenschap vertalings website. Wij kijken er naar uit om van u te horen!","You can scan bitcoin addresses, payment requests, paper wallets, and more.":"U kunt bitcoin adressen scannen, betalingsverzoeken, papieren portemonnees, en meer.","You can see the latest developments and contribute to this open source app by visiting our project on GitHub.":"U kunt de laatste ontwikkelingen volgen en bijdragen aan deze open source app door onze project pagina te bezoeken op GitHub.","You can spend bitcoin at millions of websites and stores worldwide.":"U kunt met bitcoin betalen bij miljoenen websites en winkels over de hele wereld.","You can still export it from Advanced &gt; Export.":"U kunt deze nog steeds exporteren vanuit Geavanceerd &gt; Exporteren.","You can trade it for other currencies like US Dollars, Euros, or Pounds.":"U kunt het inwisselen voor valuta's zoals de Amerikaanse Dollar, de Euro, of Ponden.","You control your bitcoin.":"U heeft de controle over uw bitcoin.","You should not set a fee higher than {{maxFeeRecommended}} satoshis/byte.":"Het is af te raden transactiekosten te kiezen hoger dan {{maxFeeRecommended}} satoshi's/byte.","You will need to log back for fill in your BitPay Card.":"U zult opnieuw moeten inloggen om uw BitPay Kaart op te laden.","You'll receive email notifications about payments sent and received from your wallets.":"U zult email meldingen ontvangen over verzonden en ontvangen betalingen van uw portemonnee.","Your BitPay Card is ready. Add funds to your card to start using it at stores and ATMs worldwide.":"Uw BitPay Kaart is gereed. Voeg saldo toe aan uw kaart om deze te kunnen gebruiken in winkels en pinautomaten over de hele wereld.","Your Gift Cards":"Uw Cadeaubonnen","Your bitcoin wallet is backed up!":"Er is een backup gemaakt van uw bitcoin portemonnee!","Your bitcoin wallet is ready!":"Uw bitcoin portemonnee is gereed!","Your fee is lower than recommended.":"Uw gekozen transactiekosten zijn lager dan aangeraden.","Your ideas, feedback, or comments":"Uw ideeën, feedback of opmerkingen","Your name":"Uw naam","Your nickname":"Uw bijnaam","Your password":"Uw wachtwoord","Your purchase could not be completed":"Uw aankoop kon niet worden voltooid","Your purchase was added to the list of pending":"Uw aankoop is op de in-behandeling lijst gezet","Your wallet is never saved to cloud storage or standard device backups.":"Uw portemonnee wordt nooit opgeslagen in de cloud of in standaard apparaat backups.","Your wallet key will be encrypted. The Spending Password cannot be recovered. Be sure to write it down.":"Uw privé sleutel wordt versleuteld. Het Bestedingswachtwoord kan niet worden achterhaald, schrijf deze zorgvuldig op.","[Balance Hidden]":"[Saldo Verborgen]","[Scanning Funds]":"[Saldo Scannen]","add your BitPay Visa card(s)":"voeg uw BitPay Visa kaart(en) toe","locked by pending payments":"vergrendeld door betalingen in behandeling","me":"ik","name@example.com":"naam@voorbeeld.nl","preparing...":"voorbereiden...","recovery tool.":"herstel tool.","{{amountStr}} for Amazon.com Gift Card":"{{amountStr}} voor Amazon.com Cadeaubon","{{amountStr}} for Mercado Livre Brazil Gift Card":"{{amountStr}} voor Mercado Livre Brazil Cadeaubon","{{appName}} depends on Bitcore Wallet Service (BWS) for blockchain information, networking and Copayer synchronization. The default configuration points to https://bws.bitpay.com (BitPay's public BWS instance).":"{{appName}} is afhankelijk van Bitcore Wallet Service (BWS) voor blockchain informatie, netwerk verbinding en Copayer synchronisatie. De standaard instelling wijst naar https://bws.bitpay.com (BitPay's openbare BWS instance).","{{fee}} will be deducted for bitcoin networking fees.":"{{fee}} wordt in mindering gebracht voor bitcoin transactiekosten.","{{tx.txp[wallet.id].feeRatePerStr}}  of the sending amount":"{{tx.txp[wallet.id].feeRatePerStr}} van het te verzenden bedrag","{{updatingTxHistoryProgress}} transactions downloaded":"{{updatingTxHistoryProgress}} transacties gedownload","{{wallet.m}}-of-{{wallet.n}}":"{{wallet.m}}-van-{{wallet.n}}"});
    gettextCatalog.setStrings('pl', {"(Trusted)":"(Zaufany)","(possible double spend)":"(możliwa podwójna wypłata)","* A payment proposal can be deleted if 1) you are the creator, and no other copayer has signed, or 2) 24 hours have passed since the proposal was created.":"* Wniosek wypłaty może być usunięty jeśli: 1) Po utworzeniu nie zatwierdził go żaden inny współwłaściciel portfela lub 2) minęły 24 godziny od kiedy wniosek został utworzony.","- {{btx.feeRateStr}} of the transaction":"{{btx.feeRateStr}} transakcji","- {{tx.feeRateStr}} of the transaction":"{{tx.feeRateStr}} transakcji","5-star ratings help us get {{appName}} into more hands, and more users means more resources can be committed to the app!":"5-gwiazdkowa ocena pozwoli na wzrost popularności {{appName}}, a większa ilość użytkowników da nam do dyspozycji więcej środków na rozwój aplikacji!","<b>Only</b> redeemable on Mercado Livre (Brazil)":"98804213800207","A member of the team will review your feedback as soon as possible.":"Członek zespołu zweryfikuje twoją opinię tak szybko, jak to możliwe.","A total of {{amountAboveMaxSizeStr}} were excluded. The maximum size allowed for a transaction was exceeded.":"Uwaga: łącznie kwota {{amountAboveMaxSizeStr}} została wyłączona. Został przekroczony maksymalny rozmiar dozwolony dla transakcji.","A total of {{amountBelowFeeStr}} were excluded. These funds come from UTXOs smaller than the network fee provided.":"Uwaga: łącznie kwota {{amountBelowFeeStr}} została wyłączona. Środki te pochodzą z UTXOs mniejszych niż gwarantowana prowizja sieci.","About":"O programie","Accepted":"Zatwierdzono","Account":"Konto","Account Number":"Numer konta","Accounts":"Konta","Activity":"Transakcje","Add Account":"Dodaj konto","Add BitPay Account?":"Dodać konto BitPay?","Add Contact":"Dodaj kontakt","Add Funds":"Dodaj środki","Add Memo":"Dodaj notatkę","Add a password":"Dodaj hasło","Add account":"Dodaj konto","Add an optional password to secure the recovery phrase":"Dodaj opcjonalnie hasło w celu zabezpieczenia kluczowej frazy","Add as a contact":"Dodaj jako kontakt","Add description":"Dodaj opis","Add funds":"Dodaj fundusze","Add this BitPay account ({{email}})?":"Dodać to konto BitPay ({{email}})?","Add wallet":"Dodaj portfel","Address":"Adres","Address Book":"Książka adresowa","Address Type":"Rodzaj adresu","Addresses With Balance":"Adresy z funduszami","Advanced":"Zaawansowane","Advanced Settings":"Ustawienia zaawansowane","All":"Wszystko","All Addresses":"Wszystkie adresy","All of your bitcoin wallet balance may not be available for immediate spending.":"Wszystkie salda portfela bitcoin mogą nie być dostępne do natychmiastowego wydania.","All signing devices must be added to this multisig wallet before bitcoin addresses can be created.":"Wszystkie podpisane urządzenia muszą zostać dodane do tego portfela przed utworzeniem adresów bitcoin.","Allow Camera Access":"Zezwalaj na dostęp do kamery","Allow notifications":"Pozwól na otrzymywanie powiadomień","Almost done! Let's review.":"Prawie gotowe! Dokonajmy przeglądu.","Alternative Currency":"Alternatywna waluta","Amazon.com is not available at this moment. Please try back later.":"Amazon.com jest aktualnie niedostępny. Spróbuj później.","Amount":"Kwota","Amount below minimum allowed":"Kwota poniżej minimum dozwolona","Amount too big":"Zbyt duża kwota","Amount too low to spend":"Zbyt niska kwota do wysłania","An update to this app is available. For your security, please update to the latest version.":"Dostępna jest aktualizacja aplikacji. Ze względów bezpieczeństwa należy zaktualizować do najnowszej wersji.","Anyone with your backup phrase can access or spend your bitcoin.":"Każdy, kto ma Twoją kluczową frazę może uzyskać dostęp lub wydać Twoje bitcoiny.","Approximate Qybcoin network fee to transfer wallet's balance (with normal priority)":"Szacunkowe opłaty sieci Qybcoin do przeniesienia salda portfela (normalny priorytet)","Are you being watched?":"Czy jesteś obserwowany?","Are you being watched? Anyone with your recovery phrase can access or spend your bitcoin.":"Czy jesteś obserwowany? Każdy, kto zdobędzie twoją kluczową frazę może uzyskać dostęp do portfela i wydać twoje bitcoiny.","Are you sure you want to cancel and delete this wallet?":"Czy na pewno chcesz usunąć ten portfel?","Are you sure you want to delete this contact?":"Czy na pewno chcesz usunąć ten kontakt?","Are you sure you want to delete this wallet?":"Czy na pewno chcesz usunąć ten portfel?","Are you sure you want to reject this transaction?":"Czy na pewno chcesz odrzucić tę transakcję?","Are you sure you want to remove this transaction?":"Czy na pewno chcesz usunąć tę transakcję?","Are you sure you want to skip it?":"Czy na pewno chcesz pominąć?","Are you sure you would like to log out of your BitPay Card account?":"Czy na pewno chcesz się wylogować z konta BitPay Card?","Are you sure you would like to remove your BitPay Card ({{lastFourDigits}}) from this device?":"Czy na pewno chcesz usunąć kartę BitPay ({{lastFourDigits}}) z tego urządzenia?","Auditable":"Weryfikowalny","Available":"Dostępne","Available Balance":"Dostępne saldo","Average confirmation time":"Spodziewany czas potwierdzania","BIP32 path for address derivation":"BIP32 ścieżka dla adresu derywacji","QYB wallets":"Portfele QYB","Backup":"Kopia zapasowa","Backup Needed":"Potrzebna kopia zapasowa","Backup all livenet wallets before using this function":"Zrób kopię zapasową wszystkich swoich portfeli przed użyciem tej funkcji","Backup needed":"Potrzebna kopia zapasowa","Backup now":"Utwórz kopię zapasową teraz","Backup wallet":"Kopia zapasowa portfela","Backup your wallet before using this function":"Zrób kopię zapasową portfela przed użyciem tej funkcji","Bad wallet invitation":"Nieprawidłowe zaproszenie","Balance By Address":"Saldo wg adresu","Be sure to store your recovery phrase in a secure place. If this app is deleted, your money cannot be recovered without it.":"Pamiętaj aby przechowywać swoją kluczową frazę w bezpiecznym miejscu. Jeśli ta aplikacja zostanie usunięta, nie będziesz mógł bez niej odzyskać swoich pieniędzy.","BitPay Visa® Cards":"Karty BitPay Visa&reg;","Qybcoin Address":"Adres bitcoin","Qybcoin Cash Wallets":"Płatność Qybcoin Cash","Qybcoin Network Fee Policy":"Polityka prowizji sieci bitcoin","Qybcoin Wallets":"Portfele Qybcoin","Qybcoin cash Payment":"Płatność Qybcoin Cash","Qybcoin is a currency.":"Qybcoin jest walutą.","Qybcoin is different – it cannot be safely held with a bank or web service.":"Qybcoin jest inny &ndash; nie może być bezpiecznie przechowywany w banku lub usłudze internetowej.","Qybcoin is secure,<br>digital money.":"Qybcoin jest bezpieczny, <br>cyfrowe pieniądze.","Qybcoin transactions include a fee collected by miners on the network.":"Transakcje Qybcoin obejmują prowizję pobieraną przez górników w sieci.","Bought {{amountUnitStr}}":"Kupiono {{amountUnitStr}}","Broadcast Payment":"Przekaż płatność","Broadcasted":"Nadawane","Broadcasting transaction":"Przekazywanie transakcji","Browser unsupported":"Przeglądarka nieobsługiwana","Buy":"Kup","Buy &amp; Sell Qybcoin":"Kup &amp; sprzedaj bitcoiny","Buy Qybcoin":"Kup bitcoiny","Buy a Gift Card":"Kup kartę podarunkową","Buy from":"Kup od","Buying Qybcoin...":"Zakup bitcoinów...","Calculating fee":"Obliczanie prowizji","Cancel":"Anuluj","Cancel invitation":"Anuluj zaproszenie","Cannot Create Wallet":"Nie można utworzyć portfela","Cannot join the same wallet more that once":"Nie można dołączyć tego samego portfela więcej niż raz","Cards":"Karty","Certified by":"Certyfikowane przez","Check installation and retry.":"Sprawdź instalację i ponów próbę.","Choose a backup file from your computer":"Wybierz plik kopii zapasowej z komputera","Choose your destination wallet":"Wybierz swój portfel docelowy","Choose your source wallet":"Wybierz swój portfel źródłowy","Clear":"Wyczyść","Clear cache":"Wyczyść pamięć podręczną","Click to accept":"Kliknij, aby zaakceptować","Click to pay":"Kliknij, aby zapłacić","Click to send":"Kliknij, aby wysłać","Close":"Zamknij","Coin":"Moneta","Color":"Kolor","Commit hash":"Zatwierdzony hash","Complete the backup process to use this option":"Zakończ proces tworzenia kopii zapasowej, aby użyć tej opcji","Completed":"Zakończono","Confirm":"Potwierdź","Confirm &amp; Finish":"Potwierdź &amp; zakończenie","Confirm purchase":"Potwierdź zakup","Confirm your PIN":"Potwierdź kod PIN","Confirm your new spending password":"Potwierdź nowe hasło wypłat","Confirmations":"Potwierdzenia","Confirming":"Potwierdzający","Connect my BitPay Card":"Podłącz kartę BitPay","Connecting to Coinbase...":"Łączenie z Coinbase...","Connecting to Glidera...":"Łączenie z Gildera...","Connection reset by peer":"Połączenie zostało zresetowane","Contacts":"Kontakty","Continue":"Dalej","Contribute Translations":"Wkład do tłumaczenia","Qyb only supports Qybcoin Cash using new version numbers addresses":"Qyb obsługuje tylko Qybcoin gotówki za pomocą nowej wersji numery adresy","Copayer already in this wallet":"Użytkownik jest już w tym portfelu","Copayer already voted on this spend proposal":"Użytkownik głosował już za tym wnioskiem wypłaty","Copayer data mismatch":"Niezgodność danych współwłaściciela portfela","Copayer joined":"Współwłaściciel dołączył","Copayer {{$index}}":"Współwłaściciele {{$index}}","Copied to clipboard":"Skopiowano do schowka","Copy this text as it is to a safe place (notepad or email)":"Skopiuj ten tekst w bezpiecznym miejscu (notatnik lub e-mail)","Copy to clipboard":"Skopiuj do schowka","Could not access Gift Card Service":"Nie można uzyskać dostępu do usługi kart podarunkowych","Could not access the wallet at the server. Please check:":"Nie można uzyskać dostępu do portfela na serwerze. Proszę sprawdzić:","Could not access to Amazon.com":"Nie może uzyskać dostępu do Amazon.com","Could not access wallet":"Nie można uzyskać dostępu do portfela","Could not add message to imported wallet without shared encrypting key":"Nie można dodać wiadomość do importowanego portfela bez udostępnionego klucza szyfrowania","Could not broadcast payment":"Wypłata nie może zostać wysłana","Could not build transaction":"Nie udało się utworzyć transakcji","Could not create address":"Nie można utworzyć adresu","Could not create the invoice":"Nie można utworzyć faktury","Could not create transaction":"Nie można utworzyć transakcji","Could not create using the specified extended private key":"Nie można utworzyć przy użyciu określonego rozszerzonego klucza prywatnego","Could not create using the specified extended public key":"Nie można utworzyć przy użyciu określonego rozszerzonego klucza publicznego","Could not create: Invalid wallet recovery phrase":"Nie można utworzyć: niepoprawna kluczowa fraza","Could not decrypt file, check your password":"Nie można odszyfrować pliku, sprawdź hasło","Could not delete payment proposal":"Nie można usunąć wniosku wypłaty","Could not duplicate":"Nie można powielić","Could not get dynamic fee":"Nie można pobrać dynamicznej prowizji","Could not get dynamic fee for level: {{feeLevel}}":"Nie można uzyskać dynamicznej prowizji dla poziomu: {{feeLevel}}","Could not get fee levels":"Nie można uzyskać poziomów prowizji","Could not get the invoice":"Nie można pobrać faktury","Could not get transactions":"Nie można pobrać transakcji","Could not import":"Nie można zaimportować","Could not import. Check input file and spending password":"Nie można zaimportować. Sprawdź plik wejściowy i hasło","Could not join wallet":"Nie można dołączyć portfela","Could not reject payment":"Wypłata nie może być odrzucona","Could not remove account":"Nie można usunąć konta","Could not remove card":"Nie można usunąć karty","Could not save preferences on the server":"Nie można zapisać ustawień na serwerze","Could not send payment":"Wypłata nie może zostać wysłana","Could not send transaction":"Nie można wysłać transakcji","Could not update transaction history":"Nie można zaktualizować historii transakcji","Could not update wallet":"Nie można zaktualizować portfela","Create Personal Wallet":"Utwórz osobisty portfel","Create Shared Wallet":"Utwórz współdzielony portfel","Create bitcoin wallet":"Utwórz portfel bitcoin","Create new wallet":"Utwórz nowy portfel","Create shared wallet":"Utwórz współdzielony portfel","Create {{formData.requiredCopayers}}-of-{{formData.totalCopayers}} wallet":"Utwórz portfel {{formData.requiredCopayers}} z {{formData.totalCopayers}}","Created by":"Utworzony przez","Creating Wallet...":"Tworzenie portfela...","Creating transaction":"Tworzenie transakcji","Current fee rate for this policy":"Aktualna stawka prowizji dla tej polityki","Custom":"Niestandardowy","Custom Amount":"Kwota własna","Custom Fee":"Niestandardowa Prowizja","Date":"Data","Delete":"Usuń","Delete Payment Proposal":"Usuń wniosek wypłaty","Delete Wallet":"Usuń portfel","Delete it and create a new one":"Usuń i utwórz nowy portfel","Deleting Wallet...":"Usuwanie portfela...","Deleting payment proposal":"Usuń propozycję płatności","Derivation Path":"Ścieżka derywacji","Derivation Strategy":"Strategia derywacji","Details":"Szczegóły","Disabled":"Wyłącz","Do it later":"Zrób to później","Do not include private key":"Nie uwzględniaj klucza prywatnego","Don't see your language on Crowdin? Contact the Owner on Crowdin! We'd love to support your language.":"Nie widzisz swojego języka na Crowdin? Skontaktuj się z właścicielem projektu, ponieważ bardzo chcielibyśmy, wspierać twój język.","Download":"Pobierz","Duplicate for dmb":"Duplikat dla dmb","Duplicating wallet...":"Duplikowanie portfela...","Each bitcoin wallet can generate billions of addresses from your 12-word backup. A new address is automatically generated and shown each time you receive a payment.":"Każdy portfel bitcoin może wygenerować miliardy adresów z twojej 12-wyrazowej kopii zapasowej. Nowy adres jest automatycznie generowany i pokazany za każdym razem, kiedy otrzymasz płatność.","Economy":"Ekonomiczna","Edit":"Edytuj","Email":"E-mail","Email Address":"Adres e-mail","Empty addresses limit reached. New addresses cannot be generated.":"Puste adresy osiągnęły limit. Nowe adresy nie mogą być generowane.","Enable camera access in your device settings to get started.":"Udostępnij kamerę w ustawieniach urządzenia, aby rozpocząć pracę.","Enable email notifications":"Włącz powiadomienia e-mail","Enable push notifications":"Włącz powiadomienia","Enable the camera to get started.":"Włącz kamerę aby rozpocząć.","Enter Spending Password":"Wprowadź hasło wypłaty","Enter Two Factor for your BitPay account":"Wprowadź podwójne uwierzytelnienie swojego konta BitPay","Enter amount":"Wprowadź kwotę","Enter custom fee":"Wprowadź niestandardową kwotę prowizji","Enter new spending password":"Wprowadź nowe hasło wypłaty","Enter the recovery phrase (BIP39)":"Wprowadź kluczową frazę (BIP39)","Enter your email":"Wpisz swój adres e-mail","Enter your password":"Wprowadź hasło","Error":"Błąd","Error at confirm":"Błąd w potwierdzeniu","Error creating gift card":"Błąd przy tworzeniu karty upominkowej","Error creating the invoice":"Wystąpił błąd podczas tworzenia faktury","Error creating wallet":"Błąd podczas tworzenia portfela","Error getting SendMax information":"Wystąpił błąd podczas uzyskiwania informacji SendMax","Error in Payment Protocol":"Błąd w protokole płatności","Error pairing BitPay Account":"Błąd parowania konta Bitpay","Error scanning funds:":"Błąd skanowania środków:","Error sweeping wallet:":"Błąd opróżniania portfela:","Error updating Debit Cards":"Błąd aktualizacji kart debetowych","Exceeded daily limit of $500 per user":"Dzienny limit 500$ na użytkownika został przekroczony","Expired":"Wygasł","Expires":"Wygasa","Export Wallet":"Eksport portfela","Export to file":"Eksportuj do pliku","Export wallet":"Eksportuj portfel","Exporting via QR not supported for this wallet":"Dla tego portfela nie jest obsługiwany eksport za pomocą kodu QR","Extended Public Keys":"Rozszerzone klucze publiczne","Extracting Wallet information...":"Wyodrębnianie danych z portfela...","Failed to export":"Nie udało się wyeksportować","Family vacation funds":"Środki na rodzinne wakacje","Fee":"Prowizja","Fee level":"Poziom opłaty","Fee level is not defined":"Poziom opłaty nie jest zdefiniowany","Fee:":"Prowizja:","Feedback could not be submitted. Please try again later.":"Twój komentarz nie może zostać wysłany. Spróbuj ponownie później.","Fetching BitPay Account...":"Odzyskiwanie konta BitPay...","Fetching payment information":"Pobieranie informacji o płatności","File/Text":"Plik/Tekst","Filter setting":"Ustawienie filtra","Finger Scan Failed":"Skanowanie odcisku nie powiodło się","Finish":"Zakończ","For audit purposes":"Do celów audytu","From":"Z","From BitPay account":"Z konta BitPay","From Hardware Wallet":"Z portfela sprzętowego","From the destination device, go to Add wallet &gt; Import wallet and scan this QR code":"Z urządzenia docelowego, przejdź do Dodaj portfel &gt; Import portfela i Zeskanuj ten kod QR","Funds are locked by pending spend proposals":"Środki są zablokowane przez rozpatrywane wniosku wypłaty","Funds found:":"Znaleziono środki:","Funds to be added":"Środki, które zostaną dodane","Funds transferred":"Środki przelewane","Funds were added to debit card":"Fundusze zostały dodane do karty debetowej","Funds will be transferred to":"Środki będą przekazane do","Generate new address":"Generuj nowy adres","Generating .csv file...":"Generowanie pliku csv...","Generating new address...":"Generowanie nowego adresu...","Get local cash anywhere you go, from any Visa<sup>®</sup> compatible ATM. ATM bank fees may apply.":"Wypłać pieniądze gdziekolwiek jesteś, z dowolnego bankomatu honorującego karty Visa<sup>&reg;</sup>. Od tej transakcji bank może pobrać prowizję.","Get news and updates from BitPay":"Otrzymywanie wiadomości i aktualizacji z BitPay","Get started":{"$$noContext":"Zacznij","button":"Pierwsze kroki"},"Get started by adding your first one.":"Zacznij dodając swój pierwszy kontakt.","Getting fee levels...":"Uzyskiwanie informacji o prowizji...","Gift Card":"Karta podarunkowa","Gift Card is not available to use anymore":"Karta podarunkowa nie jest już dostępna","Gift card expired":"Karta upominkowa wygasła","Gift card generated and ready to use.":"Karta podarunkowa wygenerowana i gotowa do użycia.","Go Back":"Powrót","Go back":"Powrót","Got it":"Rozumiem","Hardware Wallet":"Portfel sprzętowy","Hardware not connected.":"Sprzęt nie podłączony.","Hardware wallet":"Portfel sprzętowy","Hardware wallets are not yet supported with Qybcoin Cash":"Portfele sprzętowe nie są jeszcze obsługiwane z Qybcoin gotówki","Help & Support":"Centrum pomocy","Help and support information is available at the website.":"Informacja o pomocy i wsparciu technicznym jest dostępna na stronie internetowej.","Hide":"Ukryj","Hide Balance":"Ukryj środki","Hide Next Steps Card":"Ukryj następne kroki karty","Hide advanced options":"Ukryj opcje zaawansowane","Home":"Strona główna","How could we improve your experience?":"Co moglibyśmy jeszcze według Ciebie poprawić?","How do you like {{appName}}?":"Jak Ci się podoba {{appName}}?","I don't like it":"Nie podoba mi się","I have read, understood, and agree to the <a ng-click=\"openTerms()\" translate=\"\">Terms of Use</a>.":"Przeczytałem, zrozumiałem i wyrażam zgodę na <a ng-click=\"openTerms()\" translate=\"\"> warunki użytkowania</a>.","I have read, understood, and agree with the Terms of use.":"Przeczytałem, zrozumiałem i zgadzam się z Warunkami użytkowania.","I have written it down":"Zapisałem to","I like the app":"Lubię aplikację","I think this app is terrible.":"Myślę, że ta aplikacja jest straszna.","I understand":"Rozumiem","I understand that if this app is moved to another device or deleted, my bitcoin can only be recovered with the backup phrase.":"Rozumiem, że jeśli aplikacja zostanie przeniesiona na inne urządzenie, lub usunięta moje bitcoiny mogą zostać odzyskane tylko przy użyciu kluczowej frazy.","I understand that my funds are held securely on this device, not by a company.":"Rozumiem, że moje środki są bezpieczne na tym urządzeniu i nie znajdują się w posiadaniu spółki.","I've written it down":"Zapisałem to","If enabled, all sensitive information (private key and recovery phrase) and actions (spending and exporting) associated with this wallet will be protected.":"Jeśli opcja jest włączona, wszystkie poufne informacje (klucz prywatny i kluczowa fraza) oraz operacje (wydatki i eksport) związane z tym portfelem będą chronione.","If enabled, the Recent Transactions card - a list of transactions occuring across all wallets - will appear in the Home tab.":"Jeśli ta opcja jest włączona, na ekranie głównym pojawi się lista wszystkich transakcji z portfela.","If enabled, wallets will also try to spend unconfirmed funds. This option may cause transaction delays.":"Jeśli opcja jest włączona, portfele będą również starać się wydawać niepotwierdzone środki. Może to prowadzić do opóźnień transakcji.","If this device is replaced or this app is deleted, neither you nor BitPay can recover your funds without a backup.":"Jeśli to urządzenie zostanie wymienione lub jeśli aplikacja zostanie usunięta, ani ty, ani BitPay nie będzie mógł odzyskać środków bez kopii zapasowej.","If you have additional feedback, please let us know by tapping the \"Send feedback\" option in the Settings tab.":"Jeśli masz dodatkowe uwagi, prosimy o poinformowanie nas poprzez naciśnięcie przycisku \"Wyślij zgłoszenie\" w zakładce Ustawienia.","If you take a screenshot, your backup may be viewed by other apps. You can make a safe backup with physical paper and a pen.":"Jeśli zrobisz zrzut ekranu, twoja kopia zapasowa może być widziana przez inne aplikacje. Najbezpieczniejsza metoda utworzenia kopii zapasowej to długopis i papier.","Import":"Importuj","Import Wallet":"Importuj portfel","Import backup":"Importuj kopię zapasową","Import wallet":"Importuj portfel","Importing Wallet...":"Importowanie portfela...","In order to verify your wallet backup, please type your password.":"W celu weryfikacji kopii zapasowej portfela wpisz swoje hasło.","Inactive":"Nieaktywne","Incomplete":"Nie wszyscy współwłaściciele dołączyli","Incomplete wallet":"Nie wszyscy współwłaściciele dołączyli","Incorrect PIN, try again.":"Nieprawidłowy kod PIN. Spróbuj ponownie.","Incorrect code format":"Niepoprawny format kodu","Incorrect network address":"Nieprawidłowy adres","Insufficient funds":"Nie ma wystarczającej ilości środków","Insufficient funds for fee":"Niewystarczające środki na prowizję","Integrations":"Integracje","Invalid":"Nieprawidłowy","Invalid URL":"Nieprawidłowy adres URL","Invalid account number":"Nieprawidłowy numer konta","Invalid address":"Nieprawidłowy adres","Invalid data":"Nieprawidłowe dane","Invalid derivation path":"Nieprawidłowa ścieżka derywacji","Invitation to share a {{appName}} Wallet":"Zaproszenie do współdzielenia portfela {{appName}}","Invoice expired":"Faktura wygasła","Is there anything we could do better?":"Czy jest coś, co możemy poprawić?","Is this correct?":"Czy dane są poprawne?","Is this email address correct?":"Czy ten adres e-mail jest poprawny?","It's a good idea to avoid reusing addresses - this both protects your privacy and keeps your bitcoins secure against hypothetical attacks by quantum computers.":"To dobry pomysł, aby uniknąć ponownego wykorzystywania adresów - to chroni Twoją prywatność i zabezpiecza Twoje bitcoiny przed hipotetycznymi atakami przez komputery kwantowe.","It's important that you write your backup phrase down correctly. If something happens to your wallet, you'll need this backup to recover your money. Please review your backup and try again.":"Ważne, aby prawidłowo zapisać kluczową frazę. Jeśli coś stanie się z Twoim portfelem, będzie ona potrzebna, abyś mógł odzyskać pieniądze. Sprawdź dokładnie zapis i spróbuj ponownie.","Join":"Dołącz","Join my {{appName}} Wallet. Here is the invitation code: {{secret}} You can download {{appName}} for your phone or desktop at {{appUrl}}":"Dołącz do mojego portfela {{appName}}. Kod zaproszenia: {{secret}}. Wersję desktopową lub aplikację na telefon można pobrać z {{appUrl}}","Join shared wallet":"Dołącz do portfela","Joining Wallet...":"Dołączanie do portfela...","Just scan the code to pay.":"Zeskanuj kod, aby zapłacić.","Key already associated with an existing wallet":"Klucz jest już powiązany z istniejącym portfelem","Language":"Język","Last Month":"Zeszły miesiąc","Learn more":"Dowiedz się więcej","Let's verify your backup phrase.":"Sprawdź swoją kluczową frazę.","Loading addresses...":"Ładowanie adresów...","Loading transaction info...":"Ładowanie informacji o transakcji...","Lock App":"Blokada aplikacji","Lock by Fingerprint":"Blokada przez odcisk palca","Lock by PIN":"Blokada przez PIN","Locked":"Zablokowane","Locktime in effect. Please wait to create a new spend proposal":"Skuteczna blokada. Proszę czekać, aby utworzyć nowy wniosek wypłaty","Locktime in effect. Please wait to remove this spend proposal":"Skuteczna blokada. Proszę czekać, aby usunąć wniosek wypłaty","Log options":"Opcje dziennika","Log out":"Wyloguj się","Low amount inputs":"Niska kwota","Low fees":"Niskie opłaty","Makes sense":"Brzmi sensownie","Matches:":"Dopasowania:","Me":"Ja","Meh - it's alright":"Spoko - może być","Memo":"Notatka","Mercado Livre Brazil Gift Cards":"Karty podarunkowe Mercado Livre Brazil","Mercadolibre Gift Card Service is not available at this moment. Please try back later.":"Karta podarunkowa MercadoLibre nie jest obecnie dostępna. Spróbuj później.","Merchant Message":"Wiadomość handlowa","Miner Fee":"Opłata dla górnika","Missing parameter":"Brak parametru","Missing private keys to sign":"Brak kluczy prywatnych do podpisania","More Options":"Więcej opcji","Moved":"Przeniesiony","Moved Funds":"Przesuń środki","Multiple recipients":"Wielu odbiorców","NOTE: To import a wallet from a 3rd party software, please go to Add Wallet &gt; Create Wallet, and specify the Recovery Phrase there.":"Uwaga: Aby zaimportować portfel z oprogramowania innego niż Qyb, przejdź do \"Dodaj portfel\" &gt; \"Utwórz portfel\", i podaj tam kluczową frazę.","Name":"Nazwa","Network Cost":"Koszty sieci","Network error":"Błąd sieci","New Proposal":"Nowa propozycja","New address could not be generated. Please try again.":"Nowy adres nie mógł zostać utworzony. Spróbuj jeszcze raz.","New personal wallet":"Nowy portfel osobisty","Next steps":"Kolejne kroki","No Wallet":"Brak portfela","No access key defined":"Klucz dostępu nie jest zdefiniowany","No backup, no bitcoin.":"Nie ma kopii zapasowej - nie ma bitcoinów.","No contacts yet":"Brak kontaktów","No entries for this log level":"Brak wpisów dla tego poziomu dziennika","No hardware information available.":"Brak dostępnych informacji o sprzęcie.","No hardware wallets supported on this device":"Portfele sprzętowe nie są obsługiwane przez to urządzenie","No pending proposals":"Brak propozycji płatności","No recent transactions":"Brak wcześniejszych transakcji","No signing proposal: No private key":"Nie podpisywania wniosku: nie ma klucza prywatnego","No transactions yet":"Brak transakcji","No wallet found":"Nie znaleziono portfela","No wallet selected":"Nie wybrano portfela","No wallets available":"Brak dostępnych portfeli","No wallets available to receive funds":"Brak portfeli do otrzymania środków","No wallets eligible for Qybcoin Cash support":"Brak portfeli wspierających Qybcoin Cash","Non BIP44 wallet":"Nie BIP44 portfel","Normal":"Zwykła","Not authorized":"Brak autoryzacji","Not enough funds for fee":"Brak środków na opłacenie prowizji","Not even BitPay can access it.":"Nawet BitPay nie ma do niego dostępu.","Not funds found":"Nie znaleziono środków","Not now":"Nie teraz","Note":"Notatka","Note: if this dmb wallet was duplicated from a QYB wallet, they share the same recovery phrase.":"Uwaga: Jeśli ten portfel dmb został zduplikowany z portfela QYB, będą one współdzielić ten sam zwrot odzyskiwania.","Notice: only 1-1 (single signature) wallets can be used for sell bitcoin":"Uwaga: tylko 1-1 portfela (pojedynczy podpis) może być wykorzystywany do sprzedaży bitcoinów","Notifications":"Powiadomienia","Notifications by email":"Powiadomienia e-mail","Notify me if confirmed":"Powiadom mnie, jeśli potwierdzono","Notify me when transactions are confirmed":"Powiadom mnie, gdy transakcja zostanie potwierdzona","Now is a good time to backup your wallet. If this device is lost, it is impossible to access your funds without a backup.":"Najwyższy czas na wykonanie kopii zapasowej portfela. Jeśli utracisz to urządzenie, dostęp do środków bez kopii zapasowej będzie niemożliwy.","Now is a perfect time to assess your surroundings. Nearby windows? Hidden cameras? Shoulder-spies?":"Nadszedł czas, aby sprawdzić swoje otoczenie. Czy jesteś w pobliżu okna? Czy są gdzieś ukryte kamery? Osoby zerkające przez ramię?","OK":"OK","OKAY":"W PORZĄDKU","Official English Disclaimer":"Oficjalna rezygnacja w języku angielskim","Oh no!":"O nie!","Ok":"Ok","On this screen you can see all your wallets, accounts, and assets.":"Na tym ekranie można zobaczyć wszystkie swoje portfele, konta i środki.","Open":"Otwórz","Open Crowdin":"Otwórz Crowdin","Open GitHub":"Otwórz GitHub","Open GitHub Project":"Otwórz projekt GitHub","Open Insight":"Otwórz Insight","Open Settings":"Otwórz ustawienia","Open Translation Community":"Społeczność tłumaczy","Open Website":"Otwórz stronę internetową","Open the recovery tool.":"Otwórz narzędzie do odzyskiwania.","Open wallet":"Otwórz portfel","Open website":"Otwórz stronę","Order the BitPay Card":"Zamów kartę BitPay","Password":"Hasło","Password required. Make sure to enter your password in advanced options":"Wymagane hasło. Upewnij się, aby wprowadzić hasło w opcjach zaawansowanych","Paste invitation here":"Wklej tutaj zaproszenie","Paste the backup plain text code":"Wklej tekst kodu kopii zapasowej","Pay 0% fees to turn bitcoin into dollars.":"Zapłać 0% prowizji za wymianę bitcoinów na dolary.","Pay To":"Zapłać","Payment Accepted":"Wypłata zaakceptowana","Payment Expires:":"Płatność wygasa:","Payment Proposal":"Wniosek wypłaty","Payment Proposal Created":"Wniosek wypłaty utworzony","Payment Proposals":"Wniosek wypłaty","Payment Protocol Invalid":"Protokół wypłaty nieprawidłowy","Payment Protocol not supported on Chrome App":"Protokół wypłaty nieobsługiwany przez Chrome","Payment Received":"Płatność otrzymana","Payment Rejected":"Wypłata odrzucona","Payment Sent":"Płatność wysłana","Payment accepted, but not yet broadcasted":"Wypłata zaakceptowana, ale jeszcze nie nadana","Payment accepted. It will be broadcasted by Glidera. In case there is a problem, it can be deleted 6 hours after it was created.":"Wypłata zaakceptowana. Będzie nadana przez Glidera. W przypadku wystąpienia problemu, może być usunięta 6 godzin po utworzeniu.","Payment address was translated to new Qybcoin Cash address format:":"Adres płatności został przetłumaczony na nowy format adresów Qybcoin Cash:","Payment details":"Szczegóły wypłaty","Payment request":"Wniosek o płatność","Pending":"Oczekiwanie","Pending Proposals":"Rozpatrywane płatności","Permanently delete this wallet.":"Trwale usuń portfel.","Personal Wallet":"Portfel osobisty","Please carefully write down this phrase.":"Proszę dokładnie zanotować tę kluczową frazę.","Please connect a camera to get started.":"Proszę podłączyć kamerę, aby zacząć.","Please enter the recovery phrase":"Wpisz kluczową frazę","Please enter the wallet recovery phrase":"Wpisz kluczową frazę portfela","Please enter your PIN":"Wprowadź kod PIN","Please tap each word in the correct order.":"Proszę wpisać każde słowo we właściwej kolejności.","Please upgrade Qyb to perform this action":"Proszę uaktualnić Qyb, by móc wykonać tę operację","Please wait":"Czekaj","Please, select your backup file":"Proszę wybrać plik kopii zapasowej","Preferences":"Ustawienia","Preparing addresses...":"Przygotowywanie adresów...","Preparing backup...":"Przygotowywanie kopii zapasowej...","Press again to exit":"Naciśnij ponownie, aby wyjść","Priority":"Priorytetowa","Private Key":"Klucz prywatny","Private key encrypted. Enter password":"Klucz prywatny jest zaszyfrowany. Wprowadź hasło","Private key is encrypted, cannot sign":"Klucz prywatny jest zaszyfrowany, nie można podpisać","Proposal Accepted":"Płatność przyjęta","Proposal Created":"Płatność utworzona","Proposal Deleted":"Płatność usunięta","Proposal Rejected":"Płatność odrzucona","Proposals":"Proponowane płatności","Purchase Amount is limited to {{limitPerDay}} {{currency}} per day":"Kwota zakupu jest ograniczona do {{limitPerDay}} {{currency}} dziennie","Purchase amount must be a value between 50 and 2000":"Kwota zakupu musi być wartością z przedziału od 50 do 2000","Push Notifications":"Wyskakujące powiadomienia","Push notifications for {{appName}} are currently disabled. Enable them in the Settings app.":"Wyskakujące powiadomienia {{appName}} są obecnie wyłączone. Włącz je w ustawieniach aplikacji.","QR Code":"Kod QR","Quick review!":"Szybki przegląd!","Random":"Losowo","Rate on the app store":"Oceń w App Store","Read less":"Zobacz mniej","Read more":"Zobacz więcej","Read more in our Wiki":"Więcej informacji w naszej Wiki","Read only wallet":"Portfel tylko do odczytu","Receive":"Otrzymaj","Received":"Otrzymane","Received Funds":"Otrzymane środki","Receiving":"Otrzymywanie","Recent":"Ostatnie","Recent Transaction Card":"Ostatnia transakcja kartą","Recent Transactions":"Ostatnie transakcje","Recipient":"Odbiorca","Recipients":"Odbiorcy","Recovery phrase":"Kluczowa fraza","Recreating Wallet...":"Przywracanie portfela...","Redeem now":"Zrealizuj teraz","Rejected":"Odrzucono","Rejecting payment proposal":"Odrzucenie płatności","Release information":"Informacje o wersji","Remove":"Usuń","Remove BitPay Account?":"Usunąć konto BitPay?","Remove BitPay Card?":"Usunąć kartę BitPay?","Removing your BitPay account will remove all associated BitPay account data from this device. Are you sure you would like to remove your BitPay Account ({{email}}) from this device?":"Usunięcie konta BitPay spowoduje usunięcie z tego urządzenia wszystkich skojarzonych z tym kontem danych. Czy na pewno chcesz usunąć konto BitPay ({{email}}) z tego urządzenia?","Repeat password":"Powtórz hasło","Repeat the password":"Powtórz hasło","Request Fingerprint":"Zapytaj o odcisk palca","Request Specific amount":"Prośba o konkretną kwotę","Request Spending Password":"Wprowadź hasło wypłaty","Required number of signatures":"Wymagana liczba podpisów","Restore from backup":"Przywróć z kopii zapasowej","Retrieving inputs information":"Pobieranie informacji o danych wejściowych","Retry":"Spróbuj ponownie","Retry Camera":"Spróbuj ponownie z aparatem","Save":"Zapisz","Scan":"Zeskanuj","Scan QR Codes":"Zeskanuj kod QR","Scan addresses for funds":"Skanuj adresy w celu znalezienia środków","Scan again":"Skanuj ponownie","Scan your fingerprint please":"Proszę zeskanować linie papilarne","Scanning Wallet funds...":"Skanowanie środków portfela...","Scanning funds...":"Skanowanie środków portfela...","Screenshots are not secure":"Zrzuty ekranu nie są bezpieczne","Search Transactions":"Szukaj transakcji","Search or enter bitcoin address":"Wyszukaj lub wpisz adres bitcoin","Search transactions":"Szukaj transakcji","Search your currency":"Znajdź swoją walutę","Security":"Bezpieczeństwo","See invoice":"Zobacz fakturę","Select a backup file":"Wybierz plik kopii zapasowej","Select a wallet":"Wybierz portfel","Self-signed Certificate":"Certyfikat z podpisem własnym","Selling Qybcoin...":"Sprzedawanie bitcoinów...","Send":"Wyślij","Send Feedback":"Wyślij opinię","Send Money":"Wyślij pieniądze","Send addresses by email":"Wyślij adresy przez e-mail","Send by email":"Wyślij przez e-mail","Send from":"Wyślij z","Send max amount":"Wyślij całą kwotę","Send payment to this address":"Wyślij płatność na ten adres","Send us feedback instead":"Zamiast tego wyślij nam swoją opinię","Sending":"Wysyłanie","Sending 2FA code...":"Wysyłanie kodu 2FA...","Sending feedback...":"Wysyłanie opinii...","Sending maximum amount":"Wysyłanie całej kwoty","Sending transaction":"Wysyłanie transakcji","Sending {{amountStr}} from your {{name}} wallet":"Wysyłanie {{amountStr}} z twojego portfela {{name}}","Sent":"Wysłane","Sent Funds":"Wysłane środki","Server response could not be verified":"Odpowiedź serwera nie mogła zostać zweryfikowana","Service not available":"Usługa nie jest dostępna","Services":"Usługi","Session Log":"Dziennik sesji","Session log":"Dziennik sesji","Set up a password":"Ustal hasło","Set your own fee in satoshis/byte":"Ustaw własną opłatę w satoshis/bajt","Settings":"Ustawienia","Share the love by inviting your friends.":"Podziel się miłością, zapraszając swoich przyjaciół.","Share this invitation with your copayers":"Wyślij zaproszenie współwłaścicielom portfela","Share {{appName}}":"Podziel się {{appName}}","Shared Wallet":"Współdzielony portfel","Show Recovery Phrase":"Pokaż kluczową frazę","Show address":"Pokaż adres","Show advanced options":"Pokaż opcje zaawansowane","Show bitcoin address":"Pokaż adres bitcoin","Show more":"Pokaż więcej","Signatures rejected by server":"Podpisy odrzucone przez serwer","Signing transaction":"Podpisywanie transakcji","Since only you control your money, you’ll need to save your backup phrase in case this app is deleted.":"Ponieważ jedynie Ty kontrolujesz swoje pieniądze, musisz zapisać kluczową frazę na wypadek skasowania aplikacji {{appName}}.","Single Address Wallet":"Pojedynczy adres portfela","Skip":"Pomiń","Slide to accept":"Przesuń, aby zaakceptować","Slide to buy":"Przesuń, aby kupić","Slide to pay":"Przesuń, aby zapłacić","Slide to send":"Przesuń, aby wysłać","Specify Recovery Phrase...":"Podaj kluczową frazę...","Spend proposal is not accepted":"Wniosek wypłaty nie został przyjęty","Spend proposal not found":"Wniosek wypłaty nie został znaleziony","Spending Password needed":"Wymagane hasło wypłat","Start sending bitcoin":"Zacznij wysyłać bitcoiny","Startup Lock":"Blokada uruchamiania","Still pending":"Jeszcze w toku","Success":"Udało się","Super Economy":"Super Ekonomiczna","Sweep":"Opróżnij","Sweep paper wallet":"Wyczyść papierowy portfel","Sweeping Wallet...":"Sczytywanie portfela...","THIS ACTION CANNOT BE REVERSED":"TEJ CZYNNOŚCI NIE MOŻNA COFNĄĆ","Take control of your money,<br>get started with bitcoin.":"Przejmij kontrolę nad swoimi pieniędzmi,<br>zacznij korzystać z bitcoinów.","Tap and hold to show":"Dotknij i przytrzymaj, aby pokazać","Tap to recreate":"Dotknij, aby odświeżyć","Tap to retry":"Ponów próbę","Terms Of Use":"Warunki użytkowania","Terms of Use":"Warunki użytkowania","Testnet":"Testnet","Text":"Tekst","Thank you!":"Dziękujemy!","Thanks!":"Dzięki!","That's exciting to hear. We'd love to earn that fifth star from you – how could we improve your experience?":"Bardzo nam miło. Chcielibyśmy dostać od Ciebie 5 gwiazdek - co jeszcze możemy poprawić?","The Ledger Chrome application is not installed":"Aplikacja Ledger Chrome nie jest zainstalowana","The amount of bitcoin immediately spendable from this wallet.":"Możliwa jest natychmiastowa wypłata wszystkich środków z tego portfela.","The amount of bitcoin stored in this wallet that is allocated as inputs to your pending transaction proposals. The amount is determined using unspent transaction outputs associated with this wallet and may be more than the actual amounts associated with your pending transaction proposals.":"Kwota bitcoinów przechowywana w tym portfelu, przydzielona jako wejście dla oczekujących wniosków wypłat. Kwota ta jest ustalana za pomocą niewykorzystanych wyjść transakcji związanych z tym portfelem i może przekroczyć kwoty związane z proponowanymi wnioskami wypłat.","The amount of bitcoin stored in this wallet with less than 1 blockchain confirmation.":"Ilość bitcoinów przechowywana w tym portfel z mniej niż jednym potwierdzeniem w blockchainie.","The derivation path":"Ścieżka derywacji","The exchange rate changes with the market.":"Zmiany kursowe zależne od rynku.","The higher the fee, the greater the incentive a miner has to include that transaction in a block. Current fees are determined based on network load and the selected policy.":"Im wyższa prowizja, tym większa zachęta dla górników do zawarcia tej transakcji w bloku. Obecne prowizje ustala się w oparciu o obciążenia sieci i wybraną politykę.","The maximum number of consecutive unused addresses (20) has been reached. When one of your unused addresses receives a payment, a new address will be generated and shown in your Receive tab.":"Maksymalna liczba kolejnych niewykorzystanych adresów (20) została osiągnięta. Gdy na jeden z nieużywanych adresów wpłynie zapłata, nowy adres zostanie wygenerowany i pokazany w zakładce Otrzymane.","The official English Terms of Service are available on the BitPay website.":"Oficjalne Warunki użytkowania w języku angielskim dostępne są na stronie internetowej BitPay.","The password of the recovery phrase (if set)":"Hasło kluczowej frazy (jeśli ustawione)","The payment was created but could not be completed. Please try again from home screen":"Wypłata została utworzona, ale nie może być zakończona. Spróbuj ponownie na stronie głównej","The payment was removed by creator":"Wypłata została usunięta przez jej twórcę","The recovery phrase could require a password to be imported":"Kluczowa fraza może wymagać hasła do zaimportowania","The request could not be understood by the server":"Wniosek nie został zrozumiany przez serwer","The restore process will stop when 20 addresses are generated in a row which contain no funds. To safely generate more addresses, make a payment to one of the unused addresses which has already been generated.":"Proces przywracania będzie przerwany kiedy zostanie wygenerowanych 20 następujących po sobie adresów, na których nie ma żadnych środków. Aby bezpiecznie wygenerować więcej adresów, dokonaj płatności na jeden z nieużywanych adresów, które zostały już wygenerowane.","The spend proposal is not pending":"Wniosek o wypłatę nie jest w oczekujących","The total amount of bitcoin stored in this wallet.":"Łączna ilość bitcoinów przechowywana w tym portfelu.","The transaction history and every new incoming transaction are cached in the app. This feature clean this up and synchronizes again from the server":"Historia transakcji i każda nowoprzychodząca transakcja są zapisywane w aplikacji. Ta funkcja czyści te dane i ponownie synchronizuje z serwerem","The wallet service URL":"Adres URL usługi portfela","There is a new version of {{appName}} available":"Dostępna jest nowa wersja {{appName}}","There is an error in the form":"Wystąpił błąd w postaci","There's obviously something we're doing wrong.":"To oczywiste, że coś robimy źle.","This app is fantastic!":"Ta aplikacja jest fantastyczna!","This app stores your bitcoin with cutting-edge security.":"Ta aplikacja przechowuje Twoje bitcoiny z zaawansowanymi zabezpieczeniami.","This bitcoin payment request has expired.":"Ten wniosek płatności wygasł.","This password cannot be recovered. If the password is lost, there is no way you could recover your funds.":"To hasło nie może zostać odzyskane. Jeśli je utracisz, nie będziesz mógł odzyskać swoich środków.","This recovery phrase was created with a password. To recover this wallet both the recovery phrase and password are needed.":"Ta kluczowa fraza został utworzona przy użyciu hasła. Aby odzyskać portfel potrzebna jest kluczowa fraza i hasło.","This transaction could take a long time to confirm or could be dropped due to the low fees set by the sender":"Potwierdzenie transakcja może trwać długo lub zostać przerwane z powodu niskiej prowizji ustalonej przez nadawcę","This wallet is not registered at the given Bitcore Wallet Service (BWS). You can recreate it from the local information.":"Ten portfel nie jest zarejestrowany na Bitcore Wallet Service (BWS). Możesz go odtworzyć z lokalnego nośnika.","Timeline":"Historia","To":"Do","To get started, buy bitcoin or share your address. You can receive bitcoin from any wallet or service.":"Aby zacząć, kup bitcoiny lub udostępnij swój adres. Możesz otrzymać bitcoiny z dowolnego portfela lub usługi.","To get started, you'll need to create a bitcoin wallet and get some bitcoin.":"Aby rozpocząć należy utworzyć portfel i dostać trochę bitcoinów.","Total":"Łącznie","Total Locked Balance":"Łącznie zablokowane środki","Total number of copayers":"Liczba współwłaścicieli portfela","Touch ID Failed":"Odczyt Touch ID nie powiódł się","Transaction":"Transakcja","Transaction Created":"Transakcja utworzona","Transaction History":"Historia transakcji","Transaction already broadcasted":"Transakcja została już wysłana","Transaction has not been created":"Transakcja nie została utworzona","Transaction initiated":"Transakcja zainicjowana","Transaction not available at this time":"Transakcja w tej chwili niedostępna","Transaction not found":"Nie znaleziono transakcji","Transactions without fee are not supported.":"Transakcje bez opłaty nie są obsługiwane.","Transfer to":"Przekaż do","Transfer to Wallet":"Przenieś do portfela","Try again in {{expires}}":"Spróbuj ponownie w {{expires}}","Turn bitcoin into dollars, swipe anywhere Visa<sup>®</sup> is accepted.":"Zamień bitcoiny na dolary - płać wszędzie gdzie akceptowane są karty Visa <sup>&reg;</sup>.","Type the Recovery Phrase (usually 12 words)":"Wpisz kluczową frazę (zwyczajowo 12 słów)","Uh oh...":"Ups...","Unconfirmed":"Niepotwierdzone","Unsent transactions":"Niewysłane transakcje","Unused Addresses":"Nieużywane adresy","Unused Addresses Limit":"Limit nieużywanych adresów","Update Available":"Dostępna aktualizacja","Updating pending proposals. Please stand by":"Aktualizacja wniosków płatności. Proszę czekać","Updating transaction history. Please stand by.":"Aktualizowanie historii transakcji. Proszę czekać.","Updating... Please stand by":"Aktualizacja... Proszę czekać","Urgent":"Pilna","Use Unconfirmed Funds":"Użyj niepotwierdzonych środków","Validating recovery phrase...":"Sprawdzanie poprawności kluczowej frazy...","Verify your identity":"Weryfikacja konta użytkownika","Version":"Wersja","View":"Widok","View All Addresses":"Zobacz wszystkie adresy","View Terms of Service":"Zobacz zasady użytkowania","View Transaction on Insight":"Zobacz transakcje na Insight","View Update":"Zobacz aktualizacje","View on blockchain":"Zobacz na blockchainie","WARNING: Key derivation is not working on this device/wallet. Actions cannot be performed on this wallet.":"Ostrzeżenie: klucz derywacji nie działa na tym urządzeniu/portfelu. Działania dla tego portfela nie można wykonać.","WARNING: Not including the private key allows to check the wallet balance, transaction history, and create spend proposals from the export. However, does not allow to approve (sign) proposals, so <b>funds will not be accessible from the export</b>.":"UWAGA: Jeśli plik eksportu nie zawiera klucza prywatnego, możliwe będzie jedynie sprawdzenie salda i historii transakcji, jak również wygenerowanie wniosków o płatność. Nie może być on jednak używany do sprawdzania poprawności (podpisywania) wniosków płatności, więc <b>środki z wyeksportowanego pliku nie będą dostępne</b>.","WARNING: The private key of this wallet is not available. The export allows to check the wallet balance, transaction history, and create spend proposals from the export. However, does not allow to approve (sign) proposals, so <b>funds will not be accessible from the export</b>.":"UWAGA: Klucz prywatny nie jest dostępny. Ten eksport umożliwia sprawdzenie salda i historii transakcji, jak również wygenerowanie wniosków o płatność. Nie może być on jednak używany do sprawdzania poprawności (podpisywania) wniosków płatności, więc <b>środki z wyeksportowanego pliku nie będą dostępne</b>.","WARNING: UNTRUSTED CERTIFICATE":"OSTRZEŻENIE: CERTYFIKAT NIEZAUFANY","Waiting for Ledger...":"Oczekiwanie na Ledger...","Waiting for Trezor...":"Oczekiwanie na Trezor...","Waiting for copayers":"Oczekiwanie na współwłaścicieli portfela","Waiting...":"Oczekiwanie...","Wallet Addresses":"Adresy portfela","Wallet Color":"Kolor portfela","Wallet Configuration (m-n)":"Konfiguracja portfela (m-n)","Wallet Created":"Portfel został utworzony","Wallet Id":"Id Portfela","Wallet Information":"Informacje o portfelu","Wallet Invitation":"Zaproszenie do portfela","Wallet Key":"Kluczowa fraza","Wallet Name":"Nazwa portfela","Wallet Name (at creation)":"Nazwa portfela (oryginalna)","Wallet Network":"Sieć portfela","Wallet Recovery Phrase":"Kluczowa fraza portfela","Wallet Recovery Phrase is invalid":"Kluczowa fraza jest nieprawidłowa","Wallet Service URL":"Adres usług portfela","Wallet Settings":"Ustawienia portfela","Wallet Type":"Rodzaj portfela","Wallet already exists":"Portfel już istnieje","Wallet created":"Portfel został utworzony","Wallet incomplete and broken":"Portfel niekompletny lub uszkodzony","Wallet is full":"Portfel jest pełny","Wallet is locked":"Portfel jest zablokowany","Wallet is not complete":"Portfel jest niekompletny","Wallet name":"Nazwa portfela","Wallet needs backup":"Portfel wymaga kopii zapasowej","Wallet not backed up":"Portfel nie ma kopii zapasowej","Wallet not found":"Nie znaleziono portfela","Wallet not registered":"Portfel nie jest zarejestrowany","Wallet not registered at the wallet service. Recreate it from \"Create Wallet\" using \"Advanced Options\" to set your recovery phrase":"Portfel nie jest zarejestrowany w Wallet Service. Odtwórz go używając polecenia \"Utwórz portfel\" z wykorzystaniem kluczowej frazy w ustawieniach zaawansowanych","Wallet recovery phrase not available":"Fraza odzyskiwania portfela nie jest dostępna","Wallet service not found":"Nie znaleziono serwera","Wallets":"Portfele","Warning!":"Ostrzeżenie!","Warning: this transaction has unconfirmed inputs":"Ostrzeżenie: ta transakcja ma niepotwierdzone dane wejściowe","Watch out!":"Uważaj!","We'd love to do better.":"Chcielibyśmy zrobić to lepiej.","We'll confirm on the next screen.":"Potwierdzimy na następnym ekranie.","We're always looking for ways to improve {{appName}}.":"Zawsze szukamy sposobów na poprawę {{appName}}.","We're always looking for ways to improve {{appName}}. How could we improve your experience?":"Zawsze szukamy sposobów na ulepszenie {{appName}}. Co Twoim zdaniem można jeszcze poprawić?","Website":"Strona","We’re always looking for translation contributions! You can make corrections or help to make this app available in your native language by joining our community on Crowdin.":"Cały czas szukamy osób, które chciałyby przyłączyć się do tłumaczenia! Możesz dokonać korekt lub pomóc, aby aplikacja była dostępna w Twoim języku ojczystym przez dołączenie do naszej społeczności na Crowdin.","What do you call this wallet?":"Jak chcesz nazwać ten portfel?","When this wallet was created, it was called “{{walletName}}”. You can change the name displayed on this device below.":"Kiedy portfel został utworzony, otrzymał nazwę &ldquo;{{walletName}}&rdquo;. Możesz zmienić nazwę wyświetlaną poniżej.","Where would you like to receive email notifications about payments?":"Czy chcesz otrzymywać powiadomienia e-mail o płatnościach?","Why?":"Dlaczego?","Would you be willing to rate {{appName}} in the app store?":"Czy zechciałbyś ocenić {{appName}} w app store?","Would you like to receive push notifications about payments?":"Czy chcesz otrzymywać wyskakujące powiadomienia o płatnościach?","Wrong number of recovery words:":"Nieprawidłowa ilość słów frazy:","Wrong spending password":"Nieprawidłowe hasło wypłat","Yes":"Tak","Yes, skip":"Tak, pomiń","You can create a backup later from your wallet settings.":"Kopię zapasową można utworzyć później w ustawieniach portfela.","You can make contributions by signing up on our Crowdin community translation website. We’re looking forward to hearing from you!":"Możesz przyczynić się do rozwoju aplikacji rejestrując się na Crowdin - naszej stronie dla tłumaczy. Będziemy wdzięczni za kontakt!","You can scan bitcoin addresses, payment requests, paper wallets, and more.":"Możesz zeskanować adresy bitcoin, wnioski płatności, portfele papierowe i wiele innych.","You can see the latest developments and contribute to this open source app by visiting our project on GitHub.":"Możesz zobaczyć postępy prac i przyczynić się do rozwoju tej aplikacji open source odwiedzając nasz projekt na GitHub.","You can spend bitcoin at millions of websites and stores worldwide.":"Bitcoiny możesz wydać w milionach sklepów i stron internetowych na całym świecie.","You can still export it from Advanced &gt; Export.":"Nadal możesz go wyeksportować w Zaawansowane &gt; Eksport.","You can trade it for other currencies like US Dollars, Euros, or Pounds.":"Możesz je wymienić na inne waluty, takie jak dolary amerykańskie, euro lub funty.","You control your bitcoin.":"Ty kontrolujesz swoje bitcoiny.","You should not set a fee higher than {{maxFeeRecommended}} satoshis/byte.":"Nie należy ustawiać opłatę wyższą niż {{maxFeeRecommended}} satoshis/bajt.","You'll receive email notifications about payments sent and received from your wallets.":"Będziesz otrzymywać powiadomienia e-mail o płatności wysyłanych i odbieranych ze swoich portfeli.","Your BitPay Card is ready. Add funds to your card to start using it at stores and ATMs worldwide.":"Twoja karta BitPay jest gotowa. Zasil kartę, aby zacząć ją używać w sklepach i bankomatach na całym świecie.","Your Gift Cards":"Twoje karty podarunkowe","Your bitcoin wallet is backed up!":"Kopia zapasowa portfela została utworzona!","Your bitcoin wallet is ready!":"Twój portfel jest gotowy!","Your fee is lower than recommended.":"Opłata jest niższa niż zalecana.","Your ideas, feedback, or comments":"Twoje pomysły, opinie lub komentarze","Your name":"Twój nick","Your nickname":"Twój nick","Your password":"Twoje hasło","Your purchase could not be completed":"Nie można ukończyć zakupu","Your purchase was added to the list of pending":"Zakup został dodany do listy oczekujących","Your wallet is never saved to cloud storage or standard device backups.":"Twój portfel nigdy nie jest przechowywany w chmurze lub na urządzeniach do tworzenia kopii zapasowych.","Your wallet key will be encrypted. The Spending Password cannot be recovered. Be sure to write it down.":"Twój portfel będzie zaszyfrowany. Hasło wypłat nie będzie mogło być odzyskane. Pamiętaj, aby je zapisać.","[Balance Hidden]":"[Balans ukryty]","add your BitPay Visa card(s)":"dodaj swoje karty BitPay Visa","locked by pending payments":"zablokowane przez oczekujące wypłaty","me":"ja","name@example.com":"nazwa@przyklad.com","preparing...":"Przygotowywanie...","recovery tool.":"narzędzie do odzyskiwania.","{{amountStr}} for Amazon.com Gift Card":"{{amountStr}} dla karty upominkowej Amazon.com","{{appName}} depends on Bitcore Wallet Service (BWS) for blockchain information, networking and Copayer synchronization. The default configuration points to https://bws.bitpay.com (BitPay's public BWS instance).":"{{appName}} jest zależny od Bitcore Wallet Service (BWS) jeśli chodzi o informacje dotyczące blokcheina, sieci i synchronizacji współwłaścicieli portfela. Domyślnie jest to https://bws.bitpay.com (BitPay's public BWS instance).","{{fee}} will be deducted for bitcoin networking fees.":"{{fee}} zostanie potrącone jako prowizja sieci bitcoin.","{{updatingTxHistoryProgress}} transactions downloaded":"{{updatingTxHistoryProgress}} transakcje pobrane","{{wallet.m}}-of-{{wallet.n}}":"{{wallet.m}}-z-{{wallet.n}}"});
    gettextCatalog.setStrings('pt', {"(Trusted)":"(Confiável)","(possible double spend)":"(Possível gasto duplo)","* A payment proposal can be deleted if 1) you are the creator, and no other copayer has signed, or 2) 24 hours have passed since the proposal was created.":"* Uma proposta de pagamento pode ser apagada se 1) você é o criador e outro copayer não subscreveu, ou 2) Passaram-se 24 horas desde que a proposta foi criada.","- {{btx.feeRateStr}} of the transaction":"- {{btx.feeRateStr}} da transação","- {{tx.feeRateStr}} of the transaction":"- {{tx.feeRateStr}} da transação","5-star ratings help us get {{appName}} into more hands, and more users means more resources can be committed to the app!":"Classificações de 5 estrelas ajudam-nos a que o {{appName}} chegue ás mãos de mais e mais utilizadores, que significa que mais recursos serão incluídos na aplicação!","<b>Only</b> redeemable on Mercado Livre (Brazil)":"<b>Somente</b> resgatável no Mercado Livre (Brasil)","A member of the team will review your feedback as soon as possible.":"Um membro da equipa irá rever a sua avaliação assim que possível.","A total of {{amountAboveMaxSizeStr}} were excluded. The maximum size allowed for a transaction was exceeded.":"O montante de {{amountAboveMaxSizeStr}} foi excluido. O valor máximo permitido para uma transação foi excedido.","A total of {{amountBelowFeeStr}} were excluded. These funds come from UTXOs smaller than the network fee provided.":"O montante de {{amountBelowFeeStr}} foi excluido. Estes fundos vieram de UTXOs menores que a taxa de rede fornecida.","About":"Sobre","Accepted":"Aceite","Account":"Conta","Account Number":"Número de conta","Accounts":"Contas","Activity":"Atividade","Add Account":"Adicionar conta","Add BitPay Account?":"Adicionar conta BitPay?","Add Contact":"Adicionar contacto","Add Funds":"Adicionar fundos","Add Memo":"Adicionar nota","Add a password":"Adicionar uma senha","Add account":"Adicionar conta","Add an optional password to secure the recovery phrase":"Adicionar uma senha opcional para asegurar a frase de recuperação","Add as a contact":"Adicionar como um contato","Add description":"Adicionar descrição","Add funds":"Adicionar fundos","Add this BitPay account ({{email}})?":"Adicionar esta conta BitPay ({{email}})?","Add wallet":"Adicionar carteira","Address":"Endereço","Address Book":"Livros de endereços","Address Type":"Tipo de Endereço","Addresses With Balance":"Endereços com valores","Advanced":"Avançado","Advanced Settings":"Definições avançadas","All":"Todos","All Addresses":"Todos os endereços","All of your bitcoin wallet balance may not be available for immediate spending.":"Todos os seus bitcoins na carteira poderão não estar disponíveis de imediato para gastar.","All signing devices must be added to this multisig wallet before bitcoin addresses can be created.":"Todos os dispositivos de autenticação devem ser adicionados a esta carteira de multi-assinatura antes dos endereços bitcoin poderem ser criados.","Allow Camera Access":"Permitir o acesso à câmera","Allow notifications":"Permitir notificações","Almost done! Let's review.":"Quase pronto! Vamos rever.","Alternative Currency":"Moeda Alternativa","Amazon.com is not available at this moment. Please try back later.":"Amazon.com não está disponível neste momento. Por favor, tente mais tarde.","Amount":"﻿Valor","Amount below minimum allowed":"Montante abaixo do mínimo permitido","Amount too big":"Montante muito grande","Amount too low to spend":"Quantidade muito baixa para gastar","An update to this app is available. For your security, please update to the latest version.":"Está disponível uma actualização para esta aplicação. Para sua segurança, por favor atualize para a versão mais recente.","Anyone with your backup phrase can access or spend your bitcoin.":"Qualquer pessoa com sua frase de segurança pode aceder ou gastar os seus bitcoins.","Approximate Qybcoin network fee to transfer wallet's balance (with normal priority)":"Taxa de rede Qybcoin aproximada para transferir o saldo da carteira (com prioridade normal)","Are you being watched?":"Você está sendo vigiado?","Are you being watched? Anyone with your recovery phrase can access or spend your bitcoin.":"Você está sendo observado? Qualquer pessoa com sua frase de recuperação pode acessar ou gastar seu bitcoin.","Are you sure you want to cancel and delete this wallet?":"Tem certeza que deseja cancelar e eliminar esta carteira?","Are you sure you want to delete this contact?":"Tem certeza que deseja excluir este contato?","Are you sure you want to delete this wallet?":"Tem certeza que deseja excluir esta carteira?","Are you sure you want to reject this transaction?":"Tem certeza que deseja cancelar esta transação?","Are you sure you want to remove this transaction?":"Tem certeza que deseja remover esta transação?","Are you sure you want to skip it?":"Tem a certeza que deseja ignorar?","Are you sure you would like to log out of your BitPay Card account?":"Tem certeza que você deseja sair da sua conta do BitPay Card?","Are you sure you would like to remove your BitPay Card ({{lastFourDigits}}) from this device?":"Tem a certeza de que quer remover o seu Cartão BitPay ({{lastFourDigits}}) deste dispositivo?","Auditable":"Audivel","Available":"Disponível","Available Balance":"Saldo Disponível","Average confirmation time":"Tempo de confirmação (em média)","BIP32 path for address derivation":"Pacote BIP32 para endereço de derivação","QYB wallets":"Carteiras QYB","Backup":"Backup","Backup Needed":"Cópia de segurança necessária","Backup all livenet wallets before using this function":"Faça backup de todas as carteiras do livenet antes de usar esta função","Backup needed":"Backup necessário","Backup now":"Backup agora","Backup wallet":"Criar cópia da carteira","Backup your wallet before using this function":"Faça backup da sua carteira antes de usar esta função","Bad wallet invitation":"Convite para carteira inválido","Balance By Address":"Saldo por endereço","Be sure to store your recovery phrase in a secure place. If this app is deleted, your money cannot be recovered without it.":"Certifique-se de armazenar a sua frase de recuperação num lugar seguro. Se esta aplicação for eliminada o seu dinheiro não pode ser recuperado sem ela.","BitPay Visa® Cards":"Cartões BitPay Visa&reg","Qybcoin Address":"Endereço Qybcoin","Qybcoin Cash Wallets":"Carteiras Qybcoin Cash","Qybcoin Network Fee Policy":"Política de taxa de rede Qybcoin","Qybcoin Wallets":"Carteiras Qybcoin","Qybcoin cash Payment":"Pagamento Qybcoin Cash","Qybcoin is a currency.":"Qybcoin é uma moeda.","Qybcoin is different – it cannot be safely held with a bank or web service.":"Qybcoin é diferente &ndash; ela não pode ser retida com segurança por um serviço web ou banco.","Qybcoin is secure,<br>digital money.":"Qybcoin é seguro,<br>moeda digital.","Qybcoin transactions include a fee collected by miners on the network.":"As transações Qybcoin incluem uma taxa cobrada pelos mineiros na rede.","Bought {{amountUnitStr}}":"Comprado {{amountUnitStr}}","Broadcast Payment":"Transmitir Pagamento","Broadcasted":"Transmitido","Broadcasting transaction":"Transmitindo transação","Browser unsupported":"Navegador não suportado","Buy":"Comprar","Buy &amp; Sell Qybcoin":"Comprar &amp; Vender Qybcoin","Buy Qybcoin":"Comprar Qybcoin","Buy a Gift Card":"Comprar um Vale-Presente","Buy from":"Comprar de","Buying Qybcoin...":"A comprar Qybcoin...","Calculating fee":"A calcular taxa","Cancel":"Cancelar","Cancel invitation":"Cancelar convite","Cannot Create Wallet":"Não é possível criar a carteira","Cannot join the same wallet more that once":"Não pode juntar-se a mesma carteira mais que uma vez","Cards":"Cartões","Certified by":"Certificado por","Check installation and retry.":"Verifique a instalação e tente novamente.","Choose a backup file from your computer":"Escolha um arquivo de backup do seu computador","Choose your destination wallet":"Escolha a sua carteira de destino","Choose your source wallet":"Escolha a sua carteira de origem","Clear":"Eliminar","Clear cache":"Limpar cache","Click to accept":"Clique para aceitar","Click to pay":"Clique para pagar","Click to send":"Clique para enviar","Close":"Fechar","Coin":"Moeda","Color":"Cor","Commit hash":"Commit de hash","Complete the backup process to use this option":"Complete o processo de backup para usar esta opção","Completed":"Concluído","Confirm":"Confirmar","Confirm &amp; Finish":"Confirmar &amp; Terminado","Confirm purchase":"Confirmar compra","Confirm your PIN":"Confirme o seu PIN","Confirm your new spending password":"Confirme a nova senha de pagamento","Confirmations":"Confirmações","Confirming":"A confirmar","Connect my BitPay Card":"Introduzir o meu cartão do BitPay","Connecting to Coinbase...":"A conectar ao Coinbase...","Connecting to Glidera...":"A conectar ao Glidera...","Connection reset by peer":"Ligação redefinida pelo mesmo nível","Contacts":"Contactos","Continue":"Continuar","Contribute Translations":"Contribuir para a tradução","Qyb only supports Qybcoin Cash using new version numbers addresses":"Qyb apenas suporta Qybcoin Cash utilizando a nova versão de endereço","Copayer already in this wallet":"Copayer já está nesta carteira","Copayer already voted on this spend proposal":"Copayer já votou nesta proposta de pagamento","Copayer data mismatch":"Informação do Copayer inválida","Copayer joined":"Copayer juntou-se","Copayer {{$index}}":"Copayer {{$index}}","Copied to clipboard":"Copiado para a área de transferência","Copy this text as it is to a safe place (notepad or email)":"Copie este texto como está para um lugar seguro (bloco de notas ou e-mail)","Copy to clipboard":"Copiar para área de transferência","Could not access Gift Card Service":"Não foi possível acessar o serviço de Vale-Presente","Could not access the wallet at the server. Please check:":"Não foi possível acessar a carteira no servidor. Por favor, verifique:","Could not access to Amazon.com":"Não foi possível acessar a Amazon.com","Could not access wallet":"Impossível aceder à carteira","Could not add message to imported wallet without shared encrypting key":"Não foi possível adicionar mensagem à carteira importada sem chave de criptografia compartilhada","Could not broadcast payment":"Não foi possível transmitir o pagamento","Could not build transaction":"Não foi possível criar a transacção","Could not create address":"Não foi possível criar o endereço","Could not create the invoice":"Não foi possível criar a fatura","Could not create transaction":"Não foi possível criar a transação","Could not create using the specified extended private key":"Não foi possível criar usando a chave privada estendida especificada","Could not create using the specified extended public key":"Não foi possível criar usando a chave privada estendida especificada","Could not create: Invalid wallet recovery phrase":"Não foi possível criar: Frase de recuperação de carteira inválida","Could not decrypt file, check your password":"Não foi possível descriptografar o arquivo, verifique sua senha","Could not delete payment proposal":"Não foi possível excluir a proposta de pagamento","Could not duplicate":"Não foi possível duplicar","Could not get dynamic fee":"Não foi possível obter taxa dinâmica","Could not get dynamic fee for level: {{feeLevel}}":"Não foi possível obter a taxa dinâmica para nível: {{feeLevel}}","Could not get fee levels":"Não foi possível obter níveis de taxa","Could not get the invoice":"Não foi possível obter a fatura","Could not get transactions":"Não foi possível obter o histórico das transações","Could not import":"Não foi possível importar","Could not import. Check input file and spending password":"Não foi possível importar. Verifique o arquivo de entrada e senha de compra","Could not join wallet":"Impossível juntar à carteira","Could not reject payment":"Não foi possível rejeitar o pagamento","Could not remove account":"Não foi possível remover a conta","Could not remove card":"Não foi possível remover o cartão","Could not save preferences on the server":"Não foi possível guardar as suas preferências no servidor","Could not send payment":"Não foi possível enviar o pagamento","Could not send transaction":"Não foi possível enviar a transação","Could not update transaction history":"Não foi possível atualizar o histórico de transações","Could not update wallet":"Não foi possível atualizar a carteira","Create Personal Wallet":"Criar carteira pessoal","Create Shared Wallet":"Criar carteira partilhada","Create bitcoin wallet":"Criar carteira bitcoin","Create new wallet":"Criando nova carteira","Create shared wallet":"Criar carteira partilhada","Create {{formData.requiredCopayers}}-of-{{formData.totalCopayers}} wallet":"Criar carteira de {{formData.requiredCopayers}}-de-{{formData.totalCopayers}}","Created by":"Criado por","Creating Wallet...":"Criando Carteira…","Creating transaction":"Criando transação","Current fee rate for this policy":"Taxa atual para esta política","Custom":"Personalizado","Custom Amount":"Montante personalizado","Custom Fee":"Taxa personalizada","Date":"Data","Delete":"Eliminar","Delete Payment Proposal":"Excluir Proposta de Pagamento","Delete Wallet":"Excluir Carteira","Delete it and create a new one":"Apagar e criar um novo","Deleting Wallet...":"A eliminar carteira...","Deleting payment proposal":"A eliminar proposta de pagamento","Derivation Path":"Caminho de derivação","Derivation Strategy":"Estratégia de derivação","Details":"Detalhes","Disabled":"Desativado","Do it later":"Fazê-lo mais tarde","Do not include private key":"Não inclui chave privada","Don't see your language on Crowdin? Contact the Owner on Crowdin! We'd love to support your language.":"Não vê o seu idioma no Crowdin? Contacte o Dono no Crowdin! Nós adoraríamos suportar a sua linguagem.","Download":"Download","Duplicate for dmb":"Duplicado para dmb","Duplicating wallet...":"Duplicando carteira...","Each bitcoin wallet can generate billions of addresses from your 12-word backup. A new address is automatically generated and shown each time you receive a payment.":"Cada carteira de Qybcoin pode gerar biliões de endereços através do seu backup de 12-palavras. Um novo endereço é gerado automáticamente e mostrado cada vez que receber um pagamento.","Economy":"Economia","Edit":"Editar","Email":"Email","Email Address":"Endereço de email","Empty addresses limit reached. New addresses cannot be generated.":"Limite de endereços vazios atingido. Novos endereço não podem ser gerados.","Enable camera access in your device settings to get started.":"Permita o acesso de câmera nas configurações do seu dispositivo para começar.","Enable email notifications":"Ativar notificações por email","Enable push notifications":"Ativar notificações push","Enable the camera to get started.":"Ative a câmera para começar.","Enter Spending Password":"Inserir senha de compra","Enter Two Factor for your BitPay account":"Insira verificação dois passos para sua conta BitPay","Enter amount":"Digite a quantidade","Enter custom fee":"Digite a taxa personalizada","Enter new spending password":"Insira a nova senha para pagamento","Enter the recovery phrase (BIP39)":"Digite a frase de recuperação (BIP39)","Enter your email":"Digite seu e-mail","Enter your password":"Digite sua senha","Error":"Erro","Error at confirm":"Erro na confirmação","Error creating gift card":"Erro ao criar vale-presente","Error creating the invoice":"Erro ao criar a fatura","Error creating wallet":"Erro na criação da carteira","Error getting SendMax information":"Erro ao obter informações de SendMax","Error in Payment Protocol":"Erro no Protocolo de Pagamento","Error pairing BitPay Account":"Erro de emparelhamento na Conta BitPay","Error scanning funds:":"Erro na varredura dos fundos:","Error sweeping wallet:":"Erro na varredura da carteira:","Error updating Debit Cards":"Erro na atualização dos Cartões de Débito","Exceeded daily limit of $500 per user":"Excedido limite diário de $500 por usuário","Expired":"Expirado","Expires":"﻿Expira","Export Wallet":"Exportar Carteira","Export to file":"Exportar para arquivo","Export wallet":"Exportar carteira","Exporting via QR not supported for this wallet":"Exportação via QR code não suportada por essa carteira","Extended Private Key":"Chave Privada Estendida","Extended Public Keys":"Chave Pública Estendida","Extracting Wallet information...":"Extraindo informações da Carteira...","Failed to export":"Falha ao exportar","Family vacation funds":"Fundos de férias com a família","Fee":"Taxa","Fee level":"Nível de taxa","Fee level is not defined":"Nível de taxa não está definido","Fee:":"Taxa:","Feedback could not be submitted. Please try again later.":"Comentário pode não ter sido enviado. Por favor, tente novamente mais tarde.","Fetching BitPay Account...":"Buscando Conta BitPay...","Fetching payment information":"Buscando informação de pagamento","File/Text":"Arquivo/Texto","Filter setting":"Configuração de filtro","Finger Scan Failed":"Leitura de Impressão Digital falhou","Finish":"Encerrar","For audit purposes":"Para fins de auditoria","From":"De","From BitPay account":"De conta BitPay","From Hardware Wallet":"De uma Carteira de Hardware","From the destination device, go to Add wallet &gt; Import wallet and scan this QR code":"Do dispositivo de destino, go em Adicionar Carteira &gt; Importar Carteira e faça a varredura do código QR","Funds are locked by pending spend proposals":"O saldo está bloqueado por um pedido de gasto pendente","Funds found:":"Saldos encontrados:","Funds to be added":"Fundos a ser adicionado","Funds transferred":"Saldos transferidos","Funds were added to debit card":"Os fundos foram adicionados ao cartão de débito","Funds will be transferred to":"Os saldos serão transferidos para","Generate new address":"Gerar novo endereço","Generating .csv file...":"Gerando arquivo .csv...","Generating new address...":"Gerando novo endereço...","Get local cash anywhere you go, from any Visa<sup>®</sup> compatible ATM. ATM bank fees may apply.":"Sacar dinheiro em qualquer lugar que você vá, de qualquer Caixa Eletrônico Visa<sup>&reg;</sup> compatível. Tarifas bancárias podem ser geradas.","Get news and updates from BitPay":"Receba notícias e atualizações da BitPay","Get started":{"$$noContext":"Começar","button":"Começar"},"Get started by adding your first one.":"Comece adicionando o primeiro.","Getting fee levels...":"Obtendo níveis de taxa...","Gift Card":"Vale-Presente","Gift Card is not available to use anymore":"Vale-Presente não está mais disponível para uso","Gift card expired":"Vale-presente expirado","Gift card generated and ready to use.":"Vale-presente gerado e pronto para uso.","Go Back":"Retroceder","Go back":"Retroceder","Got it":"Compreendi","Hardware Wallet":"Carteira de hardware","Hardware not connected.":"Hardware não conectado.","Hardware wallet":"Carteira de hardware","Hardware wallets are not yet supported with Qybcoin Cash":"Carteiras de hardware ainda não são suportadas com Qybcoin Cash","Help & Support":"Ajuda e suporte","Help and support information is available at the website.":"Informações de Ajuda e Suporte estão disponíveis no site.","Hide":"Esconder","Hide Balance":"Esconder saldos","Hide Next Steps Card":"Esconder próximo passo do cartão","Hide advanced options":"Ocultar opções avançadas","Home":"Início","How could we improve your experience?":"Como poderíamos melhorar sua experiência?","How do you like {{appName}}?":"Como você gosta do {{appName}}?","I don't like it":"Eu não gosto","I have read, understood, and agree to the <a ng-click=\"openTerms()\" translate=\"\">Terms of Use</a>.":"Li, entendi e concordo com os <a ng-click=\"openTerms()\" translate=\"\">Termos de uso</a>.","I have read, understood, and agree with the Terms of use.":"Eu li, entendi, é concordo com os Termos de uso.","I have written it down":"Eu escrevi isso","I like the app":"Eu gosto da aplicação","I think this app is terrible.":"Acho que esta aplicação é terrível.","I understand":"Eu compreendi","I understand that if this app is moved to another device or deleted, my bitcoin can only be recovered with the backup phrase.":"Eu entendi que se esse aplicativo for movido para outro dispositivo ou deletado, meus bitcoins só podem ser recuperados com frase de backup.","I understand that my funds are held securely on this device, not by a company.":"Eu entendi que meu saldo são mantidos em segurança neste dispositivo e não por uma empresa.","I've written it down":"Já escrevi isso","If enabled, all sensitive information (private key and recovery phrase) and actions (spending and exporting) associated with this wallet will be protected.":"Se habilitado, todas as informações sensíveis (chave privada e frase de recuperação) e ações (gastos e exportações) associados à essa carteira será protegido.","If enabled, the Recent Transactions card - a list of transactions occuring across all wallets - will appear in the Home tab.":"Se habilitado, o Cartão de Transações - Lista todas as transações que ocorreram em todas as Carteiras - aparecerá na aba Início.","If enabled, wallets will also try to spend unconfirmed funds. This option may cause transaction delays.":"Se habilitado, as carteiras irão tentar gastar fundos não confirmados. Está opção pode causar atrasos de transações.","If this device is replaced or this app is deleted, neither you nor BitPay can recover your funds without a backup.":"Se esse dispositivo é substituído ou este aplicativo deletado, nem você nem a BitPay poderá recuperar seus fundos sem um backup.","If you have additional feedback, please let us know by tapping the \"Send feedback\" option in the Settings tab.":"Se você tem sugestões adicionais, por favor, informe-nos através da opção \"Enviar Sugestões\" na Aba Configurações.","If you take a screenshot, your backup may be viewed by other apps. You can make a safe backup with physical paper and a pen.":"Se você fizer uma Captura de tela, seu backup poderá ser visto por outros aplicativos. Você pode fazer um backup físico com um papel e caneta.","Import":"Importar","Import Wallet":"Importar carteira","Import backup":"Importar backup","Import wallet":"Importar carteira","Importing Wallet...":"A importar a carteira...","In order to verify your wallet backup, please type your password.":"A fim de verificar o seu backup de carteira, por favor, digite sua senha.","Inactive":"Inativo","Incomplete":"Incompleto","Incomplete wallet":"Carteira incompleta","Incorrect PIN, try again.":"PIN incorreto, tente novamente.","Incorrect code format":"Formato de código incorreto","Incorrect network address":"Endereço de rede incorreto","Insufficient funds":"Fundos insuficientes","Insufficient funds for fee":"Fundos insuficientes para taxa","Integrations":"Integrações","Invalid":"Inválido","Invalid URL":"URL inválida","Invalid account number":"Número de conta inválido","Invalid address":"Endereço inválido","Invalid data":"Dados inválidos","Invalid derivation path":"Caminho de derivação inválido","Invitation to share a {{appName}} Wallet":"Convite para compartilhar a Carteira {{appName}}","Invoice expired":"Fatura expirada","Is there anything we could do better?":"Há algo mais que podemos ajudar?","Is this correct?":"Isto está correto?","Is this email address correct?":"Este endereço de e-mail está correto?","It's a good idea to avoid reusing addresses - this both protects your privacy and keeps your bitcoins secure against hypothetical attacks by quantum computers.":"É uma boa ideia evitar a reutilização de endereços - isto também protege a sua privacidade e mantém seus bitcoins seguros, contra prováveis ataques de computadores quânticos.","It's important that you write your backup phrase down correctly. If something happens to your wallet, you'll need this backup to recover your money. Please review your backup and try again.":"É importante que você escreva sua frase backup corretamente. Se algo acontecer a sua carteira, você vai precisar deste backup para recuperar seu dinheiro. Por favor, revise seu backup e tente novamente.","Join":"Participar","Join my {{appName}} Wallet. Here is the invitation code: {{secret}} You can download {{appName}} for your phone or desktop at {{appUrl}}":"Junte-se a minha Carteira {{appName}}. Aqui está o código de convite: {{secret}} você pode baixar {{appName}} para seu celular ou desktop em {{appUrl}}","Join shared wallet":"Associando carteira compartilhada","Joining Wallet...":"Associando-se a Carteira…","Just scan the code to pay.":"Apenas digitalize o código para pagar.","Key already associated with an existing wallet":"Chave já associada com uma carteira existente","Language":"Idioma","Last Month":"Mês anterior","Learn more":"Saiba mais","Let's verify your backup phrase.":"Vamos verificar a sua frase de backup.","Loading addresses...":"A carregar endereços...","Loading transaction info...":"A carregar informação da transação...","Lock App":"Bloquear aplicativo","Lock by Fingerprint":"Bloquear por impressão digital","Lock by PIN":"Bloquear por PIN","Locked":"Bloqueado","Locktime in effect. Please wait to create a new spend proposal":"Bloqueio de tempo em ação. Por favor, espere para criar uma nova proposta de gasto.","Locktime in effect. Please wait to remove this spend proposal":"Bloqueio de tempo em ação. Por favor espere para remover esta proposta de gasto.","Log options":"Opções de log","Log out":"Sair","Low amount inputs":"Quantidade de entrada baixa","Low fees":"Baixas taxas","Makes sense":"Faz sentido","Matches:":"Correspondências:","Me":"Eu","Meh - it's alright":"Meh - está tudo bem","Memo":"Nota","Mercado Livre Brazil Gift Cards":"Vales-Presente do Mercado Livre Brasil","Mercadolibre Gift Card Service is not available at this moment. Please try back later.":"Serviço de Vale-Presente Mercado Livre não está disponível neste momento. Por favor, tente mais tarde.","Merchant Message":"Mensagem Publicitária","Miner Fee":"Taxa do Minerador","Missing parameter":"Parâmetro em falta","Missing private keys to sign":"Faltam chaves privadas para assinar","More Options":"Mais opções","Moved":"Movido","Moved Funds":"Valores transferidos","Multiple recipients":"Vários destinatários","NOTE: To import a wallet from a 3rd party software, please go to Add Wallet &gt; Create Wallet, and specify the Recovery Phrase there.":"Nota: Para importar uma carteira de software de terceiros, por favor, vá para: Adicionar carteira, Criar Carteira, e então especifique a frase de recuperação.","Name":"Nome","Network Cost":"Custo de rede","Network error":"Erro de rede","New Proposal":"Nova proposta","New address could not be generated. Please try again.":"Novo endereço não pode ser gerado. Por favor tente novamente","New personal wallet":"Nova carteira pessoal","Next steps":"Próximos passos","No Wallet":"Sem carteira","No access key defined":"Nenhuma chave de acesso definida","No backup, no bitcoin.":"Sem backup, sem bitcoin.","No contacts yet":"Ainda não existem contactos","No entries for this log level":"Não há entradas para este nível de log","No hardware information available.":"Nenhuma informação de hardware disponível.","No hardware wallets supported on this device":"Não há carteiras de hardware com suporte neste dispositivo","No pending proposals":"Sem propostas pendentes","No recent transactions":"Não há transações recentes","No signing proposal: No private key":"Nenhuma proposta de assinatura: Nenhuma chave privada","No transactions yet":"Nenhuma transação ainda","No wallet found":"Carteira não encontrada","No wallet selected":"Sem carteira selecionada","No wallets available":"Não há carteiras disponíveis","No wallets available to receive funds":"Nenhuma Carteira disponível para receber fundos","No wallets eligible for Qybcoin Cash support":"Sem carteiras elegíveis para suporte a Qybcoin Cash","Non BIP44 wallet":"Carteira sem BIP44","Non eligible QYB wallets":"Carteiras QYB não elegíveis","Normal":"Normal","Not authorized":"Não autorizada","Not enough funds for fee":"Não há fundos para taxa","Not even BitPay can access it.":"Nem mesmo Bitpay pode acessar isso.","Not funds found":"Nenhum fundo encontrado","Not now":"Agora não","Note":"Nota","Note: if this dmb wallet was duplicated from a QYB wallet, they share the same recovery phrase.":"Nota: se esta carteira dmb foi duplicada de uma carteira QYB, elas compartilham a mesma frase de recuperação.","Notice: only 1-1 (single signature) wallets can be used for sell bitcoin":"Aviso: Apenas Carteiras 1-1 (de assinatura única) podem ser usadas para vender bitcoins","Notifications":"Notificações","Notifications by email":"Notificações por e-mail","Notify me if confirmed":"Me informe se confirmado","Notify me when transactions are confirmed":"Notificar-me quando as transações são confirmadas","Now is a good time to backup your wallet. If this device is lost, it is impossible to access your funds without a backup.":"Agora é uma boa hora para fazer backup de sua carteira. Se este dispositivo for perdido, é impossível acessar seus fundos sem um backup.","Now is a perfect time to assess your surroundings. Nearby windows? Hidden cameras? Shoulder-spies?":"Agora é a hora perfeita para olhar em volta. Próximo de janelas? Câmeras escondidas? Espião atrás do ombro?","OK":"OK","OKAY":"OK","Official English Disclaimer":"Aviso Legal Oficial em Inglês","Oh no!":"Oh não!","Ok":"Ok","On this screen you can see all your wallets, accounts, and assets.":"Nesta tela você pode ver todas as suas carteiras, contas e ativos.","Open":"Abrir","Open Crowdin":"Abrir Crowdin","Open GitHub":"Abrir GitHub","Open GitHub Project":"Abrir Projeto no GitHub","Open Insight":"Abrir Insight","Open Settings":"Abrir definições","Open Translation Community":"Abrir Comunidade de Tradução","Open Website":"Abrir Site","Open the recovery tool.":"Abrir ferramenta de recuperação.","Open wallet":"Abrir Carteira","Open website":"Abrir página da Web","Order the BitPay Card":"Solicitar o Cartão Bitpay","Password":"Senha","Password required. Make sure to enter your password in advanced options":"Necessário Senha. Certifique-se de digitar sua senha em opções avançadas","Paste invitation here":"Cole o convite aqui","Paste the backup plain text code":"Cole o texto puro do backup aqui","Pay 0% fees to turn bitcoin into dollars.":"Pague taxas de 0% para transformar bitcoin em dólar.","Pay To":"Pagar Para","Payment Accepted":"﻿Pagamento Aceito","Payment Expires:":"Pagamento expirado:","Payment Proposal":"Proposta de Pagamento","Payment Proposal Created":"Proposta de Pagamento Criada","Payment Proposals":"Propostas de Pagamento","Payment Protocol Invalid":"Protocolo de Pagamento Inválido","Payment Protocol not supported on Chrome App":"Protocolo de pagamento não suportado no Chrome App","Payment Received":"Pagamento Recebido","Payment Rejected":"Pagamento Rejeitado","Payment Sent":"Pagamento Enviado","Payment accepted, but not yet broadcasted":"Pagamento aceito, mas ainda não publicado","Payment accepted. It will be broadcasted by Glidera. In case there is a problem, it can be deleted 6 hours after it was created.":"Pagamento aceito. Ele será publicado por Glidera. Em caso de problema, pode ser deletado até 6 horas depois de criado.","Payment address was translated to new Qybcoin Cash address format:":"Endereço de pagamento foi traduzido para o novo formato de endereço Qybcoin Cash:","Payment details":"Detalhes do pagamento","Payment request":"Pedido de pagamento","Pending":"Pendente","Pending Proposals":"Proposta pendente","Permanently delete this wallet.":"Excluir permanentemente esta carteira.","Personal Wallet":"Carteira Pessoal","Please carefully write down this phrase.":"Por favor, anote esta frase com cuidado.","Please connect a camera to get started.":"Por favor conecte uma câmera para iniciar.","Please enter the recovery phrase":"Por favor, digite a frase de recuperação","Please enter the wallet recovery phrase":"Por favor, digite a frase de recuperação da carteira","Please enter your PIN":"Introduza o seu PIN","Please tap each word in the correct order.":"Por favor escolhe cada palavra na ordem correta.","Please upgrade Qyb to perform this action":"Por favor atualize Qyb para executar esta ação","Please wait":"Por favor aguarde","Please, select your backup file":"Por favor, selecione seu arquivo de backup","Pre-Auth Holds":"Bloqueio Pré-Autorização","Preferences":"Preferências","Preparing addresses...":"A preparar os endereços...","Preparing backup...":"A preparar o backup...","Press again to exit":"Pressione novamente para sair","Priority":"Prioridade","Private Key":"Chave Privada","Private key encrypted. Enter password":"Chave privada criptografada. Digite a senha","Private key is encrypted, cannot sign":"A Chave privada está criptografada, não é possível acessar","Proposal Accepted":"Proposta aceite","Proposal Created":"Proposta criada","Proposal Deleted":"Proposta eliminada","Proposal Rejected":"Proposta rejeitada","Proposals":"Propostas","Purchase Amount is limited to {{limitPerDay}} {{currency}} per day":"Valor da compra é limitado a {{limitPerDay}} {{currency}} por dia","Purchase amount must be a value between 50 and 2000":"Valor da compra deve ser um valor entre 50 e 2000","Push Notifications":"Notificações","Push notifications for {{appName}} are currently disabled. Enable them in the Settings app.":"Notificações de push para {{appName}} estão desativadas no momento. Habilite nas Configurações do aplicativo.","QR Code":"Código QR","Quick review!":"Avaliação rápida!","Random":"Aleatório","Rate on the app store":"Avalie-nos na App Store","Read less":"Ler menos","Read more":"Ler mais","Read more in our Wiki":"Leia mais em nosso Wiki","Read only wallet":"Carteira somente leitura","Receive":"﻿Receber","Receive in":"﻿Receber em","Received":"Recebido","Received Funds":"Valores recebidos","Receiving":"A receber","Recent":"Recente","Recent Transaction Card":"Transações recentes do cartão","Recent Transactions":"Transações recentes","Recipient":"Destinatário","Recipients":"Destinatários","Recovery phrase":"Frase de recuperação","Recreating Wallet...":"Recriando Carteira…","Redeem now":"Resgatar agora","Rejected":"Rejeitado","Rejecting payment proposal":"Proposta de pagamento recusada","Release information":"Informação de lançamento","Remove":"Remover","Remove BitPay Account?":"Remover conta do BitPay?","Remove BitPay Card?":"Remover cartão do BitPay?","Removing your BitPay account will remove all associated BitPay account data from this device. Are you sure you would like to remove your BitPay Account ({{email}}) from this device?":"Remover sua conta BitPay removerá todos os dados da conta associada ao BitPay neste dispositivo. Tem certeza que quer remover sua conta BitPay ({{email}}) deste dispositivo?","Repeat password":"Repetir Senha","Repeat the password":"Repita a nova senha","Request Fingerprint":"Solicitação de impressão digital","Request Specific amount":"Solicitar quantia exata","Request Spending Password":"Solicitar senha de pagamento","Required number of signatures":"Número necessário de assinaturas","Restore from backup":"Restaurar do backup","Retrieving inputs information":"Recuperando informações de entradas","Retry":"Repetir","Retry Camera":"Tentar Camera novamente","Save":"Salvar","Scan":"Digitalizar","Scan QR Codes":"Digitalizar códigos QR","Scan addresses for funds":"Pesquisando endereços por fundos","Scan again":"Escanear novamente","Scan your fingerprint please":"Escaneie sua impressão digital, por favor","Scanning Wallet funds...":"Pesquisando fundos de carteira…","Scanning funds...":"Pesquisando fundos...","Screenshots are not secure":"Capturas de Tela não são seguras","Search Transactions":"Procurar transações","Search or enter bitcoin address":"Procure ou digite o endereço bitcoin","Search transactions":"Procurar transações","Search your currency":"Procure a sua moeda","Security":"Segurança","See invoice":"Ver fatura","Select a backup file":"Selecione um arquivo de backup","Select a wallet":"Selecione uma carteira","Self-signed Certificate":"Certificado Auto-Assinado","Selling Qybcoin...":"Vendendo Qybcoin...","Send":"Enviar","Send Feedback":"Enviar Sugestão","Send Money":"Enviar Dinheiro","Send addresses by email":"Enviar endereços por e-mail","Send by email":"Enviar por E-mail","Send from":"Enviar De","Send max amount":"Quantidade Máxima de envio","Send payment to this address":"Enviar pagamento para este endereço","Send us feedback instead":"Em vez disso, Envie-nos comentários","Sending":"Enviando","Sending 2FA code...":"Enviando código 2FA...","Sending feedback...":"Enviando sugestão...","Sending maximum amount":"Quantidade máxima de envio","Sending transaction":"Enviando transação","Sending {{amountStr}} from your {{name}} wallet":"Enviando {{amountStr}} de sua carteira {{name}}","Sent":"Enviado","Sent Funds":"Enviar Fundos","Server response could not be verified":"Resposta do servidor não pôde ser verificada","Service not available":"Serviço indisponível","Services":"Serviços","Session Log":"Log da sessão","Session log":"Log da sessão","Set up a password":"Configure uma senha","Set your own fee in satoshis/byte":"Defina sua própria taxa em satoshis/byte","Settings":"Configurações","Share the love by inviting your friends.":"Compartilhe o amor convidando seus amigos.","Share this invitation with your copayers":"Compartilhe este convite com seus copayers","Share {{appName}}":"Compartilhar {{appName}}","Shared Wallet":"Compartilhar Carteira","Show Recovery Phrase":"Mostrar Frase de Recuperação","Show address":"Mostrar endereço","Show advanced options":"Mostrar opções avançadas","Show bitcoin address":"Mostrar endereço bitcoin","Show more":"Mostrar mais","Signatures rejected by server":"Assinaturas rejeitadas pelo servidor","Signing transaction":"Assinando Transação","Since only you control your money, you’ll need to save your backup phrase in case this app is deleted.":"Uma vez que só você controla o seu dinheiro, você precisará salvar sua frase de backup no caso deste app ser excluído.","Single Address Wallet":"Único endereço carteira","Skip":"Pular","Slide to accept":"Deslize para aceitar","Slide to buy":"Deslize para comprar","Slide to pay":"Deslize para pagar","Slide to send":"Deslize para enviar","Some of your wallets are not eligible for Qybcoin Cash support. You can try to access dmb funds from these wallets using the":"Algumas das suas carteiras não são elegíveis para suportar Qybcoin Cash. Você pode tentar acessar fundos dmb destas carteiras usando a","Specify Recovery Phrase...":"Especifique a frase de recuperação...","Spend proposal is not accepted":"A proposta de gasto não é aceita","Spend proposal not found":"Proposta de pagamento não encontrada","Spending Password needed":"Digitar a senha é necessária","Spending this balance will need significant Qybcoin network fees":"Gastar este balanço necessitará uma taxa de rede Qybcoin significativa","Start sending bitcoin":"Comece a enviar bitcoin","Startup Lock":"Bloqueio de Inicialização","Still pending":"Ainda pendente","Success":"Sucesso","Super Economy":"Super Econômico","Sweep":"Limpar","Sweep paper wallet":"Varrer a carteira de papel","Sweeping Wallet...":"Carteira de varredura...","THIS ACTION CANNOT BE REVERSED":"ESTA AÇÃO NÃO PODE SER REVERTIDA","Take control of your money,<br>get started with bitcoin.":"Assuma o controle de seu dinheiro, <br> começar com bitcoin.","Tap and hold to show":"Toque e mantenha para mostrar","Tap to recreate":"Toque para recriar","Tap to retry":"Bata para repetir","Terms Of Use":"Termos de uso","Terms of Use":"Termos de uso","Testnet":"Testnet","Text":"Texto","Thank you!":"Obrigado!","Thanks!":"Obrigado!","That's exciting to hear. We'd love to earn that fifth star from you – how could we improve your experience?":"Isso é emocionante de ouvir. Gostaríamos de ganhar essa quinta estrela de você - como poderíamos melhorar sua experiência?","The Ledger Chrome application is not installed":"O aplicativo Ledger Chrome não está instalado","The amount of bitcoin immediately spendable from this wallet.":"A quantidade de bitcoin imediatamente spendable desta carteira.","The amount of bitcoin stored in this wallet that is allocated as inputs to your pending transaction proposals. The amount is determined using unspent transaction outputs associated with this wallet and may be more than the actual amounts associated with your pending transaction proposals.":"A quantidade de bitcoin armazenada nesta carteira que é alocada como entradas para suas propostas de transação pendentes. O valor é determinado usando saídas de transação não utilizadas associadas a essa carteira e podem ser maiores do que os valores reais associados às suas propostas de transações pendentes.","The amount of bitcoin stored in this wallet with less than 1 blockchain confirmation.":"A quantidade de bitcoin armazenada nesta carteira com menos de 1 confirmação blockchain.","The derivation path":"O caminho de derivação","The exchange rate changes with the market.":"A taxa de câmbio muda com o mercado.","The higher the fee, the greater the incentive a miner has to include that transaction in a block. Current fees are determined based on network load and the selected policy.":"Quanto maior a taxa, maior o incentivo um mineiro tem que incluir essa transação em um bloco. As taxas atuais são determinadas com base na carga da rede e na política selecionada.","The maximum number of consecutive unused addresses (20) has been reached. When one of your unused addresses receives a payment, a new address will be generated and shown in your Receive tab.":"O número máximo de endereços não utilizados consecutivos (20) foi atingido. Quando um de seus endereços não utilizados recebe um pagamento, um novo endereço será gerado e mostrado na sua guia Receber.","The official English Terms of Service are available on the BitPay website.":"Os Termos de Serviço oficiais estão disponíveis no site BitPay.","The password of the recovery phrase (if set)":"A senha da frase de recuperação (se configurada)","The payment was created but could not be completed. Please try again from home screen":"O pagamento foi criado mas não pode ser completado. Por favor, tente novamente a partir da tela inicial.","The payment was removed by creator":"O pagamento foi removido pelo criador","The recovery phrase could require a password to be imported":"A frase de recuperação pode exigir que uma senha seja importada","The request could not be understood by the server":"O pedido não pôde ser entendido pelo servidor","The restore process will stop when 20 addresses are generated in a row which contain no funds. To safely generate more addresses, make a payment to one of the unused addresses which has already been generated.":"O processo de restauração irá parar quando 20 endereços são gerados em uma linha que não contêm fundos. Para gerar segurança mais endereços, fazer um pagamento a um dos endereços não utilizados que já foi gerado.","The spend proposal is not pending":"A proposta de gasto não está pendente","The total amount of bitcoin stored in this wallet.":"A quantidade total de bitcoin armazenado nesta carteira.","The transaction history and every new incoming transaction are cached in the app. This feature clean this up and synchronizes again from the server":"O histórico de transações e todas as novas transações recebidas são armazenados em cache no aplicativo. Este recurso limpa isso e sincroniza novamente a partir do servidor","The wallet service URL":"O URL do serviço carteira","There is a new version of {{appName}} available":"Existe uma nova versão do {{appName}} disponível","There is an error in the form":"Existe um erro no formulário","There's obviously something we're doing wrong.":"Obviamente há algo que estamos fazendo de errado.","This app is fantastic!":"Esta aplicação é fantástica!","This app stores your bitcoin with cutting-edge security.":"Este aplicativo armazena seu bitcoin com segurança de ponta.","This bitcoin payment request has expired.":"Este bitcoin pagamento pedido expirou.","This password cannot be recovered. If the password is lost, there is no way you could recover your funds.":"Esta senha não pode ser recuperada. Se a senha for perdida, não há nenhuma maneira que você poderia recuperar seus fundos.","This recovery phrase was created with a password. To recover this wallet both the recovery phrase and password are needed.":"Esta frase de recuperação foi criada com uma senha. Para recuperar esta carteira, tanto a frase de recuperação como a senha são necessárias.","This transaction amount is too small compared to current Qybcoin network fees. Spending these funds will need a Qybcoin network fee cost comparable to the funds itself.":"Este valor de transação é muito pequeno em comparação com as taxas de rede Qybcoin atuais. Gastar estes fundos terão uma taxa de rede Qybcoin maior do que o fundo em si.","This transaction could take a long time to confirm or could be dropped due to the low fees set by the sender":"Esta operação poderá demorar muito tempo para ser confirmada ou poderá ser descartada devido às baixas taxas definidas pelo remetente","This wallet is not registered at the given Bitcore Wallet Service (BWS). You can recreate it from the local information.":"Esta carteira não está registrada no dado serviço Wallet Service Bitcore (BWS) informado. Você pode recriá-la a partir da informação local.","Timeline":"Cronograma","To":"Para","To get started, buy bitcoin or share your address. You can receive bitcoin from any wallet or service.":"Para começar, compre bitcoins ou compartilhe seu endereço. Você pode receber bitcoins de qualquer carteira ou serviço.","To get started, you'll need to create a bitcoin wallet and get some bitcoin.":"Para começar, você precisa criar uma carteira de bitcoins e obter alguns bitcoins.","To {{reason}} you must first add your BitPay account - {{email}}":"Para {{reason}} você deve primeiro adicionar sua conta BitPay - {{email}}","Top up in progress...":"Recarga em andamento...","Top up {{amountStr}} to debit card ({{cardLastNumber}})":"Recarga de {{amountStr}} para cartão de débito ({{cardLastNumber}})","Total":"Total","Total Locked Balance":"Saldo Total Bloqueado","Total number of copayers":"Número total de copayers","Total wallet inputs":"Total de entradas da carteira","Touch ID Failed":"Falha no Touch ID","Transaction":"Transação","Transaction Created":"Transação Criada","Transaction History":"Histórico de Transações","Transaction already broadcasted":"Transação foi publicada","Transaction has not been created":"Transação não foi criada","Transaction initiated":"Transação iniciada","Transaction not available at this time":"Transação não está disponível neste momento","Transaction not found":"Transação não encontrada","Transactions without fee are not supported.":"Transações sem taxa não são suportadas.","Transfer to":"Transferir para","Transfer to Wallet":"Transferir para carteira","Try again in {{expires}}":"Tente novamente em {{expires}}","Turn bitcoin into dollars, swipe anywhere Visa<sup>®</sup> is accepted.":"Transforme bitcoin em dólares, deslize em qualquer lugar que Visa <sup>&reg;</sup> seja aceito.","Type the Recovery Phrase (usually 12 words)":"Digite a frase de recuperação (normalmente 12 palavras)","Uh oh...":"Uh oh...","Unconfirmed":"Não confirmado","Unsent transactions":"Transações não enviadas","Unused Addresses":"Endereços não utilizados","Unused Addresses Limit":"Limite de endereços não utilizados","Update Available":"Atualização Disponível","Updating pending proposals. Please stand by":"Atualizando propostas pendentes. Por favor, aguarde","Updating transaction history. Please stand by.":"Atualizando o histórico de transações. Por favor, aguarde.","Updating... Please stand by":"Atualizando... Por favor, aguarde","Urgent":"Urgente","Use Unconfirmed Funds":"Utilizar fundos não confirmados","Validating recovery phrase...":"Validando a frase de recuperação...","Verify your identity":"Verifique a sua identidade","Version":"﻿Versão","View":"Ver","View All Addresses":"Ver todos os endereços","View Terms of Service":"Ver os Termos de Serviço","View Transaction on Insight":"Exibir Transação no Insight","View Update":"Ver atualizações","View on blockchain":"Ver no blockchain","Visit mercadolivre.com.br &rarr;":"Visite mercadolivre.com.br &rarr;","WARNING: Key derivation is not working on this device/wallet. Actions cannot be performed on this wallet.":"Aviso: Derivação de chave não está funcionando neste dispositivo/carteira. Ações não podem ser executadas nesta carteira.","WARNING: Not including the private key allows to check the wallet balance, transaction history, and create spend proposals from the export. However, does not allow to approve (sign) proposals, so <b>funds will not be accessible from the export</b>.":"ATENÇÃO: Não incluir a chave privada permite verificar o saldo da carteira, o histórico de transações e criar propostas de gastos a partir da exportação. No entanto, não permite aprovar (assinar) propostas, assim <b>fundos não serão acessíveis a partir da exportação</b>.","WARNING: The private key of this wallet is not available. The export allows to check the wallet balance, transaction history, and create spend proposals from the export. However, does not allow to approve (sign) proposals, so <b>funds will not be accessible from the export</b>.":"ATENÇÃO: A chave privada desta carteira não está disponível. A exportação permite verificar o saldo da carteira, o histórico de transações e criar propostas de gastos a partir da exportação. No entanto, não permite aprovar (assinar) propostas, assim <b>fundos não serão acessíveis a partir da exportação</b>.","WARNING: UNTRUSTED CERTIFICATE":"AVISO: CERTIFICADO NÃO CONFIÁVEL","WARNING: Your extended private keys are all that is needed to access your bitcoin funds. Be sure to protect your private keys and store them only on secure devices. BitPay does not have access to your private keys, so you alone are responsible for your keys. If you share key access with external services, you take responsibility for the risk of theft or breach. Only advanced users should handle extended private keys directly.":"Aviso: Suas chaves privadas estendidas são tudo que é necessário para acessar seus fundos bitcoin. Certifique-se de proteger suas chaves privadas e armazená-las somente em dispositivos seguros. BitPay não tem acesso às suas chaves privadas, então você é responsável pelas suas chaves. Se você compartilhar a chave de acesso com serviços externos, responsabilize-se pelo risco de roubo ou violação. Apenas usuários avançados devem lidar com chaves privadas estendidas diretamente.","Waiting for Ledger...":"Esperando por Ledger...","Waiting for Trezor...":"Esperando por Trezor...","Waiting for copayers":"Aguardando copayers","Waiting...":"Aguardando…","Wallet Addresses":"Endereços da carteira","Wallet Color":"Cor da carteira","Wallet Configuration (m-n)":"Configuração da carteira (m-n)","Wallet Created":"Carteira criada","Wallet Id":"Id da carteira","Wallet Information":"Informações da carteira","Wallet Inputs":"Entradas da carteira","Wallet Invitation":"Convite para Carteira","Wallet Key":"Chave da carteira","Wallet Name":"Nome da carteira","Wallet Name (at creation)":"Nome da carteira (na criação)","Wallet Network":"Network da carteira","Wallet Recovery Phrase":"Frase de recuperação da carteira","Wallet Recovery Phrase is invalid":"Frase de recuperação da carteira é inválida","Wallet Service URL":"URL do serviço de carteira","Wallet Settings":"Configurações da carteira","Wallet Type":"Tipo da carteira","Wallet already exists":"A carteira já existe","Wallet already in {{appName}}":"Carteira já existente no {{appName}}","Wallet created":"Carteira criada","Wallet incomplete and broken":"Carteira incompleta e quebrada","Wallet is full":"Carteira está cheia","Wallet is locked":"Carteira está bloqueada","Wallet is not complete":"Carteira não está completa","Wallet name":"Nome da carteira","Wallet needs backup":"Carteira precisa de backup","Wallet not backed up":"Carteira sem backup","Wallet not found":"Carteira não encontrada","Wallet not registered":"Carteira não registrada","Wallet not registered at the wallet service. Recreate it from \"Create Wallet\" using \"Advanced Options\" to set your recovery phrase":"Carteira não registrada no serviço de carteira. Recriá-la em \"Criar carteira\" usando \"Opções avançadas\" para definir a sua frase de recuperação","Wallet recovery phrase not available":"Frase de recuperação da carteira não disponível","Wallet service not found":"Serviço de carteira não encontrado","Wallets":"Carteiras","Warning!":"Atenção!","Warning: this transaction has unconfirmed inputs":"Aviso: esta transação tem entradas não confirmadas","Watch out!":"Cuidado!","We'd love to do better.":"Nós adoraríamos fazer melhor.","We'll confirm on the next screen.":"Confirmaremos na próxima tela.","We're always looking for ways to improve {{appName}}.":"Estamos sempre procurando maneiras de melhorar o {{appName}}.","We're always looking for ways to improve {{appName}}. How could we improve your experience?":"Estamos sempre procurando maneiras de melhorar o {{appName}}. Como melhorar sua experiência?","Website":"Página da Web","We’re always looking for translation contributions! You can make corrections or help to make this app available in your native language by joining our community on Crowdin.":"Estamos sempre procurando por contribuições de tradução! Você pode fazer correções ou ajudar a tornar este app disponível em seu idioma nativo ao aderir à nossa comunidade na Crowdin.","What do you call this wallet?":"Como você chama essa carteira?","When this wallet was created, it was called “{{walletName}}”. You can change the name displayed on this device below.":"Quando esta carteira foi criada, foi chamada de &ldquo;{{walletName}}&rdquo;. Abaixo você poderá alterar o nome exibido neste dispositivo.","Where would you like to receive email notifications about payments?":"Onde você gostaria de receber os e-mails de notificações sobre os pagamentos?","Why?":"Por quê?","Would you be willing to rate {{appName}} in the app store?":"Você estaria disposto a dar uma nota ao {{appName}} na app store?","Would you like to receive push notifications about payments?":"Gostaria de receber notificações push sobre pagamentos?","Wrong number of recovery words:":"Número errado de palavras de recuperação:","Wrong spending password":"Senha de gastos errada","Yes":"Sim","Yes, skip":"Sim, pule","You can create a backup later from your wallet settings.":"Você poderá criar um backup de suas configurações de carteira mais tarde.","You can make contributions by signing up on our Crowdin community translation website. We’re looking forward to hearing from you!":"Você pode fazer contribuições inscrevendo-se no nosso site da comunidade de tradução Crowdin. Estamos ansiosos para ouvir de você!","You can scan bitcoin addresses, payment requests, paper wallets, and more.":"Você pode escanear endereços bitcoins, pedidos de pagamento carteiras de papel e muito mais.","You can see the latest developments and contribute to this open source app by visiting our project on GitHub.":"Você pode ver os mais recentes desenvolvimentos e contribuir para este aplicativo de código aberto, visitando nosso projeto no GitHub.","You can spend bitcoin at millions of websites and stores worldwide.":"Você pode gastar bitcoins em milhões de sites e lojas em todo o mundo.","You can still export it from Advanced &gt; Export.":"Você ainda pode exportá-la em Avançado &gt; Exportar.","You can trade it for other currencies like US Dollars, Euros, or Pounds.":"Você pode trocá-lo por outras moedas como dólares americanos, Euros ou libras.","You control your bitcoin.":"Você controla o seu bitcoin.","You should not set a fee higher than {{maxFeeRecommended}} satoshis/byte.":"Você não deve definir uma taxa maior do que {{maxFeeRecommended}} satoshis/byte.","You will need to log back for fill in your BitPay Card.":"Você precisará entrar de novo para completar seu BitPay Card.","You'll receive email notifications about payments sent and received from your wallets.":"Você receberá notificações por e-mail sobre pagamentos enviados e recebidos de suas carteiras.","Your BitPay Card is ready. Add funds to your card to start using it at stores and ATMs worldwide.":"Seu BitPay Card está pronto. Adicione fundos ao seu cartão para começar a usá-lo em lojas e caixas eletrônicos em todo o mundo.","Your Gift Cards":"Seus Vales-Presente","Your bitcoin wallet is backed up!":"O backup de sua carteira de bitcoins está feito!","Your bitcoin wallet is ready!":"Sua carteira de bitcoins está pronta!","Your fee is lower than recommended.":"Sua taxa é mais baixa do que a recomendada.","Your ideas, feedback, or comments":"Suas ideias, comentários ou observações","Your name":"Seu nome","Your nickname":"Seu apelido","Your password":"Sua senha","Your purchase could not be completed":"Sua compra não pôde ser concluída","Your purchase was added to the list of pending":"Sua compra foi adicionada à lista de pendências","Your wallet is never saved to cloud storage or standard device backups.":"Sua carteira nunca foi salva num armazenamento em nuvem ou dispositivo padrão de backups.","Your wallet key will be encrypted. The Spending Password cannot be recovered. Be sure to write it down.":"Sua chave da carteira será criptografada. A senha de gastos não poderá ser recuperada. Não se esqueça de anotá-la.","[Balance Hidden]":"[Valores escondidos]","[Scanning Funds]":"[Pesquisando fundos]","add your BitPay Visa card(s)":"Adicionar seu(s) cartão(ões) BitPay Visa","locked by pending payments":"bloqueado por pagamentos pendentes","me":"eu","name@example.com":"nome@exemplo.pt","preparing...":"a preparar...","recovery tool.":"ferramenta de recuperação.","{{amountStr}} for Amazon.com Gift Card":"{{amountStr}} em Vale-Presente da Amazon.com","{{amountStr}} for Mercado Livre Brazil Gift Card":"{{amountStr}} em Vale-Presente do Mercado Livre Brasil","{{appName}} depends on Bitcore Wallet Service (BWS) for blockchain information, networking and Copayer synchronization. The default configuration points to https://bws.bitpay.com (BitPay's public BWS instance).":"{{appName}} depende do Bitcore Wallet Service (BWS) para informações sobre cadeias de blocos, rede e sincronização Copayer. A configuração padrão aponta para https://bws.bitpay.com (instância pública BWS do BitPay).","{{fee}} will be deducted for bitcoin networking fees.":"{{fee}} será deduzido para taxas de rede bitcoins.","{{tx.txp[wallet.id].feeRatePerStr}}  of the sending amount":"{{tx.txp[wallet.id].feeRatePerStr}} da quantidade de envio","{{updatingTxHistoryProgress}} transactions downloaded":"Transações de {{updatingTxHistoryProgress}} transferidas","{{wallet.m}}-of-{{wallet.n}}":"{{wallet.m}}-de-{{wallet.n}}"});
    gettextCatalog.setStrings('ru', {"(Trusted)":"(Доверенный)","(possible double spend)":"(возможна двойная трата)","* A payment proposal can be deleted if 1) you are the creator, and no other copayer has signed, or 2) 24 hours have passed since the proposal was created.":"* Предложенный платёж может быть удалён если 1) вы создали этот платёж и никто его еще не подписал, или 2) если прошло более 24 часов с момента его создания.","- {{btx.feeRateStr}} of the transaction":"{{feeRateStr}} транзакции","5-star ratings help us get {{appName}} into more hands, and more users means more resources can be committed to the app!":"=896t7!","A member of the team will review your feedback as soon as possible.":"Участник команды рассмотрит ваш отзыв при первой возможности.","A total of {{amountAboveMaxSizeStr}} were excluded. The maximum size allowed for a transaction was exceeded.":"Всего {{amountAboveMaxSizeStr}} было исключено. Превышен максимальный размер, разрешенный для транзакции.","A total of {{amountBelowFeeStr}} were excluded. These funds come from UTXOs smaller than the network fee provided.":"Примечание: в общей сложности {{amountBelowFeeStr}} было исключено. Эти средства входят поступившие в UTXOs меньше чем комиссия сети.","About":"О проекте","Accepted":"Принято","Account":"Учётная запись","Account Number":"Номер учётной записи","Accounts":"Аккаунты","Activity":"Активность","Add Account":"Добавить учётную запись","Add BitPay Account?":"L; pkoi[jpiouhouihuiykjb jvgbgyfcthgfvjyuhnij; okml',./; lkmjnhbg v?","Add Contact":"Добавить контакт","Add Funds":"Пополнить счёт","Add Memo":"Добавить памятку","Add a password":"Защитить паролем","Add account":"gfhcdtgfdth","Add an optional password to secure the recovery phrase":"Добавьте необязательный пароль для защиты ключевого словосочетания","Add as a contact":"Добавить контакт","Add description":"Добавить описание","Add funds":"Пополнить счёт","Add wallet":"Добавить кошелёк","Address":"Адрес","Address Book":"Aдресная книга","Address Type":"Тип адреса","Addresses With Balance":"Адреса с балансом","Advanced":"Дополнительные возможности","Advanced Settings":"Расширенные настройки","All":"Все","All Addresses":"Все адреса","All of your bitcoin wallet balance may not be available for immediate spending.":"В данный момент весь баланс вашего кошелька может быть недоступен для совершения платежей.","All signing devices must be added to this multisig wallet before bitcoin addresses can be created.":"Все совладельцы должны быть добавлены в этот общий кошелек, прежде чем можно будет получать переводы.","Allow Camera Access":"Разрешить доступ к камере","Allow notifications":"Разрешить уведомления","Almost done! Let's review.":"Почти готово! Давайте проверим.","Alternative Currency":"Альтернативная валюта","Amount":"Сумма","Amount below minimum allowed":"Сумма ниже допустимого минимума","Amount too big":"Слишком большая сумма","An update to this app is available. For your security, please update to the latest version.":"Доступно обновление. Для вашей же безопасности, пожалуйста, обновитесь до последней версии.","Anyone with your backup phrase can access or spend your bitcoin.":"Любой, у кого есть доступ к вашему ключевому словосочетанию, может потратить ваши биткойны.","Are you being watched?":"За вами сейчас кто-нибудь смотрит?","Are you being watched? Anyone with your recovery phrase can access or spend your bitcoin.":"За вами подглядывают? Любой у кого есть ваша фраза восстановления может получить или потратить ваши биткойны.","Are you sure you want to cancel and delete this wallet?":"Вы точно хотите отменить и удалить этот кошелёк?","Are you sure you want to delete this contact?":"Вы действительно хотите удалить этот контакт?","Are you sure you want to delete this wallet?":"Вы точно хотите удалить этот кошелёк?","Are you sure you want to reject this transaction?":"Вы точно хотите отклонить этот платёж?","Are you sure you want to remove this transaction?":"Вы точно хотите удалить эту транзакцию?","Are you sure you want to skip it?":"Вы точно хотите пропустить резервное копирование?","Are you sure you would like to remove your BitPay Card ({{lastFourDigits}}) from this device?":"Вы уверены, что вы хотели бы удалить карточку BitPay Card ({{lastFourDigits}}) из этого устройства?","Auditable":"Проверяемый","Available":"Доступно","Available Balance":"Доступный баланс","Average confirmation time":"Среднее время подтверждения","BIP32 path for address derivation":"Укажите BIP32 для генерации адресов","Backup":"Резервное копирование","Backup Needed":"Требуется резервное копирование","Backup all livenet wallets before using this function":"Сделайте резервную копию всех livenet кошельков перед использованием этой функции","Backup needed":"Требуется резервное копирование","Backup now":"Создать резервную копию","Backup wallet":"Резервное копирование","Backup your wallet before using this function":"Сделайте резервную копию вашего кошелька перед использованием этой функции","Bad wallet invitation":"Недействительное приглашение","Balance By Address":"Баланс на адресах","Be sure to store your recovery phrase in a secure place. If this app is deleted, your money cannot be recovered without it.":"Сохраните ваше ключевое словосочетание в безопасном месте. Если {{appName}} будет удален, ваши деньги нельзя будет восстановить без ключевого словосочетания.","BitPay Visa® Cards":"BitPay Visa® картыllllll","Qybcoin Address":"Биткойн-адрес","Qybcoin Network Fee Policy":"Политика комиссии сети Биткойн","Qybcoin is a currency.":"Биткойн - это валюта.","Qybcoin is different – it cannot be safely held with a bank or web service.":"Qybcoin is different &ndash; it cannot be safely held with a bank or web service.","Qybcoin is secure,<br>digital money.":"Биткойн это безопасные,<br>цифровые деньги.","Qybcoin transactions include a fee collected by miners on the network.":"Qybcoin transactions include a fee collected by miners on the network.","Broadcast Payment":"Отправить платёж","Broadcasted":"Отправка","Broadcasting transaction":"Отправка транзакции","Browser unsupported":"Браузер не поддерживается","Buy":"Купить","Buy &amp; Sell Qybcoin":"Купить &amp; продать биткойн","Buy Qybcoin":"Купить биткойн","Buy a Gift Card":"Купить подарочную карту","Buy from":"Купить","Buying Qybcoin...":"Покупка биткойн...","Calculating fee":"Вычисление комиссии","Cancel":"Отмена","Cancel invitation":"Отменить приглашение?","Cannot Create Wallet":"Не удаётся создать кошелёк","Cannot join the same wallet more that once":"Нельзя присоединиться к одному и тому же кошельку более одного раза","Cards":"Карты","Certified by":"Сертифицирован","Check installation and retry.":"Проверьте установку и повторите попытку.","Choose a backup file from your computer":"Выберите файл резервной копии","Choose your destination wallet":"Выберите целевой кошелёк","Choose your source wallet":"Выберите исходный кошелёк","Clear":"Очистить","Clear cache":"Очистить кэш","Click to accept":"Подтвердить","Click to pay":"Оплатить","Click to send":"Отправить","Close":"Закрыть","Color":"Цвет","Commit hash":"Хэш версии","Complete the backup process to use this option":"Завершите процесс резервного копирования для использования этой опции","Completed":"Завершено","Confirm":"Подтвердить","Confirm &amp; Finish":"Подтвердить &amp; Завершить","Confirm purchase":"Подтвердить покупку","Confirm your PIN":"Подтвердите Ваш PIN-код","Confirm your new spending password":"Подтвердите ваш новый платёжный пароль","Confirmations":"Подтверждения","Confirming":"Ожидает подтверждения","Connect my BitPay Card":"Подключить мою BitPay Card","Connecting to Coinbase...":"Подключение к Coinbase...","Connecting to Glidera...":"Подключение к Glidera...","Connection reset by peer":"Соединение сброшено другой стороной","Contacts":"Контакты","Continue":"Продолжить","Contribute Translations":"Помочь в переводе","Copayer already in this wallet":"Совладелец кошелька уже присоединился","Copayer already voted on this spend proposal":"Совладелец уже проголосовал по этому платежу","Copayer data mismatch":"Несоответствие данных совладельца кошелька","Copayer joined":"Совладелец присоединился","Copayer {{$index}}":"Совладелец {{$index}}","Copied to clipboard":"Скопировано в буфер обмена","Copy this text as it is to a safe place (notepad or email)":"Скопируйте этот текст как есть (в блокнот или письмо)","Copy to clipboard":"Скопировать в буфер обмена","Could not access the wallet at the server. Please check:":"Не удалось получить доступ к кошельку на сервере. Проверьте, пожалуйста:","Could not access wallet":"Не удалось получить доступ к кошельку","Could not add message to imported wallet without shared encrypting key":"Не удалось добавить сообщение в импортированный кошелёк без общего ключа шифрования","Could not broadcast payment":"Не удалось отправить платёж","Could not build transaction":"Не удалось создать транзакцию","Could not create address":"Не удалось создать адрес","Could not create using the specified extended private key":"Не удалось создать используя указанный расширенный закрытый ключ","Could not create using the specified extended public key":"Не удалось создать используя указанный расширенный открытый ключ","Could not create: Invalid wallet recovery phrase":"Не удалось создать: недействительное ключевое словосочетание","Could not decrypt file, check your password":"Не удалось расшифровать файл, проверьте пароль","Could not delete payment proposal":"Не удалось удалить предложенный платёж","Could not get dynamic fee":"Не удалось получить динамическую комиссию","Could not get dynamic fee for level: {{feeLevel}}":"Не удалось получить динамическую комиссию для уровня: {{feeLevel}}","Could not get transactions":"Не удалось получить транзакции","Could not import":"Не удалось импортировать","Could not import. Check input file and spending password":"Не удалось импортировать. Проверьте импортируемый файл и платёжный пароль","Could not join wallet":"Не удалось присоединиться к кошельку","Could not reject payment":"Не удалось отклонить платёж","Could not remove account":"Не удалось удалить аккаунт","Could not remove card":"Не удалось удалить карту","Could not save preferences on the server":"Не удалось сохранить параметры на сервере","Could not send payment":"Не удалось отправить платёж","Could not update transaction history":"Не удалось обновить журнал транзакций","Could not update wallet":"Не удалось обновить кошелёк","Create Personal Wallet":"Создать личный кошелёк","Create Shared Wallet":"Создать общий кошелёк","Create bitcoin wallet":"Создать биткойн-кошелёк","Create new wallet":"Создать новый кошелёк","Create shared wallet":"Создать общий кошелёк","Create {{formData.requiredCopayers}}-of-{{formData.totalCopayers}} wallet":"Создать кошелёк {{formData.requiredCopayers}}-из-{{formData.totalCopayers}}","Created by":"Создан","Creating Wallet...":"Создание кошелька...","Creating transaction":"Создание транзакции","Current fee rate for this policy":"Текущая комиссия для этой политики","Custom Amount":"Сумма","Date":"Дата","Delete":"Удалить","Delete Payment Proposal":"Удалить предложенный платёж","Delete Wallet":"Удалить кошелёк","Delete it and create a new one":"Удалите и создайте заново","Deleting Wallet...":"Удаление кошелька...","Deleting payment proposal":"Удаление предложенного платежа","Derivation Path":"Путь деривации","Derivation Strategy":"Стратегия деривации","Details":"Подробности","Disabled":"Отключено","Do it later":"Отложить","Do not include private key":"Не включать закрытый ключ","Don't see your language on Crowdin? Contact the Owner on Crowdin! We'd love to support your language.":"Не видите свой язык на Crowdin? Свяжитесь с владельцем по Crowdin! Мы с удовольствием поддержим ваш язык.","Download":"Скачать","Each bitcoin wallet can generate billions of addresses from your 12-word backup. A new address is automatically generated and shown each time you receive a payment.":"Любой биткойн-кошелёк может создать миллиарды адресов из вашей ключевой фразы. Новый адрес автоматически генерируется каждый раз, когда вы получаете платеж.","Economy":"Экономичная","Edit":"Редактировать","Email":"Email","Email Address":"Email","Empty addresses limit reached. New addresses cannot be generated.":"Достигнут предел пустых адресов. Новые адреса больше не могут быть сгенерированы.","Enable camera access in your device settings to get started.":"Чтобы начать, разрешите доступ к камере в настройках вашего устройства.","Enable email notifications":"Включить email-уведомления","Enable push notifications":"Включить push-уведомления","Enable the camera to get started.":"Чтобы начать, включите камеру.","Enter Spending Password":"Введите платёжный пароль","Enter Two Factor for your BitPay account":"Введите второй фактор вашей учётной записи BitPay","Enter amount":"Введите сумму","Enter new spending password":"Введите новый платёжный пароль","Enter the recovery phrase (BIP39)":"Введите ключевое словосочетание (BIP39)","Enter your email":"Введите Ваш email","Enter your password":"Введите пароль","Error":"Ошибка","Error at confirm":"Ошибка при подтверждении","Error creating gift card":"Ошибка создания Подарочной карты","Error creating wallet":"Ошибка создания кошелька","Error scanning funds:":"Ошибка сканирования кошелька:","Error sweeping wallet:":"Ошибка считывания кошелька:","Error updating Debit Cards":"Ошибка обновления Дебетовых Карт","Exceeded daily limit of $500 per user":"Превышен дневной лимит в 500$ на пользователя","Expired":"Истекла","Expires":"истёк","Export Wallet":"Экспорт кошелька","Export to file":"Экспорт в файл","Export wallet":"Экспорт кошелька","Exporting via QR not supported for this wallet":"Экспорт QR-кодом не поддерживается для этого кошелька","Extended Public Keys":"Расширенные открытые ключи","Failed to export":"Не удалось экспортировать","Family vacation funds":"Отпускной бюджет","Fee":"Комиссия","Fee:":"Комиссия:","Feedback could not be submitted. Please try again later.":"Отзыв не может быть отправлен. Пожалуйста, попробуйте позже.","Fetching BitPay Account...":"Подключение учетной записи BitPay...","File/Text":"Файл/текст","Filter setting":"Настройка фильтров","Finger Scan Failed":"Не удалось сканировать отпечаток пальца","Finish":"Готово","For audit purposes":"Для целей ревизии","From":"От","From BitPay account":"С аккаунта BitPay","From the destination device, go to Add wallet &gt; Import wallet and scan this QR code":"На целевом устройстве выберите \"Добавить кошелёк\" &gt; \"Импорт кошелька\" и отсканируйте этот QR-код","Funds are locked by pending spend proposals":"Средства заблокированы предложенным платежом","Funds found:":"Обнаружены средства:","Funds transferred":"Средства переведены","Funds will be transferred to":"Средства будут переведены на","Generate new address":"Сгенерировать новый адрес","Generating .csv file...":"Создание .сsv-файла...","Generating new address...":"Генерация нового адреса...","Get local cash anywhere you go, from any Visa<sup>®</sup> compatible ATM. ATM bank fees may apply.":"Получайте местную валюту везде, где есть банкоматы с поддержкой карт Visa<sup>&reg;</sup>. Банком может взиматься комиссия.","Get news and updates from BitPay":"Получать письма с новостями от BitPay","Get started":{"$$noContext":"Начать","button":"Начать"},"Get started by adding your first one.":"Начните, добавив первый контакт.","Getting fee levels...":"Получение информации о комиссиях...","Go Back":"Вернуться","Go back":"Вернуться","Got it":"Понял","Hardware Wallet":"Аппаратный кошелёк","Hardware not connected.":"Аппаратное обеспечение не подключено.","Hardware wallet":"Аппаратный кошелёк","Help & Support":"Помощь и поддержка","Help and support information is available at the website.":"Информация о помощи и поддержке доступна на сайте.","Hide":"Спрятать","Hide Balance":"Скрыть баланс","Hide Next Steps Card":"Пропустить следующие шаги","Hide advanced options":"Скрыть дополнительные параметры","Home":"Обзор","How could we improve your experience?":"Как мы можем улучшить ваши навыки?","How do you like {{appName}}?":"Как Вам нравится {{appName}}?","I don't like it":"Приложение не нравится","I have read, understood, and agree to the <a ng-click=\"openTerms()\" translate=\"\">Terms of Use</a>.":"Я прочитал, понял, и соглашаюсь с <a ng-click=\"openTerms()\" translate=\"\">Условиями использования</a>.","I have read, understood, and agree with the Terms of use.":"Я прочитал, понял, и соглашаюсь с Условиями использования.","I have written it down":"Я записал","I like the app":"Приложение нравится","I think this app is terrible.":"Ужасное приложение.","I understand":"Я понимаю","I understand that if this app is moved to another device or deleted, my bitcoin can only be recovered with the backup phrase.":"Я осознаю, что если {{appName}} будет перемещён на другое устройство, или удален, мои биткойны будут восстановимы только с помощью ключевого словосочетания.","I understand that my funds are held securely on this device, not by a company.":"Я понимаю, что мои средства безопасно хранятся на устройстве, а не компанией.","I've written it down":"Я записал","If enabled, all sensitive information (private key and recovery phrase) and actions (spending and exporting) associated with this wallet will be protected.":"Если включено, вся конфиденциальная информация (секретный ключ и фраза для восстановления) и действия (расходы и экспорт) связанные с этим кошельком будут защищены.","If enabled, the Recent Transactions card - a list of transactions occuring across all wallets - will appear in the Home tab.":"Если этот параметр включен, на вкладке Обзор будет отображаться список транзакций из всех кошельков.","If enabled, wallets will also try to spend unconfirmed funds. This option may cause transaction delays.":"Если этот параметр включен, {{appName}} будет пытаться тратить неподтверждённые средства, что может привезти к задержкам подтверждения транзакций.","If this device is replaced or this app is deleted, neither you nor BitPay can recover your funds without a backup.":"Если это устройство будет заменено, или если {{appName}} будет удален, ни вы, ни BitPay не смогут восстановить доступ к вашим деньгам без резервной копии.","If you have additional feedback, please let us know by tapping the \"Send feedback\" option in the Settings tab.":"Если вы хотите что-то ещё нам сообщить, пожалуйста, нажмите \"Отправить отзыв\" в разделе Параметры.","If you take a screenshot, your backup may be viewed by other apps. You can make a safe backup with physical paper and a pen.":"Если вы сохраните скриншот, ваша резервная копия может быть просмотрена другими приложениями. Безопасный способ резервного копирования - ручка и бумага.","Import":"Импорт","Import Wallet":"Импорт кошелька","Import backup":"Импорт резервной копии","Import wallet":"Импортировать кошелёк","Importing Wallet...":"Импортирование кошелька...","In order to verify your wallet backup, please type your password.":"Для проверки резервной копии требуется ввести пароль.","Incomplete":"Не все совладельцы присоединились","Incomplete wallet":"Не все совладельцы присоединились","Incorrect PIN, try again.":"Неверный PIN-код, попробуйте снова.","Incorrect code format":"Некорректный формат QR-кода","Insufficient funds":"Недостаточно средств","Insufficient funds for fee":"Недостаточно средств на комиссию","Invalid":"Недействительно","Invalid URL":"Неверный URL","Invalid account number":"Недопустимый номер учётной записи","Invalid address":"Неверный адрес","Invalid data":"Недопустимые данные","Invalid derivation path":"Недействительный путь деривации","Invitation to share a {{appName}} Wallet":"Приглашение присоединиться к кошельку {{appName}}","Is there anything we could do better?":"Есть ли что-то, что мы могли бы сделать лучше?","Is this correct?":"Правильно?","Is this email address correct?":"Это правильный email?","It's a good idea to avoid reusing addresses - this both protects your privacy and keeps your bitcoins secure against hypothetical attacks by quantum computers.":"Не используйте адреса повторно - это защитит вашу конфиденциальность и сохранит ваши биткойны в безопасности от возможных атак на квантовых компьютерах.","It's important that you write your backup phrase down correctly. If something happens to your wallet, you'll need this backup to recover your money. Please review your backup and try again.":"Крайне важно правильно записать ваше ключевое словосочетание. Оно понадобится для восстановления доступа к деньгам, если что-то случится с вашим кошельком. Пожалуйста, перепроверьте записанное и попробуйте ещё раз.","Join":"Присоединиться","Join my {{appName}} Wallet. Here is the invitation code: {{secret}} You can download {{appName}} for your phone or desktop at {{appUrl}}":"Присоединяйся к моему кошельку {{appName}}. Код приглашения: {{secret}} Ты можешь загрузить {{appName}} для своего телефона или настольного компьютера на сайте {{appUrl}}","Join shared wallet":"Присоединиться к общему кошельку","Joining Wallet...":"Присоединение к кошельку...","Just scan the code to pay.":"Для совершения оплаты достаточно отсканировать QR-код.","Key already associated with an existing wallet":"Ключ уже связан с существующим кошельком","Language":"Язык","Last Month":"Прошедший месяц","Let's verify your backup phrase.":"Давайте проверим ваше ключевое словосочетание.","Loading addresses...":"Загрузка адресов...","Loading transaction info...":"Загрузка транзакции...","Lock App":"Заблокировать приложение","Lock by Fingerprint":"Заблокировать отпечатком пальца","Lock by PIN":"Заблокировать PIN-ом","Locked":"Заблокировано","Locktime in effect. Please wait to create a new spend proposal":"Действует блокировка. Пожалуйста, подождите, чтобы предложить новый платёж","Locktime in effect. Please wait to remove this spend proposal":"Действует блокировка. Пожалуйста, подождите, чтобы удалить предложенный платёж","Log out":"Bыйти","Low fees":"Маленькая комиссия","Makes sense":"Вполне разумно","Matches:":"Совпадения:","Me":"Я","Meh - it's alright":"Ну так, терпимо","Memo":"Памятка","Merchant Message":"Сообщение от продавца","Missing parameter":"Недостающий параметр","Missing private keys to sign":"Отсутствуют закрытые ключи для подписи","More Options":"Дополнительные параметры","Moved":"Перемещено","Moved Funds":"Перемещённые средства","Multiple recipients":"Несколько получателей","NOTE: To import a wallet from a 3rd party software, please go to Add Wallet &gt; Create Wallet, and specify the Recovery Phrase there.":"Примечание: для импортирования кошелька из другой программы откройте \"Добавить кошелёк\" &gt; \"Создать личный кошелёк\", и укажите там ключевое словосочетание.","Name":"Название","Network error":"Ошибка сети","New Proposal":"Предложить платёж","New address could not be generated. Please try again.":"Адрес не может быть сгенерирован. Попробуйте позже.","New personal wallet":"Новый личный кошелёк","Next steps":"Дальнейшие шаги","No Wallet":"Нет кошельков","No backup, no bitcoin.":"Нет резервной копии - нет биткойнов.","No contacts yet":"Нет контактов","No hardware information available.":"Информация об аппаратном обеспечении отсутствует.","No hardware wallets supported on this device":"Аппаратные кошельки не поддерживаются на этом устройстве","No pending proposals":"Нет предложенных платежей","No recent transactions":"Нет недавних транзакций","No transactions yet":"Транзакций пока не было","No wallet found":"Кошельки не обнаружены","No wallet selected":"Не выбран кошелёк","No wallets available to receive funds":"Некуда перевести средства","Normal":"Обычная","Not authorized":"Не авторизован","Not enough funds for fee":"Недостаточно средств для уплаты комиссии","Not even BitPay can access it.":"BitPay не сможет получить доступ самостоятельно.","Not funds found":"Cредства не обнаружены","Not now":"Потом","Note":"Примечание","Notice: only 1-1 (single signature) wallets can be used for sell bitcoin":"Внимание: только 1-1 кошельки (требующие одной подписи) могут быть использованы для продажи биткойн","Notifications":"Уведомления","Now is a good time to backup your wallet. If this device is lost, it is impossible to access your funds without a backup.":"Если это устройство окажется утеряно, без резервной копии будет невозможно восстановить доступ к деньгам. Самое время создать резервную копию.","Now is a perfect time to assess your surroundings. Nearby windows? Hidden cameras? Shoulder-spies?":"Самое время оценить окружение. Окна поблизости? Скрытые камеры? Плечешпионы?","OK":"ХОРОШО","OKAY":"ХОРОШО","Official English Disclaimer":"Официальный оригинал","Oh no!":"О, нет!","On this screen you can see all your wallets, accounts, and assets.":"На этой вкладке вы можете видеть все ваши кошельки, учетные записи и активы.","Open":"Открыть","Open Crowdin":"Открыть Crowdin","Open GitHub":"Открытые GitHub","Open GitHub Project":"Откройте проект GitHub","Open Insight":"Открыть Insight","Open Settings":"Открыть Параметры","Open Translation Community":"Редактировать перевод","Open Website":"Перейти на сайт","Open wallet":"Открыть кошелёк","Open website":"Открыть сайт","Order the BitPay Card":"Заказать BitPay Card","Password":"Пароль","Password required. Make sure to enter your password in advanced options":"Необходим пароль. Убедитесь, что вы ввели ваш пароль в дополнительных настройках","Paste invitation here":"Вставьте приглашение сюда","Paste the backup plain text code":"Вставьте код резервной копии обычным текстом","Pay 0% fees to turn bitcoin into dollars.":"Платите нулевую комиссию за конвертацию биткойн в доллары США.","Pay To":"Отправить платёж","Payment Accepted":"Платёж принят","Payment Expires:":"Платёж истекает:","Payment Proposal":"Предложенный платёж","Payment Proposal Created":"Платёж предложен","Payment Proposals":"Предложенные платежи","Payment Protocol Invalid":"Недействительный протокол оплаты","Payment Protocol not supported on Chrome App":"Платёжный протокол не поддерживается в приложении Chrome","Payment Received":"Платёж получен","Payment Rejected":"Платёж отклонён","Payment Sent":"Платёж отправлен","Payment accepted, but not yet broadcasted":"Платёж принят, но пока не отправлен","Payment accepted. It will be broadcasted by Glidera. In case there is a problem, it can be deleted 6 hours after it was created.":"Платёж принят и будет отправлен Glidera. В случае проблем он может быть удалён спустя шесть часов после создания.","Payment details":"Детали платежа","Payment request":"Запрос платежа","Pending Proposals":"Рассматриваемые платежи","Permanently delete this wallet.":"Навсегда удалить этот кошелёк.","Personal Wallet":"Личный кошелёк","Please carefully write down this phrase.":"Внимательно запишите ключевое словосочетание.","Please connect a camera to get started.":"Чтобы начать, подключите камеру.","Please enter the recovery phrase":"Введите ключевое словосочетание","Please enter the wallet recovery phrase":"Введите ключевое словосочетание кошелька","Please enter your PIN":"Пожалуйста, введите Ваш PIN-код","Please tap each word in the correct order.":"Тапните каждое слово в правильном порядке.","Please upgrade Qyb to perform this action":"Пожалуйста, обновите Qyb для выполнения этого действия","Please wait":"Пожалуйста, подождите","Please, select your backup file":"Пожалуйста, выберите ваш файл резервной копии","Preferences":"Параметры","Preparing addresses...":"Подготовка адресов...","Preparing backup...":"Подготовка резервной копии...","Press again to exit":"Нажмите еще раз для выхода","Priority":"Приоритетная","Private Key":"Приватный ключ","Private key encrypted. Enter password":"Приватный ключ зашифрован. Введите пароль","Private key is encrypted, cannot sign":"Закрытый ключ зашифрован, не удалось подписать","Proposal Accepted":"Платёж принят","Proposal Created":"Платёж создан","Proposal Deleted":"Платёж удалён","Proposal Rejected":"Платёж отклонён","Proposals":"Предложенные платежи","Push Notifications":"Push-уведомления","Push notifications for {{appName}} are currently disabled. Enable them in the Settings app.":"Push-уведомления для {{appName}} в настоящее время отключены. Включите их в Параметрах.","QR Code":"QR-код","Quick review!":"Быстрый просмотр!","Random":"Случайное","Rate on the app store":"Оценить в магазине приложений","Read less":"Показать меньше","Read more":"Показать больше","Receive":"Получить","Received":"Получено","Received Funds":"Полученные средства","Receiving":"Получение","Recent":"Недавние","Recent Transaction Card":"Недавние транзакции","Recent Transactions":"Недавние транзакции","Recipient":"Получатель","Recipients":"Получатели","Recovery phrase":"Ключевое словосочетание","Recreating Wallet...":"Воссоздаю кошелёк...","Rejected":"Отклонён","Rejecting payment proposal":"Отклонение платежа","Release information":"Информация о выпуске","Remove":"Удалить","Remove BitPay Account?":"Удалить BitPay аккаунт?","Remove BitPay Card?":"Удалить BitPay карту?","Removing your BitPay account will remove all associated BitPay account data from this device. Are you sure you would like to remove your BitPay Account ({{email}}) from this device?":"Удаление учетной записи BitPay удалит все связанные данные учетной записи BitPay с этого устройства. Вы уверены, что вы хотели бы удалить свой BitPay аккаунт ({{email}}) с этого устройства?","Repeat password":"Повторите пароль","Repeat the password":"Повторите пароль","Request Fingerprint":"Запрос отпечатка пальца","Request Specific amount":"Запросить определенную сумму","Request Spending Password":"Запрашивать платёжный пароль","Required number of signatures":"Требуемое число подписей","Restore from backup":"Восстановить из резервной копии","Retrieving inputs information":"Получение информации о входах","Retry":"Повторить попытку","Retry Camera":"Проверить камеру","Save":"Сохранить","Scan":"Сканировать","Scan QR Codes":"Сканирование QR-кодов","Scan addresses for funds":"Просканировать адреса для обнаружения средств","Scan your fingerprint please":"Пожалуйста, отсканируйте ваш отпечаток пальца","Scanning Wallet funds...":"Сканирование адресов кошелька...","Screenshots are not secure":"Скриншоты не безопасны","Search Transactions":"Поиск транзакций","Search or enter bitcoin address":"Найти или ввести биткойн-адрес","Search transactions":"Поиск транзакций","Search your currency":"Найти вашу валюту","Security":"Безопасность","Select a backup file":"Выберите файл резервной копии","Select a wallet":"Выберите кошелёк","Self-signed Certificate":"Самозаверенные сертификат","Selling Qybcoin...":"Продажа биткойн...","Send":"Отправить","Send Feedback":"Отправить отзыв","Send Money":"Отправить деньги","Send addresses by email":"Отправить адреса по email","Send by email":"Отправить на email","Send from":"Отправить от","Send max amount":"Отправить макс. сумму","Send us feedback instead":"Или отправьте нам отзыв","Sending":"Отправка","Sending 2FA code...":"Отправка второго фактора...","Sending feedback...":"Отправка отзыва...","Sending maximum amount":"Отправляю максимальную сумму","Sending transaction":"Отправка транзакции","Sending {{amountStr}} from your {{name}} wallet":"Отправка {{amountStr}} из вашего кошелька {{name}}","Sent":"Отправлено","Sent Funds":"Отправленные средства","Server response could not be verified":"Ответ сервера не может быть проверен","Services":"Службы","Session Log":"Журнал сеанса","Session log":"Журнал сеанса","Set up a password":"Задайте пароль","Settings":"Параметры","Share the love by inviting your friends.":"Поделитесь любовью и пригласите друзей.","Share this invitation with your copayers":"Отправьте приглашение совладельцам кошелька","Share {{appName}}":"Поделиться {{appName}}","Shared Wallet":"Общий кошелёк","Show Recovery Phrase":"Показать фразу для восстановления","Show address":"Показать адрес","Show advanced options":"Показать дополнительные параметры","Show bitcoin address":"Показать биткойн-адрес","Show more":"Показать еще","Signatures rejected by server":"Подписи отклонены сервером","Signing transaction":"Подписание транзакции","Since only you control your money, you’ll need to save your backup phrase in case this app is deleted.":"Так как кошелёк хранится только у вас, вам необходимо записать ключевую фразу на случай удаления {{appName}}.","Single Address Wallet":"Кошелёк с одним адресом","Skip":"Пропустить","Specify Recovery Phrase...":"Указать ключевое словосочетание...","Spend proposal is not accepted":"Платёж не принят","Spend proposal not found":"Платёж не найден","Spending Password needed":"Необходим платёжный пароль","Start sending bitcoin":"Начать отправку bitcoin","Startup Lock":"Блокировка при запуске","Success":"Успешно","Super Economy":"Очень экономичная","Sweep":"Считать","Sweep paper wallet":"Пополнить с бумажного кошелька","Sweeping Wallet...":"Считывание кошелька...","THIS ACTION CANNOT BE REVERSED":"ЭТО ДЕЙСТВИЕ НЕ МОЖЕТ БЫТЬ ОТМЕНЕНО","Take control of your money,<br>get started with bitcoin.":"Возьмите ваши финансы под контроль,<br>начните пользоваться Биткойн.","Tap and hold to show":"Коснитесь и удерживайте, чтобы показать","Tap to retry":"Повторить","Terms Of Use":"Условия использования","Terms of Use":"Условия использования","Testnet":"Testnet","Text":"Текст","Thank you!":"Спасибо!","Thanks!":"Спасибо!","The Ledger Chrome application is not installed":"Приложение Ledger для Chrome не установлено","The amount of bitcoin immediately spendable from this wallet.":"Сумма биткойнов доступных для совершения платежей.","The amount of bitcoin stored in this wallet that is allocated as inputs to your pending transaction proposals. The amount is determined using unspent transaction outputs associated with this wallet and may be more than the actual amounts associated with your pending transaction proposals.":"Сумма биткойнов, выделенных в качестве входов для ожидающих рассмотрения платежей. Сумма определяется непотраченными выходами, ассоциированными с этим кошельком, и может превышать сумму, ассоциированную с предложенными платежами.","The amount of bitcoin stored in this wallet with less than 1 blockchain confirmation.":"Сумма биткойнов с менее, чем одним подтверждением.","The derivation path":"Путь деривации","The higher the fee, the greater the incentive a miner has to include that transaction in a block. Current fees are determined based on network load and the selected policy.":"Чем выше комиссия, тем вероятнее майнеры включат эту транзакцию в блок. Текущая комиссия опеделяется на основании нагрузки на сеть и выбранной политики.","The official English Terms of Service are available on the BitPay website.":"Официальные Условия обслуживания на английском языке доступны на сайте BitPay.","The password of the recovery phrase (if set)":"Пароль ключевого словосочетания (если установлен)","The payment was created but could not be completed. Please try again from home screen":"Платёж был создан, но не может быть завершен. Пожалуйста, вернитесь на вкладку Обзор и попробуйте снова","The payment was removed by creator":"Платёж был удалён его создателем","The recovery phrase could require a password to be imported":"Для импортирования ключевого словосочетания может потребоваться пароль","The request could not be understood by the server":"Запрос не распознан сервером","The spend proposal is not pending":"Предложенный платёж больше не на рассмотрении","The total amount of bitcoin stored in this wallet.":"Сумма биткойнов в этом кошельке.","The wallet service URL":"Адрес сервера Bitcore","There is a new version of {{appName}} available":"Доступна новая версия {{appName}}","There is an error in the form":"Ошибка в форме","This app is fantastic!":"Замечательное приложение!","This bitcoin payment request has expired.":"Этот запрос платежа истёк.","This recovery phrase was created with a password. To recover this wallet both the recovery phrase and password are needed.":"Это ключевое словосочетание было создано с паролем. Для восстановления кошелька необходимо ключевое словосочетание и его пароль.","This wallet is not registered at the given Bitcore Wallet Service (BWS). You can recreate it from the local information.":"Это кошелёк не зарегистрирован на данном сервере Bitcore. Вы можете воссоздать его из локальной информации.","Timeline":"Хронология","To":"Кому","To get started, buy bitcoin or share your address. You can receive bitcoin from any wallet or service.":"Чтобы начать работу, купите биткойн или поделитесь вашим адресом. Вы можете получать биткойны из любого кошелька или сервиса.","To get started, you'll need to create a bitcoin wallet and get some bitcoin.":"Чтобы начать работу, вам нужно создать кошелёк и получить биткойн.","Total":"Баланс кошелька","Total Locked Balance":"Всего заблокировано средств","Total number of copayers":"Количество совладельцев","Touch ID Failed":"Ошибка Touch ID","Transaction":"Транзакция","Transaction History":"История транзакций","Transaction already broadcasted":"Транзакция уже отправлена","Transaction not available at this time":"Транзакция недоступна в данный момент","Transaction not found":"Транзакция не обнаружена","Transfer to":"Перевести в","Transfer to Wallet":"Перевод в кошелёк","Try again in {{expires}}":"Попробуйте снова через {{expires}}","Turn bitcoin into dollars, swipe anywhere Visa<sup>®</sup> is accepted.":"Превращайте биткойны в доллары США - платите везде, где принимают карты Visa<sup>&reg;</sup>.","Type the Recovery Phrase (usually 12 words)":"Введите ключевое словосочетание (обычно двенадцать слов)","Uh oh...":"Упс...","Unconfirmed":"Неподтверждено","Unsent transactions":"Неотправленные транзакции","Unused Addresses":"Неиспользованные адреса","Unused Addresses Limit":"Лимит неиспользованных адресов","Update Available":"Доступно обновление","Updating pending proposals. Please stand by":"Обновление ожидающих рассмотрения платежей. Подождите, пожалуйста","Updating transaction history. Please stand by.":"Обновление истории транзакций. Подождите, пожалуйста.","Updating... Please stand by":"Обновление... Подождите, пожалуйста","Urgent":"Срочно","Use Unconfirmed Funds":"Использовать неподтверждённые средства","Validating recovery phrase...":"Проверка ключевого словосочетания...","Verify your identity":"Подтвердить личность","Version":"Версия","View":"Просмотреть","View All Addresses":"Просмотреть все адреса","View Terms of Service":"Посмотреть Условия обслуживания","View Transaction on Insight":"Просмотреть транзакцию на Insight","View Update":"Просмотреть обновление","View on blockchain":"Посмотреть в блокчейне","WARNING: Key derivation is not working on this device/wallet. Actions cannot be performed on this wallet.":"ВНИМАНИЕ: Деривация ключей не работает на этом устройстве/кошельке. Никакие действия не могут быть произведены с этим кошельком.","WARNING: Not including the private key allows to check the wallet balance, transaction history, and create spend proposals from the export. However, does not allow to approve (sign) proposals, so <b>funds will not be accessible from the export</b>.":"ВНИМАНИЕ: экспортируемый файл не включает закрытый ключ, поэтому позволит только просматривать баланс, историю транзакций и предлагать платежи. Однако, его нельзя будет использовать для одобрения (подписания) предложенных платежей, поэтому <b>средства не будет доступны из экспортируемого файла</b>.","WARNING: The private key of this wallet is not available. The export allows to check the wallet balance, transaction history, and create spend proposals from the export. However, does not allow to approve (sign) proposals, so <b>funds will not be accessible from the export</b>.":"ВНИМАНИЕ: Закрытый ключ этого кошелька недоступен. Экспортируемый файл позволит только просматривать баланс, историю транзакций и предлагать платежи. Однако, его нельзя будет использовать для одобрения (подписания) предложенных платежей, поэтому <b>средства не будет доступны из экспортируемого файла</b>.","WARNING: UNTRUSTED CERTIFICATE":"ВНИМАНИЕ: НЕНАДЕЖНЫЙ СЕРТИФИКАТ","Waiting for Ledger...":"Ожидание Ledger...","Waiting for Trezor...":"Ожидание Trezor...","Waiting for copayers":"Ожидание совладельцев кошелька","Waiting...":"Ожидание...","Wallet Addresses":"Адреса кошелька","Wallet Color":"Цвет кошелька","Wallet Configuration (m-n)":"Конфигурация кошелька (m-n)","Wallet Created":"Кошелёк создан","Wallet Id":"Идентификатор кошелька","Wallet Information":"Информация о кошельке","Wallet Invitation":"Приглашение присоединиться к кошельку","Wallet Key":"Ключевое словосочетание","Wallet Name":"Название кошелька","Wallet Name (at creation)":"Название кошелька (при создании)","Wallet Network":"Сеть кошелька","Wallet Recovery Phrase":"Ключевое словосочетание кошелька","Wallet Recovery Phrase is invalid":"Ключевое словосочетание кошелька недействительно","Wallet Service URL":"Адрес сервера Bitcore","Wallet Settings":"Параметры кошелька","Wallet Type":"Тип кошелька","Wallet already exists":"Кошелёк уже существует","Wallet created":"Кошелёк создан","Wallet incomplete and broken":"Не все совладельцы присоединились, кошелёк повреждён","Wallet is full":"Все уже присоединены","Wallet is locked":"Кошелёк заблокирован","Wallet is not complete":"Не все совладельцы присоединились","Wallet name":"Название кошелька","Wallet needs backup":"Необходимо создать резервную копию","Wallet not backed up":"Резервное копирование не выполнено","Wallet not found":"Кошелёк не найден","Wallet not registered":"Кошелёк не зарегистрирован","Wallet not registered at the wallet service. Recreate it from \"Create Wallet\" using \"Advanced Options\" to set your recovery phrase":"Кошелёк не зарегистрирован на сервере Bitcore. Пересоздайте кошелёк воспользовавшись дополнительными параметрами, чтобы указать ключевое словосочетание","Wallet service not found":"Сервер Bitcore не найден","Wallets":"Кошельки","Warning!":"Внимание!","Warning: this transaction has unconfirmed inputs":"Предупреждение: эта транзакция имеет неподтвержденные входы","Watch out!":"Осторожно!","We'd love to do better.":"Мы хотели бы сделать лучше.","We'll confirm on the next screen.":"Проверим на следующем шаге.","We're always looking for ways to improve {{appName}}.":"Мы всегда ищем пути улучшения {{appName}}.","Website":"Сайт","What do you call this wallet?":"Как вы называете этот кошелёк?","When this wallet was created, it was called “{{walletName}}”. You can change the name displayed on this device below.":"Когда этот кошелёк был создан, он назывался &ldquo;{{walletName}}&rdquo;. Вы можете изменить отображаемое имя ниже.","Where would you like to receive email notifications about payments?":"Куда бы вы хотели получать email-уведомления о платежах?","Why?":"Почему?","Would you like to receive push notifications about payments?":"Вы хотели бы получать push-уведомления о платежах?","Wrong number of recovery words:":"Неподходящее количество слов в ключевом словосочетании:","Wrong spending password":"Неверный платёжный пароль","Yes":"Да","Yes, skip":"Да, пропустить","You can create a backup later from your wallet settings.":"Вы можете создать резервную копию позже из параметров кошелька.","You can scan bitcoin addresses, payment requests, paper wallets, and more.":"Вы можете сканировать биткойн-адреса, запросы платежей, бумажные кошельки, и многое другое.","You can still export it from Advanced &gt; Export.":"Вы можете экспортировать её в Дополнительные параметры &gt; Экспорт.","You control your bitcoin.":"Вы контролируете Ваши bitcoin-ы.","You'll receive email notifications about payments sent and received from your wallets.":"Вы будете получать email-уведомления о входящих и исходящих платежах.","Your Gift Cards":"Мои подарочные карты","Your bitcoin wallet is backed up!":"Резервная копия кошелька создана!","Your bitcoin wallet is ready!":"Ваш кошелёк готов!","Your ideas, feedback, or comments":"Ваши идеи, отзывы или комментарии","Your name":"Ваше имя","Your nickname":"Ваше псевдоним","Your password":"Ваш пароль","Your wallet is never saved to cloud storage or standard device backups.":"Ваш кошелёк никогда не сохраняется в облачное хранилище или в резервные копии устройства.","Your wallet key will be encrypted. The Spending Password cannot be recovered. Be sure to write it down.":"Ваш кошелёк будет зашифрован. Платёжный пароль нельзя восстановить. Обязательно его запишите.","[Balance Hidden]":"[Баланс скрыт]","add your BitPay Visa card(s)":"добавьте вашу BitPay Visa карту(ы)","locked by pending payments":"заблокировано неподтверждёнными платежами","me":"мне","name@example.com":"name@example.com","preparing...":"Подготавливается...","{{appName}} depends on Bitcore Wallet Service (BWS) for blockchain information, networking and Copayer synchronization. The default configuration points to https://bws.bitpay.com (BitPay's public BWS instance).":"{{appName}} требует Bitcore для координации совладельцев и получения информации из блокчейна. По-умолчанию используется сервер https://bws.bitpay.com (публичный сервер Bitcore компании BitPay).","{{fee}} will be deducted for bitcoin networking fees.":"{{fee}} будет использовано для оплаты комиссии.","{{updatingTxHistoryProgress}} transactions downloaded":"{{updatingTxHistoryProgress}} транзакций загружено","{{wallet.m}}-of-{{wallet.n}}":"{{wallet.m}}-из-{{wallet.n}}"});
    gettextCatalog.setStrings('zh', {"(Trusted)":"（可信的）","(possible double spend)":"（重复支付）","* A payment proposal can be deleted if 1) you are the creator, and no other copayer has signed, or 2) 24 hours have passed since the proposal was created.":"* 如果 1) 你是创造者，及没有其他 copayer 签名，或 2) 24 小时已经过去，支付提议将被删除。","- {{btx.feeRateStr}} of the transaction":"-{{btx.feeRateStr}} 的交易记录","- {{tx.feeRateStr}} of the transaction":"-{{tx.feeRateStr}} 的交易记录","5-star ratings help us get {{appName}} into more hands, and more users means more resources can be committed to the app!":"5 星评级帮助我们进入更多的人手, {{appName}} 和更多的用户意味着更多的资源可以致力于应用!","<b>Only</b> redeemable on Mercado Livre (Brazil)":"<b>只</b>可以在 Mercado Livre（巴西）兑换","A member of the team will review your feedback as soon as possible.":"团队的成员将尽快审查你的反馈意见。","A total of {{amountAboveMaxSizeStr}} were excluded. The maximum size allowed for a transaction was exceeded.":"备注︰共有{{amountAboveMaxSizeStr}} 被排除了。超出了交易允许的最大体积","A total of {{amountBelowFeeStr}} were excluded. These funds come from UTXOs smaller than the network fee provided.":"备注：共有{{amountBelowFeeStr}} 被排除了。这些来自 UTXOs 的资金小于提供的网络费用。","About":"关于","Accepted":"同意","Account":"帐户","Account Number":"帐号","Accounts":"帐户","Activity":"活动","Add Account":"添加帐户","Add BitPay Account?":"添加QYB帐户吗？","Add Contact":"添加联系人","Add Funds":"添加金额","Add Memo":"添加备注","Add a password":"添加密码","Add account":"添加帐户","Add an optional password to secure the recovery phrase":"添加可选的密码，以保护助记词","Add as a contact":"添加到联系人","Add description":"添加描述","Add funds":"添加资金","Add this BitPay account ({{email}})?":"确定添加此QYB账户:{{email}} 吗？","Add wallet":"添加钱包","Address":"地址","Address Book":"地址簿","Address Type":"地址类型","Addresses With Balance":"地址与余额","Advanced":"进阶","Advanced Settings":"进阶设置","All":"全选","All Addresses":"所有地址","All of your bitcoin wallet balance may not be available for immediate spending.":"请先等待1分钟左右再转账","All signing devices must be added to this multisig wallet before bitcoin addresses can be created.":"QYB地址可以创建之前，签名的所有设备都必须都添加到这个对数钱包。","Allow Camera Access":"允许访问相机","Allow notifications":"允许通知","Almost done! Let's review.":"差不多完成了 ！让我们回顾一下。","Alternative Currency":"替代货币","Amazon.com is not available at this moment. Please try back later.":"亚马逊服务器暂时无法访问，请稍候再试。","Amount":"数额","Amount below minimum allowed":"数额低于最低允许值","Amount too big":"量太大","Amount too low to spend":"数量太少，无法支付","An update to this app is available. For your security, please update to the latest version.":"本程序有一个可用的更新。为了你的安全，请更新到最新版本。","Anyone with your backup phrase can access or spend your bitcoin.":"任何人只要持有你备份的助记词，就可以访问你的钱包、花费你的QYB，没有人可以帮你找回损失。","Approximate Qybcoin network fee to transfer wallet's balance (with normal priority)":"转移钱包余额大约需要的QYB网络费用（正常优先级）","Are you being watched?":"请确认周边环境安全","Are you being watched? Anyone with your recovery phrase can access or spend your bitcoin.":"请确认目前没有人在监视你的屏幕！因为只要有人知道了你的助记词，他就拥有你的QYB完全访问权限，甚至可以直接用于消费！","Are you sure you want to cancel and delete this wallet?":"确定取消和删除这个钱包？","Are you sure you want to delete this contact?":"确定要删除此联系人？","Are you sure you want to delete this wallet?":"确定要删除这个钱包？","Are you sure you want to reject this transaction?":"确定拒绝这笔交易？","Are you sure you want to remove this transaction?":"确定要删除这项交易吗？","Are you sure you want to skip it?":"确定想跳过它？","Are you sure you would like to log out of your BitPay Card account?":"确定要登出你的QYB账户？","Are you sure you would like to remove your BitPay Card ({{lastFourDigits}}) from this device?":"你确定想要从这个设备中删除你的QYB卡 ({{lastFourDigits}})吗？","Auditable":"可审核","Available":"可用空间","Available Balance":"可用余额","Average confirmation time":"平均确认时间","BIP32 path for address derivation":"BIP32 路径的地址衍生","QYB wallets":"QYB钱包","Backup":"备份","Backup Needed":"需要备份","Backup all livenet wallets before using this function":"请在使用此功能之前备份你所有的 livenet 钱包","Backup needed":"需要备份","Backup now":"现在备份","Backup wallet":"备份钱包","Backup your wallet before using this function":"在使用此功能之前，请备份你的钱包。","Bad wallet invitation":"坏钱包邀请","Balance By Address":"地址余额","Be sure to store your recovery phrase in a secure place. If this app is deleted, your money cannot be recovered without it.":"请务必将你的助记词保存好。如果卸载了APP或更换设备，你需要它来恢复你的QYB。","BitPay Visa® Cards":"BitPay Visa&reg; 牌","Qybcoin Address":"QYB地址","Qybcoin Cash Wallets":"DMB钱包","Qybcoin Network Fee Policy":"QYB网络手续费策略","Qybcoin Wallets":"QYB钱包","Qybcoin cash Payment":"DMB支付","Qybcoin is a currency.":"QYB是一种货币。","Qybcoin is different – it cannot be safely held with a bank or web service.":" QYB与人民币不同——没有银行或任何中心化中介机构来提供结算管理服务。","Qybcoin is secure,<br>digital money.":"QYB是安全的 <br>加密数字货币。","Qybcoin transactions include a fee collected by miners on the network.":"QYB交易包含了在网络上被矿工所收取的费用。","Bought {{amountUnitStr}}":"买了{{amountUnitStr}}","Broadcast Payment":"广播支付","Broadcasted":"广播商","Broadcasting transaction":"正在广播交易","Browser unsupported":"不受支持的浏览器","Buy":"购买","Buy &amp; Sell Qybcoin":"购买或出售QYB","Buy Qybcoin":"获取QYB","Buy a Gift Card":"买一张礼品卡","Buy from":"从什么地方购买","Buying Qybcoin...":"正在发送 QYB...","Calculating fee":"正在计算费用","Cancel":"取消","Cancel invitation":"取消邀请","Cannot Create Wallet":"不能创建钱包","Cannot join the same wallet more that once":"无法重复加入同一个钱包","Cards":"卡","Certified by":"通过认证：","Check installation and retry.":"检查安装包然后重试","Choose a backup file from your computer":"从你的计算机选择一个备份文件","Choose your destination wallet":"选择你的目的地钱包","Choose your source wallet":"选择源钱包","Clear":"清除","Clear cache":"清空缓存","Click to accept":"点击这里接受","Click to pay":"点击这里支付","Click to send":"点击这里发送","Close":"关闭","Coin":"币种","Color":"颜色","Commit hash":"提交哈希","Complete the backup process to use this option":"要使用此选项，请先完成备份。","Completed":"完成","Confirm":"确定","Confirm &amp; Finish":"确认并完成","Confirm purchase":"确认购买","Confirm your PIN":"确认你的PIN码","Confirm your new spending password":"确认你的新支付密码","Confirmations":"确认","Confirming":"确认","Connect my BitPay Card":"我 BitPay 卡连接","Connecting to Coinbase...":"正在连接 Coinbase...","Connecting to Glidera...":"正在连接 Glidera...","Connection reset by peer":"连接被对方重置","Contacts":"联系人","Continue":"继续","Contribute Translations":"参与翻译","Qyb only supports Qybcoin Cash using new version numbers addresses":"Copay只支持新版本的DMB地址","Copayer already in this wallet":"Copayer 已经在这个钱包里","Copayer already voted on this spend proposal":"Copayer 已经表决此花费提议","Copayer data mismatch":"Copayer 的数据不匹配","Copayer joined":"Copayer 加入","Copayer {{$index}}":"Copayer {{$index}}","Copied to clipboard":"已复制到剪贴板","Copy this text as it is to a safe place (notepad or email)":"将此文本复制到一个安全的地方（记事本或电子邮件）","Copy to clipboard":"复制到剪贴板","Could not access Gift Card Service":"不能访问礼品卡服务","Could not access the wallet at the server. Please check:":"无法访问服务器上的钱包。请确认︰","Could not access to Amazon.com":"不能访问到亚马逊网站","Could not access wallet":"无法访问钱包","Could not add message to imported wallet without shared encrypting key":"没有共享的加密密钥，无法将消息添加到进口钱包","Could not broadcast payment":"无法广播支付","Could not build transaction":"无法建立交易","Could not create address":"无法创建地址","Could not create the invoice":"不能创建发票","Could not create transaction":"无法创建交易","Could not create using the specified extended private key":"无法使用指定的扩展私人密钥创建","Could not create using the specified extended public key":"无法使用指定的扩展的公钥创建","Could not create: Invalid wallet recovery phrase":"无法创建 ︰ 无效的钱包助记词","Could not decrypt file, check your password":"无法解密文件，请检查你的密码","Could not delete payment proposal":"无法删除支付提议","Could not duplicate":"无法复制","Could not get dynamic fee":"不能动态费用","Could not get dynamic fee for level: {{feeLevel}}":"无法获取水平动态费用︰ {{feeLevel}}","Could not get fee levels":"无法获取费率","Could not get the invoice":"不能拿到发票","Could not get transactions":"不能交易","Could not import":"无法导入","Could not import. Check input file and spending password":"无法导入。请检查输入文件和支付密码","Could not join wallet":"无法加入钱包","Could not reject payment":"无法拒绝支付","Could not remove account":"无法删除帐户","Could not remove card":"无法删除卡","Could not save preferences on the server":"无法在服务器上保存首选项","Could not send payment":"无法发送支付","Could not send transaction":"无法发送交易记录","Could not update transaction history":"无法更新交易历史记录","Could not update wallet":"无法更新钱包","Create Personal Wallet":"创建个人的钱包","Create Shared Wallet":"创建自己的免费钱包","Create bitcoin wallet":"创建QYB钱包","Create new wallet":"创建新钱包","Create shared wallet":"创建共享的钱包","Create {{formData.requiredCopayers}}-of-{{formData.totalCopayers}} wallet":"创建 {{formData.requiredCopayers}} 的{{formData.totalCopayers}} 钱包","Created by":"创建者:","Creating Wallet...":"正在创建钱包...","Creating transaction":"正在创建交易","Current fee rate for this policy":"此策略的当前费用率","Custom":"自定义","Custom Amount":"自定义金额","Custom Fee":"使用自定义费率","Date":"日期","Delete":"删除","Delete Payment Proposal":"删除支付提议","Delete Wallet":"删除钱包","Delete it and create a new one":"删除并创建新的","Deleting Wallet...":"正在删除钱包...","Deleting payment proposal":"删除付款方案","Derivation Path":"衍生路径","Derivation Strategy":"衍生策略","Details":"详情","Disabled":"禁用","Do it later":"以后再做","Do not include private key":"不包括私钥","Don't see your language on Crowdin? Contact the Owner on Crowdin! We'd love to support your language.":"在 Crowdin 找不到你的语言？请联系 Crowdin 的所有者！我们很乐意支持你的语言。","Download":"下载","Duplicate for DMB":"复制 DMB","Duplicating wallet...":"正在复制钱包……","Each bitcoin wallet can generate billions of addresses from your 12-word backup. A new address is automatically generated and shown each time you receive a payment.":"每个QYB钱包可以从你的 12 个助记词生成亿万个地址。每当你收到付款，将自动生成一个新的地址。","Economy":"经济","Edit":"编辑","Email":"电子邮件","Email Address":"电子邮件地址","Empty addresses limit reached. New addresses cannot be generated.":"已达到空地址限制。无法生成新的地址。","Enable camera access in your device settings to get started.":"相机中启用访问你的设备设置入门。","Enable email notifications":"启用电子邮件通知","Enable push notifications":"启用推式通知","Enable the camera to get started.":"使该摄像机开始。","Enter Spending Password":"输入支出密码","Enter Two Factor for your BitPay account":"为你的 BitPay 帐户输入两个因素","Enter amount":"输入金额","Enter custom fee":"输入自定义费率","Enter new spending password":"输入新的消费密码","Enter the recovery phrase (BIP39)":"输入助记词 (BIP39)","Enter your email":"输入你的电子邮件","Enter your password":"请输入你的密码","Error":"错误！","Error at confirm":"在确认错误","Error creating gift card":"创建礼品卡时出错。","Error creating the invoice":"创建发票时出错","Error creating wallet":"创建钱包时出现错误","Error getting SendMax information":"获取SendMax信息时出错。","Error in Payment Protocol":"付款协议中的错误","Error pairing BitPay Account":"配对帐户错误","Error scanning funds:":"扫描资金错误︰","Error sweeping wallet:":"错误清扫钱包︰","Error updating Debit Cards":"更新借记卡时出错","Exceeded daily limit of $500 per user":"超过每个用户的每日限额","Expired":"已过期","Expires":"到期","Export Wallet":"导出钱包","Export to file":"导出到文件","Export wallet":"导出钱包","Exporting via QR not supported for this wallet":"此钱包不支持通过 QR 的导出","Extended Public Keys":"扩展的公钥","Extracting Wallet information...":"正在提取的钱包信息...","Failed to export":"导出失败","Family vacation funds":"家庭度假资金","Fee":"费用","Fee level":"费用等级","Fee level is not defined":"未定义收费等级。。","Fee:":"手续费:","Feedback could not be submitted. Please try again later.":"无法提交反馈。请稍后再试。","Fetching BitPay Account...":"正在获取QYB帐户...","Fetching payment information":"获取付款信息","File/Text":"文件/文本","Filter setting":"筛选器设置","Finger Scan Failed":"指纹扫描失败","Finish":"完成","For audit purposes":"供审计目的","From":"来自","From BitPay account":"从QYB帐户","From Hardware Wallet":"从硬件钱包","From the destination device, go to Add wallet &gt; Import wallet and scan this QR code":"从目标设备，请到添加钱包 &gt; 导入钱包和扫描此 QR 代码","Funds are locked by pending spend proposals":"资金由未决的花费提议锁定","Funds found:":"找到资金","Funds to be added":"充值金额","Funds transferred":"资金转移","Funds were added to debit card":"提现到借记卡成功","Funds will be transferred to":"资金将会转移到","Generate new address":"生成新的地址","Generating .csv file...":"正在生成 .csv 文件...","Generating new address...":"正在生成新的地址...","Get local cash anywhere you go, from any Visa<sup>®</sup> compatible ATM. ATM bank fees may apply.":"得到当地现金任何地方你去，从任何 Visa<sup>®</sup> 兼容的自动取款机 ATM 银行费用可能适用。","Get news and updates from BitPay":"从QYB获取新闻和更新","Get started":{"$$noContext":"马上体验","button":"开始使用"},"Get started by adding your first one.":"通过添加你的第一个开始。","Getting fee levels...":"正在获取收费水平...","Gift Card":"礼品卡","Gift Card is not available to use anymore":"礼品卡不可再使用","Gift card expired":"礼品卡过期","Gift card generated and ready to use.":"礼品卡已生成，可以使用了。","Go Back":"返回\t#","Go back":"上一页","Got it":"收到！","Hardware Wallet":"硬件钱包","Hardware not connected.":"硬件未连接","Hardware wallet":"硬件钱包","Hardware wallets are not yet supported with Qybcoin Cash":"DMB钱包暂时不支持硬件钱包","Help & Support":"帮助与支持","Help and support information is available at the website.":"已在网站上提供帮助和支持","Hide":"隱藏","Hide Balance":"隐藏余额","Hide Next Steps Card":"隐藏下一个步骤卡","Hide advanced options":"隐藏高级选项","Home":"首页","How could we improve your experience?":"我们如何可以改善你的体验？","How do you like {{appName}}?":"你喜欢 {{appName}}？","I don't like it":"我不喜欢","I have read, understood, and agree to the <a ng-click=\"openTerms()\" translate=\"\">Terms of Use</a>.":"我已经阅读、 理解并同意 <a ng-click=\"openTerms()\"translate=\"\"> 使用条款</a>。","I have read, understood, and agree with the Terms of use.":"我已经阅读、 理解并同意本使用条款。","I have written it down":"我有把它写下来","I like the app":"我喜欢这个应用程序","I think this app is terrible.":"这个应用程序是可怕。","I understand":"我知道了","I understand that if this app is moved to another device or deleted, my bitcoin can only be recovered with the backup phrase.":"我明白，掌握了我的私钥就掌握了我的QYB，即使换设备或换操作人，只要有私钥或助记词，都可以还原我的钱包并使用我的QYB。","I understand that my funds are held securely on this device, not by a company.":"我明白，我的QYB并不保存在任何公司的服务器上，而记录在区块链中。","I've written it down":"我已经把它写下来","If enabled, all sensitive information (private key and recovery phrase) and actions (spending and exporting) associated with this wallet will be protected.":"如果启用，与此钱包相关的所有敏感信息（私钥、回复短语）和操作（消费、导出）都将受到保护。","If enabled, the Recent Transactions card - a list of transactions occuring across all wallets - will appear in the Home tab.":"如果启用，最近的交易卡-交易发生跨所有钱包名单-将出现在主页选项卡。","If enabled, wallets will also try to spend unconfirmed funds. This option may cause transaction delays.":"如果启用了，钱包也尝试使用未经证实的资金。此选项可能会导致事务延迟。","If this device is replaced or this app is deleted, neither you nor BitPay can recover your funds without a backup.":"如果更换设备或删除粽子应用程序，没有备份的情况下没人可以恢复你的资金。","If you have additional feedback, please let us know by tapping the \"Send feedback\" option in the Settings tab.":"如果你有额外的反馈，请让我们知道通过点击设置选项卡中的\"发送反馈\"选项。","If you take a screenshot, your backup may be viewed by other apps. You can make a safe backup with physical paper and a pen.":"如果截图，你的备份可能会被其他应用程序浏览。建议使用纸笔来记录备份。","Import":"导入","Import Wallet":"导入钱包","Import backup":"导入备份","Import wallet":"导入钱包","Importing Wallet...":"正在导入钱包...","In order to verify your wallet backup, please type your password.":"为了验证你的钱包的备份，请键入你的密码。","Inactive":"禁用","Incomplete":"不完整","Incomplete wallet":"不完整的钱包","Incorrect PIN, try again.":"PIN码不正确，请重试","Incorrect code format":"代码格式不正确","Incorrect network address":"网络地址不正确","Insufficient funds":"资金不足","Insufficient funds for fee":"费用的资金不足","Integrations":"积分","Invalid":"无效","Invalid URL":"错误的URL","Invalid account number":"帐户号无效","Invalid address":"地址无效","Invalid data":"无效的数据","Invalid derivation path":"衍生路径无效","Invitation to share a {{appName}} Wallet":"邀请分享 {{appName}} 钱包","Invoice expired":"发票过期","Is there anything we could do better?":"有什么我们可以做得更好吗？","Is this correct?":"这是正确的吗？","Is this email address correct?":"此电子邮件地址是正确的？","It's a good idea to avoid reusing addresses - this both protects your privacy and keeps your bitcoins secure against hypothetical attacks by quantum computers.":"它是一个好主意，以避免重用地址 — — 这既能保护你的隐私又保持你的QYB安全假设攻击由量子计算机。","It's important that you write your backup phrase down correctly. If something happens to your wallet, you'll need this backup to recover your money. Please review your backup and try again.":"它是重要的你写你备份的短语正确。如果发生什么事情到你的钱包，你会需要此备份来恢复你的钱。请检查你的备份并再试一次。","Join":"加入","Join my {{appName}} Wallet. Here is the invitation code: {{secret}} You can download {{appName}} for your phone or desktop at {{appUrl}}":"加入我的 {{appName}} 的钱包。这里是邀请码︰ {{secret}} 你可以下载为你的电话或桌面的 {{appUrl}} {{appName}}","Join shared wallet":"加入共享钱包","Joining Wallet...":"正在加入钱包...","Just scan the code to pay.":"支持扫码支付。","Key already associated with an existing wallet":"钥已经关联现有的钱包","Language":"语言","Last Month":"上个月","Learn more":"了解更多","Let's verify your backup phrase.":"让我们验证你备份的短语。","Loading addresses...":"正在加载地址...","Loading transaction info...":"正在加载交易信息...","Lock App":"锁定应用","Lock by Fingerprint":"通过指纹锁定","Lock by PIN":"用PIN码锁定","Locked":"锁定","Locktime in effect. Please wait to create a new spend proposal":"Locktime 在进行中。请稍等以创建新的花费提议","Locktime in effect. Please wait to remove this spend proposal":"Locktime 在进行中。请稍等以删除花费提议","Log options":"日志选项","Log out":"登出","Low amount inputs":"低额投入","Low fees":"手续费太低","Makes sense":"有道理","Matches:":"匹配：","Me":"我","Meh - it's alright":"咩-没关系","Memo":"便签","Mercado Livre Brazil Gift Cards":"梅尔卡多里弗巴西礼品卡","Mercadolibre Gift Card Service is not available at this moment. Please try back later.":"Mercadolibre 礼品卡服务暂时不可用，请稍后再试。","Merchant Message":"商人的消息","Miner Fee":"矿工费用","Missing parameter":"缺失参数","Missing private keys to sign":"遗失需要签名的私钥","More Options":"更多的选择","Moved":"已调动","Moved Funds":"转移资金","Multiple recipients":"多个接收者","NOTE: To import a wallet from a 3rd party software, please go to Add Wallet &gt; Create Wallet, and specify the Recovery Phrase there.":"注意︰欲从第三方软件导入钱包，请到添加钱包 &gt; 创建钱包，并指定助记词。","Name":"名称","Network Cost":"网络手续费","Network error":"网络错误","New Proposal":"新建议","New address could not be generated. Please try again.":"无法生成新的地址。请再试一次。","New personal wallet":"新的个人钱包","Next steps":"接下来的步骤","No Wallet":"没钱包","No access key defined":"授权密钥未定义","No backup, no bitcoin.":"不备份的粽子不是好粽子。","No contacts yet":"然而没有联系人","No entries for this log level":"没有为此日志级别的的条目","No hardware information available.":"没有可用的硬件信息。","No hardware wallets supported on this device":"此设备不支持硬件钱包","No pending proposals":"没有挂起的建议","No recent transactions":"没有最近的交易","No signing proposal: No private key":"没有签名的建议： 没有私钥","No transactions yet":"没有交易记录","No wallet found":"发现没有钱包","No wallet selected":"没有选定的钱包","No wallets available":"没有可用的钱包","No wallets available to receive funds":"没有可用于接收资金的钱包","No wallets eligible for Qybcoin Cash support":"没有錢包合乎支持小比特幣資格","Non BIP44 wallet":"非BIP44錢包","Non eligible QYB wallets":"非合格比特幣錢包","Normal":"常规","Not authorized":"尚未授权","Not enough funds for fee":"费用的资金不足","Not even BitPay can access it.":"不存在QYB服务器可以访问你的钱包。","Not funds found":"没有资金发现","Not now":"不是现在","Note":"备注","Note: if this DMB wallet was duplicated from a QYB wallet, they share the same recovery phrase.":"注意: 如此比特幣錢包由小比特幣复制，他們共享相同恢復短語","Notice: only 1-1 (single signature) wallets can be used for sell bitcoin":"注意︰ 只有 1-1 （单签名） 钱包可以用于卖QYB","Notifications":"通知","Notifications by email":"用电子邮件通知","Notify me if confirmed":"确认完毕时通知我。","Notify me when transactions are confirmed":"交易确认完毕时通知我","Now is a good time to backup your wallet. If this device is lost, it is impossible to access your funds without a backup.":"请尽快备份。否则，若本设备丢失，你将无法找回钱包私钥，将无法使用属于你的QYB。","Now is a perfect time to assess your surroundings. Nearby windows? Hidden cameras? Shoulder-spies?":"请查看四周，确认没有隐藏的摄像机或围观人群。","OK":"好的","OKAY":"OKAY","Official English Disclaimer":"官方英文免责声明","Oh no!":"出错。","Ok":"还行","On this screen you can see all your wallets, accounts, and assets.":"你可以在此看到你的钱包和资产。","Open":"打开","Open Crowdin":"打开 Crowdin","Open GitHub":"打开 GitHub","Open GitHub Project":"打开 GitHub 项目","Open Insight":"开放的洞察力","Open Settings":"打开设置","Open Translation Community":"开放式翻译社区","Open Website":"打开网站","Open the recovery tool.":"打開恢復工具","Open wallet":"打开钱包","Open website":"打开网站","Order the BitPay Card":"订单 BitPay 卡","Password":"密码","Password required. Make sure to enter your password in advanced options":"需要密码。请务必在高级选项中输入你的密码","Paste invitation here":"在此粘贴邀请","Paste the backup plain text code":"粘贴备份的纯文本代码","Pay 0% fees to turn bitcoin into dollars.":"0%付费以QYB变成美元。","Pay To":"支付给","Payment Accepted":"已接受支付","Payment Expires:":"付款到期︰","Payment Proposal":"支付提议","Payment Proposal Created":"支付提议已创建","Payment Proposals":"支付提议","Payment Protocol Invalid":"支付协议无效","Payment Protocol not supported on Chrome App":"支付协议不支持 Chrome 应用程序","Payment Received":"收到付款","Payment Rejected":"支付被拒绝","Payment Sent":"支付已发送","Payment accepted, but not yet broadcasted":"支付已被接受，但尚未广播","Payment accepted. It will be broadcasted by Glidera. In case there is a problem, it can be deleted 6 hours after it was created.":"支付以被接受。它将由 Glidera 广播。如果出现问题，它可以在创建后的 6 个小时内删除。","Payment address was translated to new Qybcoin Cash address format:":"付款地址转化为新的小比特幣地址格式","Payment details":"支付明细","Payment request":"支付请求","Pending":"处理中","Pending Proposals":"支付提议","Permanently delete this wallet.":"永久删除这个钱包。","Personal Wallet":"个人钱包","Please carefully write down this phrase.":"请仔细记下这句话。","Please connect a camera to get started.":"请连接相机入门。","Please enter the recovery phrase":"请输入助记词","Please enter the wallet recovery phrase":"请输入钱包助记词","Please enter your PIN":"请输入你的PIN码","Please tap each word in the correct order.":"请点击每个单词按照正确的顺序。","Please upgrade Qyb to perform this action":"请升级 Qyb 以执行此操作","Please wait":"請等等","Please, select your backup file":"请选择你的备份文件","Pre-Auth Holds":"预授权持有","Preferences":"偏好","Preparing addresses...":"正在准备地址...","Preparing backup...":"正在准备备份...","Press again to exit":"再按一次退出","Priority":"优先","Private Key":"私钥","Private key encrypted. Enter password":"私钥加密。输入密码","Private key is encrypted, cannot sign":"私钥已加密，无法签名","Proposal Accepted":"提案被接受","Proposal Created":"建议创建","Proposal Deleted":"建议删除","Proposal Rejected":"被拒绝的建议","Proposals":"建议","Purchase Amount is limited to {{limitPerDay}} {{currency}} per day":"每天最多购买{{limitPerDay}}{{currency}}","Purchase amount must be a value between 50 and 2000":"采购金额必须 50 到 2000年之间的值","Push Notifications":"推送通知","Push notifications for {{appName}} are currently disabled. Enable them in the Settings app.":"{{appName}} 的推式通知当前已禁用。在设置应用程序启用它们。","QR Code":"QR 码","Quick review!":"请注意 ！","Random":"随机","Rate on the app store":"率的应用程序商店","Read less":"阅读少","Read more":"阅读更多","Read more in our Wiki":"去我們的維基閱讀更多","Read only wallet":"錢包只供唯讀","Receive":"收币","Receive in":"在接收","Received":"已接收","Received Funds":"收到的资金","Receiving":"收币","Recent":"最近","Recent Transaction Card":"最近交易卡","Recent Transactions":"最近的交易","Recipient":"收件人","Recipients":"接收者","Recovery phrase":"助记词","Recreating Wallet...":"正在重新创建的钱包...","Redeem now":"立即兑现","Rejected":"拒绝","Rejecting payment proposal":"拒绝付款方案","Release information":"发布信息","Remove":"移除","Remove BitPay Account?":"删除 BitPay 帐户吗？","Remove BitPay Card?":"删除 BitPay 卡吗？","Removing your BitPay account will remove all associated BitPay account data from this device. Are you sure you would like to remove your BitPay Account ({{email}}) from this device?":"从该设备删除你的 BitPay 帐户将删除所有关联的 BitPay 帐户数据。你确定你想要从这个设备中删除你的 BitPay 帐户:({{email}})？","Repeat password":"重复输入密码","Repeat the password":"重复密码","Request Fingerprint":"请求指纹","Request Specific amount":"请求特定量","Request Spending Password":"请求支付密码","Required number of signatures":"所需的签名数","Restore from backup":"从备份中还原","Retrieving inputs information":"正在获取输入的信息。","Retry":"重试","Retry Camera":"重试相机","Save":"保存","Scan":"扫码","Scan QR Codes":"扫描 QR 码","Scan addresses for funds":"扫描资金的地址","Scan again":"重新扫描","Scan your fingerprint please":"请扫描你的指纹","Scanning Wallet funds...":"正在扫描钱包资金...","Scanning funds...":"掃描資金中.....","Screenshots are not secure":"截图是不安全的","Search Transactions":"搜索交易","Search or enter bitcoin address":"搜索或输入QYB地址","Search transactions":"搜索交易","Search your currency":"搜索你的货币","Security":"安全","See invoice":"查看发票","Select a backup file":"选择备份文件","Select a wallet":"选择钱包","Self-signed Certificate":"自签名证书","Selling Qybcoin...":"出售QYB......","Send":"转账","Send Feedback":"发送反馈","Send Money":"寄钱","Send addresses by email":"通过电邮发送地址","Send by email":"通过电邮发送","Send from":"发送自","Send max amount":"发送最大数量","Send payment to this address":"付款到此地址","Send us feedback instead":"而是向我们发送反馈","Sending":"正在发送","Sending 2FA code...":"正在发送 2FA 代码...","Sending feedback...":"发送反馈信息...","Sending maximum amount":"发送的最大金额","Sending transaction":"正在发送交易","Sending {{amountStr}} from your {{name}} wallet":"从你的 {{name}} 钱包发送 {{amountStr}}","Sent":"已发送","Sent Funds":"已发送的资金","Server response could not be verified":"无法验证服务器响应","Service not available":"服务不可用","Services":"服务","Session Log":"会话日志","Session log":"会话日志","Set up a password":"设置密码","Set your own fee in satoshis/byte":"设置你的费用(satoshi每字节)","Settings":"设置","Share the love by inviting your friends.":"邀请你的朋友一起来使用粽子钱包。","Share this invitation with your copayers":"将此邀请与你的 copayers 共享","Share {{appName}}":"分享 粽子","Shared Wallet":"共享的钱包","Show Recovery Phrase":"显示助记词","Show address":"显示地址","Show advanced options":"显示高级选项","Show bitcoin address":"显示QYB地址","Show more":"显示更多","Signatures rejected by server":"签名被服务器拒绝","Signing transaction":"签名交易","Since only you control your money, you’ll need to save your backup phrase in case this app is deleted.":"只有你可以控制你的QYB，如果你删除粽子APP或者更换设备，你需要备份的助记词来恢复钱包。","Single Address Wallet":"单一地址钱包","Skip":"跳过","Slide to accept":"在此點擊掃描以接受","Slide to buy":"滑动购买","Slide to pay":"在此點擊掃描以付款","Slide to send":"在此點擊滑動以發送","Some of your wallets are not eligible for Qybcoin Cash support. You can try to access DMB funds from these wallets using the":"你有些錢包不合資格得到小比特幣的支持可嘗試連結這些錢包至BCH基金","Specify Recovery Phrase...":"指定助记词......","Spend proposal is not accepted":"花费提议不被接受","Spend proposal not found":"找不到花费提议","Spending Password needed":"需要支付密码","Spending this balance will need significant Qybcoin network fees":"这笔交易将需要非常高的QYB网络手续费","Start sending bitcoin":"向他人转账QYB","Startup Lock":"启动锁定","Still pending":"仍然等待","Success":"成功","Super Economy":"超级经济","Sweep":"扫描","Sweep paper wallet":"Sweep 纸钱包","Sweeping Wallet...":"正在导出钱包","THIS ACTION CANNOT BE REVERSED":"此操作无法撤消","Take control of your money,<br>get started with bitcoin.":"欢迎使用<br>我们共同认同的QYB。","Tap and hold to show":"点击并按住以显示","Tap to recreate":"点击此以重新创建","Tap to retry":"点击以重试","Terms Of Use":"使用条件","Terms of Use":"使用条款","Testnet":"Testnet","Text":"文本","Thank you!":"谢谢！","Thanks!":"谢谢你 ！","That's exciting to hear. We'd love to earn that fifth star from you – how could we improve your experience?":"非常期待你告诉我们——怎样可以改善你的体验？","The Ledger Chrome application is not installed":"Ledger Chrome 应用程序未安装","The amount of bitcoin immediately spendable from this wallet.":"本钱包即刻支持花费的数额。","The amount of bitcoin stored in this wallet that is allocated as inputs to your pending transaction proposals. The amount is determined using unspent transaction outputs associated with this wallet and may be more than the actual amounts associated with your pending transaction proposals.":"QYB存储在分配作为你挂起的事务建议的输入这个钱包中的金额。量确定使用未用余额交易记录输出与这个钱包关联，可能会与你挂起的事务建议相关联的实际数额超过。","The amount of bitcoin stored in this wallet with less than 1 blockchain confirmation.":"QYB存储在与小于 1 blockchain 确认这个钱包中的金额。","The derivation path":"衍生路径","The exchange rate changes with the market.":" QYB的价值将由市场说了算。","The higher the fee, the greater the incentive a miner has to include that transaction in a block. Current fees are determined based on network load and the selected policy.":"越高的费用、 更大的激励矿工有要在一个块中包含该事务。当前的费用是基于网络负载和选定的策略来确定的。","The maximum number of consecutive unused addresses (20) has been reached. When one of your unused addresses receives a payment, a new address will be generated and shown in your Receive tab.":"已连续未使用的地址 (20) 的最大数目。当你未使用的地址之一收到付款时，将生成一个新的地址，和你接收选项卡所示。","The official English Terms of Service are available on the BitPay website.":"官方的英语术语服务是可在 BitPay 网站上。","The password of the recovery phrase (if set)":"助记词的密码 (如已设置)","The payment was created but could not be completed. Please try again from home screen":"支付已创建，但无法完成。请从首页再试一次","The payment was removed by creator":"支付已被创建者移除","The recovery phrase could require a password to be imported":"助记词需要密码才能导入","The request could not be understood by the server":"服务器不理解此请求","The restore process will stop when 20 addresses are generated in a row which contain no funds. To safely generate more addresses, make a payment to one of the unused addresses which has already been generated.":"还原过程将停止 20 地址生成行包含没有资金中时。要安全地生成更多的地址，到未使用的地址已经产生之一进行付款。","The spend proposal is not pending":"花费提议不是未决","The total amount of bitcoin stored in this wallet.":"QYB存储在这个钱包的总量。","The transaction history and every new incoming transaction are cached in the app. This feature clean this up and synchronizes again from the server":"在应用程序缓存的交易历史记录和每个新传入事务。此功能清洁，这点和再次从服务器进行同步","The wallet service URL":"钱包服务 URL","There is a new version of {{appName}} available":"有可用的新版本的 {{appName}}","There is an error in the form":"表格中有错误","There's obviously something we're doing wrong.":"显然是我们正在做的事情错了。","This app is fantastic!":"这个应用程序太棒了 ！","This app stores your bitcoin with cutting-edge security.":"只要你保护好私钥。","This bitcoin payment request has expired.":"这QYB付款请求已过期。","This password cannot be recovered. If the password is lost, there is no way you could recover your funds.":"此密码将无法恢复。如果密码丢失，有是没有办法，你可以恢复你的资金。","This recovery phrase was created with a password. To recover this wallet both the recovery phrase and password are needed.":"此助记词是用密码创建。为了恢复此钱包，需要助记词和密码。","This transaction amount is too small compared to current Qybcoin network fees. Spending these funds will need a Qybcoin network fee cost comparable to the funds itself.":"相对于当前QYB网络费，这笔交易金额太小。手续费相当于这笔交易金额本身。","This transaction could take a long time to confirm or could be dropped due to the low fees set by the sender":"由于发币人设置的低费过低，这笔交易可能需要很长的时间来确认甚至可能丢失。","This wallet is not registered at the given Bitcore Wallet Service (BWS). You can recreate it from the local information.":"此钱包不在给定的 Bitcore Wallet Service (BWS) 注册。你可以从本地信息重新创建它。","Timeline":"时间轴","To":"发送到","To get started, buy bitcoin or share your address. You can receive bitcoin from any wallet or service.":"若要开始，请先获取QYB。你可以从任何钱包或地址接收QYB。","To get started, you'll need to create a bitcoin wallet and get some bitcoin.":"若要开始，你将需要创建一个QYB的钱包，并获得一些QYB。","To {{reason}} you must first add your BitPay account - {{email}}":"到 {{reason}}，你必须首先添加你的QYB帐户-{{email}}","Top up in progress...":"正在充值...","Top up {{amountStr}} to debit card ({{cardLastNumber}})":"充值 {{amountStr}}，记入借方卡 ({{cardLastNumber}})","Total":"总计","Total Locked Balance":"锁定结余的总额","Total number of copayers":"Copayers 的总数","Total wallet inputs":"钱包总共进账","Touch ID Failed":"触摸 ID 失败","Transaction":"交易","Transaction Created":"交易记录已创建","Transaction History":"交易历史记录","Transaction already broadcasted":"交易已经广播","Transaction has not been created":"交易记录尚未创建。","Transaction initiated":"交易发起","Transaction not available at this time":"交易记录暂时不可用","Transaction not found":"找不到交易","Transactions without fee are not supported.":"不支持无率交易","Transfer to":"转账给","Transfer to Wallet":"转移到钱包","Try again in {{expires}}":"在 {{expires}} 中再试一次","Turn bitcoin into dollars, swipe anywhere Visa<sup>®</sup> is accepted.":"QYB变成美元，刷在接受 Visa<sup>®</sup> 的任何地方。","Type the Recovery Phrase (usually 12 words)":"键入助记词 （通常 12 个字）","Uh oh...":"哦哦......","Unconfirmed":"未确认","Unsent transactions":"未发送的交易","Unused Addresses":"未使用的地址","Unused Addresses Limit":"未使用的地址","Update Available":"可用的更新","Updating pending proposals. Please stand by":"正在更新，请稍等。","Updating transaction history. Please stand by.":"正在更新交易历史记录。请稍等。","Updating... Please stand by":"更新中… 请稍等","Urgent":"非常快","Use Unconfirmed Funds":"使用未经确认的资金","Validating recovery phrase...":"正在验证助记词…","Verify your identity":"验证你的身份","Version":"版本","View":"查看","View All Addresses":"查看所有地址","View Terms of Service":"查看服务条款","View Transaction on Insight":"查看交易记录","View Update":"查看更新","View on blockchain":"在 qyb 上查看","Visit mercadolivre.com.br &rarr;":"访问 mercadolivre.com.br &rarr;","WARNING: Key derivation is not working on this device/wallet. Actions cannot be performed on this wallet.":"警告︰无法在此钱包上执行本操作。","WARNING: Not including the private key allows to check the wallet balance, transaction history, and create spend proposals from the export. However, does not allow to approve (sign) proposals, so <b>funds will not be accessible from the export</b>.":"警告︰不包括私钥，以检查钱包余额、交易历史记录，及从导出创建开销提议。可是，不允许批准（签名）提议，因此 <b>资金将无法从导出访问</b>。","WARNING: The private key of this wallet is not available. The export allows to check the wallet balance, transaction history, and create spend proposals from the export. However, does not allow to approve (sign) proposals, so <b>funds will not be accessible from the export</b>.":"警告︰此钱包没有可用的私钥。导出可以检查钱包余额、交易历史记录，。然而，不允许批准（签名）提议，因此 <b>资金将无从导出访问</b>。","WARNING: UNTRUSTED CERTIFICATE":"警告︰不受信任的证书","Waiting for Ledger...":"正在等待 Ledger...","Waiting for Trezor...":"正在等待 Trezor...","Waiting for copayers":"正在等待 copayers","Waiting...":"等待中...","Wallet Addresses":"钱包地址","Wallet Color":"钱包颜色","Wallet Configuration (m-n)":"钱包配置 (m n)","Wallet Created":"创建的钱包","Wallet Id":"钱包 Id","Wallet Information":"钱包信息","Wallet Inputs":"钱包总进账","Wallet Invitation":"钱包邀请","Wallet Key":"钱包钥匙","Wallet Name":"钱包名称","Wallet Name (at creation)":"钱包名称（在创建时）","Wallet Network":"钱包网","Wallet Recovery Phrase":"钱包助记词","Wallet Recovery Phrase is invalid":"无效的钱包助记词","Wallet Service URL":"钱包服务 URL","Wallet Settings":"钱包的设置","Wallet Type":"钱包类型","Wallet already exists":"钱包已存在","Wallet already in {{appName}}":"已经在 {{appName}} 的钱包","Wallet created":"创建的钱包","Wallet incomplete and broken":"钱包不完整和损坏","Wallet is full":"钱包已满","Wallet is locked":"钱包被锁定","Wallet is not complete":"钱包不完整","Wallet name":"钱包名称","Wallet needs backup":"钱包需要备份","Wallet not backed up":"未备份的钱包","Wallet not found":"找不到钱包","Wallet not registered":"未注册的钱包","Wallet not registered at the wallet service. Recreate it from \"Create Wallet\" using \"Advanced Options\" to set your recovery phrase":"钱包不在 Wallet Service 注册。使用“创建钱包\"的\"高级选项\"设置你的助记词以重新创建它","Wallet recovery phrase not available":"钱包助记词不存在","Wallet service not found":"找不到 Wallet Service","Wallets":"钱包","Warning!":"警告！​​​​​","Warning: this transaction has unconfirmed inputs":"警告︰此交易有未经确认的输入","Watch out!":"小心 ！","We'd love to do better.":"我们很乐意做得更好。","We'll confirm on the next screen.":"我们会在下一个屏幕上确认。","We're always looking for ways to improve {{appName}}.":"我们一直在寻找方法去改进{{appName}}","We're always looking for ways to improve {{appName}}. How could we improve your experience?":"我们一直在寻找方法去改进{{appName}}。我们该怎么改善你的使用体验？","Website":"网站","We’re always looking for translation contributions! You can make corrections or help to make this app available in your native language by joining our community on Crowdin.":"我们一直在寻找翻译的贡献 ！你可以作出更正或帮助使这个应用程序在你的母语中可用 Crowdin 上加入我们的社区。","What do you call this wallet?":"你叫这个钱包是什么？","When this wallet was created, it was called “{{walletName}}”. You can change the name displayed on this device below.":"这个钱包在创建时，它被称为\"{{walletName}}\"。你可以更改显示在这下面的设备的名称。","Where would you like to receive email notifications about payments?":"在那里你想要接收电子邮件通知有关付款？","Why?":"为什么？","Would you be willing to rate {{appName}} in the app store?":"你会愿意率 {{appName}} app store 中的吗？","Would you like to receive push notifications about payments?":"你想收到推式通知有关付款吗？","Wrong number of recovery words:":"恢复词句数不正确：","Wrong spending password":"支付密码错误","Yes":"是","Yes, skip":"是的跳过","You can create a backup later from your wallet settings.":"你可以从你的钱包设置以后创建备份。","You can make contributions by signing up on our Crowdin community translation website. We’re looking forward to hearing from you!":"你可以通过签约我们 Crowdin 社区翻译网站作出贡献。我们期待你的听力 ！","You can scan bitcoin addresses, payment requests, paper wallets, and more.":"你可以扫描QYB地址、 付款申请、 纸钱包和更多。","You can see the latest developments and contribute to this open source app by visiting our project on GitHub.":"你可以看到最新的事态发展和贡献这个开放源码应用程序通过在 GitHub 上访问我们的项目。","You can spend bitcoin at millions of websites and stores worldwide.":" QYB的诞生基于区块连研习社，太多你能想象和还没想象到的使用方式正在逐步实现。","You can still export it from Advanced &gt; Export.":"你仍然可以将其从高级 &gt; 出口导出。","You can trade it for other currencies like US Dollars, Euros, or Pounds.":"未来，你可以兑换成其他货币，如人民币、美元或其他数字货币。","You control your bitcoin.":"你可以控制你的QYB和你钱包的安全。","You should not set a fee higher than {{maxFeeRecommended}} satoshis/byte.":"你不应设置高于 {{maxFeeRecommended}} 粒/字节 的交易手续费。","You will need to log back for fill in your BitPay Card.":"你将需要登录回来为你 BitPay 卡填写。","You'll receive email notifications about payments sent and received from your wallets.":"在你的钱包进行付款操作时发送通知。","Your BitPay Card is ready. Add funds to your card to start using it at stores and ATMs worldwide.":"你的 BitPay 卡是准备好了。添加到你的卡开始使用它在商店和自动取款机全球基金。","Your Gift Cards":"礼品卡","Your bitcoin wallet is backed up!":"你的QYB钱包已备份 ！","Your bitcoin wallet is ready!":"你的粽子钱包已可以开始使用 ！","Your fee is lower than recommended.":"你的交易手续费低于建议量。","Your ideas, feedback, or comments":"你的想法、 反馈或评论","Your name":"你的名字：","Your nickname":"你的昵称","Your password":"你的密码","Your purchase could not be completed":"无法完成你的购买","Your purchase was added to the list of pending":"你的购买被添加到列表的挂起","Your wallet is never saved to cloud storage or standard device backups.":"你的钱包不会由云储存或备份。","Your wallet key will be encrypted. The Spending Password cannot be recovered. Be sure to write it down.":"你的钱包钥匙将被加密。支付密码不能恢复。必须把它抄写下来","[Balance Hidden]":"[隐藏余额]","[Scanning Funds]":"[正在扫描资金]","add your BitPay Visa card(s)":"添加你的 BitPay 签证卡","locked by pending payments":"被未决支付锁定","me":"我","name@example.com":"name@example.com","preparing...":"准备中...","recovery tool.":"恢复工具","{{amountStr}} for Amazon.com Gift Card":"{{amountStr}} 为亚马逊礼品卡的","{{amountStr}} for Mercado Livre Brazil Gift Card":"梅尔卡多里弗巴西礼品卡 {{amountStr}}","{{appName}} depends on Bitcore Wallet Service (BWS) for blockchain information, networking and Copayer synchronization. The default configuration points to https://bws.bitpay.com (BitPay's public BWS instance).":"{{appName}} 中的区块链信息依赖于 Bitcore Wallet Service (BWS)、网络和 Copayer synchronization。默认配置指向 https://bws.bitpay.com (BitPay 的公共 BWS 实例)。","{{fee}} will be deducted for bitcoin networking fees.":"{{fee}} 将QYB网络费用中扣除。","{{tx.txp[wallet.id].feeRatePerStr}}  of the sending amount":"发送量 {{tx.txp[wallet.id].feeRatePerStr}}","{{updatingTxHistoryProgress}} transactions downloaded":"下载的 {{updatingTxHistoryProgress}} 交易","{{wallet.m}}-of-{{wallet.n}}":"{{wallet.m}}{{wallet.n}}","Qyb wallet":"粽子钱包","Send Lucky Money":"發送紅包","History":"我的紅包","Amount Each":"單個金額","Total Amount":"總金額","Identical Amount, ":"普通等額紅包，","Random Amount, ":"拼手氣紅包，","Change to random amnout.":"改爲隨機金額","Change to Identical Amount.":"改爲固定金額","Prepare Lucky Money":"塞幣進錢包"});
/* jshint +W100 */
}]);
window.version="1.0.0";
window.commitHash="029eaa9";
window.appConfig={"//":"        Modify it in the app-template directory","packageName":"qyb","packageDescription":"QYBcoin Wallet","packageNameId":"one.chainclub.qyb","statusBarColor":"#192c3a","userVisibleName":"QYB","purposeLine":"QYBcoin Wallet","bundleName":"qyb","appUri":"qyb","name":"qyb","nameNoSpace":"qyb","nameCase":"qyb","nameCaseNoSpace":"qyb","gitHubRepoName":"QYBcoin","gitHubRepoUrl":"https://github.com/BlockChainClub/qyb-wallet-clients.git","gitHubRepoBugs":"https://github.com/BlockChainClub/qyb-wallet-clients.git","disclaimerUrl":"https://github.com/BlockChainClub/qyb-wallet-clients.git","url":"https://github.com/BlockChainClub/qyb-wallet-clients.git","appDescription":"QYBcoin Wallet","winAppName":"QYBWallet","WindowsStoreIdentityName":"18C7659D.QYBcoin-SecureCoinWallet","WindowsStoreDisplayName":"QYBcoin - Secure coin Wallet","windowsAppId":"804636ee-b017-4cad-8719-e58ac97ffa5c","pushSenderId":"1036948132229","description":"A Secure coin Wallet","version":"1.0.0","androidVersion":"100","_extraCSS":null,"_enabledExtensions":{"coinbase":false,"glidera":false,"amazon":false}};
window.externalServices={};
'use strict';

angular.element(document).ready(function() {

  // Run copayApp after device is ready.
  var startAngular = function() {
    angular.bootstrap(document, ['copayApp']);
  };


  function handleOpenURL(url) {
    if ('cordova' in window) {
      console.log('DEEP LINK:' + url);
      cordova.fireDocumentEvent('handleopenurl', {
        url: url
      });
    } else {
      console.log("ERROR: Cannont handle open URL in non-cordova apps")
    }
  };

  /* Cordova specific Init */
  if ('cordova' in window) {

    window.handleOpenURL = handleOpenURL;


    document.addEventListener('deviceready', function() {

      window.open = cordova.InAppBrowser.open;

      // Create a sticky event for handling the app being opened via a custom URL
      cordova.addStickyDocumentEventHandler('handleopenurl');
      startAngular();
    }, false);

  } else {
    startAngular();
  }

});

window.TREZOR_CHROME_URL = './bower_components/trezor-connect/chrome/wrapper.html';


/**
 * (C) 2017 SatoshiLabs
 *
 * GPLv3
 */

if (!Array.isArray) {
    Array.isArray = function(arg) {
        return Object.prototype.toString.call(arg) === '[object Array]';
    };
}

var HD_HARDENED = 0x80000000;

// react sometimes adds some other parameters that should not be there
function _fwStrFix(obj, fw) {
    if (typeof fw === 'string') {
        obj.requiredFirmware = fw;
    }
    return obj;
}

this.TrezorConnect = (function () {
    'use strict';

    var chrome = window.chrome;
    var IS_CHROME_APP = chrome && chrome.app && chrome.app.window;

    var ERR_TIMED_OUT = 'Loading timed out';
    var ERR_WINDOW_CLOSED = 'Window closed';
    var ERR_WINDOW_BLOCKED = 'Window blocked';
    var ERR_ALREADY_WAITING = 'Already waiting for a response';
    var ERR_CHROME_NOT_CONNECTED = 'Internal Chrome popup is not responding.';

    var DISABLE_LOGIN_BUTTONS = window.TREZOR_DISABLE_LOGIN_BUTTONS || false;
    var CHROME_URL = window.TREZOR_CHROME_URL || './chrome/wrapper.html';
    var POPUP_URL = window.TREZOR_POPUP_URL || 'https://connect.trezor.io/1/popup/popup.html';
    var POPUP_PATH = window.TREZOR_POPUP_PATH || 'https://connect.trezor.io/1';
    var POPUP_ORIGIN = window.TREZOR_POPUP_ORIGIN || 'https://connect.trezor.io';

    var INSIGHT_URLS = window.TREZOR_INSIGHT_URLS || 
        [
            'https://bitcore1.trezor.io/api/',
            'https://bitcore3.trezor.io/api/',
        ];

    var POPUP_INIT_TIMEOUT = 15000;

    /**
     * Public API.
     */
    function TrezorConnect() {

        var manager = new PopupManager();

        /**
         * Popup errors.
         */
        this.ERR_TIMED_OUT = ERR_TIMED_OUT;
        this.ERR_WINDOW_CLOSED = ERR_WINDOW_CLOSED;
        this.ERR_WINDOW_BLOCKED = ERR_WINDOW_BLOCKED;
        this.ERR_ALREADY_WAITING = ERR_ALREADY_WAITING;
        this.ERR_CHROME_NOT_CONNECTED = ERR_CHROME_NOT_CONNECTED;

        /**
         * Open the popup for further communication. All API functions open the
         * popup automatically, but if you need to generate some parameters
         * asynchronously, use `open` first to avoid popup blockers.
         * @param {function(?Error)} callback
         */
        this.open = function (callback) {
            var onchannel = function (result) {
                if (result instanceof Error) {
                    callback(result);
                } else {
                    callback();
                }
            };
            manager.waitForChannel(onchannel);
        };

        /**
         * Close the opened popup, if any.
         */
        this.close = function () { manager.close(); };

        /**
         * Enable or disable closing the opened popup after a successful call.
         * @param {boolean} value
         */
        this.closeAfterSuccess = function (value) { manager.closeAfterSuccess = value; };

        /**
         * Enable or disable closing the opened popup after a failed call.
         * @param {boolean} value
         */
        this.closeAfterFailure = function (value) { manager.closeAfterFailure = value; };

        /**
         * @typedef XPubKeyResult
         * @param {boolean} success
         * @param {?string} error
         * @param {?string} xpubkey  serialized extended public key
         * @param {?string} path     BIP32 serializd path of the key
         */

        /**
         * Load BIP32 extended public key by path.
         *
         * Path can be specified either in the string form ("m/44'/1/0") or as
         * raw integer array. In case you omit the path, user is asked to select
         * a BIP32 account to export, and the result contains m/44'/0'/x' node
         * of the account.
         *
         * @param {?(string|array<number>)} path
         * @param {function(XPubKeyResult)} callback
         * @param {?(string|array<number>)} requiredFirmware
         */
        this.getXPubKey = function (path, callback, requiredFirmware) {
            if (typeof path === 'string') {
                path = parseHDPath(path);
            }
            manager.sendWithChannel(_fwStrFix({
                type: 'xpubkey',
                path: path
            }, requiredFirmware), callback);
        };

        this.getFreshAddress = function (callback, requiredFirmware) {
            var wrapperCallback = function (result) {
                if (result.success) {
                    callback({success: true, address: result.freshAddress});
                } else {
                    callback(result);
                }
            }

            manager.sendWithChannel(_fwStrFix({
                type: 'accountinfo'
            }, requiredFirmware), wrapperCallback);
        }

        this.getAccountInfo = function (input, callback, requiredFirmware) {
            try {
                var description = parseAccountInfoInput(input);
                manager.sendWithChannel(_fwStrFix({
                    type: 'accountinfo',
                    description: description
                }, requiredFirmware), callback);
            } catch(e) {
                callback({success: false, error: e});
            }
        }

        this.getBalance = function (callback, requiredFirmware) {
            manager.sendWithChannel(_fwStrFix({
                type: 'accountinfo'
            }, requiredFirmware), callback)
        }

        /**
         * @typedef SignTxResult
         * @param {boolean} success
         * @param {?string} error
         * @param {?string} serialized_tx      serialized tx, in hex, including signatures
         * @param {?array<string>} signatures  array of input signatures, in hex
         */

        /**
         * Sign a transaction in the device and return both serialized
         * transaction and the signatures.
         *
         * @param {array<TxInputType>} inputs
         * @param {array<TxOutputType>} outputs
         * @param {function(SignTxResult)} callback
         * @param {?(string|array<number>)} requiredFirmware
         *
         * @see https://github.com/trezor/trezor-common/blob/master/protob/types.proto
         */
        this.signTx = function (inputs, outputs, callback, requiredFirmware) {
            manager.sendWithChannel(_fwStrFix({
                type: 'signtx',
                inputs: inputs,
                outputs: outputs
            }, requiredFirmware), callback);
        };

        this.signEthereumTx = function (
            address_n,
            nonce,
            gas_price,
            gas_limit,
            to,
            value,
            data,
            chain_id,
            callback,
            requiredFirmware
        ) {
            if (requiredFirmware == null) {
                requiredFirmware = '1.4.0'; // first firmware that supports ethereum
            }
            if (typeof address_n === 'string') {
                address_n = parseHDPath(address_n);
            }
            manager.sendWithChannel(_fwStrFix({
                type: 'signethtx',
                address_n: address_n,
                nonce: nonce,
                gas_price: gas_price,
                gas_limit: gas_limit,
                to: to,
                value: value,
                data: data,
                chain_id: chain_id,
            }, requiredFirmware), callback);
        };

        /**
         * @typedef TxRecipient
         * @param {number} amount   the amount to send, in satoshis
         * @param {string} address  the address of the recipient
         */

        /**
         * Compose a transaction by doing BIP-0044 discovery, letting the user
         * select an account, and picking UTXO by internal preferences.
         * Transaction is then signed and returned in the same format as
         * `signTx`.  Only supports BIP-0044 accounts (single-signature).
         *
         * @param {array<TxRecipient>} recipients
         * @param {function(SignTxResult)} callback
         * @param {?(string|array<number>)} requiredFirmware
         */
        this.composeAndSignTx = function (recipients, callback, requiredFirmware) {
            manager.sendWithChannel(_fwStrFix({
                type: 'composetx',
                recipients: recipients
            }, requiredFirmware), callback);
        };

        /**
         * @typedef RequestLoginResult
         * @param {boolean} success
         * @param {?string} error
         * @param {?string} public_key  public key used for signing, in hex
         * @param {?string} signature   signature, in hex
         */

        /**
         * Sign a login challenge for active origin.
         *
         * @param {?string} hosticon
         * @param {string} challenge_hidden
         * @param {string} challenge_visual
         * @param {string|function(RequestLoginResult)} callback
         * @param {?(string|array<number>)} requiredFirmware
         *
         * @see https://github.com/trezor/trezor-common/blob/master/protob/messages.proto
         */
        this.requestLogin = function (
            hosticon,
            challenge_hidden,
            challenge_visual,
            callback,
            requiredFirmware
        ) {
            if (typeof callback === 'string') {
                // special case for a login through <trezor:login> button.
                // `callback` is name of global var
                callback = window[callback];
            }
            if (!callback) {
                throw new TypeError('TrezorConnect: login callback not found');
            }
            manager.sendWithChannel(_fwStrFix({
                type: 'login',
                icon: hosticon,
                challenge_hidden: challenge_hidden,
                challenge_visual: challenge_visual
            }, requiredFirmware), callback);
        };

        /**
         * @typedef SignMessageResult
         * @param {boolean} success
         * @param {?string} error
         * @param {?string} address address (in base58check)
         * @param {?string} signature   signature, in base64
         */

        /**
         * Sign a message
         *
         * @param {string|array} path  
         * @param {string} message to sign (ascii)
         * @param {string|function(SignMessageResult)} callback
         * @param {?string} opt_coin - (optional) name of coin (default Bitcoin)
         * @param {?(string|array<number>)} requiredFirmware
         *
         */
        this.signMessage = function (
            path,
            message,
            callback,
            opt_coin,
            requiredFirmware
        ) {
            if (typeof path === 'string') {
                path = parseHDPath(path);
            }
            if (!opt_coin) {
                opt_coin = 'Bitcoin';
            }
            if (!callback) {
                throw new TypeError('TrezorConnect: callback not found');
            }
            manager.sendWithChannel(_fwStrFix({
                type: 'signmsg',
                path: path,
                message: message,
                coin: {coin_name: opt_coin},
            }, requiredFirmware), callback);
        };

        /**
         * Verify message
         *
         * @param {string} address
         * @param {string} signature (base64)
         * @param {string} message (string)
         * @param {string|function()} callback
         * @param {?string} opt_coin - (optional) name of coin (default Bitcoin)
         * @param {?(string|array<number>)} requiredFirmware
         *
         */
        this.verifyMessage = function (
            address,
            signature,
            message,
            callback,
            opt_coin,
            requiredFirmware
        ) {
            if (!opt_coin) {
                opt_coin = 'Bitcoin';
            }
            if (!callback) {
                throw new TypeError('TrezorConnect: callback not found');
            }
            manager.sendWithChannel(_fwStrFix({
                type: 'verifymsg',
                address: address,
                signature: signature,
                message: message,
                coin: {coin_name: opt_coin},
            }, requiredFirmware), callback);
        };

        /**
         * Symmetric key-value encryption
         *
         * @param {string|array} path
         * @param {string} key to show on device display
         * @param {string} value hexadecimal value, length a multiple of 16 bytes
         * @param {boolean} encrypt / decrypt direction
         * @param {boolean} ask_on_encrypt (should user confirm on encrypt?)
         * @param {boolean} ask_on_decrypt (should user confirm on decrypt?)
         * @param {string|function()} callback
         * @param {?(string|array<number>)} requiredFirmware
         *
         */
        this.cipherKeyValue = function (
            path,
            key,
            value,
            encrypt,
            ask_on_encrypt,
            ask_on_decrypt,
            callback,
            requiredFirmware
        ) {
            if (typeof path === 'string') {
                path = parseHDPath(path);
            }
            if (typeof value !== 'string') {
                throw new TypeError('TrezorConnect: Value must be a string');
            }
            if (!(/^[0-9A-Fa-f]*$/.test(value))) {
                throw new TypeError('TrezorConnect: Value must be hexadecimal');
            }
            if (value.length % 32 !== 0) {
                // 1 byte == 2 hex strings
                throw new TypeError('TrezorConnect: Value length must be multiple of 16 bytes');
            }
            if (!callback) {
                throw new TypeError('TrezorConnect: callback not found');
            }
            manager.sendWithChannel(_fwStrFix({
                type: 'cipherkeyvalue',
                path: path,
                key: key,
                value: value,
                encrypt: !!encrypt,
                ask_on_encrypt: !!ask_on_encrypt,
                ask_on_decrypt: !!ask_on_decrypt
            }, requiredFirmware), callback);
        };

        this.pushTransaction = function (
          rawTx,
          callback
        ) {
            if (!(/^[0-9A-Fa-f]*$/.test(rawTx))) {
                throw new TypeError('TrezorConnect: Transaction must be hexadecimal');
            }
            if (!callback) {
                throw new TypeError('TrezorConnect: callback not found');
            }

            var tryUrl = function(i) {
                var insight_url = INSIGHT_URLS[i];
                var xhr = new XMLHttpRequest();
                var method = 'POST';
                var url = insight_url + '/tx/send';
                var data = {
                    rawtx: rawTx
                };

                xhr.open(method, url, true);
                xhr.setRequestHeader('Content-Type', 'application/json');
                xhr.onreadystatechange = function () {
                    if (xhr.readyState === XMLHttpRequest.DONE) {
                        if (xhr.status === 200) {
                            var txid = JSON.parse(xhr.responseText).txid;
                            callback({success: true, txid: txid});
                        } else {
                            if (i === INSIGHT_URLS.length - 1) {
                                callback({error: new Error(xhr.responseText)});
                            } else {
                                tryUrl(i + 1);
                            }
                        }
                    }
                };
                xhr.send(JSON.stringify(data));
            }

            tryUrl(0);
        }

        var LOGIN_CSS =
            '<style>@import url("@connect_path@/login_buttons.css")</style>';

        var LOGIN_ONCLICK =
            'TrezorConnect.requestLogin('
            + "'@hosticon@','@challenge_hidden@','@challenge_visual@','@callback@'"
            + ')';

        var LOGIN_HTML =
            '<div id="trezorconnect-wrapper">'
            + '  <a id="trezorconnect-button" onclick="' + LOGIN_ONCLICK + '">'
            + '    <span id="trezorconnect-icon"></span>'
            + '    <span id="trezorconnect-text">@text@</span>'
            + '  </a>'
            + '  <span id="trezorconnect-info">'
            + '    <a id="trezorconnect-infolink" href="https://www.buytrezor.com/"'
            + '       target="_blank">What is TREZOR?</a>'
            + '  </span>'
            + '</div>';

        /**
         * Find <trezor:login> elements and replace them with login buttons.
         * It's not required to use these special elements, feel free to call
         * `TrezorConnect.requestLogin` directly.
         */
        this.renderLoginButtons = function () {
            var elements = document.getElementsByTagName('trezor:login');

            for (var i = 0; i < elements.length; i++) {
                var e = elements[i];
                var text = e.getAttribute('text') || 'Sign in with TREZOR';
                var callback = e.getAttribute('callback') || '';
                var hosticon = e.getAttribute('icon') || '';
                var challenge_hidden = e.getAttribute('challenge_hidden') || '';
                var challenge_visual = e.getAttribute('challenge_visual') || '';

                // it's not valid to put markup into attributes, so let users
                // supply a raw text and make TREZOR bold
                text = text.replace('TREZOR', '<strong>TREZOR</strong>');
                e.outerHTML =
                    (LOGIN_CSS + LOGIN_HTML)
                    .replace('@text@', text)
                    .replace('@callback@', callback)
                    .replace('@hosticon@', hosticon)
                    .replace('@challenge_hidden@', challenge_hidden)
                    .replace('@challenge_visual@', challenge_visual)
                    .replace('@connect_path@', POPUP_PATH);
            }
        };
    }

    /*
     * `getXPubKey()`
     */

    function parseHDPath(string) {
        return string
            .toLowerCase()
            .split('/')
            .filter(function (p) { return p !== 'm'; })
            .map(function (p) {
                var hardened = false;
                if (p[p.length - 1] === "'") {
                    hardened = true;
                    p = p.substr(0, p.length - 1);
                }
                if (isNaN(p)) {
                   throw new Error('Not a valid path.');
                }
                var n = parseInt(p);
                if (hardened) { // hardened index
                    n = (n | 0x80000000) >>> 0;
                }
                return n;
            });
    }


    function getIdFromPath(path) {
        if (path.length !== 3) {
            throw new Error();
        }
        if ((path[0] >>> 0) !== ((44 | HD_HARDENED) >>> 0)) {
            throw new Error();
        }
        if ((path[1] >>> 0) !== ((0 | HD_HARDENED) >>> 0)) {
            throw new Error();
        }
        return ((path[2] & ~HD_HARDENED) >>> 0);
    }

    // parses first argument from getAccountInfo
    function parseAccountInfoInput(input) {
        if (input == null) {
            return null;
        }

        if (typeof input === 'string') {
            if (input.substr(0, 4) === 'xpub') {
                return input;
            }
            if (isNaN(input)) {
                var parsedPath = parseHDPath(input);
                return getIdFromPath(parsedPath);
            } else {
                return parseInt(input);
            }
        } else if (Array.isArray(input)) {
            return getIdFromPath(input);
        } else if (typeof input === 'number') {
            return input;
        }
        throw new Error('Unknown input format.');
    }

    /*
     * Popup management
     */

    function ChromePopup(url, name, width, height) {
        var left = (screen.width - width) / 2;
        var top = (screen.height - height) / 2;
        var opts = {
            id: name,
            innerBounds: {
                width: width,
                height: height,
                left: left,
                top: top
            }
        };

        var closed = function () {
            if (this.onclose) {
                this.onclose(false); // never report as blocked
            }
        }.bind(this);

        var opened = function (w) {
            this.window = w;
            this.window.onClosed.addListener(closed);
        }.bind(this);

        chrome.app.window.create(url, opts, opened);

        this.name = name;
        this.window = null;
        this.onclose = null;
    }

    function ChromeChannel(popup, waiting) {
        var port = null;

        var respond = function (data) {
            if (waiting) {
                var w = waiting;
                waiting = null;
                w(data);
            }
        };

        var setup = function (p) {
            if (p.name === popup.name) {
                port = p;
                port.onMessage.addListener(respond);
                chrome.runtime.onConnect.removeListener(setup);
            }
        };

        chrome.runtime.onConnect.addListener(setup);

        this.respond = respond;

        this.close = function () {
            chrome.runtime.onConnect.removeListener(setup);
            port.onMessage.removeListener(respond);
            port.disconnect();
            port = null;
        };

        this.send = function (value, callback) {
            if (waiting === null) {
                waiting = callback;

                if (port) {
                    port.postMessage(value);
                } else {
                    throw new Error(ERR_CHROME_NOT_CONNECTED);
                }
            } else {
                throw new Error(ERR_ALREADY_WAITING);
            }
        };
    }

    function Popup(url, origin, name, width, height) {
        var left = (screen.width - width) / 2;
        var top = (screen.height - height) / 2;
        var opts =
            'width=' + width +
            ',height=' + height +
            ',left=' + left +
            ',top=' + top +
            ',menubar=no' +
            ',toolbar=no' +
            ',location=no' +
            ',personalbar=no' +
            ',status=no';
        var w = window.open(url, name, opts);

        var interval;
        var blocked = w.closed;
        var iterate = function () {
            if (w.closed) {
                clearInterval(interval);
                if (this.onclose) {
                    this.onclose(blocked);
                }
            }
        }.bind(this);
        interval = setInterval(iterate, 100);

        this.window = w;
        this.origin = origin;
        this.onclose = null;
    }

    function Channel(popup, waiting) {

        var respond = function (data) {
            if (waiting) {
                var w = waiting;
                waiting = null;
                w(data);
            }
        };

        var receive = function (event) {
            if (event.source === popup.window && event.origin === popup.origin) {
                respond(event.data);
            }
        };

        window.addEventListener('message', receive);

        this.respond = respond;

        this.close = function () {
            window.removeEventListener('message', receive);
        };

        this.send = function (value, callback) {
            if (waiting === null) {
                waiting = callback;
                popup.window.postMessage(value, popup.origin);
            } else {
                throw new Error(ERR_ALREADY_WAITING);
            }
        };
    }

    function ConnectedChannel(p) {

        var ready = function () {
            clearTimeout(this.timeout);
            this.popup.onclose = null;
            this.ready = true;
            this.onready();
        }.bind(this);

        var closed = function (blocked) {
            clearTimeout(this.timeout);
            this.channel.close();
            if (blocked) {
                this.onerror(new Error(ERR_WINDOW_BLOCKED));
            } else {
                this.onerror(new Error(ERR_WINDOW_CLOSED));
            }
        }.bind(this);

        var timedout = function () {
            this.popup.onclose = null;
            if (this.popup.window) {
                this.popup.window.close();
            }
            this.channel.close();
            this.onerror(new Error(ERR_TIMED_OUT));
        }.bind(this);

        if (IS_CHROME_APP) {
            this.popup = new ChromePopup(p.chromeUrl, p.name, p.width, p.height);
            this.channel = new ChromeChannel(this.popup, ready);
        } else {
            this.popup = new Popup(p.url, p.origin, p.name, p.width, p.height);
            this.channel = new Channel(this.popup, ready);
        }

        this.timeout = setTimeout(timedout, POPUP_INIT_TIMEOUT);

        this.popup.onclose = closed;

        this.ready = false;
        this.onready = null;
        this.onerror = null;
    }

    function PopupManager() {
        var cc = null;

        var closed = function () {
            cc.channel.respond(new Error(ERR_WINDOW_CLOSED));
            cc.channel.close();
            cc = null;
        };

        var open = function (callback) {
            cc = new ConnectedChannel({
                name: 'trezor-connect',
                width: 600,
                height: 500,
                origin: POPUP_ORIGIN,
                path: POPUP_PATH,
                url: POPUP_URL,
                chromeUrl: CHROME_URL
            });
            cc.onready = function () {
                cc.popup.onclose = closed;
                callback(cc.channel);
            };
            cc.onerror = function (error) {
                cc = null;
                callback(error);
            };
        }.bind(this);

        this.closeAfterSuccess = true;
        this.closeAfterFailure = true;

        this.close = function () {
            if (cc && cc.popup.window) {
                cc.popup.window.close();
            }
        };

        this.waitForChannel = function (callback) {
            if (cc) {
                if (cc.ready) {
                    callback(cc.channel);
                } else {
                    callback(new Error(ERR_ALREADY_WAITING));
                }
            } else {
                try {
                    open(callback);
                } catch (e) {
                    callback(new Error(ERR_WINDOW_BLOCKED));
                }
            }
        };

        this.sendWithChannel = function (message, callback) {

            var respond = function (response) {
                var succ = response.success && this.closeAfterSuccess;
                var fail = !response.success && this.closeAfterFailure;
                if (succ || fail) {
                    this.close();
                }
                callback(response);
            }.bind(this);

            var onresponse = function (response) {
                if (response instanceof Error) {
                    var error = response;
                    respond({ success: false, error: error.message });
                } else {
                    respond(response);
                }
            };

            var onchannel = function (channel) {
                if (channel instanceof Error) {
                    var error = channel;
                    respond({ success: false, error: error.message });
                } else {
                    channel.send(message, onresponse);
                }
            };

            this.waitForChannel(onchannel);
        };
    }

    var exports = new TrezorConnect();

    if (!IS_CHROME_APP && !DISABLE_LOGIN_BUTTONS) {
        exports.renderLoginButtons();
    }

    return exports;

}());

!function(r){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=r();else if("function"==typeof define&&define.amd)define([],r);else{var n;n="undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this,n.BezierEasing=r()}}(function(){return function r(n,e,t){function o(u,i){if(!e[u]){if(!n[u]){var a="function"==typeof require&&require;if(!i&&a)return a(u,!0);if(f)return f(u,!0);var c=new Error("Cannot find module '"+u+"'");throw c.code="MODULE_NOT_FOUND",c}var d=e[u]={exports:{}};n[u][0].call(d.exports,function(r){var e=n[u][1][r];return o(e?e:r)},d,d.exports,r,n,e,t)}return e[u].exports}for(var f="function"==typeof require&&require,u=0;u<t.length;u++)o(t[u]);return o}({1:[function(r,n,e){function t(r,n){return 1-3*n+3*r}function o(r,n){return 3*n-6*r}function f(r){return 3*r}function u(r,n,e){return((t(n,e)*r+o(n,e))*r+f(n))*r}function i(r,n,e){return 3*t(n,e)*r*r+2*o(n,e)*r+f(n)}function a(r,n,e,t,o){var f,i,a=0;do i=n+(e-n)/2,f=u(i,t,o)-r,f>0?e=i:n=i;while(Math.abs(f)>p&&++a<s);return i}function c(r,n,e,t){for(var o=0;d>o;++o){var f=i(n,e,t);if(0===f)return n;var a=u(n,e,t)-r;n-=a/f}return n}var d=4,l=.001,p=1e-7,s=10,v=11,y=1/(v-1),w="function"==typeof Float32Array;n.exports=function(r,n,e,t){function o(n){for(var t=0,o=1,u=v-1;o!==u&&f[o]<=n;++o)t+=y;--o;var d=(n-f[o])/(f[o+1]-f[o]),p=t+d*y,s=i(p,r,e);return s>=l?c(n,p,r,e):0===s?p:a(n,t,t+y,r,e)}if(!(r>=0&&1>=r&&e>=0&&1>=e))throw new Error("bezier x values must be in [0, 1] range");var f=w?new Float32Array(v):new Array(v);if(r!==n||e!==t)for(var d=0;v>d;++d)f[d]=u(d*y,r,e);return function(f){return r===n&&e===t?f:0===f?0:1===f?1:u(o(f),n,t)}}},{}]},{},[1])(1)});

!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define("QRScanner",[],t):"object"==typeof exports?exports.QRScanner=t():e.QRScanner=t()}(this,function(){return function(e){function t(r){if(n[r])return n[r].exports;var i=n[r]={i:r,l:!1,exports:{}};return e[r].call(i.exports,i,i.exports,t),i.l=!0,i.exports}var n={};return t.m=e,t.c=n,t.i=function(e){return e},t.d=function(e,n,r){t.o(e,n)||Object.defineProperty(e,n,{configurable:!1,enumerable:!0,get:r})},t.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(n,"a",n),n},t.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},t.p="",t(t.s=13)}([function(e,t,n){"use strict";var r=!0,i={disableLog:function(e){return"boolean"!=typeof e?new Error("Argument type: "+typeof e+". Please use a boolean."):(r=e,e?"adapter.js logging disabled":"adapter.js logging enabled")},log:function(){if("object"==typeof window){if(r)return;"undefined"!=typeof console&&"function"==typeof console.log&&console.log.apply(console,arguments)}},extractVersion:function(e,t,n){var r=e.match(t);return r&&r.length>=n&&parseInt(r[n],10)},detectBrowser:function(){var e={};if(e.browser=null,e.version=null,"undefined"==typeof window||!window.navigator)return e.browser="Not a browser.",e;if(navigator.mozGetUserMedia)e.browser="firefox",e.version=this.extractVersion(navigator.userAgent,/Firefox\/(\d+)\./,1);else if(navigator.webkitGetUserMedia)if(window.webkitRTCPeerConnection)e.browser="chrome",e.version=this.extractVersion(navigator.userAgent,/Chrom(e|ium)\/(\d+)\./,2);else{if(!navigator.userAgent.match(/Version\/(\d+).(\d+)/))return e.browser="Unsupported webkit-based browser with GUM support but no WebRTC support.",e;e.browser="safari",e.version=this.extractVersion(navigator.userAgent,/AppleWebKit\/(\d+)\./,1)}else if(navigator.mediaDevices&&navigator.userAgent.match(/Edge\/(\d+).(\d+)$/))e.browser="edge",e.version=this.extractVersion(navigator.userAgent,/Edge\/(\d+).(\d+)$/,2);else{if(!navigator.mediaDevices||!navigator.userAgent.match(/AppleWebKit\/(\d+)\./))return e.browser="Not a supported browser.",e;e.browser="safari",e.version=this.extractVersion(navigator.userAgent,/AppleWebKit\/(\d+)\./,1)}return e},shimCreateObjectURL:function(){if("object"==typeof window&&window.HTMLMediaElement&&"srcObject"in window.HTMLMediaElement.prototype){var e=URL.createObjectURL.bind(URL),t=URL.revokeObjectURL.bind(URL),n=new Map,r=0;URL.createObjectURL=function(t){if("getTracks"in t){var i="polyblob:"+ ++r;return n.set(i,t),console.log("URL.createObjectURL(stream) is deprecated! Use elem.srcObject = stream instead!"),i}return e(t)},URL.revokeObjectURL=function(e){t(e),n.delete(e)};var i=Object.getOwnPropertyDescriptor(window.HTMLMediaElement.prototype,"src");Object.defineProperty(window.HTMLMediaElement.prototype,"src",{get:function(){return i.get.apply(this)},set:function(e){return this.srcObject=n.get(e)||null,i.set.apply(this,[e])}});var o=HTMLMediaElement.prototype.setAttribute;HTMLMediaElement.prototype.setAttribute=function(){return 2===arguments.length&&"src"===(""+arguments[0]).toLowerCase()&&(this.srcObject=n.get(arguments[1])||null),o.apply(this,arguments)}}}};e.exports={log:i.log,disableLog:i.disableLog,browserDetails:i.detectBrowser(),extractVersion:i.extractVersion,shimCreateObjectURL:i.shimCreateObjectURL,detectBrowser:i.detectBrowser.bind(i)}},function(e,t,n){n(5);var r=n(3);e.exports=function(){function e(e){e.getTracks().forEach(function(e){e.stop()})}function t(t){function n(e,t,n,r){var i={audio:!1,video:{}};return i.video.deviceId={exact:e},t&&(i.video.facingMode={exact:t}),n&&(i.video.width={exact:n}),r&&(i.video.height={exact:r}),i}function r(t){return new Promise(function(n){return t.reduce(function(t,n){return t.then(function(t){return t.found?t:(t.nextConstraint=n,window.navigator.mediaDevices.getUserMedia(t.nextConstraint).then(function(n){return e(n),t.found=!0,t},function(){return t}))})},Promise.resolve({found:!1,nextConstraint:{}})).then(function(e){n(e.found?e.nextConstraint:null)})})}var i=Y.map(function(e){return n(t,e)}),o=Q.map(function(e){return n(t,null,e)}),a=Q.map(function(e){return n(t,null,null,e)});return r(i).then(function(e){return r(o).then(function(n){return r(a).then(function(r){return{deviceId:t,facingMode:null===e?null:e.video.facingMode.exact,width:null===n?null:n.video.width.exact,height:null===r?null:r.video.height.exact}})})})}function n(){var e=window.navigator.mediaDevices.enumerateDevices();return e.then(function(e){var t=e.filter(function(e){return"videoinput"===e.kind}).map(function(e){return e.deviceId});return t}).then(function(e){var n=[];return e.forEach(function(e){n.push(t(e))}),Promise.all(n)}).then(function(e){return e.filter(function(e){if(null!==e&&null!==e.width&&null!==e.height)return!0}).sort(function(e,t){return t.width-e.width})}).then(function(e){for(var t=null,n=null,r=0;r<e.length;r++)if("environment"===e[r].facingMode){t=e[r],e.splice(r,1);break}return null===t&&(e.length>0?(t=e[0],e.splice(0,1)):t=!1),n=e.length>0&&e[0],{backCamera:t,frontCamera:n}})}function i(){return null!==j}function o(){e(j),j=null}function a(){return document.getElementById(I.preview)}function s(){return document.getElementById(I.still)}function c(){return _}function d(){return 1===_?B:A}function u(){var e=s();e&&(e.style.visibility="visible",U=!1)}function h(){var e=s();e&&(e.style.visibility="hidden",U=!0)}function f(){return null!==A}function l(){return!!A&&!!B}function p(){return{authorized:null!==A&&A!==!1?"1":"0",denied:"0",restricted:"0",prepared:f()?"1":"0",scanning:F?"1":"0",previewing:U?"1":"0",showing:a()?"1":"0",lightEnabled:"0",canOpenSettings:"0",canEnableLight:"0",canChangeCamera:l()?"1":"0",currentCamera:_.toString()}}function w(e,t){var n=c(),r=d();window.navigator.mediaDevices.getUserMedia({audio:!1,video:{deviceId:{exact:r.deviceId},width:{ideal:r.width},height:{ideal:r.height}}}).then(function(t){j=t;var n=a();n.src=URL.createObjectURL(t),e(p())},function(e){e=null;var r=n?4:3;t(r)})}function v(e){var t=document.createElement("canvas"),n=d();t.height=n.height,t.width=n.width;var r=t.getContext("2d");return r.drawImage(e,0,0,n.width,n.height),{canvas:t,context:r}}function m(e){var t=v(e);return t.context.getImageData(0,0,t.canvas.width,t.canvas.height)}function g(e){return v(e).canvas.toDataURL("image/png")}function b(e,t){if(null===G){var i=new Blob([r],{type:"text/javascript"});G=new Worker(URL.createObjectURL(i))}if(!a()){var o=document.createElement("video");o.setAttribute("autoplay","autoplay"),o.setAttribute("id",I.preview),o.setAttribute("style","display:block;position:fixed;top:50%;left:50%;width:auto;height:auto;min-width:100%;min-height:100%;z-index:"+N.preview+";-moz-transform: translateX(-50%) translateY(-50%);-webkit-transform: translateX(-50%) translateY(-50%);transform:translateX(-50%) translateY(-50%);background-size:cover;background-position:50% 50%;background-color:#FFF;"),o.addEventListener("loadeddata",function(){h()});var s=document.createElement("div");s.setAttribute("id",I.still),s.setAttribute("style","display:block;position:fixed;top:50%;left:50%;visibility: hidden;width:auto;height:auto;min-width:100%;min-height:100%;z-index:"+N.still+";-moz-transform: translateX(-50%) translateY(-50%);-webkit-transform: translateX(-50%) translateY(-50%);transform:translateX(-50%) translateY(-50%);background-size:cover;background-position:50% 50%;background-color:#FFF;"),document.body.appendChild(o),document.body.appendChild(s)}null===A?n().then(function(n){A=n.backCamera,B=n.frontCamera,A!==!1?e():t(5)},function(e){e=null,t(0)}):A===!1?t(5):e()}function y(e,t){b(function(){e(p())},t)}function C(e,t){function n(){i()?e(p()):w(e,t)}f()?n():b(function(){n()},t)}function P(e,t){t=null,i()&&o();var n=a();n&&(n.src=""),e(p())}function S(e,t){C(function(n){n=null;var r=a(),i=!1;F=!0,G.onmessage=function(t){var n=t.data;n.result&&!i&&(i=!0,V=null,e(n.result))},(V=function(){G.postMessage(m(r)),null!==X&&X();var e=window.QRScanner_SCAN_INTERVAL||130;z=window.setTimeout(V,e),X=function(e){window.clearTimeout(z),z=null,X=null,e&&t(6)}})()},t)}function k(e,t){t=null,null!==X&&X(!0),F=!1,"function"==typeof e&&e(p())}function E(e,t){if(t=null,i()){null!==X&&X();var n=a();n.pause();var r=new Image;r.src=g(n),s().style.backgroundImage="url("+r.src+")",u(),o(),e(p())}else e(p())}function T(e,t){null!==V&&V(),C(e,t)}function R(e,t){t(7)}function M(e,t){t(7)}function x(e,t,n){var r=n[0],i=f();r!==_?i&&1===r&&!l()?t(4):(_=r,i?(P(function(e){e=null}),C(e,t)):e(p())):e(p())}function D(e,t){t(8)}function O(e,t){t=null,e(p())}function L(e,t){t=null,k(),i()&&o(),A=null,B=null;var n=a(),r=s();n&&n.remove(),r&&r.remove(),e(p())}var I={preview:"cordova-plugin-qrscanner-video-preview",still:"cordova-plugin-qrscanner-still"},N={preview:-100,still:-99},A=null,B=null,_=0,j=null,F=!1,U=!1,G=null,V=null,z=null,X=null,Q=[5120,4096,3840,3440,3200,3072,3e3,2880,2800,2736,2732,2560,2538,2400,2304,2160,2100,2048,2e3,1920,1856,1824,1800,1792,1776,1728,1700,1680,1600,1536,1440,1400,1392,1366,1344,1334,1280,1200,1152,1136,1120,1080,1050,1024,1e3,960,900,854,848,832,800,768,750,720,640,624,600,576,544,540,512,480,320,240],Y=["environment","user"];return{prepare:y,show:C,hide:P,scan:S,cancelScan:k,pausePreview:E,resumePreview:T,enableLight:R,disableLight:M,useCamera:x,openSettings:D,getStatus:O,destroy:L}}},function(e,t){e.exports=function(e){function t(e){switch(e){case"1":return!0;case"0":return!1;default:throw new Error("QRScanner plugin returned an invalid boolean number-string: "+e)}}function n(e){return{authorized:t(e.authorized),denied:t(e.denied),restricted:t(e.restricted),prepared:t(e.prepared),scanning:t(e.scanning),previewing:t(e.previewing),showing:t(e.showing),lightEnabled:t(e.lightEnabled),canOpenSettings:t(e.canOpenSettings),canEnableLight:t(e.canEnableLight),canChangeCamera:t(e.canChangeCamera),currentCamera:parseInt(e.currentCamera)}}function r(){var e=document.body;e.style&&(e.style.backgroundColor="rgba(0,0,0,0.01)",e.style.backgroundImage="",setTimeout(function(){e.style.backgroundColor="transparent"},1),e.parentNode&&e.parentNode.style&&(e.parentNode.style.backgroundColor="transparent",e.parentNode.style.backgroundImage=""))}function i(e){return e?function(t){var n=parseInt(t),r={};switch(n){case 0:r={name:"UNEXPECTED_ERROR",code:0,_message:"QRScanner experienced an unexpected error."};break;case 1:r={name:"CAMERA_ACCESS_DENIED",code:1,_message:"The user denied camera access."};break;case 2:r={name:"CAMERA_ACCESS_RESTRICTED",code:2,_message:"Camera access is restricted."};break;case 3:r={name:"BACK_CAMERA_UNAVAILABLE",code:3,_message:"The back camera is unavailable."};break;case 4:r={name:"FRONT_CAMERA_UNAVAILABLE",code:4,_message:"The front camera is unavailable."};break;case 5:r={name:"CAMERA_UNAVAILABLE",code:5,_message:"The camera is unavailable."};break;case 6:r={name:"SCAN_CANCELED",code:6,_message:"Scan was canceled."};break;case 7:r={name:"LIGHT_UNAVAILABLE",code:7,_message:"The device light is unavailable."};break;case 8:r={name:"OPEN_SETTINGS_UNAVAILABLE",code:8,_message:"The device is unable to open settings."};break;default:r={name:"UNEXPECTED_ERROR",code:0,_message:"QRScanner returned an invalid error code."}}e(r)}:null}function o(e){return e?function(t){e(null,n(t))}:null}function a(e,t){return e?function(i){t&&r(),e(n(i))}:null}return{prepare:function(t){e.exec(o(t),i(t),"QRScanner","prepare",[])},destroy:function(t){e.exec(a(t,!0),null,"QRScanner","destroy",[])},scan:function(t){if(!t)throw new Error("No callback provided to scan method.");var n=function(e){t(null,e)};e.exec(n,i(t),"QRScanner","scan",[])},cancelScan:function(t){e.exec(a(t),null,"QRScanner","cancelScan",[])},show:function(t){e.exec(a(t,!0),null,"QRScanner","show",[])},hide:function(t){e.exec(a(t,!0),null,"QRScanner","hide",[])},pausePreview:function(t){e.exec(a(t),null,"QRScanner","pausePreview",[])},resumePreview:function(t){e.exec(a(t),null,"QRScanner","resumePreview",[])},enableLight:function(t){e.exec(o(t),i(t),"QRScanner","enableLight",[])},disableLight:function(t){e.exec(o(t),i(t),"QRScanner","disableLight",[])},useCamera:function(t,n){e.exec(o(n),i(n),"QRScanner","useCamera",[t])},useFrontCamera:function(t){var n=1;t?this.useCamera(n,t):e.exec(null,null,"QRScanner","useCamera",[n])},useBackCamera:function(t){var n=0;t?this.useCamera(n,t):e.exec(null,null,"QRScanner","useCamera",[n])},openSettings:function(t){t?e.exec(o(t),i(t),"QRScanner","openSettings",[]):e.exec(null,null,"QRScanner","openSettings",[])},getStatus:function(t){if(!t)throw new Error("No callback provided to getStatus method.");e.exec(a(t),null,"QRScanner","getStatus",[])}}}},function(e,t){e.exports='!function(t){function e(r){if(n[r])return n[r].exports;var i=n[r]={i:r,l:!1,exports:{}};return t[r].call(i.exports,i,i.exports,e),i.l=!0,i.exports}var n={};return e.m=t,e.c=n,e.i=function(t){return t},e.d=function(t,n,r){e.o(t,n)||Object.defineProperty(t,n,{configurable:!1,enumerable:!0,get:r})},e.n=function(t){var n=t&&t.__esModule?function(){return t.default}:function(){return t};return e.d(n,"a",n),n},e.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},e.p="",e(e.s=19)}([function(t,e,n){"use strict";function r(){this.imagedata=null,this.width=0,this.height=0,this.qrCodeSymbol=null,this.debug=!1,this.callback=null}function i(t,e){return t>=0?t>>e:(t>>e)+(2<<~e)}var o=n(14),a=n(13);n.d(e,"b",function(){return s}),e.a=r,e.c=i;var s={};s.sizeOfDataLengthInfo=[[10,9,8,8],[12,11,16,10],[14,13,16,12]],r.prototype.decode=function(t,e){var n=function(){try{this.error=void 0,this.result=this.process(this.imagedata)}catch(t){this.error=t,this.result=void 0}return null!=this.callback&&this.callback(this.result,this.error),this.result}.bind(this);if(void 0==t){var r=document.getElementById("qr-canvas"),i=r.getContext("2d");this.width=r.width,this.height=r.height,this.imagedata=i.getImageData(0,0,this.width,this.height),n()}else if(void 0!=t.width)this.width=t.width,this.height=t.height,this.imagedata={data:e||t.data},this.imagedata.width=t.width,this.imagedata.height=t.height,n();else{var o=new Image;o.crossOrigin="Anonymous",o.onload=function(){var t=document.createElement("canvas"),e=t.getContext("2d"),r=document.getElementById("out-canvas");if(null!=r){var i=r.getContext("2d");i.clearRect(0,0,320,240),i.drawImage(o,0,0,320,240)}t.width=o.width,t.height=o.height,e.drawImage(o,0,0),this.width=o.width,this.height=o.height;try{this.imagedata=e.getImageData(0,0,o.width,o.height)}catch(t){if(this.result="Cross domain image reading not supported in your browser! Save it to your computer then drag and drop the file!",null!=this.callback)return this.callback(this.result)}n()}.bind(this),o.src=t}},r.prototype.decode_utf8=function(t){return decodeURIComponent(escape(t))},r.prototype.process=function(t){for(var e=(new Date).getTime(),n=this.grayScaleToBitmap(this.grayscale(t)),r=new o.a(n),i=r.detect(),s=a.a.decode(i.bits),h=s.DataByte,f="",w=0;w<h.length;w++)for(var u=0;u<h[w].length;u++)f+=String.fromCharCode(h[w][u]);var l=(new Date).getTime(),c=l-e;return this.debug&&console.log("QR Code processing time (ms): "+c),this.decode_utf8(f)},r.prototype.getPixel=function(t,e,n){if(t.width<e)throw"point error";if(t.height<n)throw"point error";var r=4*e+n*t.width*4;return(33*t.data[r]+34*t.data[r+1]+33*t.data[r+2])/100},r.prototype.binarize=function(t){for(var e=new Array(this.width*this.height),n=0;n<this.height;n++)for(var r=0;r<this.width;r++){var i=this.getPixel(r,n);e[r+n*this.width]=i<=t}return e},r.prototype.getMiddleBrightnessPerArea=function(t){for(var e=4,n=Math.floor(t.width/e),r=Math.floor(t.height/e),i=new Array(e),o=0;o<e;o++){i[o]=new Array(e);for(var a=0;a<e;a++)i[o][a]=[0,0]}for(var s=0;s<e;s++)for(var h=0;h<e;h++){i[h][s][0]=255;for(var f=0;f<r;f++)for(var w=0;w<n;w++){var u=t.data[n*h+w+(r*s+f)*t.width];u<i[h][s][0]&&(i[h][s][0]=u),u>i[h][s][1]&&(i[h][s][1]=u)}}for(var l=new Array(e),c=0;c<e;c++)l[c]=new Array(e);for(var s=0;s<e;s++)for(var h=0;h<e;h++)l[h][s]=Math.floor((i[h][s][0]+i[h][s][1])/2);return l},r.prototype.grayScaleToBitmap=function(t){for(var e=this.getMiddleBrightnessPerArea(t),n=e.length,r=Math.floor(t.width/n),i=Math.floor(t.height/n),o=0;o<n;o++)for(var a=0;a<n;a++)for(var s=0;s<i;s++)for(var h=0;h<r;h++)t.data[r*a+h+(i*o+s)*t.width]=t.data[r*a+h+(i*o+s)*t.width]<e[a][o];return t},r.prototype.grayscale=function(t){for(var e=new Array(t.width*t.height),n=0;n<t.height;n++)for(var r=0;r<t.width;r++){var i=this.getPixel(t,r,n);e[r+n*t.width]=i}return{height:t.height,width:t.width,data:e}}},function(t,e,n){"use strict";function r(t){this.expTable=new Array(256),this.logTable=new Array(256);for(var e=1,n=0;n<256;n++)this.expTable[n]=e,e<<=1,e>=256&&(e^=t);for(var n=0;n<255;n++)this.logTable[this.expTable[n]]=n;var r=new Array(1);r[0]=0,this.zero=new i.a(this,new Array(r));var o=new Array(1);o[0]=1,this.one=new i.a(this,new Array(o))}var i=n(4);e.a=r,Object.defineProperty(r.prototype,"Zero",{get:function(){return this.zero}}),Object.defineProperty(r.prototype,"One",{get:function(){return this.one}}),r.prototype.buildMonomial=function(t,e){if(t<0)throw"System.ArgumentException";if(0==e)return this.zero;for(var n=new Array(t+1),r=0;r<n.length;r++)n[r]=0;return n[0]=e,new i.a(this,n)},r.prototype.exp=function(t){return this.expTable[t]},r.prototype.log=function(t){if(0==t)throw"System.ArgumentException";return this.logTable[t]},r.prototype.inverse=function(t){if(0==t)throw"System.ArithmeticException";return this.expTable[255-this.logTable[t]]},r.prototype.multiply=function(t,e){return 0==t||0==e?0:1==t?e:1==e?t:this.expTable[(this.logTable[t]+this.logTable[e])%255]},r.QR_CODE_FIELD=new r(285),r.DATA_MATRIX_FIELD=new r(301),r.addOrSubtract=function(t,e){return t^e}},function(t,e,n){"use strict";function r(t,e){if(e||(e=t),t<1||e<1)throw"Both dimensions must be greater than 0";this.width=t,this.height=e;var n=t>>5;0!=(31&t)&&n++,this.rowSize=n,this.bits=new Array(n*e);for(var r=0;r<this.bits.length;r++)this.bits[r]=0}var i=n(0);e.a=r,Object.defineProperty(r.prototype,"Dimension",{get:function(){if(this.width!=this.height)throw"Can\'t call getDimension() on a non-square matrix";return this.width}}),r.prototype.get_Renamed=function(t,e){var r=e*this.rowSize+(t>>5);return 0!=(1&n.i(i.c)(this.bits[r],31&t))},r.prototype.set_Renamed=function(t,e){var n=e*this.rowSize+(t>>5);this.bits[n]|=1<<(31&t)},r.prototype.flip=function(t,e){var n=e*this.rowSize+(t>>5);this.bits[n]^=1<<(31&t)},r.prototype.clear=function(){for(var t=this.bits.length,e=0;e<t;e++)this.bits[e]=0},r.prototype.setRegion=function(t,e,n,r){if(e<0||t<0)throw"Left and top must be nonnegative";if(r<1||n<1)throw"Height and width must be at least 1";var i=t+n,o=e+r;if(o>this.height||i>this.width)throw"The region must fit inside the matrix";for(var a=e;a<o;a++)for(var s=a*this.rowSize,h=t;h<i;h++)this.bits[s+(h>>5)]|=1<<(31&h)}},function(t,e,n){"use strict";function r(t){this.errorCorrectionLevel=o.a.forBits(t>>3&3),this.dataMask=7&t}var i=n(0),o=n(15);e.a=r;var a=21522,s=[[21522,0],[20773,1],[24188,2],[23371,3],[17913,4],[16590,5],[20375,6],[19104,7],[30660,8],[29427,9],[32170,10],[30877,11],[26159,12],[25368,13],[27713,14],[26998,15],[5769,16],[5054,17],[7399,18],[6608,19],[1890,20],[597,21],[3340,22],[2107,23],[13663,24],[12392,25],[16177,26],[14854,27],[9396,28],[8579,29],[11994,30],[11245,31]],h=[0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4];r.prototype.GetHashCode=function(){return this.errorCorrectionLevel.ordinal()<<3|this.dataMask},r.prototype.Equals=function(t){var e=t;return this.errorCorrectionLevel==e.errorCorrectionLevel&&this.dataMask==e.dataMask},r.numBitsDiffering=function(t,e){return t^=e,h[15&t]+h[15&n.i(i.c)(t,4)]+h[15&n.i(i.c)(t,8)]+h[15&n.i(i.c)(t,12)]+h[15&n.i(i.c)(t,16)]+h[15&n.i(i.c)(t,20)]+h[15&n.i(i.c)(t,24)]+h[15&n.i(i.c)(t,28)]},r.decodeFormatInformation=function(t){var e=r.doDecodeFormatInformation(t);return null!=e?e:r.doDecodeFormatInformation(t^a)},r.doDecodeFormatInformation=function(t){for(var e=4294967295,n=0,i=0;i<s.length;i++){var o=s[i],a=o[0];if(a==t)return new r(o[1]);var h=this.numBitsDiffering(t,a);h<e&&(n=o[1],e=h)}return e<=3?new r(n):null}},function(t,e,n){"use strict";function r(t,e){if(null==e||0==e.length)throw"System.ArgumentException";this.field=t;var n=e.length;if(n>1&&0==e[0]){for(var r=1;r<n&&0==e[r];)r++;if(r==n)this.coefficients=t.Zero.coefficients;else{this.coefficients=new Array(n-r);for(var i=0;i<this.coefficients.length;i++)this.coefficients[i]=0;for(var o=0;o<this.coefficients.length;o++)this.coefficients[o]=e[r+o]}}else this.coefficients=e}var i=n(1);e.a=r,Object.defineProperty(r.prototype,"Zero",{get:function(){return 0==this.coefficients[0]}}),Object.defineProperty(r.prototype,"Degree",{get:function(){return this.coefficients.length-1}}),r.prototype.getCoefficient=function(t){return this.coefficients[this.coefficients.length-1-t]},r.prototype.evaluateAt=function(t){if(0==t)return this.getCoefficient(0);var e=this.coefficients.length;if(1==t){for(var n=0,r=0;r<e;r++)n=i.a.addOrSubtract(n,this.coefficients[r]);return n}for(var o=this.coefficients[0],r=1;r<e;r++)o=i.a.addOrSubtract(this.field.multiply(t,o),this.coefficients[r]);return o},r.prototype.addOrSubtract=function(t){if(this.field!=t.field)throw"GF256Polys do not have same GF256 field";if(this.Zero)return t;if(t.Zero)return this;var e=this.coefficients,n=t.coefficients;if(e.length>n.length){var o=e;e=n,n=o}for(var a=new Array(n.length),s=n.length-e.length,h=0;h<s;h++)a[h]=n[h];for(var f=s;f<n.length;f++)a[f]=i.a.addOrSubtract(e[f-s],n[f]);return new r(this.field,a)},r.prototype.multiply1=function(t){if(this.field!=t.field)throw"GF256Polys do not have same GF256 field";if(this.Zero||t.Zero)return this.field.Zero;for(var e=this.coefficients,n=e.length,o=t.coefficients,a=o.length,s=new Array(n+a-1),h=0;h<n;h++)for(var f=e[h],w=0;w<a;w++)s[h+w]=i.a.addOrSubtract(s[h+w],this.field.multiply(f,o[w]));return new r(this.field,s)},r.prototype.multiply2=function(t){if(0==t)return this.field.Zero;if(1==t)return this;for(var e=this.coefficients.length,n=new Array(e),i=0;i<e;i++)n[i]=this.field.multiply(this.coefficients[i],t);return new r(this.field,n)},r.prototype.multiplyByMonomial=function(t,e){if(t<0)throw"System.ArgumentException";if(0==e)return this.field.Zero;for(var n=this.coefficients.length,i=new Array(n+t),o=0;o<i.length;o++)i[o]=0;for(var o=0;o<n;o++)i[o]=this.field.multiply(this.coefficients[o],e);return new r(this.field,i)},r.prototype.divide=function(t){if(this.field!=t.field)throw"GF256Polys do not have same GF256 field";if(t.Zero)throw"Divide by 0";for(var e=this.field.Zero,n=this,r=t.getCoefficient(t.Degree),i=this.field.inverse(r);n.Degree>=t.Degree&&!n.Zero;){var o=n.Degree-t.Degree,a=this.field.multiply(n.getCoefficient(n.Degree),i),s=t.multiplyByMonomial(o,a),h=this.field.buildMonomial(o,a);e=e.addOrSubtract(h),n=n.addOrSubtract(s)}return[e,n]}},function(t,e,n){"use strict";function r(t,e){this.count=t,this.dataCodewords=e}function i(t,e,n){this.ecCodewordsPerBlock=t,n?this.ecBlocks=[e,n]:this.ecBlocks=[e]}function o(t,e,n,r,i,o){this.versionNumber=t,this.alignmentPatternCenters=e,this.ecBlocks=[n,r,i,o];for(var a=0,s=n.ecCodewordsPerBlock,h=n.getECBlocks(),f=0;f<h.length;f++){var w=h[f];a+=w.count*(w.dataCodewords+s)}this.totalCodewords=a}function a(){return[new o(1,[],new i(7,new r(1,19)),new i(10,new r(1,16)),new i(13,new r(1,13)),new i(17,new r(1,9))),new o(2,[6,18],new i(10,new r(1,34)),new i(16,new r(1,28)),new i(22,new r(1,22)),new i(28,new r(1,16))),new o(3,[6,22],new i(15,new r(1,55)),new i(26,new r(1,44)),new i(18,new r(2,17)),new i(22,new r(2,13))),new o(4,[6,26],new i(20,new r(1,80)),new i(18,new r(2,32)),new i(26,new r(2,24)),new i(16,new r(4,9))),new o(5,[6,30],new i(26,new r(1,108)),new i(24,new r(2,43)),new i(18,new r(2,15),new r(2,16)),new i(22,new r(2,11),new r(2,12))),new o(6,[6,34],new i(18,new r(2,68)),new i(16,new r(4,27)),new i(24,new r(4,19)),new i(28,new r(4,15))),new o(7,[6,22,38],new i(20,new r(2,78)),new i(18,new r(4,31)),new i(18,new r(2,14),new r(4,15)),new i(26,new r(4,13),new r(1,14))),new o(8,[6,24,42],new i(24,new r(2,97)),new i(22,new r(2,38),new r(2,39)),new i(22,new r(4,18),new r(2,19)),new i(26,new r(4,14),new r(2,15))),new o(9,[6,26,46],new i(30,new r(2,116)),new i(22,new r(3,36),new r(2,37)),new i(20,new r(4,16),new r(4,17)),new i(24,new r(4,12),new r(4,13))),new o(10,[6,28,50],new i(18,new r(2,68),new r(2,69)),new i(26,new r(4,43),new r(1,44)),new i(24,new r(6,19),new r(2,20)),new i(28,new r(6,15),new r(2,16))),new o(11,[6,30,54],new i(20,new r(4,81)),new i(30,new r(1,50),new r(4,51)),new i(28,new r(4,22),new r(4,23)),new i(24,new r(3,12),new r(8,13))),new o(12,[6,32,58],new i(24,new r(2,92),new r(2,93)),new i(22,new r(6,36),new r(2,37)),new i(26,new r(4,20),new r(6,21)),new i(28,new r(7,14),new r(4,15))),new o(13,[6,34,62],new i(26,new r(4,107)),new i(22,new r(8,37),new r(1,38)),new i(24,new r(8,20),new r(4,21)),new i(22,new r(12,11),new r(4,12))),new o(14,[6,26,46,66],new i(30,new r(3,115),new r(1,116)),new i(24,new r(4,40),new r(5,41)),new i(20,new r(11,16),new r(5,17)),new i(24,new r(11,12),new r(5,13))),new o(15,[6,26,48,70],new i(22,new r(5,87),new r(1,88)),new i(24,new r(5,41),new r(5,42)),new i(30,new r(5,24),new r(7,25)),new i(24,new r(11,12),new r(7,13))),new o(16,[6,26,50,74],new i(24,new r(5,98),new r(1,99)),new i(28,new r(7,45),new r(3,46)),new i(24,new r(15,19),new r(2,20)),new i(30,new r(3,15),new r(13,16))),new o(17,[6,30,54,78],new i(28,new r(1,107),new r(5,108)),new i(28,new r(10,46),new r(1,47)),new i(28,new r(1,22),new r(15,23)),new i(28,new r(2,14),new r(17,15))),new o(18,[6,30,56,82],new i(30,new r(5,120),new r(1,121)),new i(26,new r(9,43),new r(4,44)),new i(28,new r(17,22),new r(1,23)),new i(28,new r(2,14),new r(19,15))),new o(19,[6,30,58,86],new i(28,new r(3,113),new r(4,114)),new i(26,new r(3,44),new r(11,45)),new i(26,new r(17,21),new r(4,22)),new i(26,new r(9,13),new r(16,14))),new o(20,[6,34,62,90],new i(28,new r(3,107),new r(5,108)),new i(26,new r(3,41),new r(13,42)),new i(30,new r(15,24),new r(5,25)),new i(28,new r(15,15),new r(10,16))),new o(21,[6,28,50,72,94],new i(28,new r(4,116),new r(4,117)),new i(26,new r(17,42)),new i(28,new r(17,22),new r(6,23)),new i(30,new r(19,16),new r(6,17))),new o(22,[6,26,50,74,98],new i(28,new r(2,111),new r(7,112)),new i(28,new r(17,46)),new i(30,new r(7,24),new r(16,25)),new i(24,new r(34,13))),new o(23,[6,30,54,74,102],new i(30,new r(4,121),new r(5,122)),new i(28,new r(4,47),new r(14,48)),new i(30,new r(11,24),new r(14,25)),new i(30,new r(16,15),new r(14,16))),new o(24,[6,28,54,80,106],new i(30,new r(6,117),new r(4,118)),new i(28,new r(6,45),new r(14,46)),new i(30,new r(11,24),new r(16,25)),new i(30,new r(30,16),new r(2,17))),new o(25,[6,32,58,84,110],new i(26,new r(8,106),new r(4,107)),new i(28,new r(8,47),new r(13,48)),new i(30,new r(7,24),new r(22,25)),new i(30,new r(22,15),new r(13,16))),new o(26,[6,30,58,86,114],new i(28,new r(10,114),new r(2,115)),new i(28,new r(19,46),new r(4,47)),new i(28,new r(28,22),new r(6,23)),new i(30,new r(33,16),new r(4,17))),new o(27,[6,34,62,90,118],new i(30,new r(8,122),new r(4,123)),new i(28,new r(22,45),new r(3,46)),new i(30,new r(8,23),new r(26,24)),new i(30,new r(12,15),new r(28,16))),new o(28,[6,26,50,74,98,122],new i(30,new r(3,117),new r(10,118)),new i(28,new r(3,45),new r(23,46)),new i(30,new r(4,24),new r(31,25)),new i(30,new r(11,15),new r(31,16))),new o(29,[6,30,54,78,102,126],new i(30,new r(7,116),new r(7,117)),new i(28,new r(21,45),new r(7,46)),new i(30,new r(1,23),new r(37,24)),new i(30,new r(19,15),new r(26,16))),new o(30,[6,26,52,78,104,130],new i(30,new r(5,115),new r(10,116)),new i(28,new r(19,47),new r(10,48)),new i(30,new r(15,24),new r(25,25)),new i(30,new r(23,15),new r(25,16))),new o(31,[6,30,56,82,108,134],new i(30,new r(13,115),new r(3,116)),new i(28,new r(2,46),new r(29,47)),new i(30,new r(42,24),new r(1,25)),new i(30,new r(23,15),new r(28,16))),new o(32,[6,34,60,86,112,138],new i(30,new r(17,115)),new i(28,new r(10,46),new r(23,47)),new i(30,new r(10,24),new r(35,25)),new i(30,new r(19,15),new r(35,16))),new o(33,[6,30,58,86,114,142],new i(30,new r(17,115),new r(1,116)),new i(28,new r(14,46),new r(21,47)),new i(30,new r(29,24),new r(19,25)),new i(30,new r(11,15),new r(46,16))),new o(34,[6,34,62,90,118,146],new i(30,new r(13,115),new r(6,116)),new i(28,new r(14,46),new r(23,47)),new i(30,new r(44,24),new r(7,25)),new i(30,new r(59,16),new r(1,17))),new o(35,[6,30,54,78,102,126,150],new i(30,new r(12,121),new r(7,122)),new i(28,new r(12,47),new r(26,48)),new i(30,new r(39,24),new r(14,25)),new i(30,new r(22,15),new r(41,16))),new o(36,[6,24,50,76,102,128,154],new i(30,new r(6,121),new r(14,122)),new i(28,new r(6,47),new r(34,48)),new i(30,new r(46,24),new r(10,25)),new i(30,new r(2,15),new r(64,16))),new o(37,[6,28,54,80,106,132,158],new i(30,new r(17,122),new r(4,123)),new i(28,new r(29,46),new r(14,47)),new i(30,new r(49,24),new r(10,25)),new i(30,new r(24,15),new r(46,16))),new o(38,[6,32,58,84,110,136,162],new i(30,new r(4,122),new r(18,123)),new i(28,new r(13,46),new r(32,47)),new i(30,new r(48,24),new r(14,25)),new i(30,new r(42,15),new r(32,16))),new o(39,[6,26,54,82,110,138,166],new i(30,new r(20,117),new r(4,118)),new i(28,new r(40,47),new r(7,48)),new i(30,new r(43,24),new r(22,25)),new i(30,new r(10,15),new r(67,16))),new o(40,[6,30,58,86,114,142,170],new i(30,new r(19,118),new r(6,119)),new i(28,new r(18,47),new r(31,48)),new i(30,new r(34,24),new r(34,25)),new i(30,new r(20,15),new r(61,16)))]}var s=n(3),h=n(2);e.a=o,Object.defineProperty(i.prototype,"TotalECCodewords",{get:function(){return this.ecCodewordsPerBlock*this.NumBlocks}}),Object.defineProperty(i.prototype,"NumBlocks",{get:function(){for(var t=0,e=0;e<this.ecBlocks.length;e++)t+=this.ecBlocks[e].length;return t}}),i.prototype.getECBlocks=function(){return this.ecBlocks},Object.defineProperty(o.prototype,"DimensionForVersion",{get:function(){return 17+4*this.versionNumber}}),o.prototype.buildFunctionPattern=function(){var t=this.DimensionForVersion,e=new h.a(t);e.setRegion(0,0,9,9),e.setRegion(t-8,0,8,9),e.setRegion(0,t-8,9,8);for(var n=this.alignmentPatternCenters.length,r=0;r<n;r++)for(var i=this.alignmentPatternCenters[r]-2,o=0;o<n;o++)0==r&&(0==o||o==n-1)||r==n-1&&0==o||e.setRegion(this.alignmentPatternCenters[o]-2,i,5,5);return e.setRegion(6,9,1,t-17),e.setRegion(9,6,t-17,1),this.versionNumber>6&&(e.setRegion(t-11,0,3,6),e.setRegion(0,t-11,6,3)),e},o.prototype.getECBlocksForLevel=function(t){return this.ecBlocks[t.ordinal()]},o.VERSION_DECODE_INFO=[31892,34236,39577,42195,48118,51042,55367,58893,63784,68472,70749,76311,79154,84390,87683,92361,96236,102084,102881,110507,110734,117786,119615,126325,127568,133589,136944,141498,145311,150283,152622,158308,161089,167017],o.VERSIONS=a(),o.getVersionForNumber=function(t){if(t<1||t>40)throw"ArgumentException";return o.VERSIONS[t-1]},o.getProvisionalVersionForDimension=function(t){if(t%4!=1)throw"Error getProvisionalVersionForDimension";try{return o.getVersionForNumber(t-17>>2)}catch(t){throw"Error getVersionForNumber"}},o.decodeVersionInformation=function(t){for(var e=4294967295,n=0,r=0;r<o.VERSION_DECODE_INFO.length;r++){var i=o.VERSION_DECODE_INFO[r];if(i==t)return this.getVersionForNumber(r+7);var a=s.a.numBitsDiffering(t,i);a<e&&(n=r+7,e=a)}return e<=3?this.getVersionForNumber(n):null}},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var r=n(0);e.default=r.a},function(t,e){t.exports=function(t){return t.webpackPolyfill||(t.deprecate=function(){},t.paths=[],t.children||(t.children=[]),Object.defineProperty(t,"loaded",{enumerable:!0,get:function(){return t.l}}),Object.defineProperty(t,"id",{enumerable:!0,get:function(){return t.i}}),t.webpackPolyfill=1),t}},function(t,e,n){"use strict";function r(t,e,n){this.x=t,this.y=e,this.count=1,this.estimatedModuleSize=n}function i(t,e,n,r,i,o,a){this.image=t,this.possibleCenters=[],this.startX=e,this.startY=n,this.width=r,this.height=i,this.moduleSize=o,this.crossCheckStateCount=[0,0,0],this.resultPointCallback=a}e.a=i,Object.defineProperty(r.prototype,"X",{get:function(){return Math.floor(this.x)}}),Object.defineProperty(r.prototype,"Y",{get:function(){return Math.floor(this.y)}}),r.prototype.incrementCount=function(){this.count++},r.prototype.aboutEquals=function(t,e,n){if(Math.abs(e-this.y)<=t&&Math.abs(n-this.x)<=t){var r=Math.abs(t-this.estimatedModuleSize);return r<=1||r/this.estimatedModuleSize<=1}return!1},i.prototype.centerFromEnd=function(t,e){return e-t[2]-t[1]/2},i.prototype.foundPatternCross=function(t){for(var e=this.moduleSize,n=e/2,r=0;r<3;r++)if(Math.abs(e-t[r])>=n)return!1;return!0},i.prototype.crossCheckVertical=function(t,e,n,r){var i=this.image,o=i.height,a=this.crossCheckStateCount;a[0]=0,a[1]=0,a[2]=0;for(var s=t;s>=0&&i.data[e+s*i.width]&&a[1]<=n;)a[1]++,s--;if(s<0||a[1]>n)return NaN;for(;s>=0&&!i.data[e+s*i.width]&&a[0]<=n;)a[0]++,s--;if(a[0]>n)return NaN;for(s=t+1;s<o&&i.data[e+s*i.width]&&a[1]<=n;)a[1]++,s++;if(s==o||a[1]>n)return NaN;for(;s<o&&!i.data[e+s*i.width]&&a[2]<=n;)a[2]++,s++;if(a[2]>n)return NaN;var h=a[0]+a[1]+a[2];return 5*Math.abs(h-r)>=2*r?NaN:this.foundPatternCross(a)?this.centerFromEnd(a,s):NaN},i.prototype.handlePossibleCenter=function(t,e,n){var i=t[0]+t[1]+t[2],o=this.centerFromEnd(t,n),a=this.crossCheckVertical(e,Math.floor(o),2*t[1],i);if(!isNaN(a)){for(var s=(t[0]+t[1]+t[2])/3,h=this.possibleCenters.length,f=0;f<h;f++){var w=this.possibleCenters[f];if(w.aboutEquals(s,a,o))return new r(o,a,s)}var u=new r(o,a,s);this.possibleCenters.push(u),null!=this.resultPointCallback&&this.resultPointCallback.foundPossibleResultPoint(u)}return null},i.prototype.find=function(){for(var t=this.image,e=this.startX,n=this.height,r=e+this.width,i=this.startY+(n>>1),o=[0,0,0],a=0;a<n;a++){var s=i+(0==(1&a)?a+1>>1:-(a+1>>1));o[0]=0,o[1]=0,o[2]=0;for(var h=e;h<r&&!t.data[h+t.width*s];)h++;for(var f=0;h<r;){if(t.data[h+s*t.width])if(1==f)o[f]++;else if(2==f){if(this.foundPatternCross(o)){var w=this.handlePossibleCenter(o,s,h);if(null!=w)return w}o[0]=o[2],o[1]=1,o[2]=0,f=1}else o[++f]++;else 1==f&&f++,o[f]++;h++}if(this.foundPatternCross(o)){var w=this.handlePossibleCenter(o,s,r);if(null!=w)return w}}if(0!=this.possibleCenters.length)return this.possibleCenters[0];throw"Couldn\'t find enough alignment patterns"}},function(t,e,n){"use strict";function r(t){var e=t.Dimension;if(e<21||1!=(3&e))throw"Error BitMatrixParser";this.bitMatrix=t,this.parsedVersion=null,this.parsedFormatInfo=null}var i=n(3),o=n(5),a=n(12);e.a=r,r.prototype.copyBit=function(t,e,n){return this.bitMatrix.get_Renamed(t,e)?n<<1|1:n<<1},r.prototype.readFormatInformation=function(){if(null!=this.parsedFormatInfo)return this.parsedFormatInfo;for(var t=0,e=0;e<6;e++)t=this.copyBit(e,8,t);t=this.copyBit(7,8,t),t=this.copyBit(8,8,t),t=this.copyBit(8,7,t);for(var n=5;n>=0;n--)t=this.copyBit(8,n,t);if(this.parsedFormatInfo=i.a.decodeFormatInformation(t),null!=this.parsedFormatInfo)return this.parsedFormatInfo;var r=this.bitMatrix.Dimension;t=0;for(var o=r-8,e=r-1;e>=o;e--)t=this.copyBit(e,8,t);for(var n=r-7;n<r;n++)t=this.copyBit(8,n,t);if(this.parsedFormatInfo=i.a.decodeFormatInformation(t),null!=this.parsedFormatInfo)return this.parsedFormatInfo;throw"Error readFormatInformation"},r.prototype.readVersion=function(){if(null!=this.parsedVersion)return this.parsedVersion;var t=this.bitMatrix.Dimension,e=t-17>>2;if(e<=6)return o.a.getVersionForNumber(e);for(var n=0,r=t-11,i=5;i>=0;i--)for(var a=t-9;a>=r;a--)n=this.copyBit(a,i,n);if(this.parsedVersion=o.a.decodeVersionInformation(n),null!=this.parsedVersion&&this.parsedVersion.DimensionForVersion==t)return this.parsedVersion;n=0;for(var a=5;a>=0;a--)for(var i=t-9;i>=r;i--)n=this.copyBit(a,i,n);if(this.parsedVersion=o.a.decodeVersionInformation(n),null!=this.parsedVersion&&this.parsedVersion.DimensionForVersion==t)return this.parsedVersion;throw"Error readVersion"},r.prototype.readCodewords=function(){var t=this.readFormatInformation(),e=this.readVersion(),n=a.a.forReference(t.dataMask),r=this.bitMatrix.Dimension;n.unmaskBitMatrix(this.bitMatrix,r);for(var i=e.buildFunctionPattern(),o=!0,s=new Array(e.totalCodewords),h=0,f=0,w=0,u=r-1;u>0;u-=2){6==u&&u--;for(var l=0;l<r;l++)for(var c=o?r-1-l:l,d=0;d<2;d++)i.get_Renamed(u-d,c)||(w++,f<<=1,this.bitMatrix.get_Renamed(u-d,c)&&(f|=1),8==w&&(s[h++]=f,w=0,f=0));o^=!0}if(h!=e.totalCodewords)throw"Error readCodewords";return s}},function(t,e,n){"use strict";function r(t,e){this.numDataCodewords=t,this.codewords=e}e.a=r,r.getDataBlocks=function(t,e,n){if(t.length!=e.totalCodewords)throw"ArgumentException";for(var i=e.getECBlocksForLevel(n),o=0,a=i.getECBlocks(),s=0;s<a.length;s++)o+=a[s].count;for(var h=new Array(o),f=0,w=0;w<a.length;w++)for(var u=a[w],s=0;s<u.count;s++){var l=u.dataCodewords,c=i.ecCodewordsPerBlock+l;h[f++]=new r(l,new Array(c))}for(var d=h[0].codewords.length,p=h.length-1;p>=0;){var g=h[p].codewords.length;if(g==d)break;p--}p++;for(var v=d-i.ecCodewordsPerBlock,m=0,s=0;s<v;s++)for(var w=0;w<f;w++)h[w].codewords[s]=t[m++];for(var w=p;w<f;w++)h[w].codewords[v]=t[m++];for(var b=h[0].codewords.length,s=v;s<b;s++)for(var w=0;w<f;w++){var y=w<p?s:s+1;h[w].codewords[y]=t[m++]}return h}},function(t,e,n){"use strict";function r(t,e,n){this.blockPointer=0,this.bitPointer=7,this.dataLength=0,this.blocks=t,this.numErrorCorrectionCode=n,e<=9?this.dataLengthMode=0:e>=10&&e<=26?this.dataLengthMode=1:e>=27&&e<=40&&(this.dataLengthMode=2)}var i=n(0);e.a=r,r.prototype.getNextBits=function(t){var e=0;if(t<this.bitPointer+1){for(var n=0,r=0;r<t;r++)n+=1<<r;return n<<=this.bitPointer-t+1,e=(this.blocks[this.blockPointer]&n)>>this.bitPointer-t+1,this.bitPointer-=t,e}if(t<this.bitPointer+1+8){for(var i=0,r=0;r<this.bitPointer+1;r++)i+=1<<r;return e=(this.blocks[this.blockPointer]&i)<<t-(this.bitPointer+1),this.blockPointer++,e+=this.blocks[this.blockPointer]>>8-(t-(this.bitPointer+1)),this.bitPointer=this.bitPointer-t%8,this.bitPointer<0&&(this.bitPointer=8+this.bitPointer),e}if(t<this.bitPointer+1+16){for(var i=0,o=0,r=0;r<this.bitPointer+1;r++)i+=1<<r;var a=(this.blocks[this.blockPointer]&i)<<t-(this.bitPointer+1);this.blockPointer++;var s=this.blocks[this.blockPointer]<<t-(this.bitPointer+1+8);this.blockPointer++;for(var r=0;r<t-(this.bitPointer+1+8);r++)o+=1<<r;o<<=8-(t-(this.bitPointer+1+8));var h=(this.blocks[this.blockPointer]&o)>>8-(t-(this.bitPointer+1+8));return e=a+s+h,this.bitPointer=this.bitPointer-(t-8)%8,this.bitPointer<0&&(this.bitPointer=8+this.bitPointer),e}return 0},r.prototype.NextMode=function(){return this.blockPointer>this.blocks.length-this.numErrorCorrectionCode-2?0:this.getNextBits(4)},r.prototype.getDataLength=function(t){for(var e=0;;){if(t>>e==1)break;e++}return this.getNextBits(i.b.sizeOfDataLengthInfo[this.dataLengthMode][e])},r.prototype.getRomanAndFigureString=function(t){var e=t,n=0,r="",i=["0","1","2","3","4","5","6","7","8","9","A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z"," ","$","%","*","+","-",".","/",":"];do if(e>1){n=this.getNextBits(11);var o=Math.floor(n/45),a=n%45;r+=i[o],r+=i[a],e-=2}else 1==e&&(n=this.getNextBits(6),r+=i[n],e-=1);while(e>0);return r},r.prototype.getFigureString=function(t){var e=t,n=0,r="";do e>=3?(n=this.getNextBits(10),n<100&&(r+="0"),n<10&&(r+="0"),e-=3):2==e?(n=this.getNextBits(7),n<10&&(r+="0"),e-=2):1==e&&(n=this.getNextBits(4),e-=1),r+=n;while(e>0);return r},r.prototype.get8bitByteArray=function(t){var e=t,n=0,r=[];do n=this.getNextBits(8),r.push(n),e--;while(e>0);return r},r.prototype.getKanjiString=function(t){var e=t,n=0,r="";do{n=this.getNextBits(13);var i=n%192,o=n/192,a=(o<<8)+i,s=0;s=a+33088<=40956?a+33088:a+49472,r+=String.fromCharCode(s),e--}while(e>0);return r},Object.defineProperty(r.prototype,"DataByte",{get:function(){for(var t=[],e=1,n=2,r=4,i=8;;){var o=this.NextMode();if(0==o){if(t.length>0)break;throw"Empty data block"}if(o!=e&&o!=n&&o!=r&&o!=i)throw"Invalid mode: "+o+" in (block:"+this.blockPointer+" bit:"+this.bitPointer+")";var a=this.getDataLength(o);if(a<1)throw"Invalid data length: "+a;switch(o){case e:for(var s=this.getFigureString(a),h=new Array(s.length),f=0;f<s.length;f++)h[f]=s.charCodeAt(f);t.push(h);break;case n:for(var s=this.getRomanAndFigureString(a),h=new Array(s.length),f=0;f<s.length;f++)h[f]=s.charCodeAt(f);t.push(h);break;case r:var w=this.get8bitByteArray(a);t.push(w);break;case i:var s=this.getKanjiString(a);t.push(s)}}return t}})},function(t,e,n){"use strict";function r(){this.unmaskBitMatrix=function(t,e){for(var n=0;n<e;n++)for(var r=0;r<e;r++)this.isMasked(n,r)&&t.flip(r,n)},this.isMasked=function(t,e){return 0==(t+e&1)}}function i(){this.unmaskBitMatrix=function(t,e){for(var n=0;n<e;n++)for(var r=0;r<e;r++)this.isMasked(n,r)&&t.flip(r,n)},this.isMasked=function(t,e){return 0==(1&t)}}function o(){this.unmaskBitMatrix=function(t,e){for(var n=0;n<e;n++)for(var r=0;r<e;r++)this.isMasked(n,r)&&t.flip(r,n)},this.isMasked=function(t,e){return e%3==0}}function a(){this.unmaskBitMatrix=function(t,e){for(var n=0;n<e;n++)for(var r=0;r<e;r++)this.isMasked(n,r)&&t.flip(r,n)},this.isMasked=function(t,e){return(t+e)%3==0}}function s(){this.unmaskBitMatrix=function(t,e){for(var n=0;n<e;n++)for(var r=0;r<e;r++)this.isMasked(n,r)&&t.flip(r,n)},this.isMasked=function(t,e){return 0==(n.i(u.c)(t,1)+e/3&1)}}function h(){this.unmaskBitMatrix=function(t,e){for(var n=0;n<e;n++)for(var r=0;r<e;r++)this.isMasked(n,r)&&t.flip(r,n)},this.isMasked=function(t,e){var n=t*e;return(1&n)+n%3==0}}function f(){this.unmaskBitMatrix=function(t,e){for(var n=0;n<e;n++)for(var r=0;r<e;r++)this.isMasked(n,r)&&t.flip(r,n)},this.isMasked=function(t,e){var n=t*e;return 0==((1&n)+n%3&1)}}function w(){this.unmaskBitMatrix=function(t,e){for(var n=0;n<e;n++)for(var r=0;r<e;r++)this.isMasked(n,r)&&t.flip(r,n)},this.isMasked=function(t,e){return 0==((t+e&1)+t*e%3&1)}}var u=n(0),l={};l.forReference=function(t){if(t<0||t>7)throw"System.ArgumentException";return l.DATA_MASKS[t]},l.DATA_MASKS=[new r,new i,new o,new a,new s,new h,new f,new w],e.a=l},function(t,e,n){"use strict";var r=n(18),i=n(1),o=n(9),a=n(10),s=n(11),h={};h.rsDecoder=new r.a(i.a.QR_CODE_FIELD),h.correctErrors=function(t,e){for(var n=t.length,r=new Array(n),i=0;i<n;i++)r[i]=255&t[i];var o=t.length-e;try{h.rsDecoder.decode(r,o)}catch(t){throw t}for(var i=0;i<e;i++)t[i]=r[i]},h.decode=function(t){for(var e=new o.a(t),n=e.readVersion(),r=e.readFormatInformation().errorCorrectionLevel,i=e.readCodewords(),f=a.a.getDataBlocks(i,n,r),w=0,u=0;u<f.length;u++)w+=f[u].numDataCodewords;for(var l=new Array(w),c=0,d=0;d<f.length;d++){var p=f[d],g=p.codewords,v=p.numDataCodewords;h.correctErrors(g,v);for(var u=0;u<v;u++)l[c++]=g[u]}var m=new s.a(l,n.versionNumber,r.bits);return m},e.a=h},function(t,e,n){"use strict";function r(t,e,n,r,i,o,a,s,h){this.a11=t,this.a12=r,this.a13=a,this.a21=e,this.a22=i,this.a23=s,this.a31=n,this.a32=o,this.a33=h}function i(t,e){this.bits=t,this.points=e}function o(t){this.image=t,this.resultPointCallback=null}var a=n(5),s=n(8),h=n(17),f=n(16);e.a=o,r.prototype.transformPoints1=function(t){for(var e=t.length,n=this.a11,r=this.a12,i=this.a13,o=this.a21,a=this.a22,s=this.a23,h=this.a31,f=this.a32,w=this.a33,u=0;u<e;u+=2){var l=t[u],c=t[u+1],d=i*l+s*c+w;t[u]=(n*l+o*c+h)/d,t[u+1]=(r*l+a*c+f)/d}},r.prototype.transformPoints2=function(t,e){for(var n=t.length,r=0;r<n;r++){var i=t[r],o=e[r],a=this.a13*i+this.a23*o+this.a33;t[r]=(this.a11*i+this.a21*o+this.a31)/a,e[r]=(this.a12*i+this.a22*o+this.a32)/a}},r.prototype.buildAdjoint=function(){return new r(this.a22*this.a33-this.a23*this.a32,this.a23*this.a31-this.a21*this.a33,this.a21*this.a32-this.a22*this.a31,this.a13*this.a32-this.a12*this.a33,this.a11*this.a33-this.a13*this.a31,this.a12*this.a31-this.a11*this.a32,this.a12*this.a23-this.a13*this.a22,this.a13*this.a21-this.a11*this.a23,this.a11*this.a22-this.a12*this.a21)},r.prototype.times=function(t){return new r(this.a11*t.a11+this.a21*t.a12+this.a31*t.a13,this.a11*t.a21+this.a21*t.a22+this.a31*t.a23,this.a11*t.a31+this.a21*t.a32+this.a31*t.a33,this.a12*t.a11+this.a22*t.a12+this.a32*t.a13,this.a12*t.a21+this.a22*t.a22+this.a32*t.a23,this.a12*t.a31+this.a22*t.a32+this.a32*t.a33,this.a13*t.a11+this.a23*t.a12+this.a33*t.a13,this.a13*t.a21+this.a23*t.a22+this.a33*t.a23,this.a13*t.a31+this.a23*t.a32+this.a33*t.a33)},r.quadrilateralToQuadrilateral=function(t,e,n,r,i,o,a,s,h,f,w,u,l,c,d,p){var g=this.quadrilateralToSquare(t,e,n,r,i,o,a,s),v=this.squareToQuadrilateral(h,f,w,u,l,c,d,p);return v.times(g)},r.squareToQuadrilateral=function(t,e,n,i,o,a,s,h){var f=h-a,w=e-i+a-h;if(0==f&&0==w)return new r(n-t,o-n,t,i-e,a-i,e,0,0,1);\nvar u=n-o,l=s-o,c=t-n+o-s,d=i-a,p=u*f-l*d,g=(c*f-l*w)/p,v=(u*w-c*d)/p;return new r(n-t+g*n,s-t+v*s,t,i-e+g*i,h-e+v*h,e,g,v,1)},r.quadrilateralToSquare=function(t,e,n,r,i,o,a,s){return this.squareToQuadrilateral(t,e,n,r,i,o,a,s).buildAdjoint()},o.prototype.sizeOfBlackWhiteBlackRun=function(t,e,n,r){var i=Math.abs(r-e)>Math.abs(n-t);if(i){var o=t;t=e,e=o,o=n,n=r,r=o}for(var a=Math.abs(n-t),s=Math.abs(r-e),h=-a>>1,f=e<r?1:-1,w=t<n?1:-1,u=0,l=t,c=e;l!=n;l+=w){var d=i?c:l,p=i?l:c;if(1==u?this.image.data[d+p*this.image.width]&&u++:this.image.data[d+p*this.image.width]||u++,3==u){var g=l-t,v=c-e;return Math.sqrt(g*g+v*v)}if(h+=s,h>0){if(c==r)break;c+=f,h-=a}}var m=n-t,b=r-e;return Math.sqrt(m*m+b*b)},o.prototype.sizeOfBlackWhiteBlackRunBothWays=function(t,e,n,r){var i=this.sizeOfBlackWhiteBlackRun(t,e,n,r),o=1,a=t-(n-t);a<0?(o=t/(t-a),a=0):a>=this.image.width&&(o=(this.image.width-1-t)/(a-t),a=this.image.width-1);var s=Math.floor(e-(r-e)*o);return o=1,s<0?(o=e/(e-s),s=0):s>=this.image.height&&(o=(this.image.height-1-e)/(s-e),s=this.image.height-1),a=Math.floor(t+(a-t)*o),i+=this.sizeOfBlackWhiteBlackRun(t,e,a,s),i-1},o.prototype.calculateModuleSizeOneWay=function(t,e){var n=this.sizeOfBlackWhiteBlackRunBothWays(Math.floor(t.X),Math.floor(t.Y),Math.floor(e.X),Math.floor(e.Y)),r=this.sizeOfBlackWhiteBlackRunBothWays(Math.floor(e.X),Math.floor(e.Y),Math.floor(t.X),Math.floor(t.Y));return isNaN(n)?r/7:isNaN(r)?n/7:(n+r)/14},o.prototype.calculateModuleSize=function(t,e,n){return(this.calculateModuleSizeOneWay(t,e)+this.calculateModuleSizeOneWay(t,n))/2},o.prototype.distance=function(t,e){var n=t.X-e.X,r=t.Y-e.Y;return Math.sqrt(n*n+r*r)},o.prototype.computeDimension=function(t,e,n,r){var i=Math.round(this.distance(t,e)/r),o=Math.round(this.distance(t,n)/r),a=(i+o>>1)+7;switch(3&a){case 0:a++;break;case 2:a--;break;case 3:throw"Error"}return a},o.prototype.findAlignmentInRegion=function(t,e,n,r){var i=Math.floor(r*t),o=Math.max(0,e-i),a=Math.min(this.image.width-1,e+i);if(a-o<3*t)throw"Error";var h=Math.max(0,n-i),f=Math.min(this.image.height-1,n+i),w=new s.a(this.image,o,h,a-o,f-h,t,this.resultPointCallback);return w.find()},o.prototype.createTransform=function(t,e,n,i,o){var a,s,h,f,w=o-3.5;null!=i?(a=i.X,s=i.Y,h=f=w-3):(a=e.X-t.X+n.X,s=e.Y-t.Y+n.Y,h=f=w);var u=r.quadrilateralToQuadrilateral(3.5,3.5,w,3.5,h,f,3.5,w,t.X,t.Y,e.X,e.Y,a,s,n.X,n.Y);return u},o.prototype.sampleGrid=function(t,e,n){var r=h.a;return r.sampleGrid3(t,n,e)},o.prototype.processFinderPatternInfo=function(t){var e=t.topLeft,n=t.topRight,r=t.bottomLeft,o=this.calculateModuleSize(e,n,r);if(o<1)throw"Error";var s=this.computeDimension(e,n,r,o),h=a.a.getProvisionalVersionForDimension(s),f=h.DimensionForVersion-7,w=null;if(h.alignmentPatternCenters.length>0)for(var u=n.X-e.X+r.X,l=n.Y-e.Y+r.Y,c=1-3/f,d=Math.floor(e.X+c*(u-e.X)),p=Math.floor(e.Y+c*(l-e.Y)),g=4;g<=16;g<<=1){w=this.findAlignmentInRegion(o,d,p,g);break}var v,m=this.createTransform(e,n,r,w,s),b=this.sampleGrid(this.image,m,s);return v=null==w?[r,e,n]:[r,e,n,w],new i(b,v)},o.prototype.detect=function(){var t=(new f.a).findFinderPattern(this.image);return this.processFinderPatternInfo(t)}},function(t,e,n){"use strict";function r(t,e,n){this.ordinal_Renamed_Field=t,this.bits=e,this.name=n}e.a=r,r.prototype.ordinal=function(){return this.ordinal_Renamed_Field},r.forBits=function(t){if(t<0||t>=i.length)throw"ArgumentException";return i[t]};var i=[new r(1,0,"M"),new r(0,1,"L"),new r(3,2,"H"),new r(2,3,"Q")]},function(t,e,n){"use strict";function r(t){function e(t,e){var n=t.X-e.X,r=t.Y-e.Y;return Math.sqrt(n*n+r*r)}function n(t,e,n){var r=e.x,i=e.y;return(n.x-r)*(t.y-i)-(n.y-i)*(t.x-r)}var r,i,o,a=e(t[0],t[1]),s=e(t[1],t[2]),h=e(t[0],t[2]);if(s>=a&&s>=h?(i=t[0],r=t[1],o=t[2]):h>=s&&h>=a?(i=t[1],r=t[0],o=t[2]):(i=t[2],r=t[0],o=t[1]),n(r,i,o)<0){var f=r;r=o,o=f}t[0]=r,t[1]=i,t[2]=o}function i(t,e,n){this.x=t,this.y=e,this.count=1,this.estimatedModuleSize=n}function o(t){this.bottomLeft=t[0],this.topLeft=t[1],this.topRight=t[2]}function a(){this.image=null,this.possibleCenters=[],this.hasSkipped=!1,this.crossCheckStateCount=[0,0,0,0,0],this.resultPointCallback=null}e.a=a;var s=3,h=57,f=8,w=2;Object.defineProperty(i.prototype,"X",{get:function(){return this.x}}),Object.defineProperty(i.prototype,"Y",{get:function(){return this.y}}),i.prototype.incrementCount=function(){this.count++},i.prototype.aboutEquals=function(t,e,n){if(Math.abs(e-this.y)<=t&&Math.abs(n-this.x)<=t){var r=Math.abs(t-this.estimatedModuleSize);return r<=1||r/this.estimatedModuleSize<=1}return!1},Object.defineProperty(a.prototype,"CrossCheckStateCount",{get:function(){return this.crossCheckStateCount[0]=0,this.crossCheckStateCount[1]=0,this.crossCheckStateCount[2]=0,this.crossCheckStateCount[3]=0,this.crossCheckStateCount[4]=0,this.crossCheckStateCount}}),a.prototype.foundPatternCross=function(t){for(var e=0,n=0;n<5;n++){var r=t[n];if(0==r)return!1;e+=r}if(e<7)return!1;var i=Math.floor((e<<f)/7),o=Math.floor(i/2);return Math.abs(i-(t[0]<<f))<o&&Math.abs(i-(t[1]<<f))<o&&Math.abs(3*i-(t[2]<<f))<3*o&&Math.abs(i-(t[3]<<f))<o&&Math.abs(i-(t[4]<<f))<o},a.prototype.centerFromEnd=function(t,e){return e-t[4]-t[3]-t[2]/2},a.prototype.crossCheckVertical=function(t,e,n,r){for(var i=this.image,o=i.height,a=this.CrossCheckStateCount,s=t;s>=0&&i.data[e+s*i.width];)a[2]++,s--;if(s<0)return NaN;for(;s>=0&&!i.data[e+s*i.width]&&a[1]<=n;)a[1]++,s--;if(s<0||a[1]>n)return NaN;for(;s>=0&&i.data[e+s*i.width]&&a[0]<=n;)a[0]++,s--;if(a[0]>n)return NaN;for(s=t+1;s<o&&i.data[e+s*i.width];)a[2]++,s++;if(s==o)return NaN;for(;s<o&&!i.data[e+s*i.width]&&a[3]<n;)a[3]++,s++;if(s==o||a[3]>=n)return NaN;for(;s<o&&i.data[e+s*i.width]&&a[4]<n;)a[4]++,s++;if(a[4]>=n)return NaN;var h=a[0]+a[1]+a[2]+a[3]+a[4];return 5*Math.abs(h-r)>=2*r?NaN:this.foundPatternCross(a)?this.centerFromEnd(a,s):NaN},a.prototype.crossCheckHorizontal=function(t,e,n,r){for(var i=this.image,o=i.width,a=this.CrossCheckStateCount,s=t;s>=0&&i.data[s+e*i.width];)a[2]++,s--;if(s<0)return NaN;for(;s>=0&&!i.data[s+e*i.width]&&a[1]<=n;)a[1]++,s--;if(s<0||a[1]>n)return NaN;for(;s>=0&&i.data[s+e*i.width]&&a[0]<=n;)a[0]++,s--;if(a[0]>n)return NaN;for(s=t+1;s<o&&i.data[s+e*i.width];)a[2]++,s++;if(s==o)return NaN;for(;s<o&&!i.data[s+e*i.width]&&a[3]<n;)a[3]++,s++;if(s==o||a[3]>=n)return NaN;for(;s<o&&i.data[s+e*i.width]&&a[4]<n;)a[4]++,s++;if(a[4]>=n)return NaN;var h=a[0]+a[1]+a[2]+a[3]+a[4];return 5*Math.abs(h-r)>=r?NaN:this.foundPatternCross(a)?this.centerFromEnd(a,s):NaN},a.prototype.handlePossibleCenter=function(t,e,n){var r=t[0]+t[1]+t[2]+t[3]+t[4],o=this.centerFromEnd(t,n),a=this.crossCheckVertical(e,Math.floor(o),t[2],r);if(!isNaN(a)&&(o=this.crossCheckHorizontal(Math.floor(o),Math.floor(a),t[2],r),!isNaN(o))){for(var s=r/7,h=!1,f=this.possibleCenters.length,w=0;w<f;w++){var u=this.possibleCenters[w];if(u.aboutEquals(s,a,o)){u.incrementCount(),h=!0;break}}if(!h){var l=new i(o,a,s);this.possibleCenters.push(l),null!=this.resultPointCallback&&this.resultPointCallback.foundPossibleResultPoint(l)}return!0}return!1},a.prototype.selectBestPatterns=function(){var t=this.possibleCenters.length;if(t<3)throw"Couldn\'t find enough finder patterns:"+t+" patterns found";if(t>3){for(var e=0,n=0,r=0;r<t;r++){var i=this.possibleCenters[r].estimatedModuleSize;e+=i,n+=i*i}var o=e/t;this.possibleCenters.sort(function(t,e){var n=Math.abs(e.estimatedModuleSize-o),r=Math.abs(t.estimatedModuleSize-o);return n<r?-1:n==r?0:1});for(var a=Math.sqrt(n/t-o*o),s=Math.max(.2*o,a),r=this.possibleCenters-1;r>=0;r--){var h=this.possibleCenters[r];Math.abs(h.estimatedModuleSize-o)>s&&this.possibleCenters.splice(r,1)}}return this.possibleCenters.length>3&&this.possibleCenters.sort(function(t,e){return t.count>e.count?-1:t.count<e.count?1:0}),[this.possibleCenters[0],this.possibleCenters[1],this.possibleCenters[2]]},a.prototype.findRowSkip=function(){var t=this.possibleCenters.length;if(t<=1)return 0;for(var e=null,n=0;n<t;n++){var r=this.possibleCenters[n];if(r.count>=w){if(null!=e)return this.hasSkipped=!0,Math.floor((Math.abs(e.X-r.X)-Math.abs(e.Y-r.Y))/2);e=r}}return 0},a.prototype.haveMultiplyConfirmedCenters=function(){for(var t=0,e=0,n=this.possibleCenters.length,r=0;r<n;r++){var i=this.possibleCenters[r];i.count>=w&&(t++,e+=i.estimatedModuleSize)}if(t<3)return!1;for(var o=e/n,a=0,r=0;r<n;r++)i=this.possibleCenters[r],a+=Math.abs(i.estimatedModuleSize-o);return a<=.05*e},a.prototype.findFinderPattern=function(t){var e=!1;this.image=t;var n=t.height,i=t.width,a=Math.floor(3*n/(4*h));(a<s||e)&&(a=s);for(var f=!1,w=new Array(5),u=a-1;u<n&&!f;u+=a){w[0]=0,w[1]=0,w[2]=0,w[3]=0,w[4]=0;for(var l=0,c=0;c<i;c++)if(t.data[c+u*t.width])1==(1&l)&&l++,w[l]++;else if(0==(1&l))if(4==l)if(this.foundPatternCross(w)){var d=this.handlePossibleCenter(w,u,c);if(d)if(a=2,this.hasSkipped)f=this.haveMultiplyConfirmedCenters();else{var p=this.findRowSkip();p>w[2]&&(u+=p-w[2]-a,c=i-1)}else{do c++;while(c<i&&!t.data[c+u*t.width]);c--}l=0,w[0]=0,w[1]=0,w[2]=0,w[3]=0,w[4]=0}else w[0]=w[2],w[1]=w[3],w[2]=w[4],w[3]=1,w[4]=0,l=3;else w[++l]++;else w[l]++;if(this.foundPatternCross(w)){var d=this.handlePossibleCenter(w,u,i);d&&(a=w[0],this.hasSkipped&&(f=this.haveMultiplyConfirmedCenters()))}}var g=this.selectBestPatterns();return r(g),new o(g)}},function(t,e,n){"use strict";var r=n(2),i={};i.checkAndNudgePoints=function(t,e){for(var n=t.width,r=t.height,i=!0,o=0;o<e.length&&i;o+=2){var a=Math.floor(e[o]),s=Math.floor(e[o+1]);if(a<-1||a>n||s<-1||s>r)throw"Error.checkAndNudgePoints ";i=!1,a==-1?(e[o]=0,i=!0):a==n&&(e[o]=n-1,i=!0),s==-1?(e[o+1]=0,i=!0):s==r&&(e[o+1]=r-1,i=!0)}i=!0;for(var o=e.length-2;o>=0&&i;o-=2){var a=Math.floor(e[o]),s=Math.floor(e[o+1]);if(a<-1||a>n||s<-1||s>r)throw"Error.checkAndNudgePoints ";i=!1,a==-1?(e[o]=0,i=!0):a==n&&(e[o]=n-1,i=!0),s==-1?(e[o+1]=0,i=!0):s==r&&(e[o+1]=r-1,i=!0)}},i.sampleGrid3=function(t,e,n){for(var o=new r.a(e),a=new Array(e<<1),s=0;s<e;s++){for(var h=a.length,f=s+.5,w=0;w<h;w+=2)a[w]=(w>>1)+.5,a[w+1]=f;n.transformPoints1(a),i.checkAndNudgePoints(t,a);try{for(var w=0;w<h;w+=2){var u=t.data[Math.floor(a[w])+t.width*Math.floor(a[w+1])];u&&o.set_Renamed(w>>1,s)}}catch(t){throw"Error.checkAndNudgePoints"}}return o},e.a=i},function(t,e,n){"use strict";function r(t){this.field=t}var i=n(1),o=n(4);e.a=r,r.prototype.decode=function(t,e){for(var n=new o.a(this.field,t),r=new Array(e),a=0;a<r.length;a++)r[a]=0;for(var s=!1,h=!0,a=0;a<e;a++){var f=n.evaluateAt(this.field.exp(s?a+1:a));r[r.length-1-a]=f,0!=f&&(h=!1)}if(!h)for(var w=new o.a(this.field,r),u=this.runEuclideanAlgorithm(this.field.buildMonomial(e,1),w,e),l=u[0],c=u[1],d=this.findErrorLocations(l),p=this.findErrorMagnitudes(c,d,s),a=0;a<d.length;a++){var g=t.length-1-this.field.log(d[a]);if(g<0)throw"ReedSolomonException Bad error location";t[g]=i.a.addOrSubtract(t[g],p[a])}},r.prototype.runEuclideanAlgorithm=function(t,e,n){if(t.Degree<e.Degree){var r=t;t=e,e=r}for(var i=t,o=e,a=this.field.One,s=this.field.Zero,h=this.field.Zero,f=this.field.One;o.Degree>=Math.floor(n/2);){var w=i,u=a,l=h;if(i=o,a=s,h=f,i.Zero)throw"r_{i-1} was zero";o=w;for(var c=this.field.Zero,d=i.getCoefficient(i.Degree),p=this.field.inverse(d);o.Degree>=i.Degree&&!o.Zero;){var g=o.Degree-i.Degree,v=this.field.multiply(o.getCoefficient(o.Degree),p);c=c.addOrSubtract(this.field.buildMonomial(g,v)),o=o.addOrSubtract(i.multiplyByMonomial(g,v))}s=c.multiply1(a).addOrSubtract(u),f=c.multiply1(h).addOrSubtract(l)}var m=f.getCoefficient(0);if(0==m)throw"ReedSolomonException sigmaTilde(0) was zero";var b=this.field.inverse(m),y=f.multiply2(b),C=o.multiply2(b);return[y,C]},r.prototype.findErrorLocations=function(t){var e=t.Degree;if(1==e)return new Array(t.getCoefficient(1));for(var n=new Array(e),r=0,i=1;i<256&&r<e;i++)0==t.evaluateAt(i)&&(n[r]=this.field.inverse(i),r++);if(r!=e)throw"Error locator degree does not match number of roots";return n},r.prototype.findErrorMagnitudes=function(t,e,n){for(var r=e.length,o=new Array(r),a=0;a<r;a++){for(var s=this.field.inverse(e[a]),h=1,f=0;f<r;f++)a!=f&&(h=this.field.multiply(h,i.a.addOrSubtract(1,this.field.multiply(e[f],s))));o[a]=this.field.multiply(t.evaluateAt(s),this.field.inverse(h)),n&&(o[a]=this.field.multiply(o[a],s))}return o}},function(t,e,n){(function(t){t={};var e=n(6).default,r=new e;r.callback=function(t,e){postMessage({result:t,err:e})},onmessage=function(t){var e=t.data;r.decode(e)}}).call(e,n(7)(t))}]);';
},function(e,t,n){"use strict";var r={};r.generateIdentifier=function(){return Math.random().toString(36).substr(2,10)},r.localCName=r.generateIdentifier(),r.splitLines=function(e){return e.trim().split("\n").map(function(e){return e.trim()})},r.splitSections=function(e){var t=e.split("\nm=");return t.map(function(e,t){return(t>0?"m="+e:e).trim()+"\r\n"})},r.matchPrefix=function(e,t){return r.splitLines(e).filter(function(e){return 0===e.indexOf(t)})},r.parseCandidate=function(e){var t;t=0===e.indexOf("a=candidate:")?e.substring(12).split(" "):e.substring(10).split(" ");for(var n={foundation:t[0],component:t[1],protocol:t[2].toLowerCase(),priority:parseInt(t[3],10),ip:t[4],port:parseInt(t[5],10),type:t[7]},r=8;r<t.length;r+=2)switch(t[r]){case"raddr":n.relatedAddress=t[r+1];break;case"rport":n.relatedPort=parseInt(t[r+1],10);break;case"tcptype":n.tcpType=t[r+1]}return n},r.writeCandidate=function(e){var t=[];t.push(e.foundation),t.push(e.component),t.push(e.protocol.toUpperCase()),t.push(e.priority),t.push(e.ip),t.push(e.port);var n=e.type;return t.push("typ"),t.push(n),"host"!==n&&e.relatedAddress&&e.relatedPort&&(t.push("raddr"),t.push(e.relatedAddress),t.push("rport"),t.push(e.relatedPort)),e.tcpType&&"tcp"===e.protocol.toLowerCase()&&(t.push("tcptype"),t.push(e.tcpType)),"candidate:"+t.join(" ")},r.parseRtpMap=function(e){var t=e.substr(9).split(" "),n={payloadType:parseInt(t.shift(),10)};return t=t[0].split("/"),n.name=t[0],n.clockRate=parseInt(t[1],10),n.numChannels=3===t.length?parseInt(t[2],10):1,n},r.writeRtpMap=function(e){var t=e.payloadType;return void 0!==e.preferredPayloadType&&(t=e.preferredPayloadType),"a=rtpmap:"+t+" "+e.name+"/"+e.clockRate+(1!==e.numChannels?"/"+e.numChannels:"")+"\r\n"},r.parseExtmap=function(e){var t=e.substr(9).split(" ");return{id:parseInt(t[0],10),uri:t[1]}},r.writeExtmap=function(e){return"a=extmap:"+(e.id||e.preferredId)+" "+e.uri+"\r\n"},r.parseFmtp=function(e){for(var t,n={},r=e.substr(e.indexOf(" ")+1).split(";"),i=0;i<r.length;i++)t=r[i].trim().split("="),n[t[0].trim()]=t[1];return n},r.writeFmtp=function(e){var t="",n=e.payloadType;if(void 0!==e.preferredPayloadType&&(n=e.preferredPayloadType),e.parameters&&Object.keys(e.parameters).length){var r=[];Object.keys(e.parameters).forEach(function(t){r.push(t+"="+e.parameters[t])}),t+="a=fmtp:"+n+" "+r.join(";")+"\r\n"}return t},r.parseRtcpFb=function(e){var t=e.substr(e.indexOf(" ")+1).split(" ");return{type:t.shift(),parameter:t.join(" ")}},r.writeRtcpFb=function(e){var t="",n=e.payloadType;return void 0!==e.preferredPayloadType&&(n=e.preferredPayloadType),e.rtcpFeedback&&e.rtcpFeedback.length&&e.rtcpFeedback.forEach(function(e){t+="a=rtcp-fb:"+n+" "+e.type+(e.parameter&&e.parameter.length?" "+e.parameter:"")+"\r\n"}),t},r.parseSsrcMedia=function(e){var t=e.indexOf(" "),n={ssrc:parseInt(e.substr(7,t-7),10)},r=e.indexOf(":",t);return r>-1?(n.attribute=e.substr(t+1,r-t-1),n.value=e.substr(r+1)):n.attribute=e.substr(t+1),n},r.getDtlsParameters=function(e,t){var n=r.splitLines(e);n=n.concat(r.splitLines(t));var i=n.filter(function(e){return 0===e.indexOf("a=fingerprint:")})[0].substr(14),o={role:"auto",fingerprints:[{algorithm:i.split(" ")[0],value:i.split(" ")[1]}]};return o},r.writeDtlsParameters=function(e,t){var n="a=setup:"+t+"\r\n";return e.fingerprints.forEach(function(e){n+="a=fingerprint:"+e.algorithm+" "+e.value+"\r\n"}),n},r.getIceParameters=function(e,t){var n=r.splitLines(e);n=n.concat(r.splitLines(t));var i={usernameFragment:n.filter(function(e){return 0===e.indexOf("a=ice-ufrag:")})[0].substr(12),password:n.filter(function(e){return 0===e.indexOf("a=ice-pwd:")})[0].substr(10)};return i},r.writeIceParameters=function(e){return"a=ice-ufrag:"+e.usernameFragment+"\r\na=ice-pwd:"+e.password+"\r\n"},r.parseRtpParameters=function(e){for(var t={codecs:[],headerExtensions:[],fecMechanisms:[],rtcp:[]},n=r.splitLines(e),i=n[0].split(" "),o=3;o<i.length;o++){var a=i[o],s=r.matchPrefix(e,"a=rtpmap:"+a+" ")[0];if(s){var c=r.parseRtpMap(s),d=r.matchPrefix(e,"a=fmtp:"+a+" ");switch(c.parameters=d.length?r.parseFmtp(d[0]):{},c.rtcpFeedback=r.matchPrefix(e,"a=rtcp-fb:"+a+" ").map(r.parseRtcpFb),t.codecs.push(c),c.name.toUpperCase()){case"RED":case"ULPFEC":t.fecMechanisms.push(c.name.toUpperCase())}}}return r.matchPrefix(e,"a=extmap:").forEach(function(e){t.headerExtensions.push(r.parseExtmap(e))}),t},r.writeRtpDescription=function(e,t){var n="";n+="m="+e+" ",n+=t.codecs.length>0?"9":"0",n+=" UDP/TLS/RTP/SAVPF ",n+=t.codecs.map(function(e){return void 0!==e.preferredPayloadType?e.preferredPayloadType:e.payloadType}).join(" ")+"\r\n",n+="c=IN IP4 0.0.0.0\r\n",n+="a=rtcp:9 IN IP4 0.0.0.0\r\n",t.codecs.forEach(function(e){n+=r.writeRtpMap(e),n+=r.writeFmtp(e),n+=r.writeRtcpFb(e)});var i=0;return t.codecs.forEach(function(e){e.maxptime>i&&(i=e.maxptime)}),i>0&&(n+="a=maxptime:"+i+"\r\n"),n+="a=rtcp-mux\r\n",t.headerExtensions.forEach(function(e){n+=r.writeExtmap(e)}),n},r.parseRtpEncodingParameters=function(e){var t,n=[],i=r.parseRtpParameters(e),o=i.fecMechanisms.indexOf("RED")!==-1,a=i.fecMechanisms.indexOf("ULPFEC")!==-1,s=r.matchPrefix(e,"a=ssrc:").map(function(e){return r.parseSsrcMedia(e)}).filter(function(e){return"cname"===e.attribute}),c=s.length>0&&s[0].ssrc,d=r.matchPrefix(e,"a=ssrc-group:FID").map(function(e){var t=e.split(" ");return t.shift(),t.map(function(e){return parseInt(e,10)})});d.length>0&&d[0].length>1&&d[0][0]===c&&(t=d[0][1]),i.codecs.forEach(function(e){if("RTX"===e.name.toUpperCase()&&e.parameters.apt){var r={ssrc:c,codecPayloadType:parseInt(e.parameters.apt,10),rtx:{ssrc:t}};n.push(r),o&&(r=JSON.parse(JSON.stringify(r)),r.fec={ssrc:t,mechanism:a?"red+ulpfec":"red"},n.push(r))}}),0===n.length&&c&&n.push({ssrc:c});var u=r.matchPrefix(e,"b=");return u.length&&(0===u[0].indexOf("b=TIAS:")?u=parseInt(u[0].substr(7),10):0===u[0].indexOf("b=AS:")&&(u=parseInt(u[0].substr(5),10)),n.forEach(function(e){e.maxBitrate=u})),n},r.parseMsid=function(e){var t,n=r.matchPrefix(e,"a=msid:");if(1===n.length)return t=n[0].substr(7).split(" "),{stream:t[0],track:t[1]};var i=r.matchPrefix(e,"a=ssrc:").map(function(e){return r.parseSsrcMedia(e)}).filter(function(e){return"msid"===e.attribute});return i.length>0?(t=i[0].value.split(" "),{stream:t[0],track:t[1]}):void 0},r.writeSessionBoilerplate=function(){return"v=0\r\no=thisisadapterortc 8169639915646943137 2 IN IP4 127.0.0.1\r\ns=-\r\nt=0 0\r\n"},r.writeMediaSection=function(e,t,n,i){var o=r.writeRtpDescription(e.kind,t);if(o+=r.writeIceParameters(e.iceGatherer.getLocalParameters()),o+=r.writeDtlsParameters(e.dtlsTransport.getLocalParameters(),"offer"===n?"actpass":"active"),o+="a=mid:"+e.mid+"\r\n",o+=e.rtpSender&&e.rtpReceiver?"a=sendrecv\r\n":e.rtpSender?"a=sendonly\r\n":e.rtpReceiver?"a=recvonly\r\n":"a=inactive\r\n",e.rtpSender){var a="msid:"+i.id+" "+e.rtpSender.track.id+"\r\n";o+="a="+a,o+="a=ssrc:"+e.sendEncodingParameters[0].ssrc+" "+a,e.sendEncodingParameters[0].rtx&&(o+="a=ssrc:"+e.sendEncodingParameters[0].rtx.ssrc+" "+a,o+="a=ssrc-group:FID "+e.sendEncodingParameters[0].ssrc+" "+e.sendEncodingParameters[0].rtx.ssrc+"\r\n")}return o+="a=ssrc:"+e.sendEncodingParameters[0].ssrc+" cname:"+r.localCName+"\r\n",e.rtpSender&&e.sendEncodingParameters[0].rtx&&(o+="a=ssrc:"+e.sendEncodingParameters[0].rtx.ssrc+" cname:"+r.localCName+"\r\n"),o},r.getDirection=function(e,t){for(var n=r.splitLines(e),i=0;i<n.length;i++)switch(n[i]){case"a=sendrecv":case"a=sendonly":case"a=recvonly":case"a=inactive":return n[i].substr(2)}return t?r.getDirection(t):"sendrecv"},r.getKind=function(e){var t=r.splitLines(e),n=t[0].split(" ");return n[0].substr(2)},e.exports=r},function(e,t,n){"use strict";!function(){var t=n(0),r=t.log,i=t.browserDetails;e.exports.browserDetails=i,e.exports.extractVersion=t.extractVersion,e.exports.disableLog=t.disableLog;var o=n(6)||null,a=n(8)||null,s=n(10)||null,c=n(12)||null;switch(i.browser){case"chrome":if(!o||!o.shimPeerConnection)return void r("Chrome shim is not included in this adapter release.");r("adapter.js shimming chrome."),e.exports.browserShim=o,o.shimGetUserMedia(),o.shimMediaStream(),t.shimCreateObjectURL(),o.shimSourceObject(),o.shimPeerConnection(),o.shimOnTrack(),o.shimGetSendersWithDtmf();break;case"firefox":if(!s||!s.shimPeerConnection)return void r("Firefox shim is not included in this adapter release.");r("adapter.js shimming firefox."),e.exports.browserShim=s,s.shimGetUserMedia(),t.shimCreateObjectURL(),s.shimSourceObject(),s.shimPeerConnection(),s.shimOnTrack();break;case"edge":if(!a||!a.shimPeerConnection)return void r("MS edge shim is not included in this adapter release.");r("adapter.js shimming edge."),e.exports.browserShim=a,a.shimGetUserMedia(),t.shimCreateObjectURL(),a.shimPeerConnection();break;case"safari":if(!c)return void r("Safari shim is not included in this adapter release.");r("adapter.js shimming safari."),e.exports.browserShim=c,c.shimGetUserMedia();break;default:r("Unsupported browser!")}}()},function(e,t,n){"use strict";var r=n(0).log,i=n(0).browserDetails,o={shimMediaStream:function(){window.MediaStream=window.MediaStream||window.webkitMediaStream},shimOnTrack:function(){"object"!=typeof window||!window.RTCPeerConnection||"ontrack"in window.RTCPeerConnection.prototype||Object.defineProperty(window.RTCPeerConnection.prototype,"ontrack",{get:function(){return this._ontrack},set:function(e){var t=this;this._ontrack&&(this.removeEventListener("track",this._ontrack),this.removeEventListener("addstream",this._ontrackpoly)),this.addEventListener("track",this._ontrack=e),this.addEventListener("addstream",this._ontrackpoly=function(e){e.stream.addEventListener("addtrack",function(n){var r=new Event("track");r.track=n.track,r.receiver={track:n.track},r.streams=[e.stream],t.dispatchEvent(r)}),e.stream.getTracks().forEach(function(t){var n=new Event("track");n.track=t,n.receiver={track:t},n.streams=[e.stream],this.dispatchEvent(n)}.bind(this))}.bind(this))}})},shimGetSendersWithDtmf:function(){if("object"==typeof window&&window.RTCPeerConnection&&!("getSenders"in RTCPeerConnection.prototype)&&"createDTMFSender"in RTCPeerConnection.prototype){RTCPeerConnection.prototype.getSenders=function(){return this._senders};var e=RTCPeerConnection.prototype.addStream;RTCPeerConnection.prototype.addStream=function(t){var n=this;n._senders=n._senders||[],e.apply(n,[t]),t.getTracks().forEach(function(e){n._senders.push({track:e,get dtmf(){return this._dtmf||(this._dtmf=n.createDTMFSender(e)),this._dtmf}})})}}},shimSourceObject:function(){"object"==typeof window&&(!window.HTMLMediaElement||"srcObject"in window.HTMLMediaElement.prototype||Object.defineProperty(window.HTMLMediaElement.prototype,"srcObject",{get:function(){return this._srcObject},set:function(e){var t=this;return this._srcObject=e,this.src&&URL.revokeObjectURL(this.src),e?(this.src=URL.createObjectURL(e),e.addEventListener("addtrack",function(){t.src&&URL.revokeObjectURL(t.src),t.src=URL.createObjectURL(e)}),void e.addEventListener("removetrack",function(){t.src&&URL.revokeObjectURL(t.src),t.src=URL.createObjectURL(e)})):void(this.src="")}}))},shimPeerConnection:function(){window.RTCPeerConnection||(window.RTCPeerConnection=function(e,t){return r("PeerConnection"),e&&e.iceTransportPolicy&&(e.iceTransports=e.iceTransportPolicy),new webkitRTCPeerConnection(e,t)},window.RTCPeerConnection.prototype=webkitRTCPeerConnection.prototype,webkitRTCPeerConnection.generateCertificate&&Object.defineProperty(window.RTCPeerConnection,"generateCertificate",{get:function(){return webkitRTCPeerConnection.generateCertificate}}));var e=RTCPeerConnection.prototype.getStats;RTCPeerConnection.prototype.getStats=function(t,n,r){var i=this,o=arguments;if(arguments.length>0&&"function"==typeof t)return e.apply(this,arguments);if(0===e.length&&(0===arguments.length||"function"!=typeof arguments[0]))return e.apply(this,[]);var a=function(e){var t={},n=e.result();return n.forEach(function(e){var n={id:e.id,timestamp:e.timestamp,type:{localcandidate:"local-candidate",remotecandidate:"remote-candidate"}[e.type]||e.type};e.names().forEach(function(t){n[t]=e.stat(t)}),t[n.id]=n}),t},s=function(e){return new Map(Object.keys(e).map(function(t){return[t,e[t]]}))};if(arguments.length>=2){var c=function(e){o[1](s(a(e)))};return e.apply(this,[c,arguments[0]])}return new Promise(function(t,n){e.apply(i,[function(e){t(s(a(e)))},n])}).then(n,r)},i.version<51&&["setLocalDescription","setRemoteDescription","addIceCandidate"].forEach(function(e){var t=RTCPeerConnection.prototype[e];RTCPeerConnection.prototype[e]=function(){var e=arguments,n=this,r=new Promise(function(r,i){t.apply(n,[e[0],r,i])});return e.length<2?r:r.then(function(){e[1].apply(null,[])},function(t){e.length>=3&&e[2].apply(null,[t])})}}),i.version<52&&["createOffer","createAnswer"].forEach(function(e){var t=RTCPeerConnection.prototype[e];RTCPeerConnection.prototype[e]=function(){var e=this;if(arguments.length<1||1===arguments.length&&"object"==typeof arguments[0]){var n=1===arguments.length?arguments[0]:void 0;return new Promise(function(r,i){t.apply(e,[r,i,n])})}return t.apply(this,arguments)}}),["setLocalDescription","setRemoteDescription","addIceCandidate"].forEach(function(e){var t=RTCPeerConnection.prototype[e];RTCPeerConnection.prototype[e]=function(){return arguments[0]=new("addIceCandidate"===e?RTCIceCandidate:RTCSessionDescription)(arguments[0]),t.apply(this,arguments)}});var t=RTCPeerConnection.prototype.addIceCandidate;RTCPeerConnection.prototype.addIceCandidate=function(){return arguments[0]?t.apply(this,arguments):(arguments[1]&&arguments[1].apply(null),Promise.resolve())}}};e.exports={shimMediaStream:o.shimMediaStream,shimOnTrack:o.shimOnTrack,shimGetSendersWithDtmf:o.shimGetSendersWithDtmf,shimSourceObject:o.shimSourceObject,shimPeerConnection:o.shimPeerConnection,shimGetUserMedia:n(7)}},function(e,t,n){"use strict";var r=n(0).log;e.exports=function(){var e=function(e){if("object"!=typeof e||e.mandatory||e.optional)return e;var t={};return Object.keys(e).forEach(function(n){if("require"!==n&&"advanced"!==n&&"mediaSource"!==n){var r="object"==typeof e[n]?e[n]:{ideal:e[n]};void 0!==r.exact&&"number"==typeof r.exact&&(r.min=r.max=r.exact);var i=function(e,t){return e?e+t.charAt(0).toUpperCase()+t.slice(1):"deviceId"===t?"sourceId":t};if(void 0!==r.ideal){t.optional=t.optional||[];var o={};"number"==typeof r.ideal?(o[i("min",n)]=r.ideal,t.optional.push(o),o={},o[i("max",n)]=r.ideal,t.optional.push(o)):(o[i("",n)]=r.ideal,t.optional.push(o))}void 0!==r.exact&&"number"!=typeof r.exact?(t.mandatory=t.mandatory||{},t.mandatory[i("",n)]=r.exact):["min","max"].forEach(function(e){void 0!==r[e]&&(t.mandatory=t.mandatory||{},t.mandatory[i(e,n)]=r[e])})}}),e.advanced&&(t.optional=(t.optional||[]).concat(e.advanced)),t},t=function(t,n){if(t=JSON.parse(JSON.stringify(t)),t&&t.audio&&(t.audio=e(t.audio)),t&&"object"==typeof t.video){var i=t.video.facingMode;if(i=i&&("object"==typeof i?i:{ideal:i}),i&&("user"===i.exact||"environment"===i.exact||"user"===i.ideal||"environment"===i.ideal)&&(!navigator.mediaDevices.getSupportedConstraints||!navigator.mediaDevices.getSupportedConstraints().facingMode)&&(delete t.video.facingMode,"environment"===i.exact||"environment"===i.ideal))return navigator.mediaDevices.enumerateDevices().then(function(o){o=o.filter(function(e){return"videoinput"===e.kind});var a=o.find(function(e){return e.label.toLowerCase().indexOf("back")!==-1})||o.length&&o[o.length-1];return a&&(t.video.deviceId=i.exact?{exact:a.deviceId}:{ideal:a.deviceId}),t.video=e(t.video),r("chrome: "+JSON.stringify(t)),n(t)});t.video=e(t.video)}return r("chrome: "+JSON.stringify(t)),n(t)},n=function(e){return{name:{PermissionDeniedError:"NotAllowedError",ConstraintNotSatisfiedError:"OverconstrainedError"}[e.name]||e.name,message:e.message,constraint:e.constraintName,toString:function(){return this.name+(this.message&&": ")+this.message}}},i=function(e,r,i){t(e,function(e){navigator.webkitGetUserMedia(e,r,function(e){i(n(e))})})};navigator.getUserMedia=i;var o=function(e){return new Promise(function(t,n){navigator.getUserMedia(e,t,n)})};if(navigator.mediaDevices||(navigator.mediaDevices={getUserMedia:o,enumerateDevices:function(){return new Promise(function(e){var t={audio:"audioinput",video:"videoinput"};return MediaStreamTrack.getSources(function(n){e(n.map(function(e){return{label:e.label,kind:t[e.kind],deviceId:e.id,groupId:""}}))})})}}),navigator.mediaDevices.getUserMedia){var a=navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices);navigator.mediaDevices.getUserMedia=function(e){return t(e,function(e){return a(e).then(function(t){if(e.audio&&!t.getAudioTracks().length||e.video&&!t.getVideoTracks().length)throw t.getTracks().forEach(function(e){e.stop()}),new DOMException("","NotFoundError");return t},function(e){return Promise.reject(n(e))})})}}else navigator.mediaDevices.getUserMedia=function(e){return o(e)};"undefined"==typeof navigator.mediaDevices.addEventListener&&(navigator.mediaDevices.addEventListener=function(){r("Dummy mediaDevices.addEventListener called.")}),"undefined"==typeof navigator.mediaDevices.removeEventListener&&(navigator.mediaDevices.removeEventListener=function(){r("Dummy mediaDevices.removeEventListener called.")})}},function(e,t,n){"use strict";var r=n(4),i=n(0).browserDetails,o={shimPeerConnection:function(){if(window.RTCIceGatherer&&(window.RTCIceCandidate||(window.RTCIceCandidate=function(e){return e}),window.RTCSessionDescription||(window.RTCSessionDescription=function(e){return e}),i.version<15025)){var e=Object.getOwnPropertyDescriptor(MediaStreamTrack.prototype,"enabled");Object.defineProperty(MediaStreamTrack.prototype,"enabled",{set:function(t){e.set.call(this,t);var n=new Event("enabled");n.enabled=t,this.dispatchEvent(n)}})}window.RTCPeerConnection=function(e){var t=this,n=document.createDocumentFragment();if(["addEventListener","removeEventListener","dispatchEvent"].forEach(function(e){t[e]=n[e].bind(n)}),this.onicecandidate=null,this.onaddstream=null,this.ontrack=null,this.onremovestream=null,this.onsignalingstatechange=null,this.oniceconnectionstatechange=null,this.onicegatheringstatechange=null,this.onnegotiationneeded=null,this.ondatachannel=null,this.localStreams=[],this.remoteStreams=[],this.getLocalStreams=function(){return t.localStreams},this.getRemoteStreams=function(){return t.remoteStreams},this.localDescription=new RTCSessionDescription({type:"",sdp:""}),this.remoteDescription=new RTCSessionDescription({type:"",sdp:""}),this.signalingState="stable",this.iceConnectionState="new",this.iceGatheringState="new",this.iceOptions={gatherPolicy:"all",iceServers:[]},e&&e.iceTransportPolicy)switch(e.iceTransportPolicy){case"all":case"relay":this.iceOptions.gatherPolicy=e.iceTransportPolicy;break;case"none":throw new TypeError('iceTransportPolicy "none" not supported')}if(this.usingBundle=e&&"max-bundle"===e.bundlePolicy,e&&e.iceServers){var r=JSON.parse(JSON.stringify(e.iceServers));this.iceOptions.iceServers=r.filter(function(e){if(e&&e.urls){var t=e.urls;return"string"==typeof t&&(t=[t]),t=t.filter(function(e){return 0===e.indexOf("turn:")&&e.indexOf("transport=udp")!==-1&&e.indexOf("turn:[")===-1||0===e.indexOf("stun:")&&i.version>=14393})[0],!!t}return!1})}this._config=e,this.transceivers=[],this._localIceCandidatesBuffer=[]},window.RTCPeerConnection.prototype._emitGatheringStateChange=function(){var e=new Event("icegatheringstatechange");this.dispatchEvent(e),null!==this.onicegatheringstatechange&&this.onicegatheringstatechange(e)},window.RTCPeerConnection.prototype._emitBufferedCandidates=function(){var e=this,t=r.splitSections(e.localDescription.sdp);this._localIceCandidatesBuffer.forEach(function(n){var r=!n.candidate||0===Object.keys(n.candidate).length;if(r)for(var i=1;i<t.length;i++)t[i].indexOf("\r\na=end-of-candidates\r\n")===-1&&(t[i]+="a=end-of-candidates\r\n");else t[n.candidate.sdpMLineIndex+1]+="a="+n.candidate.candidate+"\r\n";if(e.localDescription.sdp=t.join(""),e.dispatchEvent(n),null!==e.onicecandidate&&e.onicecandidate(n),!n.candidate&&"complete"!==e.iceGatheringState){var o=e.transceivers.every(function(e){return e.iceGatherer&&"completed"===e.iceGatherer.state});o&&"complete"!==e.iceGatheringStateChange&&(e.iceGatheringState="complete",e._emitGatheringStateChange())}}),this._localIceCandidatesBuffer=[]},window.RTCPeerConnection.prototype.getConfiguration=function(){return this._config},window.RTCPeerConnection.prototype.addStream=function(e){if(i.version>=15025)this.localStreams.push(e);else{var t=e.clone();e.getTracks().forEach(function(e,n){var r=t.getTracks()[n];e.addEventListener("enabled",function(e){r.enabled=e.enabled})}),this.localStreams.push(t)}this._maybeFireNegotiationNeeded()},window.RTCPeerConnection.prototype.removeStream=function(e){var t=this.localStreams.indexOf(e);t>-1&&(this.localStreams.splice(t,1),this._maybeFireNegotiationNeeded())},window.RTCPeerConnection.prototype.getSenders=function(){return this.transceivers.filter(function(e){return!!e.rtpSender}).map(function(e){return e.rtpSender})},window.RTCPeerConnection.prototype.getReceivers=function(){return this.transceivers.filter(function(e){return!!e.rtpReceiver}).map(function(e){return e.rtpReceiver})},window.RTCPeerConnection.prototype._getCommonCapabilities=function(e,t){var n={codecs:[],headerExtensions:[],fecMechanisms:[]};return e.codecs.forEach(function(e){for(var r=0;r<t.codecs.length;r++){var i=t.codecs[r];if(e.name.toLowerCase()===i.name.toLowerCase()&&e.clockRate===i.clockRate){i.numChannels=Math.min(e.numChannels,i.numChannels),n.codecs.push(i),i.rtcpFeedback=i.rtcpFeedback.filter(function(t){for(var n=0;n<e.rtcpFeedback.length;n++)if(e.rtcpFeedback[n].type===t.type&&e.rtcpFeedback[n].parameter===t.parameter)return!0;return!1});break}}}),e.headerExtensions.forEach(function(e){for(var r=0;r<t.headerExtensions.length;r++){var i=t.headerExtensions[r];if(e.uri===i.uri){n.headerExtensions.push(i);break}}}),n},window.RTCPeerConnection.prototype._createIceAndDtlsTransports=function(e,t){var n=this,i=new RTCIceGatherer(n.iceOptions),o=new RTCIceTransport(i);i.onlocalcandidate=function(a){var s=new Event("icecandidate");s.candidate={sdpMid:e,sdpMLineIndex:t};var c=a.candidate,d=!c||0===Object.keys(c).length;d?void 0===i.state&&(i.state="completed"):(c.component="RTCP"===o.component?2:1,s.candidate.candidate=r.writeCandidate(c));var u=r.splitSections(n.localDescription.sdp);d?u[s.candidate.sdpMLineIndex+1]+="a=end-of-candidates\r\n":u[s.candidate.sdpMLineIndex+1]+="a="+s.candidate.candidate+"\r\n",n.localDescription.sdp=u.join("");var h=n._pendingOffer?n._pendingOffer:n.transceivers,f=h.every(function(e){return e.iceGatherer&&"completed"===e.iceGatherer.state});switch(n.iceGatheringState){case"new":d||n._localIceCandidatesBuffer.push(s),d&&f&&n._localIceCandidatesBuffer.push(new Event("icecandidate"));break;case"gathering":n._emitBufferedCandidates(),d||(n.dispatchEvent(s),null!==n.onicecandidate&&n.onicecandidate(s)),f&&(n.dispatchEvent(new Event("icecandidate")),null!==n.onicecandidate&&n.onicecandidate(new Event("icecandidate")),n.iceGatheringState="complete",n._emitGatheringStateChange());break;case"complete":}},o.onicestatechange=function(){n._updateConnectionState()};var a=new RTCDtlsTransport(o);return a.ondtlsstatechange=function(){n._updateConnectionState()},a.onerror=function(){a.state="failed",n._updateConnectionState()},{iceGatherer:i,iceTransport:o,dtlsTransport:a}},window.RTCPeerConnection.prototype._transceive=function(e,t,n){var i=this._getCommonCapabilities(e.localCapabilities,e.remoteCapabilities);t&&e.rtpSender&&(i.encodings=e.sendEncodingParameters,i.rtcp={cname:r.localCName},e.recvEncodingParameters.length&&(i.rtcp.ssrc=e.recvEncodingParameters[0].ssrc),e.rtpSender.send(i)),n&&e.rtpReceiver&&("video"===e.kind&&e.recvEncodingParameters&&e.recvEncodingParameters.forEach(function(e){delete e.rtx}),i.encodings=e.recvEncodingParameters,i.rtcp={cname:e.cname},e.sendEncodingParameters.length&&(i.rtcp.ssrc=e.sendEncodingParameters[0].ssrc),e.rtpReceiver.receive(i))},window.RTCPeerConnection.prototype.setLocalDescription=function(e){var t,n,i=this;if("offer"===e.type)this._pendingOffer&&(t=r.splitSections(e.sdp),n=t.shift(),t.forEach(function(e,t){var n=r.parseRtpParameters(e);i._pendingOffer[t].localCapabilities=n}),this.transceivers=this._pendingOffer,delete this._pendingOffer);else if("answer"===e.type){t=r.splitSections(i.remoteDescription.sdp),n=t.shift();var o=r.matchPrefix(n,"a=ice-lite").length>0;t.forEach(function(e,t){var a=i.transceivers[t],s=a.iceGatherer,c=a.iceTransport,d=a.dtlsTransport,u=a.localCapabilities,h=a.remoteCapabilities,f="0"===e.split("\n",1)[0].split(" ",2)[1];if(!f&&!a.isDatachannel){var l=r.getIceParameters(e,n),p=r.getDtlsParameters(e,n);o&&(p.role="server"),i.usingBundle&&0!==t||(c.start(s,l,o?"controlling":"controlled"),d.start(p));var w=i._getCommonCapabilities(u,h);i._transceive(a,w.codecs.length>0,!1)}})}switch(this.localDescription={type:e.type,sdp:e.sdp},e.type){case"offer":this._updateSignalingState("have-local-offer");break;case"answer":this._updateSignalingState("stable");break;default:throw new TypeError('unsupported type "'+e.type+'"')}var a=arguments.length>1&&"function"==typeof arguments[1];if(a){var s=arguments[1];window.setTimeout(function(){s(),"new"===i.iceGatheringState&&(i.iceGatheringState="gathering"),i._emitBufferedCandidates()},0)}var c=Promise.resolve();return c.then(function(){a||("new"===i.iceGatheringState&&(i.iceGatheringState="gathering"),window.setTimeout(i._emitBufferedCandidates.bind(i),500))}),c},window.RTCPeerConnection.prototype.setRemoteDescription=function(e){var t=this,n=new MediaStream,i=[],o=r.splitSections(e.sdp),a=o.shift(),s=r.matchPrefix(a,"a=ice-lite").length>0;switch(this.usingBundle=r.matchPrefix(a,"a=group:BUNDLE ").length>0,o.forEach(function(o,c){var d=r.splitLines(o),u=d[0].substr(2).split(" "),h=u[0],f="0"===u[1],l=r.getDirection(o,a),p=r.matchPrefix(o,"a=mid:");if(p=p.length?p[0].substr(6):r.generateIdentifier(),"application"===h&&"DTLS/SCTP"===u[2])return void(t.transceivers[c]={mid:p,isDatachannel:!0});var w,v,m,g,b,y,C,P,S,k,E,T,R=r.parseRtpParameters(o);f||(E=r.getIceParameters(o,a),T=r.getDtlsParameters(o,a),T.role="client"),P=r.parseRtpEncodingParameters(o);var M,x=r.matchPrefix(o,"a=ssrc:").map(function(e){return r.parseSsrcMedia(e)}).filter(function(e){return"cname"===e.attribute})[0];x&&(M=x.value);var D=r.matchPrefix(o,"a=end-of-candidates",a).length>0,O=r.matchPrefix(o,"a=candidate:").map(function(e){return r.parseCandidate(e)}).filter(function(e){return"1"===e.component});if("offer"!==e.type||f)"answer"!==e.type||f||(w=t.transceivers[c],v=w.iceGatherer,m=w.iceTransport,g=w.dtlsTransport,b=w.rtpSender,y=w.rtpReceiver,C=w.sendEncodingParameters,S=w.localCapabilities,t.transceivers[c].recvEncodingParameters=P,t.transceivers[c].remoteCapabilities=R,t.transceivers[c].cname=M,(s||D)&&O.length&&m.setRemoteCandidates(O),t.usingBundle&&0!==c||(m.start(v,E,"controlling"),g.start(T)),t._transceive(w,"sendrecv"===l||"recvonly"===l,"sendrecv"===l||"sendonly"===l),!y||"sendrecv"!==l&&"sendonly"!==l?delete w.rtpReceiver:(k=y.track,i.push([k,y]),n.addTrack(k)));else{var L=t.usingBundle&&c>0?{iceGatherer:t.transceivers[0].iceGatherer,iceTransport:t.transceivers[0].iceTransport,dtlsTransport:t.transceivers[0].dtlsTransport}:t._createIceAndDtlsTransports(p,c);if(!D||t.usingBundle&&0!==c||L.iceTransport.setRemoteCandidates(O),S=RTCRtpReceiver.getCapabilities(h),S.codecs=S.codecs.filter(function(e){return"rtx"!==e.name}),C=[{ssrc:1001*(2*c+2)}],y=new RTCRtpReceiver(L.dtlsTransport,h),k=y.track,i.push([k,y]),n.addTrack(k),t.localStreams.length>0&&t.localStreams[0].getTracks().length>=c){var I;"audio"===h?I=t.localStreams[0].getAudioTracks()[0]:"video"===h&&(I=t.localStreams[0].getVideoTracks()[0]),I&&(b=new RTCRtpSender(I,L.dtlsTransport))}t.transceivers[c]={iceGatherer:L.iceGatherer,iceTransport:L.iceTransport,dtlsTransport:L.dtlsTransport,localCapabilities:S,remoteCapabilities:R,rtpSender:b,rtpReceiver:y,kind:h,mid:p,cname:M,sendEncodingParameters:C,recvEncodingParameters:P},t._transceive(t.transceivers[c],!1,"sendrecv"===l||"sendonly"===l)}}),this.remoteDescription={type:e.type,sdp:e.sdp},e.type){case"offer":this._updateSignalingState("have-remote-offer");break;case"answer":this._updateSignalingState("stable");break;default:throw new TypeError('unsupported type "'+e.type+'"')}return n.getTracks().length&&(t.remoteStreams.push(n),window.setTimeout(function(){var e=new Event("addstream");e.stream=n,t.dispatchEvent(e),null!==t.onaddstream&&window.setTimeout(function(){t.onaddstream(e)},0),i.forEach(function(e){var r=e[0],i=e[1],o=new Event("track");o.track=r,o.receiver=i,o.streams=[n],t.dispatchEvent(o),null!==t.ontrack&&window.setTimeout(function(){t.ontrack(o)},0)})},0)),arguments.length>1&&"function"==typeof arguments[1]&&window.setTimeout(arguments[1],0),Promise.resolve()},window.RTCPeerConnection.prototype.close=function(){this.transceivers.forEach(function(e){e.iceTransport&&e.iceTransport.stop(),e.dtlsTransport&&e.dtlsTransport.stop(),e.rtpSender&&e.rtpSender.stop(),e.rtpReceiver&&e.rtpReceiver.stop()}),this._updateSignalingState("closed")},window.RTCPeerConnection.prototype._updateSignalingState=function(e){this.signalingState=e;var t=new Event("signalingstatechange");this.dispatchEvent(t),null!==this.onsignalingstatechange&&this.onsignalingstatechange(t)},window.RTCPeerConnection.prototype._maybeFireNegotiationNeeded=function(){var e=new Event("negotiationneeded");this.dispatchEvent(e),null!==this.onnegotiationneeded&&this.onnegotiationneeded(e)},window.RTCPeerConnection.prototype._updateConnectionState=function(){var e,t=this,n={new:0,closed:0,connecting:0,checking:0,connected:0,completed:0,failed:0};if(this.transceivers.forEach(function(e){n[e.iceTransport.state]++,n[e.dtlsTransport.state]++}),n.connected+=n.completed,e="new",n.failed>0?e="failed":n.connecting>0||n.checking>0?e="connecting":n.disconnected>0?e="disconnected":n.new>0?e="new":(n.connected>0||n.completed>0)&&(e="connected"),e!==t.iceConnectionState){t.iceConnectionState=e;var r=new Event("iceconnectionstatechange");this.dispatchEvent(r),null!==this.oniceconnectionstatechange&&this.oniceconnectionstatechange(r)}},window.RTCPeerConnection.prototype.createOffer=function(){var e=this;if(this._pendingOffer)throw new Error("createOffer called while there is a pending offer.");var t;1===arguments.length&&"function"!=typeof arguments[0]?t=arguments[0]:3===arguments.length&&(t=arguments[2]);var n=[],i=0,o=0;if(this.localStreams.length&&(i=this.localStreams[0].getAudioTracks().length,o=this.localStreams[0].getVideoTracks().length),t){if(t.mandatory||t.optional)throw new TypeError("Legacy mandatory/optional constraints not supported.");void 0!==t.offerToReceiveAudio&&(i=t.offerToReceiveAudio),void 0!==t.offerToReceiveVideo&&(o=t.offerToReceiveVideo)}for(this.localStreams.length&&this.localStreams[0].getTracks().forEach(function(e){n.push({kind:e.kind,track:e,wantReceive:"audio"===e.kind?i>0:o>0}),"audio"===e.kind?i--:"video"===e.kind&&o--});i>0||o>0;)i>0&&(n.push({kind:"audio",wantReceive:!0}),i--),o>0&&(n.push({kind:"video",wantReceive:!0}),o--);var a=r.writeSessionBoilerplate(),s=[];n.forEach(function(t,n){var i=t.track,o=t.kind,a=r.generateIdentifier(),c=e.usingBundle&&n>0?{iceGatherer:s[0].iceGatherer,iceTransport:s[0].iceTransport,dtlsTransport:s[0].dtlsTransport}:e._createIceAndDtlsTransports(a,n),d=RTCRtpSender.getCapabilities(o);d.codecs=d.codecs.filter(function(e){return"rtx"!==e.name}),d.codecs.forEach(function(e){"H264"===e.name&&void 0===e.parameters["level-asymmetry-allowed"]&&(e.parameters["level-asymmetry-allowed"]="1")});var u,h,f=[{ssrc:1001*(2*n+1)}];i&&(u=new RTCRtpSender(i,c.dtlsTransport)),t.wantReceive&&(h=new RTCRtpReceiver(c.dtlsTransport,o)),s[n]={iceGatherer:c.iceGatherer,iceTransport:c.iceTransport,dtlsTransport:c.dtlsTransport,localCapabilities:d,remoteCapabilities:null,rtpSender:u,rtpReceiver:h,kind:o,mid:a,
sendEncodingParameters:f,recvEncodingParameters:null}}),this.usingBundle&&(a+="a=group:BUNDLE "+s.map(function(e){return e.mid}).join(" ")+"\r\n"),n.forEach(function(t,n){var i=s[n];a+=r.writeMediaSection(i,i.localCapabilities,"offer",e.localStreams[0])}),this._pendingOffer=s;var c=new RTCSessionDescription({type:"offer",sdp:a});return arguments.length&&"function"==typeof arguments[0]&&window.setTimeout(arguments[0],0,c),Promise.resolve(c)},window.RTCPeerConnection.prototype.createAnswer=function(){var e=this,t=r.writeSessionBoilerplate();this.usingBundle&&(t+="a=group:BUNDLE "+this.transceivers.map(function(e){return e.mid}).join(" ")+"\r\n"),this.transceivers.forEach(function(n){if(n.isDatachannel)return void(t+="m=application 0 DTLS/SCTP 5000\r\nc=IN IP4 0.0.0.0\r\na=mid:"+n.mid+"\r\n");var i=e._getCommonCapabilities(n.localCapabilities,n.remoteCapabilities);t+=r.writeMediaSection(n,i,"answer",e.localStreams[0])});var n=new RTCSessionDescription({type:"answer",sdp:t});return arguments.length&&"function"==typeof arguments[0]&&window.setTimeout(arguments[0],0,n),Promise.resolve(n)},window.RTCPeerConnection.prototype.addIceCandidate=function(e){if(e){var t=e.sdpMLineIndex;if(e.sdpMid)for(var n=0;n<this.transceivers.length;n++)if(this.transceivers[n].mid===e.sdpMid){t=n;break}var i=this.transceivers[t];if(i){var o=Object.keys(e.candidate).length>0?r.parseCandidate(e.candidate):{};if("tcp"===o.protocol&&(0===o.port||9===o.port))return Promise.resolve();if("1"!==o.component)return Promise.resolve();i.iceTransport.addRemoteCandidate(o);var a=r.splitSections(this.remoteDescription.sdp);a[t+1]+=(o.type?e.candidate.trim():"a=end-of-candidates")+"\r\n",this.remoteDescription.sdp=a.join("")}}else for(var s=0;s<this.transceivers.length;s++)if(this.transceivers[s].iceTransport.addRemoteCandidate({}),this.usingBundle)return Promise.resolve();return arguments.length>1&&"function"==typeof arguments[1]&&window.setTimeout(arguments[1],0),Promise.resolve()},window.RTCPeerConnection.prototype.getStats=function(){var e=[];this.transceivers.forEach(function(t){["rtpSender","rtpReceiver","iceGatherer","iceTransport","dtlsTransport"].forEach(function(n){t[n]&&e.push(t[n].getStats())})});var t=arguments.length>1&&"function"==typeof arguments[1]&&arguments[1],n=function(e){return e.type={inboundrtp:"inbound-rtp",outboundrtp:"outbound-rtp",candidatepair:"candidate-pair",localcandidate:"local-candidate",remotecandidate:"remote-candidate"}[e.type]||e.type,e};return new Promise(function(r){var i=new Map;Promise.all(e).then(function(e){e.forEach(function(e){Object.keys(e).forEach(function(t){e[t].type=n(e[t]),i.set(t,e[t])})}),t&&window.setTimeout(t,0,i),r(i)})})}}};e.exports={shimPeerConnection:o.shimPeerConnection,shimGetUserMedia:n(9)}},function(e,t,n){"use strict";e.exports=function(){var e=function(e){return{name:{PermissionDeniedError:"NotAllowedError"}[e.name]||e.name,message:e.message,constraint:e.constraint,toString:function(){return this.name}}},t=navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices);navigator.mediaDevices.getUserMedia=function(n){return t(n).catch(function(t){return Promise.reject(e(t))})}}},function(e,t,n){"use strict";var r=n(0).browserDetails,i={shimOnTrack:function(){"object"!=typeof window||!window.RTCPeerConnection||"ontrack"in window.RTCPeerConnection.prototype||Object.defineProperty(window.RTCPeerConnection.prototype,"ontrack",{get:function(){return this._ontrack},set:function(e){this._ontrack&&(this.removeEventListener("track",this._ontrack),this.removeEventListener("addstream",this._ontrackpoly)),this.addEventListener("track",this._ontrack=e),this.addEventListener("addstream",this._ontrackpoly=function(e){e.stream.getTracks().forEach(function(t){var n=new Event("track");n.track=t,n.receiver={track:t},n.streams=[e.stream],this.dispatchEvent(n)}.bind(this))}.bind(this))}})},shimSourceObject:function(){"object"==typeof window&&(!window.HTMLMediaElement||"srcObject"in window.HTMLMediaElement.prototype||Object.defineProperty(window.HTMLMediaElement.prototype,"srcObject",{get:function(){return this.mozSrcObject},set:function(e){this.mozSrcObject=e}}))},shimPeerConnection:function(){if("object"==typeof window&&(window.RTCPeerConnection||window.mozRTCPeerConnection)){window.RTCPeerConnection||(window.RTCPeerConnection=function(e,t){if(r.version<38&&e&&e.iceServers){for(var n=[],i=0;i<e.iceServers.length;i++){var o=e.iceServers[i];if(o.hasOwnProperty("urls"))for(var a=0;a<o.urls.length;a++){var s={url:o.urls[a]};0===o.urls[a].indexOf("turn")&&(s.username=o.username,s.credential=o.credential),n.push(s)}else n.push(e.iceServers[i])}e.iceServers=n}return new mozRTCPeerConnection(e,t)},window.RTCPeerConnection.prototype=mozRTCPeerConnection.prototype,mozRTCPeerConnection.generateCertificate&&Object.defineProperty(window.RTCPeerConnection,"generateCertificate",{get:function(){return mozRTCPeerConnection.generateCertificate}}),window.RTCSessionDescription=mozRTCSessionDescription,window.RTCIceCandidate=mozRTCIceCandidate),["setLocalDescription","setRemoteDescription","addIceCandidate"].forEach(function(e){var t=RTCPeerConnection.prototype[e];RTCPeerConnection.prototype[e]=function(){return arguments[0]=new("addIceCandidate"===e?RTCIceCandidate:RTCSessionDescription)(arguments[0]),t.apply(this,arguments)}});var e=RTCPeerConnection.prototype.addIceCandidate;RTCPeerConnection.prototype.addIceCandidate=function(){return arguments[0]?e.apply(this,arguments):(arguments[1]&&arguments[1].apply(null),Promise.resolve())};var t=function(e){var t=new Map;return Object.keys(e).forEach(function(n){t.set(n,e[n]),t[n]=e[n]}),t},n={inboundrtp:"inbound-rtp",outboundrtp:"outbound-rtp",candidatepair:"candidate-pair",localcandidate:"local-candidate",remotecandidate:"remote-candidate"},i=RTCPeerConnection.prototype.getStats;RTCPeerConnection.prototype.getStats=function(e,o,a){return i.apply(this,[e||null]).then(function(e){if(r.version<48&&(e=t(e)),r.version<53&&!o)try{e.forEach(function(e){e.type=n[e.type]||e.type})}catch(t){if("TypeError"!==t.name)throw t;e.forEach(function(t,r){e.set(r,Object.assign({},t,{type:n[t.type]||t.type}))})}return e}).then(o,a)}}}};e.exports={shimOnTrack:i.shimOnTrack,shimSourceObject:i.shimSourceObject,shimPeerConnection:i.shimPeerConnection,shimGetUserMedia:n(11)}},function(e,t,n){"use strict";var r=n(0).log,i=n(0).browserDetails;e.exports=function(){var e=function(e){return{name:{SecurityError:"NotAllowedError",PermissionDeniedError:"NotAllowedError"}[e.name]||e.name,message:{"The operation is insecure.":"The request is not allowed by the user agent or the platform in the current context."}[e.message]||e.message,constraint:e.constraint,toString:function(){return this.name+(this.message&&": ")+this.message}}},t=function(t,n,o){var a=function(e){if("object"!=typeof e||e.require)return e;var t=[];return Object.keys(e).forEach(function(n){if("require"!==n&&"advanced"!==n&&"mediaSource"!==n){var r=e[n]="object"==typeof e[n]?e[n]:{ideal:e[n]};if(void 0===r.min&&void 0===r.max&&void 0===r.exact||t.push(n),void 0!==r.exact&&("number"==typeof r.exact?r.min=r.max=r.exact:e[n]=r.exact,delete r.exact),void 0!==r.ideal){e.advanced=e.advanced||[];var i={};"number"==typeof r.ideal?i[n]={min:r.ideal,max:r.ideal}:i[n]=r.ideal,e.advanced.push(i),delete r.ideal,Object.keys(r).length||delete e[n]}}}),t.length&&(e.require=t),e};return t=JSON.parse(JSON.stringify(t)),i.version<38&&(r("spec: "+JSON.stringify(t)),t.audio&&(t.audio=a(t.audio)),t.video&&(t.video=a(t.video)),r("ff37: "+JSON.stringify(t))),navigator.mozGetUserMedia(t,n,function(t){o(e(t))})},n=function(e){return new Promise(function(n,r){t(e,n,r)})};if(navigator.mediaDevices||(navigator.mediaDevices={getUserMedia:n,addEventListener:function(){},removeEventListener:function(){}}),navigator.mediaDevices.enumerateDevices=navigator.mediaDevices.enumerateDevices||function(){return new Promise(function(e){var t=[{kind:"audioinput",deviceId:"default",label:"",groupId:""},{kind:"videoinput",deviceId:"default",label:"",groupId:""}];e(t)})},i.version<41){var o=navigator.mediaDevices.enumerateDevices.bind(navigator.mediaDevices);navigator.mediaDevices.enumerateDevices=function(){return o().then(void 0,function(e){if("NotFoundError"===e.name)return[];throw e})}}if(i.version<49){var a=navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices);navigator.mediaDevices.getUserMedia=function(t){return a(t).then(function(e){if(t.audio&&!e.getAudioTracks().length||t.video&&!e.getVideoTracks().length)throw e.getTracks().forEach(function(e){e.stop()}),new DOMException("The object can not be found here.","NotFoundError");return e},function(t){return Promise.reject(e(t))})}}navigator.getUserMedia=function(e,n,r){return i.version<44?t(e,n,r):(console.warn("navigator.getUserMedia has been replaced by navigator.mediaDevices.getUserMedia"),void navigator.mediaDevices.getUserMedia(e).then(n,r))}}},function(e,t,n){"use strict";var r={shimGetUserMedia:function(){navigator.getUserMedia||(navigator.webkitGetUserMedia?navigator.getUserMedia=navigator.webkitGetUserMedia.bind(navigator):navigator.mediaDevices&&navigator.mediaDevices.getUserMedia&&(navigator.getUserMedia=function(e,t,n){navigator.mediaDevices.getUserMedia(e).then(t,n)}.bind(navigator)))}};e.exports={shimGetUserMedia:r.shimGetUserMedia}},function(e,t,n){function r(){function e(e){return"function"==typeof e?e:function(){}}var t=n(2),r=n(1),i=r(),o={prepare:i.prepare,show:i.show,hide:i.hide,scan:i.scan,cancelScan:i.cancelScan,pausePreview:i.pausePreview,resumePreview:i.resumePreview,enableLight:i.enableLight,disableLight:i.disableLight,useCamera:i.useCamera,openSettings:i.openSettings,getStatus:i.getStatus,destroy:i.destroy},a={exec:function(t,n,r,i,a){return"QRScanner"===r&&o[i]?void(a?o[i](e(t),e(n),a):o[i](e(t),e(n))):n(0)}},s=t(a);return s}e.exports=new r}])});
//# sourceMappingURL=cordova-plugin-qrscanner-lib.min.js.map
